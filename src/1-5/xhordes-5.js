		! function(b, c) {
			function d(a, b) {
				for (var c = 0; c < ta.length; c++)
					if (a >= ta[c].value) return (a / ta[c].value).toFixed(b).replace(ua, "$1") + ta[c].symbol;
				return a.toFixed(b).replace(ua, "$1")
			}

			function f(a, b) {
				a = a.substring(0, 150), "string" == typeof a && "" != a && xd.emit("c", {
					m: a,
					i: b
				})
			}

			function g(a, b) {
				if (void 0 !== Sa && (Sa.dispose(), delete Sa, Sa = void 0), void 0 !== Ta && (ca(Ta), Ac.remove(Ta), delete Ta, Ta = void 0), "0" != Pa.get("grass")) {
					Sa = new THREE.InstancedBufferGeometry, Sa.copy(new THREE.PlaneBufferGeometry(2, 2)), zc = a;
					var c = 5e3;
					switch (parseInt(Pa.get("grass"))) {
						default:
							case 1:
							c = 7;
						break;
						case 2:
								c = 15;
							break;
						case 3:
								c = 30;
							break;
						case 4:
								c = 60;
							break;
						case 5:
								c = 100
					}
					for (var d = [], e = [], f = [], g = [], h = 0, i = 0, j = 0; j < a.width; ++j)
						for (var k = 0; k < a.height; ++k) {
							var l = aa(j, k),
								m = l.a / 255;
							if (!(l.a <= 5))
								for (var n = 0; n < c * m; ++n) {
									var o = (j + Math.random()) / a.width,
										p = (k + Math.random()) / a.height,
										q = Math.floor(p * (wc / Lc)) * xc + 3 * Math.floor(o * (wc / Lc));
									d[i + 0] = o * wc, d[i + 1] = Qc(wc * o, wc * p) + .6, d[i + 2] = p * wc, e[h] = m * (Math.random() + .1) * 2.5 + .4, f[i + 0] = .1 * Math.random() - .05 + l.r / 255, f[i + 1] = .1 * Math.random() - .05 + l.g / 255, f[i + 2] = .1 * Math.random() - .05 + l.b / 255, Math.random() < 1 / (10 * c) && (e[h] += 1.5 * Math.random(), f[i + 0] *= .3 * Math.random() + .7, f[i + 1] *= .3 * Math.random() + .7, f[i + 2] *= .3 * Math.random() + .7), g[i + 0] = b.attributes.normal.array[q], g[i + 1] = b.attributes.normal.array[q + 1], g[i + 2] = b.attributes.normal.array[q + 2], h++, i += 3
								}
						}
					Sa.addAttribute("translate", new THREE.InstancedBufferAttribute(new Float32Array(d), 3, 1)), Sa.addAttribute("color", new THREE.InstancedBufferAttribute(new Float32Array(f), 3, 1)), Sa.addAttribute("scale", new THREE.InstancedBufferAttribute(new Float32Array(e), 1, 1)), Sa.addAttribute("groundNormal", new THREE.InstancedBufferAttribute(new Float32Array(g), 3, 1)), Vc.foliage || (Vc.foliage = new THREE.RawShaderMaterial({
						uniforms: {
							map: {
								value: oa.grass
							},
							shadow: {
								value: Ec.shadow.map
							},
							time: {
								value: 0
							},
							camXRot: {
								value: 0
							},
							camYRot: {
								value: 0
							},
							ambient: {
								value: Dc.color
							},
							directional: {
								value: Ec.color
							},
							directionalDir: {
								value: Ec.position
							},
							directionalMVP: {
								value: new THREE.Matrix4
							},
							maxDrawDistance: {
								value: 150
							},
							fogColor: {
								value: Ac.fog.color
							},
							fogDensity: {
								value: Ac.fog.density
							},
							targetCircle: {
								value: new THREE.Vector4(0, 0, 0, 2)
							},
							targetCirclePos: {
								value: new THREE.Vector2(0, 0)
							},
							shadowSize: {
								value: 0
							},
							playerscale: {
								value: 1
							}
						},
						vertexShader: pa["grass.vert"],
						fragmentShader: pa["grass.frag"],
						depthTest: true,
						depthWrite: true
					})), Ta = new THREE.Mesh(Sa, Vc.foliage), Ta.frustumCulled = false, Ac.add(Ta)
				}
			}

			function h() {
				if (void 0 !== Sa) {
					var a = 5e-4 * performance.now();
					Vc.foliage.uniforms.time.value = a;
					var b = Fc.getWorldRotation();
					Vc.foliage.uniforms.camXRot.value = b.x, Vc.foliage.uniforms.camYRot.value = b.y, Vc.foliage.uniforms.directionalMVP.value = Ec.shadow.matrix, Ec.shadow.map && Vc.foliage.uniforms.shadow.value != Ec.shadow.map.texture && (Vc.foliage.uniforms.shadow.value = Ec.shadow.map.texture), Ic ? (void 0 !== Ic.stats.scale && (Vc.foliage.uniforms.playerscale.value = Ic.stats.scale), Ic.target || Xc && Xc.drop ? Xc && Xc.drop ? (Vc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(Xc.position.x, Xc.position.z), Vc.foliage.uniforms.targetCircle.value.w = 2, Vc.foliage.uniforms.targetCircle.value.x = 0, Vc.foliage.uniforms.targetCircle.value.y = 0) : (Vc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(Ic.target.visualPosition.x, Ic.target.visualPosition.z), Vc.foliage.uniforms.targetCircle.value.w = Ic.target.stats.scale + .5, Vc.foliage.uniforms.targetCircle.value.x = Ic.target.faction == Ic.faction ? 0 : 1, Vc.foliage.uniforms.targetCircle.value.y = Ic.target.faction == Ic.faction ? 1 : 0) : Vc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(0, 0)) : Vc.foliage.uniforms.playerscale.value = 1
				}
			}

			function j(a, b) {
				this.position = new THREE.Vector3(0, 0, 0), this.velocity = new THREE.Vector3, this.walkForward = 0, this.walkSideward = 0, this.rotation = 0, this.state = new A, this.name = "", this.id = "", this.faction = a, this.stats = new w(this), this.class = new K, this.class.stats = this.stats, this.target = void 0, this.combat = false, this.clan = "", this.clanrole = 0, this.ignSteep = false, this.gold = 0, this.fame = 0, this.last = {}, this.last.gold = 0, this.last.faction = -1, this.last.name = "", this.last.id = "", this.last.position = new THREE.Vector3, this.last.walkForward = 0, this.last.walkSideward = 0, this.last.rotation = 0, this.last.updateTime = Date.now(), this.last.state = {}, this.last.class = {}, this.last.class.ai = {}, this.last.class.ai.isresetting = 0, this.last.state.id = 0, this.last.target = {}, this.last.target.id = void 0, this.last.stats = {}, this.last.isAi = false, this.last.combat = false, this.visuals = {
					h: 0
				}, this.last.visuals = {
					h: 0
				}, this.serverMsgQueue = {}, Va ? (this.lastDmgTakenTime = 0, this.class = b, this.class.stats = this.stats, this.class.parent = this, this.respawn = false, this.pickup = void 0, this.fullrequests = [], this.class.ai ? (this.class.ai.class = this.class, this.class.ai.parent = this, this.isAi = true) : (this.lastPositionUpdate = new THREE.Vector3, this.inventory = new Inventory), this.ignoreMovement = 0, this.class.update(), this.stats.spawn(), this.class.skills[1].setLevel(1), this.personalMessages = {}) : (this.globalAnimStepFuss = Math.round(2 * Math.random()), this.dmgShake = 0, this.class.ai = void 0, this.class.color = Vc.monster, this.next = {}, this.next.position = new THREE.Vector3, this.animationQueue = [])
			}

			function l(a) {
				for (var b in a) return false;
				return true
			}

			function n(a, b) {
				var c = b.x - a.x,
					d = b.z - a.z;
				return Math.sqrt(c * c + d * d)
			}

			function o(a, b) {
				this.a = a, this.b = b, this.aggroA = 0, this.aggroB = 0, this.expShareA = 0, this.expShareB = 0
			}

			function p(a) {
				Va ? this.serverInit(a) : this.clientInit(a)
			}

			function q() {
				return Mb = void 0, window.removeEventListener("mousemove", r, true), false
			}

			function r(a) {
				Mb && (Mb.style.top = a.clientY - Ob + "px", Mb.style.left = a.clientX - Nb + "px")
			}

			function t(a) {
				return a.charAt(0).toUpperCase() + a.substring(1)
			}

			function u(a) {
				if (this.name = a.name || "", this.target = a.target || void 0, this.source = a.source || void 0, this.ribbon = a.ribbon || void 0, this.effectCallback = a.effect || void 0, this.effectInterval = a.effectInterval || -1, this.effectTimer = this.effectInterval, this.timeout = a.timeout || 30, this.mode = a.mode || "follow", this.movespeed = a.movespeed || 10, this.movedir = a.movedir || void 0, this.position = new THREE.Vector3, a.startposition) this.position.copy(a.startposition);
				else if (this.source) {
					if (this.position.copy(this.source.position), this.source) {
						var b = F(this.source.rotation);
						b.multiplyScalar(1.2 * this.source.stats.scale)
					}
					if (this.position.x += b.x, this.position.z += b.y, !Va) {
						var c = this.source.chest ? this.source.chest.getWorldPosition() : this.source.position;
						this.position.y = c.y
					}
				} else this.deleteMe = true;
				Va || (a.tick && (this.visualtick = a.tick), this.geometry = a.geometry || new THREE.Mesh(new THREE.BoxGeometry(.3, .3, .3), new THREE.MeshBasicMaterial({
					color: 255
				})), this.geometry.position.copy(this.position), Ac.add(this.geometry), this.ribbon && (this.ribbonObject = nd(this.ribbon)))
			}

			function v(a, b, c) {
				this.slot = a, this.class = b, this.predict = void 0 === c.predict || c.predict, this.ignoreEc = void 0 !== c.ignoreEc && c.ignoreEc, this.simulate = void 0 !== c.simulate && c.simulate, this.allowDeadTarget = void 0 !== c.allowDeadTarget && c.allowDeadTarget, this.description = c.description || "missing description", this.manacost = c.mana || 0, this.levelUpMinLevel = 0, this.level = 0, this.nextLevelCost = 0, this.abilitypower = 0, this.setLevel(c.baselevel || 0), this.name = c.name || "Error: no skill id", this.icon = c.icon || "hpbarbg", this.targettype = c.targettype || "enemy", this.unique = c.unique || false, this.casttype = c.casttype || "instant", this.casttime = c.casttime || 0, this.casttimer = 0, this.casttarget = void 0, this.cooldown = void 0 !== c.cooldown ? c.cooldown : 0, this.cooldowntimer = 0, this.causeGlobalCooldown = void 0 === c.causeGlobalCD || c.causeGlobalCD, this.maxrange = c.maxrange || 1e3, this.spell = c.spell || void 0, this.hasChanneledSpell = c.spellchannel || void 0, this.effect = c.effect || function() {
					console.log("error, missing skill effect: " + this.name)
				}, this.effecttype = c.effecttype || "instant", this.channelInterval = c.channelInterval || ("channel" == this.effecttype ? 1 : void 0), this.channelDuration = c.channelDuration || ("channel" == this.effecttype ? 2 : void 0), this.channelMoveInterrupt = void 0 === c.channelMoveInterrupt || c.channelMoveInterrupt, this.channelInstantFirstTick = void 0 !== c.channelInstantFirstTick && c.channelInstantFirstTick, this.channelDuration && (this.channelTimer = -1), this.channelInterval && (this.channelIntervalTimer = -1), this.onCastFun = c.onCastFun || void 0;
				var d = this;
				this.effectWrapper = function(a) {
					d.effect && (a.source = a.source || d.parent, a.target = a.target || d.casttarget, d.effect(a))
				}, Va || (this.getCharacterAnim = c.characterAnim || function() {
					return new V({
						id: "release_spell",
						duration: .5
					})
				}), Va || ("timed" == this.casttype && (this.castAnimation = c.castAnim || new V({
					id: "cast",
					duration: .8,
					type: "loop"
				})), "channel" == this.effecttype && (this.channelAnimation = c.channelAnim || new V({
					id: "channel",
					duration: .5,
					type: "loop"
				})))
			}

			function w(a) {
				this.scale = 1, this.currenthp = 1, this.currentmp = 1, this.maxhp = 1, this.maxmp = 1, this.currentmindmg = 1, this.currentmaxdmg = 1, this.hpregen = 0, this.mpregen = 0, this.movespeed = 1, this.basemana = 100, this.healmod = 1, this.defense = 1, this.crit = 0, this.parent = a, this.incapacitated = false, this.stunned = false, this.periodicTickTimerHP = 0, this.periodicTickTimerMP = 0, this.mods = []
			}

			function y(a, b, c) {
				this.id = c.id || void 0, this.duration = c.duration || 1, this.effectinterval = c.interval || -1, this.effectfunction = c.effect || void 0, this.name = c.name || "Error: no name", this.overwrite = c.overwrite || false, this.unique = c.unique || false, this.invincible = c.invincible || false, this.incapacitate = c.incapacitate || false, this.stun = c.stun || false, this.movespeed = c.movespeed || void 0, this.healmod = c.healmod || void 0, this.target = a, this.source = b, this.timer = this.duration, this.effecttimer = this.effectinterval, this.deleteMe = false
			}

			function z() {
				this.id = 0, this.timer = 0, this.duration = 0, this.tick = function(a, b) {}
			}

			function A() {
				this.id = 0, this.duration = 0, this.tick = function(a, b) {
					if (Va && void 0 !== b.queuedSkill) 0 !== b.walkForward || 0 !== b.walkSideward ? b.queuedSkill = void 0 : (b.useSkill(b.queuedSkill, true), b.queuedSkill = void 0);
					else if (!Va && b.animationQueue && b.animationQueue[0]) switch (b.animationQueue[0].id) {
						case "cast":
						case "dead":
							b.animationQueue[0].deleteMe = true
					}
				}
			}

			function B(a) {
				this.id = 1, this.skill = a.skill, this.duration = a.casttime || 1, Va || (this.duration += Bd / 1e3), this.maxduration = this.duration, this.active = a.activeCheck, this.interrupt = a.interrupt, this.tick = function(a, b) {
					!this.active.call(this.skill) || this.skill.channelMoveInterrupt && (b.walkForward || b.walkSideward) ? (this.skill.channelMoveInterrupt && (b.walkForward || b.walkSideward) && this.interrupt.call(this.skill), b.state = new A) : (this.duration -= a, this.duration < 0 && Va && (b.state = new A))
				}
			}

			function C() {
				this.id = 2, this.duration = 5, this.tick = function(a, b) {
					this.timer += a
				}
			}

			function D(a) {
				var b = a.angle() + .5 * Math.PI;
				return b > 2 * Math.PI && (b -= 2 * Math.PI), b = 2 * Math.PI - b
			}

			function E(a, b) {
				for (var c = b - a; c < -Math.PI;) c += 2 * Math.PI;
				for (; c > Math.PI;) c -= 2 * Math.PI;
				return c
			}

			function F(a) {
				return new THREE.Vector2(-Math.sin(a), -Math.cos(a))
			}

			function G(a, b) {
				return D(new THREE.Vector2(b.x - a.x, b.z - a.z))
			}

			function H(a, b) {
				return D(new THREE.Vector2(b.position.x - a.position.x, b.position.z - a.position.z))
			}

			function I(a, b) {
				return a.position.distanceTo(b)
			}

			function J(a, b) {
				return a.position.distanceTo(b.position)
			}

			function K() {
				this.level = 1, this.nextLevelExp = 1, this.sumexp = 0, this.exp = 0, this.mindmg = 1, this.maxdmg = 1, this.maxhp = 5, this.scale = 1, this.crit = 0
			}

			function L() {
				var a = new R(100);
				return a.skills[1].setLevel(1), a.skills[2].setLevel(1), a.exp = 0, a.fame = 5e3, a.gold = 1e4, a.type = "king", a.ai = new ea, Va && (a.ai.protect = true, a.ai.idleinterval = 20, a.ai.idleradius = 2, a.ai.aggrodistance = 45, a.ai.idlewalkduration = .02, a.ai.hardResetDistanceSqr = 6e3), Va || (a.color = Vc.warden), a.getMaxHp = function() {
					return 1e5
				}, a.getMinDmg = function() {
					return 2e3
				}, a.getMaxDmg = function() {
					return 2500
				}, a.getMovespeed = function() {
					return 1 == this.ai.isresetting ? 25 : 15
				}, a.getScale = function() {
					return 6
				}, a
			}

			function M() {
				var a = new R(100);
				return a.skills[1].setLevel(1), a.skills[2].setLevel(1), a.skills[3].setLevel(1), a.skills[4].setLevel(1), a.fame = 300, a.gold = 1e3, a.ai = new ea, Va && (a.ai.protect = true, a.ai.idleinterval = 20, a.ai.idleradius = 2, a.ai.aggrodistance = 5, a.ai.idlewalkduration = .02, a.ai.hardResetDistanceSqr = 6e3), a.type = "warden", Va || (a.color = Vc.warden), a.getMaxHp = function() {
					return 5e4
				}, a.getMinDmg = function() {
					return 1600
				}, a.getMaxDmg = function() {
					return 1600
				}, this.getHpRegen = function() {
					return 350
				}, a.getMovespeed = function() {
					return 1 == this.ai.isresetting ? 25 : 15
				}, a.getScale = function() {
					return 1.8
				}, a
			}

			function N() {
				var a = new R(100);
				return a.fame = 300, a.gold = 1e3, a.type = "vendor", a.idleAi = true, Va || (a.color = Vc.vendor), a.getMaxHp = function() {
					return 5e4
				}, a.getHpRegen = function() {
					return 1e4
				}, a.getScale = function() {
					return 1.5
				}, Va || (a.initBodyGeometry = function() {
					this.weapon = new THREE.Mesh(kd.generic_vendorlist.geo, Vc.archer_ammo2), this.weapon.scale.set(kd.generic_vendorlist.scale[0], kd.generic_vendorlist.scale[1], kd.generic_vendorlist.scale[2]), this.weapon.position.set(0, 0, 1), this.hands.r.add(this.weapon), this.backpack = new THREE.Mesh(kd.generic_backpack.geo, Vc.generic_wood), this.backpack.scale.set(kd.generic_backpack.scale[0], kd.generic_backpack.scale[1], kd.generic_backpack.scale[2]), Ac.add(this.backpack), this.backpack.position.set(0, .2, .7), this.chest.add(this.backpack)
				}, a.tickClassAnimation = function(a, b) {
					switch (a) {
						default:
							case "idle":
							this.hands.r.position.z -= .5,
						this.hands.r.rotation.y += 4,
						this.hands.r.rotation.z += .5,
						this.hands.r.rotation.x -= .5,
						this.weapon.rotation.set(0, 0, 0),
						this.weapon.position.set(0, 0, 1)
					}
				}), a
			}

			function O(a) {
				this.level = a, this.ai = new ea, this.type = "mob_sword", this.exp = 0, Va || (this.color = Vc.monster), this.skills = {
					1: new v(1, this, {
						name: "Melee Attack",
						targettype: "enemy",
						casttype: "instant",
						baselevel: 3,
						cooldown: 1,
						maxrange: 1.5,
						simulate: true,
						effect: function() {
							mb.damage({
								spread: .2,
								attacker: this.parent,
								target: this.casttarget
							})
						},
						characterAnim: function() {
							return new V({
								id: "swing_melee",
								duration: .5
							})
						}
					})
				}
			}

			function P(a) {
				this.level = a, this.ai = new ea, this.type = "mob_bow", this.exp = 0, Va || (this.color = Vc.bone, this.initBodyGeometry = function() {
					this.weapon = new THREE.Mesh(kd.archer_bow.geo, Vc.generic_wood), this.weapon.scale.set(2.5, 2.5, 1.9), this.weapon.rotation.z = .32, this.weapon.position.y = -2, this.bowcontainer = new THREE.Object3D, this.bowcontainer.add(this.weapon), this.bowcontainer.rotation.z = 1.5, this.bowcontainer.rotation.x = 1.6, this.bowcontainer.position.x = 1.1, this.bowcontainer.position.z = -.1, this.hands.l.add(this.bowcontainer)
				}, this.tickClassAnimation = T.prototype.tickClassAnimation), this.skills = {
					1: new v(1, this, {
						name: "Piercing Shot",
						targettype: "enemy",
						casttype: "instant",
						baselevel: 2,
						maxrange: 20,
						cooldown: 1.5,
						simulate: true,
						spell: function(a, b, c) {
							if (!Va) {
								var d = new THREE.Mesh(kd.archer_arrow.geo, Vc.generic_wood);
								d.scale.set(kd.archer_arrow.scale[0], kd.archer_arrow.scale[1], kd.archer_arrow.scale[2])
							}
							return new u({
								name: "Pierce Shot",
								target: a,
								source: b,
								effect: c,
								mode: "follow",
								movespeed: 50,
								geometry: d ? d : void 0,
								ribbon: Va ? void 0 : {
									deleteWithSpell: false,
									parent: d,
									stepInterval: .08,
									steps: 3,
									timeout: 1,
									material: Vc.ribbon_arrow,
									aPos: new THREE.Vector3(.6, 0, 0),
									bPos: new THREE.Vector3(-.6, -0, 0)
								}
							})
						},
						effect: function(a) {
							a.target && mb.damage({
								spread: .2,
								attacker: this.parent,
								target: this.casttarget
							})
						},
						characterAnim: function() {
							return new V({
								id: "release_spell",
								duration: .3
							})
						}
					})
				}
			}

			function Q(a) {
				this.level = a, this.ai = new ea, this.type = "mob_slime", this.exp = 0, Va || (a < 12 ? this.color = Vc.slime_green : a < 30 ? this.color = Vc.slime_blue : this.color = Vc.slime_red), this.skills = {
					1: new v(1, this, {
						name: "Melee Attack",
						targettype: "enemy",
						casttype: "instant",
						baselevel: 3,
						cooldown: 1,
						maxrange: 1.5,
						simulate: true,
						effect: function() {
							mb.damage({
								spread: .2,
								attacker: this.parent,
								target: this.casttarget
							})
						},
						characterAnim: function() {
							return new V({
								id: "swing_melee",
								duration: .5
							})
						}
					})
				}
			}

			function R(a) {
				this.level = a, this.type = "warrior", Va || (this.color = Vc.warrior), this.skills = {
					1: new v(1, this, {
						name: "Deep Cut",
						mana: .08,
						description: "Slash your enemies arteries, causing them to bleed over a period of time. Heals you for a percentage of your missing health.",
						icon: "data/skill/warrior_rend.jpg",
						targettype: "enemy",
						casttype: "instant",
						baselevel: 1,
						maxrange: 1.5,
						simulate: true,
						effect: function() {
							var a = this.abilitypower;
							this.parent.takeHealing(.1 * (this.parent.stats.maxhp - this.parent.stats.currenthp), this.parent), mb.damage({
								spread: .2,
								basedmg: 5,
								scaledmg: .5 + .4 * this.abilitypower,
								attacker: this.parent,
								target: this.casttarget,
								mod: {
									id: "deepcut",
									overwrite: true,
									duration: 5,
									interval: 1,
									movespeed: function(a) {
										return .65 * a
									},
									effect: function() {
										mb.damage({
											attacker: this.source,
											target: this.target,
											spread: .1,
											basedmg: 10,
											scaledmg: .2 + .1 * a
										})
									}
								}
							})
						},
						characterAnim: function() {
							return nd({
								parent: this.parent.weapon,
								aPos: new THREE.Vector3(0, 1.5, 0),
								bPos: new THREE.Vector3(0, -.3, 0),
								material: Vc.ribbon_arrow,
								stepInterval: .01,
								steps: 10,
								timeout: .45
							}), new V({
								id: "swing_melee",
								duration: .45
							})
						}
					}),
					2: new v(2, this, {
						name: "Whirlwind",
						mana: .2,
						icon: "data/skill/warrior_spin.jpg",
						description: "Spin your sword, dealing damage to enemies in a circle around you. Decreases movement speed while active.",
						targettype: "none",
						casttype: "instant",
						cooldown: 6,
						effecttype: "channel",
						channelInterval: .5,
						channelDuration: 4,
						channelMoveInterrupt: false,
						channelInstantFirstTick: true,
						maxrange: 8,
						predict: false,
						effect: function() {
							mb.damage({
								scaledmg: .42 + .4 * this.abilitypower,
								basedmg: 3,
								spread: .2,
								attacker: this.parent,
								mode: "aoe",
								aoeRange: 4
							}), this.parent.stats.addMod(new y(this.parent, this.parent, {
								duration: .8,
								name: "Whirlwind Slow",
								movespeed: function(a) {
									return 5
								}
							}))
						},
						channelAnim: Va ? void 0 : new V({
							id: "spin",
							duration: .5,
							type: "loop"
						}),
						onCastFun: Va ? void 0 : function() {
							nd({
								parent: this.parent.weapon,
								aPos: new THREE.Vector3(0, 1.8, 0),
								bPos: new THREE.Vector3(0, -.3, 0),
								material: Vc.ribbon_whirlwind,
								stepInterval: .015,
								steps: 15,
								timeout: 4
							})
						}
					}),
					3: new v(3, this, {
						name: "Charge",
						mana: .2,
						icon: "data/skill/warrior_charge.jpg",
						description: "Charge at your enemy, interrupting his current cast and stopping his movements.",
						casttype: "instant",
						cooldown: 9,
						effecttype: "channel",
						channelInterval: .1,
						channelDuration: 5,
						maxrange: 35,
						channelMoveInterrupt: false,
						ignoreEc: true,
						predict: false,
						effect: function() {
							this.casttarget && ib(this.parent, this.casttarget).distance() > 3 && !this.casttarget.stats.isDead() ? (this.parent.rotation = H(this.parent, this.casttarget), this.parent.walkForward = 1, this.parent.walkSideward = 0, Va ? this.parent.ignoreMovement = .1 : this.parent.ignoreInput = .15, this.parent.stats.addMod(new y(this.parent, this.parent, {
								duration: .15,
								name: "Charge",
								unique: true,
								movespeed: function(a) {
									return 30
								}
							})), this.casttarget.stats.addMod(new y(this.casttarget, this.parent, {
								duration: 1,
								name: "Stun",
								unique: true,
								incapacitate: true
							})), this.casttarget.walkForward = 0, this.casttarget.walkSideward = 0, mb.interrupt(this.casttarget, this.parent)) : (this.interruptChannel(), this.parent.walkForward = 0, this.parent.walkSideward = 0, this.parent.stats.servermovespeed = void 0)
						}
					}),
					4: new v(4, this, {
						name: "Taunt",
						mana: .2,
						icon: "data/skill/warrior_shout.jpg",
						description: "Intimidate your enemies with a loud roar, generating high levels of threat and regenerating a portion of your missing health. Removes debuffs.",
						targettype: "none",
						casttype: "instant",
						cooldown: 20,
						maxrange: 30,
						simulate: true,
						effect: function() {
							var a = this.abilitypower;
							mb.damage({
								scaledmg: .2 + .02 * this.abilitypower,
								basedmg: 3 + 2 * this.abilitypower,
								spread: .1,
								attacker: this.parent,
								mode: "aoe",
								aoeRange: 23,
								aggro: 1e3
							}), this.parent.stats.addMod(new y(this.parent, this.parent, {
								id: "tauntreg",
								overwrite: true,
								duration: 10,
								interval: 1,
								effect: function() {
									mb.damage({
										attacker: this.source,
										target: this.target,
										spread: .1,
										basedmg: (this.target.stats.maxhp - this.target.stats.currenthp) * (.04 + .018 * a),
										scaledmg: 0,
										heal: true
									})
								}
							}))
						},
						characterAnim: function() {
							return new V({
								id: "boost",
								duration: 1
							})
						}
					})
				}
			}

			function S(a) {
				this.level = a, this.type = "mage", Va || (this.color = Vc.mage), this.skills = {
					1: new v(1, this, {
						name: "Ice Bolt",
						mana: .05,
						description: "Fire a magic ice bolt at the enemy, dealing damage to all targets in the area and slowing them for a brief moment.",
						icon: "data/skill/mage_icebolt.jpg",
						targettype: "enemy",
						casttype: "instant",
						baselevel: 1,
						maxrange: 30,
						simulate: true,
						spell: function(a, b, c) {
							if (!Va) {
								var d = new THREE.Mesh(kd.icebolt.geo, Vc.generic_ice);
								d.scale.z = 2
							}
							return new u({
								name: "Ice Bolt",
								target: a,
								source: b,
								effect: c,
								mode: "follow",
								movespeed: 20,
								geometry: d ? d : void 0,
								ribbon: Va ? void 0 : {
									deleteWithSpell: false,
									parent: d,
									stepInterval: .1,
									steps: 5,
									timeout: 2,
									material: Vc.ribbon_ice,
									aPos: new THREE.Vector3(.9, 0, 1),
									bPos: new THREE.Vector3(-.9, 0, 1)
								}
							})
						},
						effect: function(a) {
							mb.damage({
								scaledmg: .3 + .3 * this.abilitypower,
								basedmg: 5,
								attacker: a.source,
								mode: "aoe",
								aoeRange: 9,
								aoeCenter: a.target.position,
								mod: {
									unique: true,
									id: "frostcallfrosted",
									duration: 6,
									name: "Frosted",
									movespeed: function(a) {
										return .6 * a
									}
								}
							})
						}
					}),
					2: new v(2, this, {
						name: "Frostcall",
						mana: .2,
						description: "You call down a blizzard on an enemies position, dealing damage over time. Channeled.",
						icon: "data/skill/mage_blizzard.jpg",
						targettype: "enemy",
						casttype: "timed",
						casttime: 1,
						effecttype: "channel",
						channelInterval: 1,
						channelDuration: 5,
						spellchannel: true,
						baselevel: 1,
						cooldown: 7,
						maxrange: 35,
						channelInstantFirstTick: true,
						allowDeadTarget: true,
						spell: function(a, b, c) {
							if (a) return new u({
								name: "Frostcall",
								startposition: Va ? a.position : a.geometry ? a.geometry.position : a.position,
								source: b,
								effect: c,
								mode: "static",
								timeout: 5,
								geometry: Va ? void 0 : new THREE.Mesh(kd.frostcall.geo, Vc.mage_frost)
							})
						},
						effect: function(a) {
							if (mb.damage({
									scaledmg: .8 + .5 * this.abilitypower,
									basedmg: 8 + 2 * this.abilitypower,
									spread: .2,
									attacker: a.source,
									mode: "aoe",
									aoeRange: 12,
									aoeCenter: a.spell.position,
									mod: {
										unique: true,
										id: "frostcallfrosted",
										duration: 2,
										name: "Frosted",
										movespeed: function(a) {
											return .4 * a
										}
									}
								}), !Va && a.target && a.target.geometry)
								for (var b = 0; b < 15; ++b) {
									var c = Math.random() * Math.PI * 2,
										d = 12 * Math.random(),
										e = new u({
											name: "Flake",
											mode: "static",
											movedir: new THREE.Vector3(0, -1, 0),
											startposition: new THREE.Vector3(a.spell.position.x + Math.cos(c) * d, a.target.geometry.position.y + 15 + 10 * Math.random(), a.spell.position.z + Math.sin(c) * d),
											timeout: 2,
											movespeed: 12,
											geometry: new THREE.Mesh(kd.frostcallblizz.geo, Vc.generic_ice)
										});
									Qb.push(e)
								}
						}
					}),
					3: new v(3, this, {
						name: "Teleport",
						mana: .2,
						description: "Teleports you forward in an instant.",
						icon: "data/skill/mage_tp.jpg",
						targettype: "none",
						casttype: "instant",
						cooldown: 9,
						effecttype: "instant",
						maxrange: 100,
						predict: false,
						effect: function(a) {
							var b = F(a.source.rotation);
							a.source.position.x += 25 * b.x, a.source.position.z += 25 * b.y, Va && (this.parent.ignoreMovement = .5), Va || a.source.animationQueue.push(new V({
								id: "channel",
								duration: .5
							}))
						}
					}),
					4: new v(4, this, {
						name: "Iceblock",
						mana: .3,
						description: "Freezes you in an iceblock, rendering you invincible for a moment and recovering a portion of your health.",
						icon: "data/skill/mage_iceblock.jpg",
						targettype: "none",
						casttype: "instant",
						cooldown: 18,
						effecttype: "channel",
						channelDuration: 5,
						channelInterval: 8,
						channelInstantFirstTick: true,
						channelMoveInterrupt: false,
						spellchannel: true,
						maxrange: 100,
						predict: false,
						ignoreEc: true,
						spell: function(a, b, c) {
							return new u({
								name: "Iceblock",
								startposition: Va ? b.position : b.geometry.position,
								source: b,
								mode: "static",
								effect: c,
								timeout: 5,
								geometry: Va ? void 0 : new THREE.Mesh(kd.iceblock.geo, Vc.mage_frost)
							})
						},
						effect: function(a) {
							var b = this.abilitypower;
							a.source.stats.addMod(new y(a.source, a.source, {
								duration: 5,
								name: "Iceblock",
								invincible: true,
								interval: 1,
								id: "iceblock",
								overwrite: true,
								movespeed: function() {
									return 0
								},
								effect: function() {
									mb.damage({
										attacker: this.source,
										target: this.target,
										spread: .1,
										basedmg: this.target.stats.maxhp * (.035 + .03 * b),
										scaledmg: 0,
										heal: true
									})
								}
							})), a.source.walkForward = 0, a.source.walkSideward = 0
						},
						channelAnim: Va ? void 0 : new V({
							id: "channel",
							duration: 60
						})
					})
				}
			}

			function T(a) {
				this.level = a, this.type = "archer", Va || (this.color = Vc.archer), this.skills = {
					1: new v(1, this, {
						name: "Piercing Shot",
						mana: .05,
						description: "Fires an arrow at your target. Pierces their armor up to 5 times, increasing your next Piercing Shot damage by 18%",
						icon: "data/skill/archer_pierce.jpg",
						targettype: "enemy",
						casttype: "instant",
						baselevel: 1,
						maxrange: 30,
						simulate: true,
						spell: function(a, b, c) {
							if (!Va) {
								var d = new THREE.Mesh(kd.archer_arrow.geo, Vc.archer_arrow);
								d.scale.set(kd.archer_arrow.scale[0], kd.archer_arrow.scale[1], kd.archer_arrow.scale[2])
							}
							return new u({
								name: "Pierce Shot",
								target: a,
								source: b,
								effect: c,
								mode: "follow",
								movespeed: 80,
								geometry: d ? d : void 0,
								ribbon: Va ? void 0 : {
									deleteWithSpell: false,
									parent: d,
									stepInterval: .05,
									steps: 5,
									timeout: 1,
									material: Vc.ribbon_arrow,
									aPos: new THREE.Vector3(.6, 0, 0),
									bPos: new THREE.Vector3(-.6, -0, 0)
								}
							})
						},
						effect: function(a) {
							if (a.target) {
								var b = 1 + .18 * a.target.stats.queryMod({
									source: a.source,
									id: "pierceshot"
								}).length;
								mb.damage({
									scaledmg: (.5 + .5 * this.abilitypower) * b,
									basedmg: 3 * b,
									attacker: a.source,
									target: a.target,
									mod: {
										id: "pierceshot",
										duration: 6
									}
								})
							}
						},
						characterAnim: function() {
							return new V({
								id: "release_spell",
								duration: .3
							})
						}
					}),
					2: new v(2, this, {
						name: "Volley",
						mana: .2,
						icon: "data/skill/archer_volley.jpg",
						description: "Shoot all targets infront of you over a duration.",
						targettype: "enemy",
						casttype: "instant",
						cooldown: 6,
						effecttype: "channel",
						channelInterval: Va ? .3 : .1,
						channelDuration: 3,
						channelMoveInterrupt: false,
						channelInstantFirstTick: true,
						maxrange: 30,
						predict: false,
						allowDeadTarget: true,
						effect: function() {
							mb.damage({
								scaledmg: .2 + .3 * this.abilitypower,
								basedmg: 3,
								spread: .2,
								attacker: this.parent,
								mode: "aoe",
								aoeRange: 33,
								aoeArc: .7,
								aoeFun: Va ? void 0 : function(a, b) {
									if (!(a.length <= 0)) {
										var c = new THREE.Mesh(kd.archer_arrow.geo, Vc.generic_wood);
										c.scale.set(kd.archer_arrow.scale[0], kd.archer_arrow.scale[1], kd.archer_arrow.scale[2]);
										var d = new u({
											name: "Volley",
											target: eb(a),
											source: b,
											mode: "follow",
											movespeed: 50,
											geometry: c,
											ribbon: {
												deleteWithSpell: false,
												parent: c,
												stepInterval: .05,
												steps: 5,
												timeout: 1,
												material: Vc.ribbon_arrow,
												aPos: new THREE.Vector3(.6, 0, 0),
												bPos: new THREE.Vector3(-.6, -0, 0)
											}
										});
										Qb.push(d)
									}
								}
							})
						},
						channelAnim: Va ? void 0 : new V({
							id: "release_spell",
							duration: .1,
							type: "loop"
						})
					}),
					3: new v(3, this, {
						name: "Leeching Arrow",
						mana: .2,
						description: "Fires a condemned arrow at your enemy, reducing their healing and stealing some of their health.",
						icon: "data/skill/archer_siphon.jpg",
						targettype: "enemy",
						casttype: "instant",
						maxrange: 30,
						cooldown: 14,
						simulate: true,
						spell: function(a, b, c) {
							if (!Va) var d = new THREE.Object3D;
							return new u({
								name: "Leeching Arrow",
								target: a,
								source: b,
								effect: c,
								mode: "follow",
								movespeed: 55,
								geometry: d ? d : void 0,
								ribbon: Va ? void 0 : {
									deleteWithSpell: false,
									parent: d,
									stepInterval: .05,
									steps: 10,
									timeout: 3,
									tailType: "default",
									material: Vc.ribbon_leech,
									aPos: new THREE.Vector3(1.5, 0, 0),
									bPos: new THREE.Vector3(-1.5, -0, 0)
								}
							})
						},
						effect: function(a) {
							var b = this.abilitypower,
								c = .8 + .5 * b;
							mb.damage({
								scaledmg: c,
								basedmg: 15,
								attacker: a.source,
								target: a.target,
								mod: {
									id: "leeching",
									unique: true,
									duration: 6,
									name: "Leeching Arrow",
									healmod: function(a) {
										return a * (.5 / b * .7 + .3)
									}
								}
							}), mb.damage({
								scaledmg: 1.2 * c,
								basedmg: 8,
								attacker: a.source,
								target: a.source,
								heal: true
							})
						},
						characterAnim: function() {
							return new V({
								id: "release_spell",
								duration: .3
							})
						}
					}),
					4: new v(4, this, {
						name: "Sprint",
						mana: .1,
						description: "You sprint at a very high speed for a short moment.",
						icon: "data/skill/archer_sprint.jpg",
						targettype: "none",
						casttype: "instant",
						cooldown: 5,
						effect: function(a) {
							mb.damage({
								attacker: a.source,
								target: a.source,
								buff: true,
								mod: {
									id: "windrush",
									unique: true,
									duration: .6,
									name: "Wind rush",
									movespeed: function(a) {
										return 30
									}
								}
							})
						},
						characterAnim: function() {
							return new V({
								id: "release_buff",
								duration: 1
							})
						}
					})
				}
			}

			function U(a) {
				this.level = a, this.type = "shaman", Va || (this.color = Vc.shaman), this.skills = {
					1: new v(1, this, {
						name: "Healing ritual",
						mana: .08,
						description: "Heals your target upon cast and for a short while afterwards.",
						icon: "data/skill/shaman_heal.jpg",
						targettype: "friendly",
						casttype: "instant",
						casttime: .6,
						baselevel: 1,
						maxrange: 30,
						effect: function() {
							var a = this.abilitypower;
							mb.damage({
								scaledmg: .25 + .1 * a,
								basedmg: 4,
								spread: .2,
								attacker: this.parent,
								target: this.casttarget,
								heal: true,
								mod: {
									id: "healritual",
									overwrite: true,
									duration: 10,
									interval: 1,
									effect: function() {
										mb.damage({
											attacker: this.source,
											target: this.target,
											spread: .1,
											basedmg: 2,
											scaledmg: .12 + .15 * a,
											heal: true
										})
									}
								}
							})
						},
						spell: Va ? void 0 : function(a, b, c) {
							if (a && b) {
								var d = new THREE.Object3D;
								return new u({
									name: "Healing ritual",
									mode: "attach",
									target: a,
									source: b,
									timeout: 10,
									geometry: d,
									tick: function(b) {
										this.geometry.position.copy(this.position);
										var c = .15 + a.stats.scale;
										this.geometry.position.x += Math.sin(8 * this.timeout) * c, this.geometry.position.z += Math.cos(8 * this.timeout) * c, this.geometry.position.y += Math.cos(5 + 6 * this.timeout) * c * .5, c *= .5, this.geometry.scale.set(c, c, c)
									},
									ribbon: {
										deleteWithSpell: true,
										parent: d,
										stepInterval: .1,
										steps: 8,
										timeout: 10,
										material: Vc.ribbon_heal,
										aPos: new THREE.Vector3(1.5, 0, 0),
										bPos: new THREE.Vector3(-1.5, -0, 0)
									}
								})
							}
						},
						characterAnim: function() {
							return new V({
								id: "release_buff",
								duration: .5
							})
						}
					}),
					2: new v(2, this, {
						name: "Equilibrate",
						mana: .2,
						description: "Summons a spirit upon a friendly target that heals allys and damages enemies",
						icon: "data/skill/shaman_spirit.jpg",
						targettype: "friendly",
						casttype: "instant",
						maxrange: 30,
						channelInstantFirstTick: true,
						unique: true,
						simulate: true,
						effect: function(a) {
							var b = this.abilitypower;
							mb.damage({
								scaledmg: .2 + .2 * b,
								basedmg: 3,
								spread: .2,
								attacker: a.source,
								target: a.target,
								heal: true
							}), mb.damage({
								scaledmg: .3 + .2 * b,
								basedmg: 6,
								spread: .1,
								attacker: a.source,
								mode: "aoe",
								aoeRange: 8,
								aoeCenter: a.spell.position
							})
						},
						spell: function(a, b, c) {
							var d = void 0;
							b.position;
							return Va || (d = new THREE.Mesh(kd.equilibrate.geo, Vc.generic_wood), d.scale.set(kd.equilibrate.scale[0], kd.equilibrate.scale[1], kd.equilibrate.scale[2])), new u({
								name: "Spirit",
								mode: "attach",
								target: a,
								source: b,
								effect: c,
								effectInterval: 1,
								timeout: 60,
								geometry: d,
								tick: Va ? void 0 : function(b) {
									this.geometry.position.copy(this.position);
									var c = .35 + a.stats.scale;
									this.geometry.position.x += Math.sin(4 * this.timeout) * c, this.geometry.position.z += Math.cos(4 * this.timeout) * c, this.geometry.rotation.x += 3 * b, this.geometry.rotation.z -= 2 * b, this.geometry.rotation.y = 1.5 * b, c *= .4, this.geometry.scale.set(c, c, c)
								},
								ribbon: Va ? void 0 : {
									deleteWithSpell: true,
									parent: d,
									stepInterval: .05,
									steps: 5,
									timeout: 60,
									material: Vc.ribbon_arrow,
									aPos: new THREE.Vector3(.6, 0, 0),
									bPos: new THREE.Vector3(-.6, -0, 0)
								}
							})
						}
					}),
					3: new v(3, this, {
						name: "Decay",
						mana: .1,
						icon: "data/skill/shaman_decay.jpg",
						description: "Cast a spell of decay upon your enemy, slowing their movement and dealing damage over time.",
						targettype: "enemy",
						casttype: "instant",
						baselevel: 1,
						maxrange: 25,
						simulate: true,
						effect: function(a) {
							var b = this.abilitypower;
							mb.damage({
								attacker: a.source,
								target: a.target,
								debuff: true,
								mod: {
									overwrite: true,
									id: "decay",
									duration: 8,
									name: "Decay",
									interval: 1,
									effect: function() {
										mb.damage({
											attacker: this.source,
											target: this.target,
											spread: .1,
											basedmg: 6 + 1 * b,
											scaledmg: .32 + .3 * b
										})
									}
								}
							}), mb.damage({
								attacker: a.source,
								target: a.target,
								debuff: true,
								mod: {
									unique: true,
									id: "decayslow",
									duration: 8,
									name: "Decay",
									movespeed: function(a) {
										return .7 * a
									}
								}
							})
						},
						spell: Va ? void 0 : function(a, b, c) {
							if (a && b && a != b) {
								var d = new THREE.Object3D;
								return new u({
									name: "Decay",
									mode: "attach",
									target: a,
									source: b,
									timeout: 10,
									geometry: d,
									tick: function(b) {
										this.geometry.position.copy(this.position);
										var c = .15 + a.stats.scale;
										this.geometry.position.x += Math.sin(8 * this.timeout) * c, this.geometry.position.z += Math.cos(8 * this.timeout) * c, this.geometry.position.y += Math.cos(5 + 6 * this.timeout) * c * .5, c *= .5, this.geometry.scale.set(c, c, c)
									},
									ribbon: {
										deleteWithSpell: true,
										parent: d,
										stepInterval: .1,
										steps: 8,
										timeout: 10,
										material: Vc.ribbon_decay,
										aPos: new THREE.Vector3(1.5, 0, 0),
										bPos: new THREE.Vector3(-1.5, -0, 0)
									}
								})
							}
						},
						characterAnim: function() {
							return new V({
								id: "release_buff",
								duration: 1
							})
						}
					}),
					4: new v(4, this, {
						name: "Wind rush",
						mana: .3,
						description: "Temporarily boost the movement speed of you and your allies.",
						icon: "data/skill/shaman_windrush.jpg",
						targettype: "none",
						casttype: "instant",
						cooldown: 20,
						maxrange: 30,
						simulate: true,
						effect: function(a) {
							mb.damage({
								attacker: a.source,
								buff: true,
								mode: "aoe",
								aoeRange: 30,
								mod: {
									id: "windrush",
									unique: true,
									duration: 6,
									name: "Wind rush",
									movespeed: function(a) {
										return 1.5 * a
									}
								}
							})
						},
						characterAnim: function() {
							return new V({
								id: "release_buff",
								duration: 1
							})
						}
					})
				}
			}

			function V(a) {
				this.id = a.id || "idle", this.type = a.type || "timed", this.duration = a.duration || 1, this.timer = this.duration, this.deleteMe = false
			}

			function W() {
				if (cc.expbar && Ic) {
					cc.expbartext.html(Ic.class.exp + " / " + Ic.class.nextLevelExp);
					var a = Math.min(100, Ic.class.exp / Ic.class.nextLevelExp * 100);
					cc.expbar.css("width", a + "%")
				}
			}

			function X() {
				var a;
				cc.castbar && Ic && 1 == Ic.state.id ? (a = 100 - Ic.state.duration / Ic.state.maxduration * 100, cc.castbarcontainer.show()) : (cc.castbarcontainer.hide(), a = 0), cc.castbar.css("width", a + "%")
			}

			function Y(a) {
				if (cc.chatboxWrapper) {
					var b = a.msg || "Message error.",
						c = "chatmsg";
					if (a.src) switch (a.src) {
						case "server":
						case "whisper":
							c += " chatmsg-w";
							break;
						case "playerkill":
							if (!va(Pa.get("chat-pvp"))) return;
							c += " chatmsg-pk";
							break;
						case "death":
							c += " chatmsg-death";
							break;
						case "system":
							c += " chatmsg-system";
							break;
						case "loot":
							if (!va(Pa.get("chat-loot"))) return;
							c += " chatmsg-loot";
							break;
						case "exp":
							if (!va(Pa.get("chat-exp"))) return;
							c += " chatmsg-exp";
							break;
						case "clan":
							if (!va(Pa.get("chat-chat"))) return;
							if (c += " chatmsg-clan", !a.name) return false;
							b = "[" + a.name + " (clan)]: " + b;
							break;
						case "global":
							if (!va(Pa.get("chat-chat"))) return;
							if (c += " chatmsg-global", 0 === a.r && (c += " unreg"), !a.name) return false;
							if(typeof window.muted!=="undefined"&&!!~window.muted.indexOf(a.name)) return;
							if ($(".targetname")[0].innerText.substring(0, $(".targetname")[0].innerText.length-4)!=='')(b.startsWith("@"+$(".targetname")[0].innerText.substring(0, $(".targetname")[0].innerText.length-4)+" "))||b==="@"+$(".targetname")[0].innerText.substring(0, $(".targetname")[0].innerText.length-4)?c="chatmsg chatmsg-mention":c=c;
							b = "[" + a.name + "]: " + b;
							break;
						case "gm":
							if (!va(Pa.get("chat-chat"))) return;
							if (c += " chatmsg-w", !a.name) return false;
							b = "[" + a.name + " (GM)]: " + b
					}
					var d = Math.round(cc.chatboxWrapper[0].scrollHeight - cc.chatboxWrapper[0].scrollTop) === Math.round(cc.chatboxWrapper[0].clientHeight),
						e = $("<p class='" + c + "'></p>");
					e.text(b), void 0 !== a.c && void 0 !== a.f && e.html("<span class='" + (0 == a.f ? "factionA" : "factionB") + "'>" + a.c + " </span>" + e.html()), e.html(e.html().replace("$g", dc.goldCoin)), e.html(e.html().replace("$0", dc.faction1)), e.html(e.html().replace("$1", dc.faction2)), e.appendTo(cc.chatboxBody);
					var f = $("#chatboxBody > p");
					f.length > 50 && f[0].remove(), d && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
				}
			}

			function Z(a) {
				var b = document.createElement("canvas");
				b.width = a.width, b.height = a.height;
				var c = b.getContext("2d");
				return c.drawImage(a, 0, 0), c.getImageData(0, 0, a.width, a.height)
			}

			function _(a, b, c) {
				return a <= b ? b : a >= c ? c : a
			}

			function aa(a, b) {
				a = _(a, 0, Va ? heightmap.shape[0] : zc.width - 1), b = _(b, 0, Va ? heightmap.shape[0] : zc.width - 1);
				var c = Va ? 4 * (a + heightmap.shape[0] * b) : 4 * (a + zc.width * b),
					d = Va ? heightmap.data : zc.data;
				return {
					r: d[c],
					g: d[c + 1],
					b: d[c + 2],
					a: d[c + 3]
				}
			}

			function ba(a) {
				if (!a.material) return false;
				this.steps = a.steps || 10, this.stepInterval = a.stepInterval || .5, this.stepIntervalTimer = this.stepInterval, this.stepsDone = 0, this.headType = a.headType || "glue", this.tailType = a.tailType || "compress", this.geom = new THREE.PlaneGeometry(1, 1, 1, this.steps - 1), this.material = a.material, this.mesh = new THREE.Mesh(this.geom, this.material), this.mesh.frustumCulled = false, Ac.add(this.mesh), this.timeout = a.timeout || void 0, this.timeout && (this.timer = this.timeout), this.a = new THREE.Object3D, Ac.add(this.a), this.b = new THREE.Object3D, Ac.add(this.b), a.parent && (a.parent.add(this.a), a.parent.add(this.b), a.parent.updateMatrixWorld()), a.aPos && this.a.position.copy(a.aPos), a.bPos && this.b.position.copy(a.bPos), this.at = [];
				var b = this.a.getWorldPosition();
				this.bt = [];
				for (var c = this.b.getWorldPosition(), d = 0; d < this.steps; ++d) this.at.push(new THREE.Vector3(b.x, b.y, b.z)), this.bt.push(new THREE.Vector3(c.x, c.y, c.z));
				this.step(b, c), this.uvStepSize = 1 / this.steps, this.uvShift = 0, this.deleteMe = false
			}

			function ca(a) {
				"use strict";
				var b, c = a.children;
				if (c)
					for (var d = 0; d < c.length; d += 1) b = c[d], ca(b)
			}

			function da(a, b) {
				var c = new THREE.Vector3;
				return c.copy(a), c.project(b), c.x = Math.round(c.x * za.width * .5), c.y = Math.round(c.y * za.height * .5), c
			}

			function ea() {
				this.isresetting = 0, this.goal = new THREE.Vector2(0, 0), this.hasReachedGoal = false, this.tick = function(a) {
					if (this.parent.target && !za.entities.hasOwnProperty(this.parent.target.id) && (this.parent.desiredTarget = this.parent.target.id, this.parent.target = void 0), this.parent.target) {
						var b = ib(this.parent.target, this.parent),
							c = void 0 != b && b.distance() < this.parent.class.skills[1].maxrange + 1.2;
						this.parent.walkForward = c ? 0 : 1, this.parent.rotation = H(this.parent, this.parent.target)
					} else this.parent.walkForward = 0, 0 == this.goal.x || 0 == this.goal.z || this.hasReachedGoal || (I(this.parent, this.goal) > this.parent.stats.movespeed * a ? (this.parent.walkForward = 1, this.parent.rotation = G(this.parent.position, this.goal)) : (this.parent.walkForward = 0, this.hasReachedGoal = true))
				}
			}

			function fa(a) {
				var b = Pd[a];
				if (!b) {
					var c = document.getElementsByTagName("body")[0],
						d = document.createElement("div"),
						e = document.createTextNode("MÃ‰q");
					d.appendChild(e), d.setAttribute("style", "font:" + a + ";position:absolute;top:0;left:0"), c.appendChild(d), b = d.offsetHeight, Pd[a] = b, c.removeChild(d)
				}
				return b
			}

			function ga() {
				return this.textWidth = null, this.textHeight = null, this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this
			}

			function ha(a, b) {
				THREE.Object3D.call(this), this._font = b.font || "30px Arial", this._fillStyle = b.fillStyle || "#FFFFFF", this._shadow = void 0 !== b.shadow ? b.shadow : 1, this.canvas = new ga, this.align = b.align || Od.center, this.antialias = ("undefined" === b.antialias, true), this.setText(a)
			}
			var ia = window.location != window.parent.location ? document.referrer : document.location.href,
				ja = function(a, b) {
					return a.indexOf(b) !== -1
				};
			(ja(ia, "hordesio.com") || ja(ia, "hordes-io.com")) && (window.top.location.href = "http://hordes.io"), window.onerror = function(a, b, c, d, e) {
					if (window.onerror = null, e && (e = e.toString()), "undefined" != typeof WebSocket && (null == b || b.indexOf("hordes") != -1)) {
						var f = new XMLHttpRequest,
							g = JSON.stringify({
								message: a,
								source: b,
								lineno: c,
								colno: d,
								error: e
							});
						f.open("POST", "/error", true), f.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), f.send(g), console.log("Error: " + g)
					}
				}, ! function(a, b) {
					"use strict";
					"object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, true) : function(a) {
						if (!a.document) throw new Error("jQuery requires a window with a document");
						return b(a)
					} : b(a)
				}("undefined" != typeof window ? window : this, function(a, b) {
					"use strict";

					function c(a, b) {
						b = b || ca;
						var c = b.createElement("script");
						c.text = a, b.head.appendChild(c).parentNode.removeChild(c)
					}

					function d(a) {
						var b = !!a && "length" in a && a.length,
							c = pa.type(a);
						return "function" !== c && !pa.isWindow(a) && ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a)
					}

					function e(a, b) {
						return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
					}

					function f(a, b, c) {
						return pa.isFunction(b) ? pa.grep(a, function(a, d) {
							return !!b.call(a, d, a) !== c
						}) : b.nodeType ? pa.grep(a, function(a) {
							return a === b !== c
						}) : "string" != typeof b ? pa.grep(a, function(a) {
							return ha.call(b, a) > -1 !== c
						}) : za.test(b) ? pa.filter(b, a, c) : (b = pa.filter(b, a), pa.grep(a, function(a) {
							return ha.call(b, a) > -1 !== c && 1 === a.nodeType
						}))
					}

					function g(a, b) {
						for (;
							(a = a[b]) && 1 !== a.nodeType;);
						return a
					}

					function h(a) {
						var b = {};
						return pa.each(a.match(Fa) || [], function(a, c) {
							b[c] = true
						}), b
					}

					function i(a) {
						return a
					}

					function j(a) {
						throw a
					}

					function k(a, b, c, d) {
						var e;
						try {
							a && pa.isFunction(e = a.promise) ? e.call(a).done(b).fail(c) : a && pa.isFunction(e = a.then) ? e.call(a, b, c) : b.apply(void 0, [a].slice(d))
						} catch (a) {
							c.apply(void 0, [a])
						}
					}

					function l() {
						ca.removeEventListener("DOMContentLoaded", l), a.removeEventListener("load", l), pa.ready()
					}

					function m() {
						this.expando = pa.expando + m.uid++
					}

					function n(a) {
						return "true" === a || "false" !== a && ("null" === a ? null : a === +a + "" ? +a : Ma.test(a) ? JSON.parse(a) : a)
					}

					function o(a, b, c) {
						var d;
						if (void 0 === c && 1 === a.nodeType)
							if (d = "data-" + b.replace(Na, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
								try {
									c = n(c)
								} catch (a) {}
								La.set(a, b, c)
							} else c = void 0;
						return c
					}

					function p(a, b, c, d) {
						var e, f = 1,
							g = 20,
							h = d ? function() {
								return d.cur()
							} : function() {
								return pa.css(a, b, "")
							},
							i = h(),
							j = c && c[3] || (pa.cssNumber[b] ? "" : "px"),
							k = (pa.cssNumber[b] || "px" !== j && +i) && Pa.exec(pa.css(a, b));
						if (k && k[3] !== j) {
							j = j || k[3], c = c || [], k = +i || 1;
							do f = f || ".5", k /= f, pa.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g)
						}
						return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e
					}

					function q(a) {
						var b, c = a.ownerDocument,
							d = a.nodeName,
							e = Ta[d];
						return e ? e : (b = c.body.appendChild(c.createElement(d)), e = pa.css(b, "display"), b.parentNode.removeChild(b), "none" === e && (e = "block"), Ta[d] = e, e)
					}

					function r(a, b) {
						for (var c, d, e = [], f = 0, g = a.length; f < g; f++) d = a[f], d.style && (c = d.style.display, b ? ("none" === c && (e[f] = Ka.get(d, "display") || null, e[f] || (d.style.display = "")), "" === d.style.display && Ra(d) && (e[f] = q(d))) : "none" !== c && (e[f] = "none", Ka.set(d, "display", c)));
						for (f = 0; f < g; f++) null != e[f] && (a[f].style.display = e[f]);
						return a
					}

					function s(a, b) {
						var c;
						return c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [], void 0 === b || b && e(a, b) ? pa.merge([a], c) : c
					}

					function t(a, b) {
						for (var c = 0, d = a.length; c < d; c++) Ka.set(a[c], "globalEval", !b || Ka.get(b[c], "globalEval"))
					}

					function u(a, b, c, d, e) {
						for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], n = 0, o = a.length; n < o; n++)
							if (f = a[n], f || 0 === f)
								if ("object" === pa.type(f)) pa.merge(m, f.nodeType ? [f] : f);
								else if (Ya.test(f)) {
							for (g = g || l.appendChild(b.createElement("div")), h = (Va.exec(f) || ["", ""])[1].toLowerCase(), i = Xa[h] || Xa._default, g.innerHTML = i[1] + pa.htmlPrefilter(f) + i[2], k = i[0]; k--;) g = g.lastChild;
							pa.merge(m, g.childNodes), g = l.firstChild, g.textContent = ""
						} else m.push(b.createTextNode(f));
						for (l.textContent = "", n = 0; f = m[n++];)
							if (d && pa.inArray(f, d) > -1) e && e.push(f);
							else if (j = pa.contains(f.ownerDocument, f), g = s(l.appendChild(f), "script"), j && t(g), c)
							for (k = 0; f = g[k++];) Wa.test(f.type || "") && c.push(f);
						return l
					}

					function v() {
						return true
					}

					function w() {
						return false
					}

					function x() {
						try {
							return ca.activeElement
						} catch (a) {}
					}

					function y(a, b, c, d, e, f) {
						var g, h;
						if ("object" == typeof b) {
							"string" != typeof c && (d = d || c, c = void 0);
							for (h in b) y(a, h, c, d, b[h], f);
							return a
						}
						if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === false) e = w;
						else if (!e) return a;
						return 1 === f && (g = e, e = function(a) {
							return pa().off(a), g.apply(this, arguments)
						}, e.guid = g.guid || (g.guid = pa.guid++)), a.each(function() {
							pa.event.add(this, b, e, d, c)
						})
					}

					function z(a, b) {
						return e(a, "table") && e(11 !== b.nodeType ? b : b.firstChild, "tr") ? pa(">tbody", a)[0] || a : a
					}

					function A(a) {
						return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
					}

					function B(a) {
						var b = eb.exec(a.type);
						return b ? a.type = b[1] : a.removeAttribute("type"), a
					}

					function C(a, b) {
						var c, d, e, f, g, h, i, j;
						if (1 === b.nodeType) {
							if (Ka.hasData(a) && (f = Ka.access(a), g = Ka.set(b, f), j = f.events)) {
								delete g.handle, g.events = {};
								for (e in j)
									for (c = 0, d = j[e].length; c < d; c++) pa.event.add(b, e, j[e][c])
							}
							La.hasData(a) && (h = La.access(a), i = pa.extend({}, h), La.set(b, i))
						}
					}

					function D(a, b) {
						var c = b.nodeName.toLowerCase();
						"input" === c && Ua.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue)
					}

					function E(a, b, d, e) {
						b = fa.apply([], b);
						var f, g, h, i, j, k, l = 0,
							m = a.length,
							n = m - 1,
							o = b[0],
							p = pa.isFunction(o);
						if (p || m > 1 && "string" == typeof o && !na.checkClone && db.test(o)) return a.each(function(c) {
							var f = a.eq(c);
							p && (b[0] = o.call(this, c, f.html())), E(f, b, d, e)
						});
						if (m && (f = u(b, a[0].ownerDocument, false, a, e), g = f.firstChild, 1 === f.childNodes.length && (f = g), g || e)) {
							for (h = pa.map(s(f, "script"), A), i = h.length; l < m; l++) j = f, l !== n && (j = pa.clone(j, true, true), i && pa.merge(h, s(j, "script"))), d.call(a[l], j, l);
							if (i)
								for (k = h[h.length - 1].ownerDocument, pa.map(h, B), l = 0; l < i; l++) j = h[l], Wa.test(j.type || "") && !Ka.access(j, "globalEval") && pa.contains(k, j) && (j.src ? pa._evalUrl && pa._evalUrl(j.src) : c(j.textContent.replace(fb, ""), k))
						}
						return a
					}

					function F(a, b, c) {
						for (var d, e = b ? pa.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || pa.cleanData(s(d)), d.parentNode && (c && pa.contains(d.ownerDocument, d) && t(s(d, "script")), d.parentNode.removeChild(d));
						return a
					}

					function G(a, b, c) {
						var d, e, f, g, h = a.style;
						return c = c || ib(a), c && (g = c.getPropertyValue(b) || c[b], "" !== g || pa.contains(a.ownerDocument, a) || (g = pa.style(a, b)), !na.pixelMarginRight() && hb.test(g) && gb.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g
					}

					function H(a, b) {
						return {
							get: function() {
								return a() ? void delete this.get : (this.get = b).apply(this, arguments)
							}
						}
					}

					function I(a) {
						if (a in ob) return a;
						for (var b = a[0].toUpperCase() + a.slice(1), c = nb.length; c--;)
							if (a = nb[c] + b, a in ob) return a
					}

					function J(a) {
						var b = pa.cssProps[a];
						return b || (b = pa.cssProps[a] = I(a) || a), b
					}

					function K(a, b, c) {
						var d = Pa.exec(b);
						return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b
					}

					function L(a, b, c, d, e) {
						var f, g = 0;
						for (f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0; f < 4; f += 2) "margin" === c && (g += pa.css(a, c + Qa[f], true, e)), d ? ("content" === c && (g -= pa.css(a, "padding" + Qa[f], true, e)), "margin" !== c && (g -= pa.css(a, "border" + Qa[f] + "Width", true, e))) : (g += pa.css(a, "padding" + Qa[f], true, e), "padding" !== c && (g += pa.css(a, "border" + Qa[f] + "Width", true, e)));
						return g
					}

					function M(a, b, c) {
						var d, e = ib(a),
							f = G(a, b, e),
							g = "border-box" === pa.css(a, "boxSizing", false, e);
						return hb.test(f) ? f : (d = g && (na.boxSizingReliable() || f === a.style[b]), f = parseFloat(f) || 0, f + L(a, b, c || (g ? "border" : "content"), d, e) + "px")
					}

					function N(a, b, c, d, e) {
						return new N.prototype.init(a, b, c, d, e)
					}

					function O() {
						qb && (ca.hidden === false && a.requestAnimationFrame ? a.requestAnimationFrame(O) : a.setTimeout(O, pa.fx.interval), pa.fx.tick())
					}

					function P() {
						return a.setTimeout(function() {
							pb = void 0
						}), pb = pa.now()
					}

					function Q(a, b) {
						var c, d = 0,
							e = {
								height: a
							};
						for (b = b ? 1 : 0; d < 4; d += 2 - b) c = Qa[d], e["margin" + c] = e["padding" + c] = a;
						return b && (e.opacity = e.width = a), e
					}

					function R(a, b, c) {
						for (var d, e = (U.tweeners[b] || []).concat(U.tweeners["*"]), f = 0, g = e.length; f < g; f++)
							if (d = e[f].call(c, b, a)) return d
					}

					function S(a, b, c) {
						var d, e, f, g, h, i, j, k, l = "width" in b || "height" in b,
							m = this,
							n = {},
							o = a.style,
							p = a.nodeType && Ra(a),
							q = Ka.get(a, "fxshow");
						c.queue || (g = pa._queueHooks(a, "fx"), null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function() {
							g.unqueued || h()
						}), g.unqueued++, m.always(function() {
							m.always(function() {
								g.unqueued--, pa.queue(a, "fx").length || g.empty.fire()
							})
						}));
						for (d in b)
							if (e = b[d], rb.test(e)) {
								if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
									if ("show" !== e || !q || void 0 === q[d]) continue;
									p = true
								}
								n[d] = q && q[d] || pa.style(a, d)
							}
						if (i = !pa.isEmptyObject(b), i || !pa.isEmptyObject(n)) {
							l && 1 === a.nodeType && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = q && q.display, null == j && (j = Ka.get(a, "display")), k = pa.css(a, "display"), "none" === k && (j ? k = j : (r([a], true), j = a.style.display || j, k = pa.css(a, "display"), r([a]))), ("inline" === k || "inline-block" === k && null != j) && "none" === pa.css(a, "float") && (i || (m.done(function() {
								o.display = j
							}), null == j && (k = o.display, j = "none" === k ? "" : k)), o.display = "inline-block")), c.overflow && (o.overflow = "hidden", m.always(function() {
								o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
							})), i = false;
							for (d in n) i || (q ? "hidden" in q && (p = q.hidden) : q = Ka.access(a, "fxshow", {
								display: j
							}), f && (q.hidden = !p), p && r([a], true), m.done(function() {
								p || r([a]), Ka.remove(a, "fxshow");
								for (d in n) pa.style(a, d, n[d])
							})), i = R(p ? q[d] : 0, d, m), d in q || (q[d] = i.start, p && (i.end = i.start, i.start = 0))
						}
					}

					function T(a, b) {
						var c, d, e, f, g;
						for (c in a)
							if (d = pa.camelCase(c), e = b[d], f = a[c], Array.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = pa.cssHooks[d], g && "expand" in g) {
								f = g.expand(f), delete a[d];
								for (c in f) c in a || (a[c] = f[c], b[c] = e)
							} else b[d] = e
					}

					function U(a, b, c) {
						var d, e, f = 0,
							g = U.prefilters.length,
							h = pa.Deferred().always(function() {
								delete i.elem
							}),
							i = function() {
								if (e) return false;
								for (var b = pb || P(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.neonates.length; g < i; g++) j.neonates[g].run(f);
								return h.notifyWith(a, [j, f, c]), f < 1 && i ? c : (i || h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j]), false)
							},
							j = h.promise({
								elem: a,
								props: pa.extend({}, b),
								opts: pa.extend(true, {
									specialEasing: {},
									easing: pa.easing._default
								}, c),
								originalProperties: b,
								originalOptions: c,
								startTime: pb || P(),
								duration: c.duration,
								neonates: [],
								createTween: function(b, c) {
									var d = pa.Neonate(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
									return j.neonates.push(d), d
								},
								stop: function(b) {
									var c = 0,
										d = b ? j.neonates.length : 0;
									if (e) return this;
									for (e = true; c < d; c++) j.neonates[c].run(1);
									return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this
								}
							}),
							k = j.props;
						for (T(k, j.opts.specialEasing); f < g; f++)
							if (d = U.prefilters[f].call(j, a, k, j.opts)) return pa.isFunction(d.stop) && (pa._queueHooks(j.elem, j.opts.queue).stop = pa.proxy(d.stop, d)), d;
						return pa.map(k, R, j), pa.isFunction(j.opts.start) && j.opts.start.call(a, j), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always), pa.fx.timer(pa.extend(i, {
							elem: a,
							anim: j,
							queue: j.opts.queue
						})), j
					}

					function V(a) {
						var b = a.match(Fa) || [];
						return b.join(" ")
					}

					function W(a) {
						return a.getAttribute && a.getAttribute("class") || ""
					}

					function X(a, b, c, d) {
						var e;
						if (Array.isArray(b)) pa.each(b, function(b, e) {
							c || Cb.test(a) ? d(a, e) : X(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d)
						});
						else if (c || "object" !== pa.type(b)) d(a, b);
						else
							for (e in b) X(a + "[" + e + "]", b[e], c, d)
					}

					function Y(a) {
						return function(b, c) {
							"string" != typeof b && (c = b, b = "*");
							var d, e = 0,
								f = b.toLowerCase().match(Fa) || [];
							if (pa.isFunction(c))
								for (; d = f[e++];) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
						}
					}

					function Z(a, b, c, d) {
						function e(h) {
							var i;
							return f[h] = true, pa.each(a[h] || [], function(a, h) {
								var j = h(b, c, d);
								return "string" != typeof j || g || f[j] ? g ? !(i = j) : void 0 : (b.dataTypes.unshift(j), e(j), false)
							}), i
						}
						var f = {},
							g = a === Ob;
						return e(b.dataTypes[0]) || !f["*"] && e("*")
					}

					function $(a, b) {
						var c, d, e = pa.ajaxSettings.flatOptions || {};
						for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
						return d && pa.extend(true, a, d), a
					}

					function _(a, b, c) {
						for (var d, e, f, g, h = a.contents, i = a.dataTypes;
							"*" === i[0];) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
						if (d)
							for (e in h)
								if (h[e] && h[e].test(d)) {
									i.unshift(e);
									break
								}
						if (i[0] in c) f = i[0];
						else {
							for (e in c) {
								if (!i[0] || a.converters[e + " " + i[0]]) {
									f = e;
									break
								}
								g || (g = e)
							}
							f = f || g
						}
						if (f) return f !== i[0] && i.unshift(f), c[f]
					}

					function aa(a, b, c, d) {
						var e, f, g, h, i, j = {},
							k = a.dataTypes.slice();
						if (k[1])
							for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
						for (f = k.shift(); f;)
							if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
								if ("*" === f) f = i;
								else if ("*" !== i && i !== f) {
							if (g = j[i + " " + f] || j["* " + f], !g)
								for (e in j)
									if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
										g === true ? g = j[e] : j[e] !== true && (f = h[0], k.unshift(h[1]));
										break
									}
							if (g !== true)
								if (g && a.throws) b = g(b);
								else try {
									b = g(b)
								} catch (a) {
									return {
										state: "parsererror",
										error: g ? a : "No conversion from " + i + " to " + f
									}
								}
						}
						return {
							state: "success",
							data: b
						}
					}
					var ba = [],
						ca = a.document,
						da = Object.getPrototypeOf,
						ea = ba.slice,
						fa = ba.concat,
						ga = ba.push,
						ha = ba.indexOf,
						ia = {},
						ja = ia.toString,
						ka = ia.hasOwnProperty,
						la = ka.toString,
						ma = la.call(Object),
						na = {},
						oa = "3.2.0",
						pa = function(a, b) {
							return new pa.fn.init(a, b)
						},
						qa = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
						ra = /^-ms-/,
						sa = /-([a-z])/g,
						ta = function(a, b) {
							return b.toUpperCase()
						};
					pa.fn = pa.prototype = {
						jquery: oa,
						constructor: pa,
						length: 0,
						toArray: function() {
							return ea.call(this)
						},
						get: function(a) {
							return null == a ? ea.call(this) : a < 0 ? this[a + this.length] : this[a]
						},
						pushStack: function(a) {
							var b = pa.merge(this.constructor(), a);
							return b.prevObject = this, b
						},
						each: function(a) {
							return pa.each(this, a)
						},
						map: function(a) {
							return this.pushStack(pa.map(this, function(b, c) {
								return a.call(b, c, b)
							}))
						},
						slice: function() {
							return this.pushStack(ea.apply(this, arguments))
						},
						first: function() {
							return this.eq(0)
						},
						last: function() {
							return this.eq(-1)
						},
						eq: function(a) {
							var b = this.length,
								c = +a + (a < 0 ? b : 0);
							return this.pushStack(c >= 0 && c < b ? [this[c]] : [])
						},
						end: function() {
							return this.prevObject || this.constructor()
						},
						push: ga,
						sort: ba.sort,
						splice: ba.splice
					}, pa.extend = pa.fn.extend = function() {
						var a, b, c, d, e, f, g = arguments[0] || {},
							h = 1,
							i = arguments.length,
							j = false;
						for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || pa.isFunction(g) || (g = {}), h === i && (g = this, h--); h < i; h++)
							if (null != (a = arguments[h]))
								for (b in a) c = g[b], d = a[b], g !== d && (j && d && (pa.isPlainObject(d) || (e = Array.isArray(d))) ? (e ? (e = false, f = c && Array.isArray(c) ? c : []) : f = c && pa.isPlainObject(c) ? c : {}, g[b] = pa.extend(j, f, d)) : void 0 !== d && (g[b] = d));
						return g
					}, pa.extend({
						expando: "jQuery" + (oa + Math.random()).replace(/\D/g, ""),
						isReady: true,
						error: function(a) {
							throw new Error(a)
						},
						noop: function() {},
						isFunction: function(a) {
							return "function" === pa.type(a)
						},
						isWindow: function(a) {
							return null != a && a === a.window
						},
						isNumeric: function(a) {
							var b = pa.type(a);
							return ("number" === b || "string" === b) && !isNaN(a - parseFloat(a))
						},
						isPlainObject: function(a) {
							var b, c;
							return !(!a || "[object Object]" !== ja.call(a) || (b = da(a)) && (c = ka.call(b, "constructor") && b.constructor, "function" != typeof c || la.call(c) !== ma))
						},
						isEmptyObject: function(a) {
							var b;
							for (b in a) return false;
							return true
						},
						type: function(a) {
							return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? ia[ja.call(a)] || "object" : typeof a
						},
						globalEval: function(a) {
							c(a)
						},
						camelCase: function(a) {
							return a.replace(ra, "ms-").replace(sa, ta)
						},
						each: function(a, b) {
							var c, e = 0;
							if (d(a))
								for (c = a.length; e < c && b.call(a[e], e, a[e]) !== false; e++);
							else
								for (e in a)
									if (b.call(a[e], e, a[e]) === false) break;
							return a
						},
						trim: function(a) {
							return null == a ? "" : (a + "").replace(qa, "")
						},
						makeArray: function(a, b) {
							var c = b || [];
							return null != a && (d(Object(a)) ? pa.merge(c, "string" == typeof a ? [a] : a) : ga.call(c, a)), c
						},
						inArray: function(a, b, c) {
							return null == b ? -1 : ha.call(b, a, c)
						},
						merge: function(a, b) {
							for (var c = +b.length, d = 0, e = a.length; d < c; d++) a[e++] = b[d];
							return a.length = e, a
						},
						grep: function(a, b, c) {
							for (var d, e = [], f = 0, g = a.length, h = !c; f < g; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
							return e
						},
						map: function(a, b, c) {
							var e, f, g = 0,
								h = [];
							if (d(a))
								for (e = a.length; g < e; g++) f = b(a[g], g, c), null != f && h.push(f);
							else
								for (g in a) f = b(a[g], g, c), null != f && h.push(f);
							return fa.apply([], h)
						},
						guid: 1,
						proxy: function(a, b) {
							var c, d, e;
							if ("string" == typeof b && (c = a[b], b = a, a = c), pa.isFunction(a)) return d = ea.call(arguments, 2), e = function() {
								return a.apply(b || this, d.concat(ea.call(arguments)))
							}, e.guid = a.guid = a.guid || pa.guid++, e
						},
						now: Date.now,
						support: na
					}), "function" == typeof Symbol && (pa.fn[Symbol.iterator] = ba[Symbol.iterator]), pa.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(a, b) {
						ia["[object " + b + "]"] = b.toLowerCase()
					});
					var ua = function(a) {
						function b(a, b, c, d) {
							var e, f, g, h, i, j, k, m = b && b.ownerDocument,
								o = b ? b.nodeType : 9;
							if (c = c || [], "string" != typeof a || !a || 1 !== o && 9 !== o && 11 !== o) return c;
							if (!d && ((b ? b.ownerDocument || b : P) !== H && G(b), b = b || H, J)) {
								if (11 !== o && (i = ra.exec(a)))
									if (e = i[1]) {
										if (9 === o) {
											if (!(g = b.getElementById(e))) return c;
											if (g.id === e) return c.push(g), c
										} else if (m && (g = m.getElementById(e)) && N(b, g) && g.id === e) return c.push(g), c
									} else {
										if (i[2]) return $.apply(c, b.getElementsByTagName(a)), c;
										if ((e = i[3]) && w.getElementsByClassName && b.getElementsByClassName) return $.apply(c, b.getElementsByClassName(e)), c
									}
								if (w.qsa && !U[a + " "] && (!K || !K.test(a))) {
									if (1 !== o) m = b, k = a;
									else if ("object" !== b.nodeName.toLowerCase()) {
										for ((h = b.getAttribute("id")) ? h = h.replace(va, wa) : b.setAttribute("id", h = O), j = A(a), f = j.length; f--;) j[f] = "#" + h + " " + n(j[f]);
										k = j.join(","), m = sa.test(a) && l(b.parentNode) || b
									}
									if (k) try {
										return $.apply(c, m.querySelectorAll(k)), c
									} catch (a) {} finally {
										h === O && b.removeAttribute("id")
									}
								}
							}
							return C(a.replace(ha, "$1"), b, c, d)
						}

						function c() {
							function a(c, d) {
								return b.push(c + " ") > x.cacheLength && delete a[b.shift()], a[c + " "] = d
							}
							var b = [];
							return a
						}

						function d(a) {
							return a[O] = true, a
						}

						function e(a) {
							var b = H.createElement("fieldset");
							try {
								return !!a(b)
							} catch (a) {
								return false
							} finally {
								b.parentNode && b.parentNode.removeChild(b), b = null
							}
						}

						function f(a, b) {
							for (var c = a.split("|"), d = c.length; d--;) x.attrHandle[c[d]] = b
						}

						function g(a, b) {
							var c = b && a,
								d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
							if (d) return d;
							if (c)
								for (; c = c.nextSibling;)
									if (c === b) return -1;
							return a ? 1 : -1
						}

						function h(a) {
							return function(b) {
								var c = b.nodeName.toLowerCase();
								return "input" === c && b.type === a
							}
						}

						function i(a) {
							return function(b) {
								var c = b.nodeName.toLowerCase();
								return ("input" === c || "button" === c) && b.type === a
							}
						}

						function j(a) {
							return function(b) {
								return "form" in b ? b.parentNode && b.disabled === false ? "label" in b ? "label" in b.parentNode ? b.parentNode.disabled === a : b.disabled === a : b.isDisabled === a || b.isDisabled !== !a && ya(b) === a : b.disabled === a : "label" in b && b.disabled === a
							}
						}

						function k(a) {
							return d(function(b) {
								return b = +b, d(function(c, d) {
									for (var e, f = a([], c.length, b), g = f.length; g--;) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
								})
							})
						}

						function l(a) {
							return a && "undefined" != typeof a.getElementsByTagName && a
						}

						function m() {}

						function n(a) {
							for (var b = 0, c = a.length, d = ""; b < c; b++) d += a[b].value;
							return d
						}

						function o(a, b, c) {
							var d = b.dir,
								e = b.next,
								f = e || d,
								g = c && "parentNode" === f,
								h = R++;
							return b.first ? function(b, c, e) {
								for (; b = b[d];)
									if (1 === b.nodeType || g) return a(b, c, e);
								return false
							} : function(b, c, i) {
								var j, k, l, m = [Q, h];
								if (i) {
									for (; b = b[d];)
										if ((1 === b.nodeType || g) && a(b, c, i)) return true
								} else
									for (; b = b[d];)
										if (1 === b.nodeType || g)
											if (l = b[O] || (b[O] = {}), k = l[b.uniqueID] || (l[b.uniqueID] = {}), e && e === b.nodeName.toLowerCase()) b = b[d] || b;
											else {
												if ((j = k[f]) && j[0] === Q && j[1] === h) return m[2] = j[2];
												if (k[f] = m, m[2] = a(b, c, i)) return true
											} return false
							}
						}

						function p(a) {
							return a.length > 1 ? function(b, c, d) {
								for (var e = a.length; e--;)
									if (!a[e](b, c, d)) return false;
								return true
							} : a[0]
						}

						function q(a, c, d) {
							for (var e = 0, f = c.length; e < f; e++) b(a, c[e], d);
							return d
						}

						function r(a, b, c, d, e) {
							for (var f, g = [], h = 0, i = a.length, j = null != b; h < i; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
							return g
						}

						function s(a, b, c, e, f, g) {
							return e && !e[O] && (e = s(e)), f && !f[O] && (f = s(f, g)), d(function(d, g, h, i) {
								var j, k, l, m = [],
									n = [],
									o = g.length,
									p = d || q(b || "*", h.nodeType ? [h] : h, []),
									s = !a || !d && b ? p : r(p, m, a, h, i),
									t = c ? f || (d ? a : o || e) ? [] : g : s;
								if (c && c(s, t, h, i), e)
									for (j = r(t, n), e(j, [], h, i), k = j.length; k--;)(l = j[k]) && (t[n[k]] = !(s[n[k]] = l));
								if (d) {
									if (f || a) {
										if (f) {
											for (j = [], k = t.length; k--;)(l = t[k]) && j.push(s[k] = l);
											f(null, t = [], j, i)
										}
										for (k = t.length; k--;)(l = t[k]) && (j = f ? aa(d, l) : m[k]) > -1 && (d[j] = !(g[j] = l))
									}
								} else t = r(t === g ? t.splice(o, t.length) : t), f ? f(null, g, t, i) : $.apply(g, t)
							})
						}

						function t(a) {
							for (var b, c, d, e = a.length, f = x.relative[a[0].type], g = f || x.relative[" "], h = f ? 1 : 0, i = o(function(a) {
									return a === b
								}, g, true), j = o(function(a) {
									return aa(b, a) > -1
								}, g, true), k = [function(a, c, d) {
									var e = !f && (d || c !== D) || ((b = c).nodeType ? i(a, c, d) : j(a, c, d));
									return b = null, e
								}]; h < e; h++)
								if (c = x.relative[a[h].type]) k = [o(p(k), c)];
								else {
									if (c = x.filter[a[h].type].apply(null, a[h].matches), c[O]) {
										for (d = ++h; d < e && !x.relative[a[d].type]; d++);
										return s(h > 1 && p(k), h > 1 && n(a.slice(0, h - 1).concat({
											value: " " === a[h - 2].type ? "*" : ""
										})).replace(ha, "$1"), c, h < d && t(a.slice(h, d)), d < e && t(a = a.slice(d)), d < e && n(a))
									}
									k.push(c)
								}
							return p(k)
						}

						function u(a, c) {
							var e = c.length > 0,
								f = a.length > 0,
								g = function(d, g, h, i, j) {
									var k, l, m, n = 0,
										o = "0",
										p = d && [],
										q = [],
										s = D,
										t = d || f && x.find.TAG("*", j),
										u = Q += null == s ? 1 : Math.random() || .1,
										v = t.length;
									for (j && (D = g === H || g || j); o !== v && null != (k = t[o]); o++) {
										if (f && k) {
											for (l = 0, g || k.ownerDocument === H || (G(k), h = !J); m = a[l++];)
												if (m(k, g || H, h)) {
													i.push(k);
													break
												}
											j && (Q = u)
										}
										e && ((k = !m && k) && n--, d && p.push(k))
									}
									if (n += o, e && o !== n) {
										for (l = 0; m = c[l++];) m(p, q, g, h);
										if (d) {
											if (n > 0)
												for (; o--;) p[o] || q[o] || (q[o] = Y.call(i));
											q = r(q)
										}
										$.apply(i, q), j && !d && q.length > 0 && n + c.length > 1 && b.uniqueSort(i)
									}
									return j && (Q = u, D = s), p
								};
							return e ? d(g) : g
						}
						var v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O = "sizzle" + 1 * new Date,
							P = a.document,
							Q = 0,
							R = 0,
							S = c(),
							T = c(),
							U = c(),
							V = function(a, b) {
								return a === b && (F = true), 0
							},
							W = {}.hasOwnProperty,
							X = [],
							Y = X.pop,
							Z = X.push,
							$ = X.push,
							_ = X.slice,
							aa = function(a, b) {
								for (var c = 0, d = a.length; c < d; c++)
									if (a[c] === b) return c;
								return -1
							},
							ba = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
							ca = "[\\x20\\t\\r\\n\\f]",
							da = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
							ea = "\\[" + ca + "*(" + da + ")(?:" + ca + "*([*^$|!~]?=)" + ca + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + da + "))|)" + ca + "*\\]",
							fa = ":(" + da + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ea + ")*)|.*)\\)|)",
							ga = new RegExp(ca + "+", "g"),
							ha = new RegExp("^" + ca + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ca + "+$", "g"),
							ia = new RegExp("^" + ca + "*," + ca + "*"),
							ja = new RegExp("^" + ca + "*([>+~]|" + ca + ")" + ca + "*"),
							ka = new RegExp("=" + ca + "*([^\\]'\"]*?)" + ca + "*\\]", "g"),
							la = new RegExp(fa),
							ma = new RegExp("^" + da + "$"),
							na = {
								ID: new RegExp("^#(" + da + ")"),
								CLASS: new RegExp("^\\.(" + da + ")"),
								TAG: new RegExp("^(" + da + "|[*])"),
								ATTR: new RegExp("^" + ea),
								PSEUDO: new RegExp("^" + fa),
								CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ca + "*(even|odd|(([+-]|)(\\d*)n|)" + ca + "*(?:([+-]|)" + ca + "*(\\d+)|))" + ca + "*\\)|)", "i"),
								bool: new RegExp("^(?:" + ba + ")$", "i"),
								needsContext: new RegExp("^" + ca + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ca + "*((?:-\\d)?\\d*)" + ca + "*\\)|)(?=[^-]|$)", "i")
							},
							oa = /^(?:input|select|textarea|button)$/i,
							pa = /^h\d$/i,
							qa = /^[^{]+\{\s*\[native \w/,
							ra = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
							sa = /[+~]/,
							ta = new RegExp("\\\\([\\da-f]{1,6}" + ca + "?|(" + ca + ")|.)", "ig"),
							ua = function(a, b, c) {
								var d = "0x" + b - 65536;
								return d !== d || c ? b : d < 0 ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
							},
							va = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
							wa = function(a, b) {
								return b ? "\0" === a ? "ï¿½" : a.slice(0, -1) + "\\" + a.charCodeAt(a.length - 1).toString(16) + " " : "\\" + a
							},
							xa = function() {
								G()
							},
							ya = o(function(a) {
								return a.disabled === true && ("form" in a || "label" in a)
							}, {
								dir: "parentNode",
								next: "legend"
							});
						try {
							$.apply(X = _.call(P.childNodes), P.childNodes), X[P.childNodes.length].nodeType
						} catch (a) {
							$ = {
								apply: X.length ? function(a, b) {
									Z.apply(a, _.call(b))
								} : function(a, b) {
									for (var c = a.length, d = 0; a[c++] = b[d++];);
									a.length = c - 1
								}
							}
						}
						w = b.support = {}, z = b.isXML = function(a) {
							var b = a && (a.ownerDocument || a).documentElement;
							return !!b && "HTML" !== b.nodeName
						}, G = b.setDocument = function(a) {
							var b, c, d = a ? a.ownerDocument || a : P;
							return d !== H && 9 === d.nodeType && d.documentElement ? (H = d, I = H.documentElement, J = !z(H), P !== H && (c = H.defaultView) && c.top !== c && (c.addEventListener ? c.addEventListener("unload", xa, false) : c.attachEvent && c.attachEvent("onunload", xa)), w.attributes = e(function(a) {
								return a.className = "i", !a.getAttribute("className")
							}), w.getElementsByTagName = e(function(a) {
								return a.appendChild(H.createComment("")), !a.getElementsByTagName("*").length
							}), w.getElementsByClassName = qa.test(H.getElementsByClassName), w.getById = e(function(a) {
								return I.appendChild(a).id = O, !H.getElementsByName || !H.getElementsByName(O).length
							}), w.getById ? (x.filter.ID = function(a) {
								var b = a.replace(ta, ua);
								return function(a) {
									return a.getAttribute("id") === b
								}
							}, x.find.ID = function(a, b) {
								if ("undefined" != typeof b.getElementById && J) {
									var c = b.getElementById(a);
									return c ? [c] : []
								}
							}) : (x.filter.ID = function(a) {
								var b = a.replace(ta, ua);
								return function(a) {
									var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
									return c && c.value === b
								}
							}, x.find.ID = function(a, b) {
								if ("undefined" != typeof b.getElementById && J) {
									var c, d, e, f = b.getElementById(a);
									if (f) {
										if (c = f.getAttributeNode("id"), c && c.value === a) return [f];
										for (e = b.getElementsByName(a), d = 0; f = e[d++];)
											if (c = f.getAttributeNode("id"), c && c.value === a) return [f]
									}
									return []
								}
							}), x.find.TAG = w.getElementsByTagName ? function(a, b) {
								return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : w.qsa ? b.querySelectorAll(a) : void 0
							} : function(a, b) {
								var c, d = [],
									e = 0,
									f = b.getElementsByTagName(a);
								if ("*" === a) {
									for (; c = f[e++];) 1 === c.nodeType && d.push(c);
									return d
								}
								return f
							}, x.find.CLASS = w.getElementsByClassName && function(a, b) {
								if ("undefined" != typeof b.getElementsByClassName && J) return b.getElementsByClassName(a)
							}, L = [], K = [], (w.qsa = qa.test(H.querySelectorAll)) && (e(function(a) {
								I.appendChild(a).innerHTML = "<a id='" + O + "'></a><select id='" + O + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && K.push("[*^$]=" + ca + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || K.push("\\[" + ca + "*(?:value|" + ba + ")"), a.querySelectorAll("[id~=" + O + "-]").length || K.push("~="), a.querySelectorAll(":checked").length || K.push(":checked"), a.querySelectorAll("a#" + O + "+*").length || K.push(".#.+[+~]")
							}), e(function(a) {
								a.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
								var b = H.createElement("input");
								b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && K.push("name" + ca + "*[*^$|!~]?="), 2 !== a.querySelectorAll(":enabled").length && K.push(":enabled", ":disabled"), I.appendChild(a).disabled = true, 2 !== a.querySelectorAll(":disabled").length && K.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), K.push(",.*:")
							})), (w.matchesSelector = qa.test(M = I.matches || I.webkitMatchesSelector || I.mozMatchesSelector || I.oMatchesSelector || I.msMatchesSelector)) && e(function(a) {
								w.disconnectedMatch = M.call(a, "*"), M.call(a, "[s!='']:x"), L.push("!=", fa)
							}), K = K.length && new RegExp(K.join("|")), L = L.length && new RegExp(L.join("|")), b = qa.test(I.compareDocumentPosition), N = b || qa.test(I.contains) ? function(a, b) {
								var c = 9 === a.nodeType ? a.documentElement : a,
									d = b && b.parentNode;
								return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
							} : function(a, b) {
								if (b)
									for (; b = b.parentNode;)
										if (b === a) return true;
								return false
							}, V = b ? function(a, b) {
								if (a === b) return F = true, 0;
								var c = !a.compareDocumentPosition - !b.compareDocumentPosition;
								return c ? c : (c = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & c || !w.sortDetached && b.compareDocumentPosition(a) === c ? a === H || a.ownerDocument === P && N(P, a) ? -1 : b === H || b.ownerDocument === P && N(P, b) ? 1 : E ? aa(E, a) - aa(E, b) : 0 : 4 & c ? -1 : 1)
							} : function(a, b) {
								if (a === b) return F = true, 0;
								var c, d = 0,
									e = a.parentNode,
									f = b.parentNode,
									h = [a],
									i = [b];
								if (!e || !f) return a === H ? -1 : b === H ? 1 : e ? -1 : f ? 1 : E ? aa(E, a) - aa(E, b) : 0;
								if (e === f) return g(a, b);
								for (c = a; c = c.parentNode;) h.unshift(c);
								for (c = b; c = c.parentNode;) i.unshift(c);
								for (; h[d] === i[d];) d++;
								return d ? g(h[d], i[d]) : h[d] === P ? -1 : i[d] === P ? 1 : 0
							}, H) : H
						}, b.matches = function(a, c) {
							return b(a, null, null, c)
						}, b.matchesSelector = function(a, c) {
							if ((a.ownerDocument || a) !== H && G(a), c = c.replace(ka, "='$1']"), w.matchesSelector && J && !U[c + " "] && (!L || !L.test(c)) && (!K || !K.test(c))) try {
								var d = M.call(a, c);
								if (d || w.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
							} catch (a) {}
							return b(c, H, null, [a]).length > 0
						}, b.contains = function(a, b) {
							return (a.ownerDocument || a) !== H && G(a), N(a, b)
						}, b.attr = function(a, b) {
							(a.ownerDocument || a) !== H && G(a);
							var c = x.attrHandle[b.toLowerCase()],
								d = c && W.call(x.attrHandle, b.toLowerCase()) ? c(a, b, !J) : void 0;
							return void 0 !== d ? d : w.attributes || !J ? a.getAttribute(b) : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
						}, b.escape = function(a) {
							return (a + "").replace(va, wa)
						}, b.error = function(a) {
							throw new Error("Syntax error, unrecognized expression: " + a)
						}, b.uniqueSort = function(a) {
							var b, c = [],
								d = 0,
								e = 0;
							if (F = !w.detectDuplicates, E = !w.sortStable && a.slice(0), a.sort(V), F) {
								for (; b = a[e++];) b === a[e] && (d = c.push(e));
								for (; d--;) a.splice(c[d], 1)
							}
							return E = null, a
						}, y = b.getText = function(a) {
							var b, c = "",
								d = 0,
								e = a.nodeType;
							if (e) {
								if (1 === e || 9 === e || 11 === e) {
									if ("string" == typeof a.textContent) return a.textContent;
									for (a = a.firstChild; a; a = a.nextSibling) c += y(a)
								} else if (3 === e || 4 === e) return a.nodeValue
							} else
								for (; b = a[d++];) c += y(b);
							return c
						}, x = b.selectors = {
							cacheLength: 50,
							createPseudo: d,
							match: na,
							attrHandle: {},
							find: {},
							relative: {
								">": {
									dir: "parentNode",
									first: true
								},
								" ": {
									dir: "parentNode"
								},
								"+": {
									dir: "previousSibling",
									first: true
								},
								"~": {
									dir: "previousSibling"
								}
							},
							preFilter: {
								ATTR: function(a) {
									return a[1] = a[1].replace(ta, ua), a[3] = (a[3] || a[4] || a[5] || "").replace(ta, ua), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
								},
								CHILD: function(a) {
									return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || b.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && b.error(a[0]), a
								},
								PSEUDO: function(a) {
									var b, c = !a[6] && a[2];
									return na.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && la.test(c) && (b = A(c, true)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
								}
							},
							filter: {
								TAG: function(a) {
									var b = a.replace(ta, ua).toLowerCase();
									return "*" === a ? function() {
										return true
									} : function(a) {
										return a.nodeName && a.nodeName.toLowerCase() === b
									}
								},
								CLASS: function(a) {
									var b = S[a + " "];
									return b || (b = new RegExp("(^|" + ca + ")" + a + "(" + ca + "|$)")) && S(a, function(a) {
										return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
									})
								},
								ATTR: function(a, c, d) {
									return function(e) {
										var f = b.attr(e, a);
										return null == f ? "!=" === c : !c || (f += "", "=" === c ? f === d : "!=" === c ? f !== d : "^=" === c ? d && 0 === f.indexOf(d) : "*=" === c ? d && f.indexOf(d) > -1 : "$=" === c ? d && f.slice(-d.length) === d : "~=" === c ? (" " + f.replace(ga, " ") + " ").indexOf(d) > -1 : "|=" === c && (f === d || f.slice(0, d.length + 1) === d + "-"))
									}
								},
								CHILD: function(a, b, c, d, e) {
									var f = "nth" !== a.slice(0, 3),
										g = "last" !== a.slice(-4),
										h = "of-type" === b;
									return 1 === d && 0 === e ? function(a) {
										return !!a.parentNode
									} : function(b, c, i) {
										var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
											q = b.parentNode,
											r = h && b.nodeName.toLowerCase(),
											s = !i && !h,
											t = false;
										if (q) {
											if (f) {
												for (; p;) {
													for (m = b; m = m[p];)
														if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return false;
													o = p = "only" === a && !o && "nextSibling"
												}
												return true
											}
											if (o = [g ? q.firstChild : q.lastChild], g && s) {
												for (m = q, l = m[O] || (m[O] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === Q && j[1], t = n && j[2], m = n && q.childNodes[n]; m = ++n && m && m[p] || (t = n = 0) || o.pop();)
													if (1 === m.nodeType && ++t && m === b) {
														k[a] = [Q, n, t];
														break
													}
											} else if (s && (m = b, l = m[O] || (m[O] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === Q && j[1], t = n), t === false)
												for (;
													(m = ++n && m && m[p] || (t = n = 0) || o.pop()) && ((h ? m.nodeName.toLowerCase() !== r : 1 !== m.nodeType) || !++t || (s && (l = m[O] || (m[O] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [Q, t]), m !== b)););
											return t -= e, t === d || t % d === 0 && t / d >= 0
										}
									}
								},
								PSEUDO: function(a, c) {
									var e, f = x.pseudos[a] || x.setFilters[a.toLowerCase()] || b.error("unsupported pseudo: " + a);
									return f[O] ? f(c) : f.length > 1 ? (e = [a, a, "", c], x.setFilters.hasOwnProperty(a.toLowerCase()) ? d(function(a, b) {
										for (var d, e = f(a, c), g = e.length; g--;) d = aa(a, e[g]), a[d] = !(b[d] = e[g])
									}) : function(a) {
										return f(a, 0, e)
									}) : f
								}
							},
							pseudos: {
								not: d(function(a) {
									var b = [],
										c = [],
										e = B(a.replace(ha, "$1"));
									return e[O] ? d(function(a, b, c, d) {
										for (var f, g = e(a, null, d, []), h = a.length; h--;)(f = g[h]) && (a[h] = !(b[h] = f))
									}) : function(a, d, f) {
										return b[0] = a, e(b, null, f, c), b[0] = null, !c.pop()
									}
								}),
								has: d(function(a) {
									return function(c) {
										return b(a, c).length > 0
									}
								}),
								contains: d(function(a) {
									return a = a.replace(ta, ua),
										function(b) {
											return (b.textContent || b.innerText || y(b)).indexOf(a) > -1
										}
								}),
								lang: d(function(a) {
									return ma.test(a || "") || b.error("unsupported lang: " + a), a = a.replace(ta, ua).toLowerCase(),
										function(b) {
											var c;
											do
												if (c = J ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
											return false
										}
								}),
								target: function(b) {
									var c = a.location && a.location.hash;
									return c && c.slice(1) === b.id
								},
								root: function(a) {
									return a === I
								},
								focus: function(a) {
									return a === H.activeElement && (!H.hasFocus || H.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
								},
								enabled: j(false),
								disabled: j(true),
								checked: function(a) {
									var b = a.nodeName.toLowerCase();
									return "input" === b && !!a.checked || "option" === b && !!a.selected
								},
								selected: function(a) {
									return a.parentNode && a.parentNode.selectedIndex, a.selected === true
								},
								empty: function(a) {
									for (a = a.firstChild; a; a = a.nextSibling)
										if (a.nodeType < 6) return false;
									return true
								},
								parent: function(a) {
									return !x.pseudos.empty(a)
								},
								header: function(a) {
									return pa.test(a.nodeName)
								},
								input: function(a) {
									return oa.test(a.nodeName)
								},
								button: function(a) {
									var b = a.nodeName.toLowerCase();
									return "input" === b && "button" === a.type || "button" === b
								},
								text: function(a) {
									var b;
									return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
								},
								first: k(function() {
									return [0]
								}),
								last: k(function(a, b) {
									return [b - 1]
								}),
								eq: k(function(a, b, c) {
									return [c < 0 ? c + b : c]
								}),
								even: k(function(a, b) {
									for (var c = 0; c < b; c += 2) a.push(c);
									return a
								}),
								odd: k(function(a, b) {
									for (var c = 1; c < b; c += 2) a.push(c);
									return a
								}),
								lt: k(function(a, b, c) {
									for (var d = c < 0 ? c + b : c; --d >= 0;) a.push(d);
									return a
								}),
								gt: k(function(a, b, c) {
									for (var d = c < 0 ? c + b : c; ++d < b;) a.push(d);
									return a
								})
							}
						}, x.pseudos.nth = x.pseudos.eq;
						for (v in {
								radio: true,
								checkbox: true,
								file: true,
								password: true,
								image: true
							}) x.pseudos[v] = h(v);
						for (v in {
								submit: true,
								reset: true
							}) x.pseudos[v] = i(v);
						return m.prototype = x.filters = x.pseudos, x.setFilters = new m, A = b.tokenize = function(a, c) {
							var d, e, f, g, h, i, j, k = T[a + " "];
							if (k) return c ? 0 : k.slice(0);
							for (h = a, i = [], j = x.preFilter; h;) {
								d && !(e = ia.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), d = false, (e = ja.exec(h)) && (d = e.shift(), f.push({
									value: d,
									type: e[0].replace(ha, " ")
								}), h = h.slice(d.length));
								for (g in x.filter) !(e = na[g].exec(h)) || j[g] && !(e = j[g](e)) || (d = e.shift(), f.push({
									value: d,
									type: g,
									matches: e
								}), h = h.slice(d.length));
								if (!d) break
							}
							return c ? h.length : h ? b.error(a) : T(a, i).slice(0)
						}, B = b.compile = function(a, b) {
							var c, d = [],
								e = [],
								f = U[a + " "];
							if (!f) {
								for (b || (b = A(a)), c = b.length; c--;) f = t(b[c]), f[O] ? d.push(f) : e.push(f);
								f = U(a, u(e, d)), f.selector = a
							}
							return f
						}, C = b.select = function(a, b, c, d) {
							var e, f, g, h, i, j = "function" == typeof a && a,
								k = !d && A(a = j.selector || a);
							if (c = c || [], 1 === k.length) {
								if (f = k[0] = k[0].slice(0), f.length > 2 && "ID" === (g = f[0]).type && 9 === b.nodeType && J && x.relative[f[1].type]) {
									if (b = (x.find.ID(g.matches[0].replace(ta, ua), b) || [])[0], !b) return c;
									j && (b = b.parentNode), a = a.slice(f.shift().value.length)
								}
								for (e = na.needsContext.test(a) ? 0 : f.length; e-- && (g = f[e], !x.relative[h = g.type]);)
									if ((i = x.find[h]) && (d = i(g.matches[0].replace(ta, ua), sa.test(f[0].type) && l(b.parentNode) || b))) {
										if (f.splice(e, 1), a = d.length && n(f), !a) return $.apply(c, d), c;
										break
									}
							}
							return (j || B(a, k))(d, b, !J, c, !b || sa.test(a) && l(b.parentNode) || b), c
						}, w.sortStable = O.split("").sort(V).join("") === O, w.detectDuplicates = !!F, G(), w.sortDetached = e(function(a) {
							return 1 & a.compareDocumentPosition(H.createElement("fieldset"))
						}), e(function(a) {
							return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
						}) || f("type|href|height|width", function(a, b, c) {
							if (!c) return a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
						}), w.attributes && e(function(a) {
							return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
						}) || f("value", function(a, b, c) {
							if (!c && "input" === a.nodeName.toLowerCase()) return a.defaultValue
						}), e(function(a) {
							return null == a.getAttribute("disabled")
						}) || f(ba, function(a, b, c) {
							var d;
							if (!c) return a[b] === true ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
						}), b
					}(a);
					pa.find = ua, pa.expr = ua.selectors, pa.expr[":"] = pa.expr.pseudos, pa.uniqueSort = pa.unique = ua.uniqueSort, pa.text = ua.getText, pa.isXMLDoc = ua.isXML, pa.contains = ua.contains, pa.escapeSelector = ua.escape;
					var va = function(a, b, c) {
							for (var d = [], e = void 0 !== c;
								(a = a[b]) && 9 !== a.nodeType;)
								if (1 === a.nodeType) {
									if (e && pa(a).is(c)) break;
									d.push(a)
								}
							return d
						},
						wa = function(a, b) {
							for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
							return c
						},
						xa = pa.expr.match.needsContext,
						ya = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,
						za = /^.[^:#\[\.,]*$/;
					pa.filter = function(a, b, c) {
						var d = b[0];
						return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? pa.find.matchesSelector(d, a) ? [d] : [] : pa.find.matches(a, pa.grep(b, function(a) {
							return 1 === a.nodeType
						}))
					}, pa.fn.extend({
						find: function(a) {
							var b, c, d = this.length,
								e = this;
							if ("string" != typeof a) return this.pushStack(pa(a).filter(function() {
								for (b = 0; b < d; b++)
									if (pa.contains(e[b], this)) return true
							}));
							for (c = this.pushStack([]), b = 0; b < d; b++) pa.find(a, e[b], c);
							return d > 1 ? pa.uniqueSort(c) : c
						},
						filter: function(a) {
							return this.pushStack(f(this, a || [], false))
						},
						not: function(a) {
							return this.pushStack(f(this, a || [], true))
						},
						is: function(a) {
							return !!f(this, "string" == typeof a && xa.test(a) ? pa(a) : a || [], false).length
						}
					});
					var Aa, Ba = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
						Ca = pa.fn.init = function(a, b, c) {
							var d, e;
							if (!a) return this;
							if (c = c || Aa, "string" == typeof a) {
								if (d = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : Ba.exec(a), !d || !d[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
								if (d[1]) {
									if (b = b instanceof pa ? b[0] : b, pa.merge(this, pa.parseHTML(d[1], b && b.nodeType ? b.ownerDocument || b : ca, true)), ya.test(d[1]) && pa.isPlainObject(b))
										for (d in b) pa.isFunction(this[d]) ? this[d](b[d]) : this.attr(d, b[d]);
									return this
								}
								return e = ca.getElementById(d[2]), e && (this[0] = e, this.length = 1), this
							}
							return a.nodeType ? (this[0] = a, this.length = 1, this) : pa.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(pa) : pa.makeArray(a, this)
						};
					Ca.prototype = pa.fn, Aa = pa(ca);
					var Da = /^(?:parents|prev(?:Until|All))/,
						Ea = {
							children: true,
							contents: true,
							next: true,
							prev: true
						};
					pa.fn.extend({
						has: function(a) {
							var b = pa(a, this),
								c = b.length;
							return this.filter(function() {
								for (var a = 0; a < c; a++)
									if (pa.contains(this, b[a])) return true
							})
						},
						closest: function(a, b) {
							var c, d = 0,
								e = this.length,
								f = [],
								g = "string" != typeof a && pa(a);
							if (!xa.test(a))
								for (; d < e; d++)
									for (c = this[d]; c && c !== b; c = c.parentNode)
										if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && pa.find.matchesSelector(c, a))) {
											f.push(c);
											break
										}
							return this.pushStack(f.length > 1 ? pa.uniqueSort(f) : f)
						},
						index: function(a) {
							return a ? "string" == typeof a ? ha.call(pa(a), this[0]) : ha.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
						},
						add: function(a, b) {
							return this.pushStack(pa.uniqueSort(pa.merge(this.get(), pa(a, b))))
						},
						addBack: function(a) {
							return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
						}
					}), pa.each({
						parent: function(a) {
							var b = a.parentNode;
							return b && 11 !== b.nodeType ? b : null
						},
						parents: function(a) {
							return va(a, "parentNode")
						},
						parentsUntil: function(a, b, c) {
							return va(a, "parentNode", c)
						},
						next: function(a) {
							return g(a, "nextSibling")
						},
						prev: function(a) {
							return g(a, "previousSibling")
						},
						nextAll: function(a) {
							return va(a, "nextSibling")
						},
						prevAll: function(a) {
							return va(a, "previousSibling")
						},
						nextUntil: function(a, b, c) {
							return va(a, "nextSibling", c)
						},
						prevUntil: function(a, b, c) {
							return va(a, "previousSibling", c)
						},
						siblings: function(a) {
							return wa((a.parentNode || {}).firstChild, a)
						},
						children: function(a) {
							return wa(a.firstChild)
						},
						contents: function(a) {
							return e(a, "iframe") ? a.contentDocument : (e(a, "template") && (a = a.content || a), pa.merge([], a.childNodes))
						}
					}, function(a, b) {
						pa.fn[a] = function(c, d) {
							var e = pa.map(this, b, c);
							return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = pa.filter(d, e)), this.length > 1 && (Ea[a] || pa.uniqueSort(e), Da.test(a) && e.reverse()), this.pushStack(e)
						}
					});
					var Fa = /[^\x20\t\r\n\f]+/g;
					pa.Callbacks = function(a) {
						a = "string" == typeof a ? h(a) : pa.extend({}, a);
						var b, c, d, e, f = [],
							g = [],
							i = -1,
							j = function() {
								for (e = e || a.once, d = b = true; g.length; i = -1)
									for (c = g.shift(); ++i < f.length;) f[i].apply(c[0], c[1]) === false && a.stopOnFalse && (i = f.length, c = false);
								a.memory || (c = false), b = false, e && (f = c ? [] : "")
							},
							k = {
								add: function() {
									return f && (c && !b && (i = f.length - 1, g.push(c)), function b(c) {
										pa.each(c, function(c, d) {
											pa.isFunction(d) ? a.unique && k.has(d) || f.push(d) : d && d.length && "string" !== pa.type(d) && b(d)
										})
									}(arguments), c && !b && j()), this
								},
								remove: function() {
									return pa.each(arguments, function(a, b) {
										for (var c;
											(c = pa.inArray(b, f, c)) > -1;) f.splice(c, 1), c <= i && i--
									}), this
								},
								has: function(a) {
									return a ? pa.inArray(a, f) > -1 : f.length > 0
								},
								empty: function() {
									return f && (f = []), this
								},
								disable: function() {
									return e = g = [], f = c = "", this
								},
								disabled: function() {
									return !f
								},
								lock: function() {
									return e = g = [], c || b || (f = c = ""), this
								},
								locked: function() {
									return !!e
								},
								fireWith: function(a, c) {
									return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || j()), this
								},
								fire: function() {
									return k.fireWith(this, arguments), this
								},
								fired: function() {
									return !!d
								}
							};
						return k
					}, pa.extend({
						Deferred: function(b) {
							var c = [
									["notify", "progress", pa.Callbacks("memory"), pa.Callbacks("memory"), 2],
									["resolve", "done", pa.Callbacks("once memory"), pa.Callbacks("once memory"), 0, "resolved"],
									["reject", "fail", pa.Callbacks("once memory"), pa.Callbacks("once memory"), 1, "rejected"]
								],
								d = "pending",
								e = {
									state: function() {
										return d
									},
									always: function() {
										return f.done(arguments).fail(arguments), this
									},
									catch: function(a) {
										return e.then(null, a)
									},
									pipe: function() {
										var a = arguments;
										return pa.Deferred(function(b) {
											pa.each(c, function(c, d) {
												var e = pa.isFunction(a[d[4]]) && a[d[4]];
												f[d[1]](function() {
													var a = e && e.apply(this, arguments);
													a && pa.isFunction(a.promise) ? a.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[d[0] + "With"](this, e ? [a] : arguments)
												})
											}), a = null
										}).promise()
									},
									then: function(b, d, e) {
										function f(b, c, d, e) {
											return function() {
												var h = this,
													k = arguments,
													l = function() {
														var a, l;
														if (!(b < g)) {
															if (a = d.apply(h, k), a === c.promise()) throw new TypeError("Thenable self-resolution");
															l = a && ("object" == typeof a || "function" == typeof a) && a.then, pa.isFunction(l) ? e ? l.call(a, f(g, c, i, e), f(g, c, j, e)) : (g++, l.call(a, f(g, c, i, e), f(g, c, j, e), f(g, c, i, c.notifyWith))) : (d !== i && (h = void 0, k = [a]), (e || c.resolveWith)(h, k))
														}
													},
													m = e ? l : function() {
														try {
															l()
														} catch (a) {
															pa.Deferred.exceptionHook && pa.Deferred.exceptionHook(a, m.stackTrace), b + 1 >= g && (d !== j && (h = void 0, k = [a]), c.rejectWith(h, k))
														}
													};
												b ? m() : (pa.Deferred.getStackHook && (m.stackTrace = pa.Deferred.getStackHook()), a.setTimeout(m))
											}
										}
										var g = 0;
										return pa.Deferred(function(a) {
											c[0][3].add(f(0, a, pa.isFunction(e) ? e : i, a.notifyWith)), c[1][3].add(f(0, a, pa.isFunction(b) ? b : i)), c[2][3].add(f(0, a, pa.isFunction(d) ? d : j))
										}).promise()
									},
									promise: function(a) {
										return null != a ? pa.extend(a, e) : e
									}
								},
								f = {};
							return pa.each(c, function(a, b) {
								var g = b[2],
									h = b[5];
								e[b[1]] = g.add, h && g.add(function() {
									d = h
								}, c[3 - a][2].disable, c[0][2].lock), g.add(b[3].fire), f[b[0]] = function() {
									return f[b[0] + "With"](this === f ? void 0 : this, arguments), this
								}, f[b[0] + "With"] = g.fireWith
							}), e.promise(f), b && b.call(f, f), f
						},
						when: function(a) {
							var b = arguments.length,
								c = b,
								d = Array(c),
								e = ea.call(arguments),
								f = pa.Deferred(),
								g = function(a) {
									return function(c) {
										d[a] = this, e[a] = arguments.length > 1 ? ea.call(arguments) : c, --b || f.resolveWith(d, e)
									}
								};
							if (b <= 1 && (k(a, f.done(g(c)).resolve, f.reject, !b), "pending" === f.state() || pa.isFunction(e[c] && e[c].then))) return f.then();
							for (; c--;) k(e[c], g(c), f.reject);
							return f.promise()
						}
					});
					var Ga = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
					pa.Deferred.exceptionHook = function(b, c) {
						a.console && a.console.warn && b && Ga.test(b.name) && a.console.warn("jQuery.Deferred exception: " + b.message, b.stack, c)
					}, pa.readyException = function(b) {
						a.setTimeout(function() {
							throw b
						})
					};
					var Ha = pa.Deferred();
					pa.fn.ready = function(a) {
						return Ha.then(a).catch(function(a) {
							pa.readyException(a)
						}), this
					}, pa.extend({
						isReady: false,
						readyWait: 1,
						ready: function(a) {
							(a === true ? --pa.readyWait : pa.isReady) || (pa.isReady = true, a !== true && --pa.readyWait > 0 || Ha.resolveWith(ca, [pa]))
						}
					}), pa.ready.then = Ha.then, "complete" === ca.readyState || "loading" !== ca.readyState && !ca.documentElement.doScroll ? a.setTimeout(pa.ready) : (ca.addEventListener("DOMContentLoaded", l), a.addEventListener("load", l));
					var Ia = function(a, b, c, d, e, f, g) {
							var h = 0,
								i = a.length,
								j = null == c;
							if ("object" === pa.type(c)) {
								e = true;
								for (h in c) Ia(a, b, h, c[h], true, f, g)
							} else if (void 0 !== d && (e = true, pa.isFunction(d) || (g = true), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
									return j.call(pa(a), c)
								})), b))
								for (; h < i; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
							return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
						},
						Ja = function(a) {
							return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
						};
					m.uid = 1, m.prototype = {
						cache: function(a) {
							var b = a[this.expando];
							return b || (b = {}, Ja(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
								value: b,
								configurable: true
							}))), b
						},
						set: function(a, b, c) {
							var d, e = this.cache(a);
							if ("string" == typeof b) e[pa.camelCase(b)] = c;
							else
								for (d in b) e[pa.camelCase(d)] = b[d];
							return e
						},
						get: function(a, b) {
							return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][pa.camelCase(b)]
						},
						access: function(a, b, c) {
							return void 0 === b || b && "string" == typeof b && void 0 === c ? this.get(a, b) : (this.set(a, b, c), void 0 !== c ? c : b)
						},
						remove: function(a, b) {
							var c, d = a[this.expando];
							if (void 0 !== d) {
								if (void 0 !== b) {
									Array.isArray(b) ? b = b.map(pa.camelCase) : (b = pa.camelCase(b), b = b in d ? [b] : b.match(Fa) || []), c = b.length;
									for (; c--;) delete d[b[c]]
								}(void 0 === b || pa.isEmptyObject(d)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando])
							}
						},
						hasData: function(a) {
							var b = a[this.expando];
							return void 0 !== b && !pa.isEmptyObject(b)
						}
					};
					var Ka = new m,
						La = new m,
						Ma = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
						Na = /[A-Z]/g;
					pa.extend({
						hasData: function(a) {
							return La.hasData(a) || Ka.hasData(a)
						},
						data: function(a, b, c) {
							return La.access(a, b, c)
						},
						removeData: function(a, b) {
							La.remove(a, b)
						},
						_data: function(a, b, c) {
							return Ka.access(a, b, c)
						},
						_removeData: function(a, b) {
							Ka.remove(a, b)
						}
					}), pa.fn.extend({
						data: function(a, b) {
							var c, d, e, f = this[0],
								g = f && f.attributes;
							if (void 0 === a) {
								if (this.length && (e = La.get(f), 1 === f.nodeType && !Ka.get(f, "hasDataAttrs"))) {
									for (c = g.length; c--;) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = pa.camelCase(d.slice(5)), o(f, d, e[d])));
									Ka.set(f, "hasDataAttrs", true)
								}
								return e
							}
							return "object" == typeof a ? this.each(function() {
								La.set(this, a)
							}) : Ia(this, function(b) {
								var c;
								if (f && void 0 === b) {
									if (c = La.get(f, a), void 0 !== c) return c;
									if (c = o(f, a), void 0 !== c) return c
								} else this.each(function() {
									La.set(this, a, b)
								})
							}, null, b, arguments.length > 1, null, true)
						},
						removeData: function(a) {
							return this.each(function() {
								La.remove(this, a)
							})
						}
					}), pa.extend({
						queue: function(a, b, c) {
							var d;
							if (a) return b = (b || "fx") + "queue", d = Ka.get(a, b), c && (!d || Array.isArray(c) ? d = Ka.access(a, b, pa.makeArray(c)) : d.push(c)), d || []
						},
						dequeue: function(a, b) {
							b = b || "fx";
							var c = pa.queue(a, b),
								d = c.length,
								e = c.shift(),
								f = pa._queueHooks(a, b),
								g = function() {
									pa.dequeue(a, b)
								};
							"inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
						},
						_queueHooks: function(a, b) {
							var c = b + "queueHooks";
							return Ka.get(a, c) || Ka.access(a, c, {
								empty: pa.Callbacks("once memory").add(function() {
									Ka.remove(a, [b + "queue", c])
								})
							})
						}
					}), pa.fn.extend({
						queue: function(a, b) {
							var c = 2;
							return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? pa.queue(this[0], a) : void 0 === b ? this : this.each(function() {
								var c = pa.queue(this, a, b);
								pa._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && pa.dequeue(this, a)
							})
						},
						dequeue: function(a) {
							return this.each(function() {
								pa.dequeue(this, a)
							})
						},
						clearQueue: function(a) {
							return this.queue(a || "fx", [])
						},
						promise: function(a, b) {
							var c, d = 1,
								e = pa.Deferred(),
								f = this,
								g = this.length,
								h = function() {
									--d || e.resolveWith(f, [f])
								};
							for ("string" != typeof a && (b = a, a = void 0), a = a || "fx"; g--;) c = Ka.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
							return h(), e.promise(b)
						}
					});
					var Oa = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
						Pa = new RegExp("^(?:([+-])=|)(" + Oa + ")([a-z%]*)$", "i"),
						Qa = ["Top", "Right", "Bottom", "Left"],
						Ra = function(a, b) {
							return a = b || a, "none" === a.style.display || "" === a.style.display && pa.contains(a.ownerDocument, a) && "none" === pa.css(a, "display")
						},
						Sa = function(a, b, c, d) {
							var e, f, g = {};
							for (f in b) g[f] = a.style[f], a.style[f] = b[f];
							e = c.apply(a, d || []);
							for (f in b) a.style[f] = g[f];
							return e
						},
						Ta = {};
					pa.fn.extend({
						show: function() {
							return r(this, true)
						},
						hide: function() {
							return r(this)
						},
						toggle: function(a) {
							return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
								Ra(this) ? pa(this).show() : pa(this).hide()
							})
						}
					});
					var Ua = /^(?:checkbox|radio)$/i,
						Va = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
						Wa = /^$|\/(?:java|ecma)script/i,
						Xa = {
							option: [1, "<select multiple='multiple'>", "</select>"],
							thead: [1, "<table>", "</table>"],
							col: [2, "<table><colgroup>", "</colgroup></table>"],
							tr: [2, "<table><tbody>", "</tbody></table>"],
							td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
							_default: [0, "", ""]
						};
					Xa.optgroup = Xa.option, Xa.tbody = Xa.tfoot = Xa.colgroup = Xa.caption = Xa.thead, Xa.th = Xa.td;
					var Ya = /<|&#?\w+;/;
					! function() {
						var a = ca.createDocumentFragment(),
							b = a.appendChild(ca.createElement("div")),
							c = ca.createElement("input");
						c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), na.checkClone = b.cloneNode(true).cloneNode(true).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", na.noCloneChecked = !!b.cloneNode(true).lastChild.defaultValue
					}();
					var Za = ca.documentElement,
						$a = /^key/,
						_a = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
						ab = /^([^.]*)(?:\.(.+)|)/;
					pa.event = {
						global: {},
						add: function(a, b, c, d, e) {
							var f, g, h, i, j, k, l, m, n, o, p, q = Ka.get(a);
							if (q)
								for (c.handler && (f = c, c = f.handler, e = f.selector), e && pa.find.matchesSelector(Za, e), c.guid || (c.guid = pa.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function(b) {
										return "undefined" != typeof pa && pa.event.triggered !== b.type ? pa.event.dispatch.apply(a, arguments) : void 0
									}), b = (b || "").match(Fa) || [""], j = b.length; j--;) h = ab.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n && (l = pa.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = pa.event.special[n] || {}, k = pa.extend({
									type: n,
									origType: p,
									data: d,
									handler: c,
									guid: c.guid,
									selector: e,
									needsContext: e && pa.expr.match.needsContext.test(e),
									namespace: o.join(".")
								}, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, o, g) !== false || a.addEventListener && a.addEventListener(n, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), pa.event.global[n] = true)
						},
						remove: function(a, b, c, d, e) {
							var f, g, h, i, j, k, l, m, n, o, p, q = Ka.hasData(a) && Ka.get(a);
							if (q && (i = q.events)) {
								for (b = (b || "").match(Fa) || [""], j = b.length; j--;)
									if (h = ab.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n) {
										for (l = pa.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length; f--;) k = m[f], !e && p !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
										g && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== false || pa.removeEvent(a, n, q.handle), delete i[n])
									} else
										for (n in i) pa.event.remove(a, n + b[j], c, d, true);
								pa.isEmptyObject(i) && Ka.remove(a, "handle events")
							}
						},
						dispatch: function(a) {
							var b, c, d, e, f, g, h = pa.event.fix(a),
								i = new Array(arguments.length),
								j = (Ka.get(this, "events") || {})[h.type] || [],
								k = pa.event.special[h.type] || {};
							for (i[0] = h, b = 1; b < arguments.length; b++) i[b] = arguments[b];
							if (h.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, h) !== false) {
								for (g = pa.event.handlers.call(this, h, j), b = 0;
									(e = g[b++]) && !h.isPropagationStopped();)
									for (h.currentTarget = e.elem, c = 0;
										(f = e.handlers[c++]) && !h.isImmediatePropagationStopped();) h.rnamespace && !h.rnamespace.test(f.namespace) || (h.handleObj = f, h.data = f.data, d = ((pa.event.special[f.origType] || {}).handle || f.handler).apply(e.elem, i), void 0 !== d && (h.result = d) === false && (h.preventDefault(), h.stopPropagation()));
								return k.postDispatch && k.postDispatch.call(this, h), h.result
							}
						},
						handlers: function(a, b) {
							var c, d, e, f, g, h = [],
								i = b.delegateCount,
								j = a.target;
							if (i && j.nodeType && !("click" === a.type && a.button >= 1))
								for (; j !== this; j = j.parentNode || this)
									if (1 === j.nodeType && ("click" !== a.type || j.disabled !== true)) {
										for (f = [], g = {}, c = 0; c < i; c++) d = b[c], e = d.selector + " ", void 0 === g[e] && (g[e] = d.needsContext ? pa(e, this).index(j) > -1 : pa.find(e, this, null, [j]).length), g[e] && f.push(d);
										f.length && h.push({
											elem: j,
											handlers: f
										})
									}
							return j = this, i < b.length && h.push({
								elem: j,
								handlers: b.slice(i)
							}), h
						},
						addProp: function(a, b) {
							Object.defineProperty(pa.Event.prototype, a, {
								enumerable: true,
								configurable: true,
								get: pa.isFunction(b) ? function() {
									if (this.originalEvent) return b(this.originalEvent)
								} : function() {
									if (this.originalEvent) return this.originalEvent[a]
								},
								set: function(b) {
									Object.defineProperty(this, a, {
										enumerable: true,
										configurable: true,
										writable: true,
										value: b
									})
								}
							})
						},
						fix: function(a) {
							return a[pa.expando] ? a : new pa.Event(a)
						},
						special: {
							load: {
								noBubble: true
							},
							focus: {
								trigger: function() {
									if (this !== x() && this.focus) return this.focus(), false
								},
								delegateType: "focusin"
							},
							blur: {
								trigger: function() {
									if (this === x() && this.blur) return this.blur(), false
								},
								delegateType: "focusout"
							},
							click: {
								trigger: function() {
									if (Ua.test(this.type) && this.click && e(this, "input")) return this.click(), false
								},
								_default: function(a) {
									return e(a.target, "a")
								}
							},
							beforeunload: {
								postDispatch: function(a) {
									void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
								}
							}
						}
					}, pa.removeEvent = function(a, b, c) {
						a.removeEventListener && a.removeEventListener(b, c)
					}, pa.Event = function(a, b) {
						return this instanceof pa.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === false ? v : w, this.target = a.target && 3 === a.target.nodeType ? a.target.parentNode : a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget) : this.type = a, b && pa.extend(this, b), this.timeStamp = a && a.timeStamp || pa.now(), void(this[pa.expando] = true)) : new pa.Event(a, b)
					}, pa.Event.prototype = {
						constructor: pa.Event,
						isDefaultPrevented: w,
						isPropagationStopped: w,
						isImmediatePropagationStopped: w,
						isSimulated: false,
						preventDefault: function() {
							var a = this.originalEvent;
							this.isDefaultPrevented = v, a && !this.isSimulated && a.preventDefault()
						},
						stopPropagation: function() {
							var a = this.originalEvent;
							this.isPropagationStopped = v, a && !this.isSimulated && a.stopPropagation()
						},
						stopImmediatePropagation: function() {
							var a = this.originalEvent;
							this.isImmediatePropagationStopped = v, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation()
						}
					}, pa.each({
						altKey: true,
						bubbles: true,
						cancelable: true,
						changedTouches: true,
						ctrlKey: true,
						detail: true,
						eventPhase: true,
						metaKey: true,
						pageX: true,
						pageY: true,
						shiftKey: true,
						view: true,
						char: true,
						charCode: true,
						key: true,
						keyCode: true,
						button: true,
						buttons: true,
						clientX: true,
						clientY: true,
						offsetX: true,
						offsetY: true,
						pointerId: true,
						pointerType: true,
						screenX: true,
						screenY: true,
						targetTouches: true,
						toElement: true,
						touches: true,
						which: function(a) {
							var b = a.button;
							return null == a.which && $a.test(a.type) ? null != a.charCode ? a.charCode : a.keyCode : !a.which && void 0 !== b && _a.test(a.type) ? 1 & b ? 1 : 2 & b ? 3 : 4 & b ? 2 : 0 : a.which
						}
					}, pa.event.addProp), pa.each({
						mouseenter: "mouseover",
						mouseleave: "mouseout",
						pointerenter: "pointerover",
						pointerleave: "pointerout"
					}, function(a, b) {
						pa.event.special[a] = {
							delegateType: b,
							bindType: b,
							handle: function(a) {
								var c, d = this,
									e = a.relatedTarget,
									f = a.handleObj;
								return e && (e === d || pa.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
							}
						}
					}), pa.fn.extend({
						on: function(a, b, c, d) {
							return y(this, a, b, c, d)
						},
						one: function(a, b, c, d) {
							return y(this, a, b, c, d, 1)
						},
						off: function(a, b, c) {
							var d, e;
							if (a && a.preventDefault && a.handleObj) return d = a.handleObj, pa(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
							if ("object" == typeof a) {
								for (e in a) this.off(e, b, a[e]);
								return this
							}
							return b !== false && "function" != typeof b || (c = b, b = void 0), c === false && (c = w), this.each(function() {
								pa.event.remove(this, a, c, b)
							})
						}
					});
					var bb = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
						cb = /<script|<style|<link/i,
						db = /checked\s*(?:[^=]|=\s*.checked.)/i,
						eb = /^true\/(.*)/,
						fb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
					pa.extend({
						htmlPrefilter: function(a) {
							return a.replace(bb, "<$1></$2>")
						},
						clone: function(a, b, c) {
							var d, e, f, g, h = a.cloneNode(true),
								i = pa.contains(a.ownerDocument, a);
							if (!(na.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || pa.isXMLDoc(a)))
								for (g = s(h), f = s(a), d = 0, e = f.length; d < e; d++) D(f[d], g[d]);
							if (b)
								if (c)
									for (f = f || s(a), g = g || s(h), d = 0, e = f.length; d < e; d++) C(f[d], g[d]);
								else C(a, h);
							return g = s(h, "script"), g.length > 0 && t(g, !i && s(a, "script")), h
						},
						cleanData: function(a) {
							for (var b, c, d, e = pa.event.special, f = 0; void 0 !== (c = a[f]); f++)
								if (Ja(c)) {
									if (b = c[Ka.expando]) {
										if (b.events)
											for (d in b.events) e[d] ? pa.event.remove(c, d) : pa.removeEvent(c, d, b.handle);
										c[Ka.expando] = void 0
									}
									c[La.expando] && (c[La.expando] = void 0)
								}
						}
					}), pa.fn.extend({
						detach: function(a) {
							return F(this, a, true)
						},
						remove: function(a) {
							return F(this, a)
						},
						text: function(a) {
							return Ia(this, function(a) {
								return void 0 === a ? pa.text(this) : this.empty().each(function() {
									1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a)
								})
							}, null, a, arguments.length)
						},
						append: function() {
							return E(this, arguments, function(a) {
								if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
									var b = z(this, a);
									b.appendChild(a)
								}
							})
						},
						prepend: function() {
							return E(this, arguments, function(a) {
								if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
									var b = z(this, a);
									b.insertBefore(a, b.firstChild)
								}
							})
						},
						before: function() {
							return E(this, arguments, function(a) {
								this.parentNode && this.parentNode.insertBefore(a, this)
							})
						},
						after: function() {
							return E(this, arguments, function(a) {
								this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
							})
						},
						empty: function() {
							for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (pa.cleanData(s(a, false)), a.textContent = "");
							return this
						},
						clone: function(a, b) {
							return a = null != a && a, b = null == b ? a : b, this.map(function() {
								return pa.clone(this, a, b)
							})
						},
						html: function(a) {
							return Ia(this, function(a) {
								var b = this[0] || {},
									c = 0,
									d = this.length;
								if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
								if ("string" == typeof a && !cb.test(a) && !Xa[(Va.exec(a) || ["", ""])[1].toLowerCase()]) {
									a = pa.htmlPrefilter(a);
									try {
										for (; c < d; c++) b = this[c] || {}, 1 === b.nodeType && (pa.cleanData(s(b, false)), b.innerHTML = a);
										b = 0
									} catch (a) {}
								}
								b && this.empty().append(a)
							}, null, a, arguments.length)
						},
						replaceWith: function() {
							var a = [];
							return E(this, arguments, function(b) {
								var c = this.parentNode;
								pa.inArray(this, a) < 0 && (pa.cleanData(s(this)), c && c.replaceChild(b, this))
							}, a)
						}
					}), pa.each({
						appendTo: "append",
						prependTo: "prepend",
						insertBefore: "before",
						insertAfter: "after",
						replaceAll: "replaceWith"
					}, function(a, b) {
						pa.fn[a] = function(a) {
							for (var c, d = [], e = pa(a), f = e.length - 1, g = 0; g <= f; g++) c = g === f ? this : this.clone(true), pa(e[g])[b](c), ga.apply(d, c.get());
							return this.pushStack(d)
						}
					});
					var gb = /^margin/,
						hb = new RegExp("^(" + Oa + ")(?!px)[a-z%]+$", "i"),
						ib = function(b) {
							var c = b.ownerDocument.defaultView;
							return c && c.opener || (c = a), c.getComputedStyle(b)
						};
					! function() {
						function b() {
							if (h) {
								h.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", h.innerHTML = "", Za.appendChild(g);
								var b = a.getComputedStyle(h);
								c = "1%" !== b.top, f = "2px" === b.marginLeft, d = "4px" === b.width, h.style.marginRight = "50%", e = "4px" === b.marginRight, Za.removeChild(g), h = null
							}
						}
						var c, d, e, f, g = ca.createElement("div"),
							h = ca.createElement("div");
						h.style && (h.style.backgroundClip = "content-box", h.cloneNode(true).style.backgroundClip = "", na.clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", g.appendChild(h), pa.extend(na, {
							pixelPosition: function() {
								return b(), c
							},
							boxSizingReliable: function() {
								return b(), d
							},
							pixelMarginRight: function() {
								return b(), e
							},
							reliableMarginLeft: function() {
								return b(), f
							}
						}))
					}();
					var jb = /^(none|table(?!-c[ea]).+)/,
						kb = /^--/,
						lb = {
							position: "absolute",
							visibility: "hidden",
							display: "block"
						},
						mb = {
							letterSpacing: "0",
							fontWeight: "400"
						},
						nb = ["Webkit", "Moz", "ms"],
						ob = ca.createElement("div").style;
					pa.extend({
						cssHooks: {
							opacity: {
								get: function(a, b) {
									if (b) {
										var c = G(a, "opacity");
										return "" === c ? "1" : c
									}
								}
							}
						},
						cssNumber: {
							animationIterationCount: true,
							columnCount: true,
							fillOpacity: true,
							flexGrow: true,
							flexShrink: true,
							fontWeight: true,
							lineHeight: true,
							opacity: true,
							order: true,
							orphans: true,
							widows: true,
							zIndex: true,
							zoom: true
						},
						cssProps: {
							float: "cssFloat"
						},
						style: function(a, b, c, d) {
							if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
								var e, f, g, h = pa.camelCase(b),
									i = kb.test(b),
									j = a.style;
								return i || (b = J(h)), g = pa.cssHooks[b] || pa.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, false, d)) ? e : j[b] : (f = typeof c, "string" === f && (e = Pa.exec(c)) && e[1] && (c = p(a, b, e), f = "number"), void(null != c && c === c && ("number" === f && (c += e && e[3] || (pa.cssNumber[h] ? "" : "px")),
									na.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (j[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i ? j.setProperty(b, c) : j[b] = c))))
							}
						},
						css: function(a, b, c, d) {
							var e, f, g, h = pa.camelCase(b),
								i = kb.test(b);
							return i || (b = J(h)), g = pa.cssHooks[b] || pa.cssHooks[h], g && "get" in g && (e = g.get(a, true, c)), void 0 === e && (e = G(a, b, d)), "normal" === e && b in mb && (e = mb[b]), "" === c || c ? (f = parseFloat(e), c === true || isFinite(f) ? f || 0 : e) : e
						}
					}), pa.each(["height", "width"], function(a, b) {
						pa.cssHooks[b] = {
							get: function(a, c, d) {
								if (c) return !jb.test(pa.css(a, "display")) || a.getClientRects().length && a.getBoundingClientRect().width ? M(a, b, d) : Sa(a, lb, function() {
									return M(a, b, d)
								})
							},
							set: function(a, c, d) {
								var e, f = d && ib(a),
									g = d && L(a, b, d, "border-box" === pa.css(a, "boxSizing", false, f), f);
								return g && (e = Pa.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = pa.css(a, b)), K(a, c, g)
							}
						}
					}), pa.cssHooks.marginLeft = H(na.reliableMarginLeft, function(a, b) {
						if (b) return (parseFloat(G(a, "marginLeft")) || a.getBoundingClientRect().left - Sa(a, {
							marginLeft: 0
						}, function() {
							return a.getBoundingClientRect().left
						})) + "px"
					}), pa.each({
						margin: "",
						padding: "",
						border: "Width"
					}, function(a, b) {
						pa.cssHooks[a + b] = {
							expand: function(c) {
								for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; d < 4; d++) e[a + Qa[d] + b] = f[d] || f[d - 2] || f[0];
								return e
							}
						}, gb.test(a) || (pa.cssHooks[a + b].set = K)
					}), pa.fn.extend({
						css: function(a, b) {
							return Ia(this, function(a, b, c) {
								var d, e, f = {},
									g = 0;
								if (Array.isArray(b)) {
									for (d = ib(a), e = b.length; g < e; g++) f[b[g]] = pa.css(a, b[g], false, d);
									return f
								}
								return void 0 !== c ? pa.style(a, b, c) : pa.css(a, b)
							}, a, b, arguments.length > 1)
						}
					}), pa.Neonate = N, N.prototype = {
						constructor: N,
						init: function(a, b, c, d, e, f) {
							this.elem = a, this.prop = c, this.easing = e || pa.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (pa.cssNumber[c] ? "" : "px")
						},
						cur: function() {
							var a = N.propHooks[this.prop];
							return a && a.get ? a.get(this) : N.propHooks._default.get(this)
						},
						run: function(a) {
							var b, c = N.propHooks[this.prop];
							return this.options.duration ? this.pos = b = pa.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : N.propHooks._default.set(this), this
						}
					}, N.prototype.init.prototype = N.prototype, N.propHooks = {
						_default: {
							get: function(a) {
								var b;
								return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = pa.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0)
							},
							set: function(a) {
								pa.fx.step[a.prop] ? pa.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[pa.cssProps[a.prop]] && !pa.cssHooks[a.prop] ? a.elem[a.prop] = a.now : pa.style(a.elem, a.prop, a.now + a.unit)
							}
						}
					}, N.propHooks.scrollTop = N.propHooks.scrollLeft = {
						set: function(a) {
							a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
						}
					}, pa.easing = {
						linear: function(a) {
							return a
						},
						swing: function(a) {
							return .5 - Math.cos(a * Math.PI) / 2
						},
						_default: "swing"
					}, pa.fx = N.prototype.init, pa.fx.step = {};
					var pb, qb, rb = /^(?:toggle|show|hide)$/,
						sb = /queueHooks$/;
					pa.Animation = pa.extend(U, {
							tweeners: {
								"*": [function(a, b) {
									var c = this.createTween(a, b);
									return p(c.elem, a, Pa.exec(b), c), c
								}]
							},
							tweener: function(a, b) {
								pa.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(Fa);
								for (var c, d = 0, e = a.length; d < e; d++) c = a[d], U.tweeners[c] = U.tweeners[c] || [], U.tweeners[c].unshift(b)
							},
							prefilters: [S],
							prefilter: function(a, b) {
								b ? U.prefilters.unshift(a) : U.prefilters.push(a)
							}
						}), pa.speed = function(a, b, c) {
							var d = a && "object" == typeof a ? pa.extend({}, a) : {
								complete: c || !c && b || pa.isFunction(a) && a,
								duration: a,
								easing: c && b || b && !pa.isFunction(b) && b
							};
							return pa.fx.off ? d.duration = 0 : "number" != typeof d.duration && (d.duration in pa.fx.speeds ? d.duration = pa.fx.speeds[d.duration] : d.duration = pa.fx.speeds._default), null != d.queue && d.queue !== true || (d.queue = "fx"), d.old = d.complete, d.complete = function() {
								pa.isFunction(d.old) && d.old.call(this), d.queue && pa.dequeue(this, d.queue)
							}, d
						}, pa.fn.extend({
							fadeTo: function(a, b, c, d) {
								return this.filter(Ra).css("opacity", 0).show().end().animate({
									opacity: b
								}, a, c, d)
							},
							animate: function(a, b, c, d) {
								var e = pa.isEmptyObject(a),
									f = pa.speed(b, c, d),
									g = function() {
										var b = U(this, pa.extend({}, a), f);
										(e || Ka.get(this, "finish")) && b.stop(true)
									};
								return g.finish = g, e || f.queue === false ? this.each(g) : this.queue(f.queue, g)
							},
							stop: function(a, b, c) {
								var d = function(a) {
									var b = a.stop;
									delete a.stop, b(c)
								};
								return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== false && this.queue(a || "fx", []), this.each(function() {
									var b = true,
										e = null != a && a + "queueHooks",
										f = pa.timers,
										g = Ka.get(this);
									if (e) g[e] && g[e].stop && d(g[e]);
									else
										for (e in g) g[e] && g[e].stop && sb.test(e) && d(g[e]);
									for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = false, f.splice(e, 1));
									!b && c || pa.dequeue(this, a)
								})
							},
							finish: function(a) {
								return a !== false && (a = a || "fx"), this.each(function() {
									var b, c = Ka.get(this),
										d = c[a + "queue"],
										e = c[a + "queueHooks"],
										f = pa.timers,
										g = d ? d.length : 0;
									for (c.finish = true, pa.queue(this, a, []), e && e.stop && e.stop.call(this, true), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(true), f.splice(b, 1));
									for (b = 0; b < g; b++) d[b] && d[b].finish && d[b].finish.call(this);
									delete c.finish
								})
							}
						}), pa.each(["toggle", "show", "hide"], function(a, b) {
							var c = pa.fn[b];
							pa.fn[b] = function(a, d, e) {
								return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Q(b, true), a, d, e)
							}
						}), pa.each({
							slideDown: Q("show"),
							slideUp: Q("hide"),
							slideToggle: Q("toggle"),
							fadeIn: {
								opacity: "show"
							},
							fadeOut: {
								opacity: "hide"
							},
							fadeToggle: {
								opacity: "toggle"
							}
						}, function(a, b) {
							pa.fn[a] = function(a, c, d) {
								return this.animate(b, a, c, d)
							}
						}), pa.timers = [], pa.fx.tick = function() {
							var a, b = 0,
								c = pa.timers;
							for (pb = pa.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
							c.length || pa.fx.stop(), pb = void 0
						}, pa.fx.timer = function(a) {
							pa.timers.push(a), pa.fx.start()
						}, pa.fx.interval = 13, pa.fx.start = function() {
							qb || (qb = true, O())
						}, pa.fx.stop = function() {
							qb = null
						}, pa.fx.speeds = {
							slow: 600,
							fast: 200,
							_default: 400
						}, pa.fn.delay = function(b, c) {
							return b = pa.fx ? pa.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function(c, d) {
								var e = a.setTimeout(c, b);
								d.stop = function() {
									a.clearTimeout(e)
								}
							})
						},
						function() {
							var a = ca.createElement("input"),
								b = ca.createElement("select"),
								c = b.appendChild(ca.createElement("option"));
							a.type = "checkbox", na.checkOn = "" !== a.value, na.optSelected = c.selected, a = ca.createElement("input"), a.value = "t", a.type = "radio", na.radioValue = "t" === a.value
						}();
					var tb, ub = pa.expr.attrHandle;
					pa.fn.extend({
						attr: function(a, b) {
							return Ia(this, pa.attr, a, b, arguments.length > 1)
						},
						removeAttr: function(a) {
							return this.each(function() {
								pa.removeAttr(this, a)
							})
						}
					}), pa.extend({
						attr: function(a, b, c) {
							var d, e, f = a.nodeType;
							if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? pa.prop(a, b, c) : (1 === f && pa.isXMLDoc(a) || (e = pa.attrHooks[b.toLowerCase()] || (pa.expr.match.bool.test(b) ? tb : void 0)), void 0 !== c ? null === c ? void pa.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = pa.find.attr(a, b), null == d ? void 0 : d))
						},
						attrHooks: {
							type: {
								set: function(a, b) {
									if (!na.radioValue && "radio" === b && e(a, "input")) {
										var c = a.value;
										return a.setAttribute("type", b), c && (a.value = c), b
									}
								}
							}
						},
						removeAttr: function(a, b) {
							var c, d = 0,
								e = b && b.match(Fa);
							if (e && 1 === a.nodeType)
								for (; c = e[d++];) a.removeAttribute(c)
						}
					}), tb = {
						set: function(a, b, c) {
							return b === false ? pa.removeAttr(a, c) : a.setAttribute(c, c), c
						}
					}, pa.each(pa.expr.match.bool.source.match(/\w+/g), function(a, b) {
						var c = ub[b] || pa.find.attr;
						ub[b] = function(a, b, d) {
							var e, f, g = b.toLowerCase();
							return d || (f = ub[g], ub[g] = e, e = null != c(a, b, d) ? g : null, ub[g] = f), e
						}
					});
					var vb = /^(?:input|select|textarea|button)$/i,
						wb = /^(?:a|area)$/i;
					pa.fn.extend({
						prop: function(a, b) {
							return Ia(this, pa.prop, a, b, arguments.length > 1)
						},
						removeProp: function(a) {
							return this.each(function() {
								delete this[pa.propFix[a] || a]
							})
						}
					}), pa.extend({
						prop: function(a, b, c) {
							var d, e, f = a.nodeType;
							if (3 !== f && 8 !== f && 2 !== f) return 1 === f && pa.isXMLDoc(a) || (b = pa.propFix[b] || b, e = pa.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
						},
						propHooks: {
							tabIndex: {
								get: function(a) {
									var b = pa.find.attr(a, "tabindex");
									return b ? parseInt(b, 10) : vb.test(a.nodeName) || wb.test(a.nodeName) && a.href ? 0 : -1
								}
							}
						},
						propFix: {
							for: "htmlFor",
							class: "className"
						}
					}), na.optSelected || (pa.propHooks.selected = {
						get: function(a) {
							var b = a.parentNode;
							return b && b.parentNode && b.parentNode.selectedIndex, null
						},
						set: function(a) {
							var b = a.parentNode;
							b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
						}
					}), pa.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
						pa.propFix[this.toLowerCase()] = this
					}), pa.fn.extend({
						addClass: function(a) {
							var b, c, d, e, f, g, h, i = 0;
							if (pa.isFunction(a)) return this.each(function(b) {
								pa(this).addClass(a.call(this, b, W(this)))
							});
							if ("string" == typeof a && a)
								for (b = a.match(Fa) || []; c = this[i++];)
									if (e = W(c), d = 1 === c.nodeType && " " + V(e) + " ") {
										for (g = 0; f = b[g++];) d.indexOf(" " + f + " ") < 0 && (d += f + " ");
										h = V(d), e !== h && c.setAttribute("class", h)
									}
							return this
						},
						removeClass: function(a) {
							var b, c, d, e, f, g, h, i = 0;
							if (pa.isFunction(a)) return this.each(function(b) {
								pa(this).removeClass(a.call(this, b, W(this)))
							});
							if (!arguments.length) return this.attr("class", "");
							if ("string" == typeof a && a)
								for (b = a.match(Fa) || []; c = this[i++];)
									if (e = W(c), d = 1 === c.nodeType && " " + V(e) + " ") {
										for (g = 0; f = b[g++];)
											for (; d.indexOf(" " + f + " ") > -1;) d = d.replace(" " + f + " ", " ");
										h = V(d), e !== h && c.setAttribute("class", h)
									}
							return this
						},
						toggleClass: function(a, b) {
							var c = typeof a;
							return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : pa.isFunction(a) ? this.each(function(c) {
								pa(this).toggleClass(a.call(this, c, W(this), b), b)
							}) : this.each(function() {
								var b, d, e, f;
								if ("string" === c)
									for (d = 0, e = pa(this), f = a.match(Fa) || []; b = f[d++];) e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
								else void 0 !== a && "boolean" !== c || (b = W(this), b && Ka.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === false ? "" : Ka.get(this, "__className__") || ""))
							})
						},
						hasClass: function(a) {
							var b, c, d = 0;
							for (b = " " + a + " "; c = this[d++];)
								if (1 === c.nodeType && (" " + V(W(c)) + " ").indexOf(b) > -1) return true;
							return false
						}
					});
					var xb = /\r/g;
					pa.fn.extend({
						val: function(a) {
							var b, c, d, e = this[0];
							return arguments.length ? (d = pa.isFunction(a), this.each(function(c) {
								var e;
								1 === this.nodeType && (e = d ? a.call(this, c, pa(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : Array.isArray(e) && (e = pa.map(e, function(a) {
									return null == a ? "" : a + ""
								})), b = pa.valHooks[this.type] || pa.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
							})) : e ? (b = pa.valHooks[e.type] || pa.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(xb, "") : null == c ? "" : c)) : void 0
						}
					}), pa.extend({
						valHooks: {
							option: {
								get: function(a) {
									var b = pa.find.attr(a, "value");
									return null != b ? b : V(pa.text(a))
								}
							},
							select: {
								get: function(a) {
									var b, c, d, f = a.options,
										g = a.selectedIndex,
										h = "select-one" === a.type,
										i = h ? null : [],
										j = h ? g + 1 : f.length;
									for (d = g < 0 ? j : h ? g : 0; d < j; d++)
										if (c = f[d], (c.selected || d === g) && !c.disabled && (!c.parentNode.disabled || !e(c.parentNode, "optgroup"))) {
											if (b = pa(c).val(), h) return b;
											i.push(b)
										}
									return i
								},
								set: function(a, b) {
									for (var c, d, e = a.options, f = pa.makeArray(b), g = e.length; g--;) d = e[g], (d.selected = pa.inArray(pa.valHooks.option.get(d), f) > -1) && (c = true);
									return c || (a.selectedIndex = -1), f
								}
							}
						}
					}), pa.each(["radio", "checkbox"], function() {
						pa.valHooks[this] = {
							set: function(a, b) {
								if (Array.isArray(b)) return a.checked = pa.inArray(pa(a).val(), b) > -1
							}
						}, na.checkOn || (pa.valHooks[this].get = function(a) {
							return null === a.getAttribute("value") ? "on" : a.value
						})
					});
					var yb = /^(?:focusinfocus|focusoutblur)$/;
					pa.extend(pa.event, {
						trigger: function(b, c, d, e) {
							var f, g, h, i, j, k, l, m = [d || ca],
								n = ka.call(b, "type") ? b.type : b,
								o = ka.call(b, "namespace") ? b.namespace.split(".") : [];
							if (g = h = d = d || ca, 3 !== d.nodeType && 8 !== d.nodeType && !yb.test(n + pa.event.triggered) && (n.indexOf(".") > -1 && (o = n.split("."), n = o.shift(), o.sort()), j = n.indexOf(":") < 0 && "on" + n, b = b[pa.expando] ? b : new pa.Event(n, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = o.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : pa.makeArray(c, [b]), l = pa.event.special[n] || {}, e || !l.trigger || l.trigger.apply(d, c) !== false)) {
								if (!e && !l.noBubble && !pa.isWindow(d)) {
									for (i = l.delegateType || n, yb.test(i + n) || (g = g.parentNode); g; g = g.parentNode) m.push(g), h = g;
									h === (d.ownerDocument || ca) && m.push(h.defaultView || h.parentWindow || a)
								}
								for (f = 0;
									(g = m[f++]) && !b.isPropagationStopped();) b.type = f > 1 ? i : l.bindType || n, k = (Ka.get(g, "events") || {})[b.type] && Ka.get(g, "handle"), k && k.apply(g, c), k = j && g[j], k && k.apply && Ja(g) && (b.result = k.apply(g, c), b.result === false && b.preventDefault());
								return b.type = n, e || b.isDefaultPrevented() || l._default && l._default.apply(m.pop(), c) !== false || !Ja(d) || j && pa.isFunction(d[n]) && !pa.isWindow(d) && (h = d[j], h && (d[j] = null), pa.event.triggered = n, d[n](), pa.event.triggered = void 0, h && (d[j] = h)), b.result
							}
						},
						simulate: function(a, b, c) {
							var d = pa.extend(new pa.Event, c, {
								type: a,
								isSimulated: true
							});
							pa.event.trigger(d, null, b)
						}
					}), pa.fn.extend({
						trigger: function(a, b) {
							return this.each(function() {
								pa.event.trigger(a, b, this)
							})
						},
						triggerHandler: function(a, b) {
							var c = this[0];
							if (c) return pa.event.trigger(a, b, c, true)
						}
					}), pa.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(a, b) {
						pa.fn[b] = function(a, c) {
							return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
						}
					}), pa.fn.extend({
						hover: function(a, b) {
							return this.mouseenter(a).mouseleave(b || a)
						}
					}), na.focusin = "onfocusin" in a, na.focusin || pa.each({
						focus: "focusin",
						blur: "focusout"
					}, function(a, b) {
						var c = function(a) {
							pa.event.simulate(b, a.target, pa.event.fix(a))
						};
						pa.event.special[b] = {
							setup: function() {
								var d = this.ownerDocument || this,
									e = Ka.access(d, b);
								e || d.addEventListener(a, c, true), Ka.access(d, b, (e || 0) + 1)
							},
							teardown: function() {
								var d = this.ownerDocument || this,
									e = Ka.access(d, b) - 1;
								e ? Ka.access(d, b, e) : (d.removeEventListener(a, c, true), Ka.remove(d, b))
							}
						}
					});
					var zb = a.location,
						Ab = pa.now(),
						Bb = /\?/;
					pa.parseXML = function(b) {
						var c;
						if (!b || "string" != typeof b) return null;
						try {
							c = (new a.DOMParser).parseFromString(b, "text/xml")
						} catch (a) {
							c = void 0
						}
						return c && !c.getElementsByTagName("parsererror").length || pa.error("Invalid XML: " + b), c
					};
					var Cb = /\[\]$/,
						Db = /\r?\n/g,
						Eb = /^(?:submit|button|image|reset|file)$/i,
						Fb = /^(?:input|select|textarea|keygen)/i;
					pa.param = function(a, b) {
						var c, d = [],
							e = function(a, b) {
								var c = pa.isFunction(b) ? b() : b;
								d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(null == c ? "" : c)
							};
						if (Array.isArray(a) || a.jquery && !pa.isPlainObject(a)) pa.each(a, function() {
							e(this.name, this.value)
						});
						else
							for (c in a) X(c, a[c], b, e);
						return d.join("&")
					}, pa.fn.extend({
						serialize: function() {
							return pa.param(this.serializeArray())
						},
						serializeArray: function() {
							return this.map(function() {
								var a = pa.prop(this, "elements");
								return a ? pa.makeArray(a) : this
							}).filter(function() {
								var a = this.type;
								return this.name && !pa(this).is(":disabled") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !Ua.test(a))
							}).map(function(a, b) {
								var c = pa(this).val();
								return null == c ? null : Array.isArray(c) ? pa.map(c, function(a) {
									return {
										name: b.name,
										value: a.replace(Db, "\r\n")
									}
								}) : {
									name: b.name,
									value: c.replace(Db, "\r\n")
								}
							}).get()
						}
					});
					var Gb = /%20/g,
						Hb = /#.*$/,
						Ib = /([?&])_=[^&]*/,
						Jb = /^(.*?):[ \t]*([^\r\n]*)$/gm,
						Kb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
						Lb = /^(?:GET|HEAD)$/,
						Mb = /^\/\//,
						Nb = {},
						Ob = {},
						Pb = "*/".concat("*"),
						Qb = ca.createElement("a");
					Qb.href = zb.href, pa.extend({
						active: 0,
						lastModified: {},
						etag: {},
						ajaxSettings: {
							url: zb.href,
							type: "GET",
							isLocal: Kb.test(zb.protocol),
							global: true,
							processData: true,
							async: true,
							contentType: "application/x-www-form-urlencoded; charset=UTF-8",
							accepts: {
								"*": Pb,
								text: "text/plain",
								html: "text/html",
								xml: "application/xml, text/xml",
								json: "application/json, text/javascript"
							},
							contents: {
								xml: /\bxml\b/,
								html: /\bhtml/,
								json: /\bjson\b/
							},
							responseFields: {
								xml: "responseXML",
								text: "responseText",
								json: "responseJSON"
							},
							converters: {
								"* text": String,
								"text html": true,
								"text json": JSON.parse,
								"text xml": pa.parseXML
							},
							flatOptions: {
								url: true,
								context: true
							}
						},
						ajaxSetup: function(a, b) {
							return b ? $($(a, pa.ajaxSettings), b) : $(pa.ajaxSettings, a)
						},
						ajaxPrefilter: Y(Nb),
						ajaxTransport: Y(Ob),
						ajax: function(b, c) {
							function d(b, c, d, h) {
								var j, m, n, u, v, w = c;
								k || (k = true, i && a.clearTimeout(i), e = void 0, g = h || "", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && b < 300 || 304 === b, d && (u = _(o, x, d)), u = aa(o, u, x, j), j ? (o.ifModified && (v = x.getResponseHeader("Last-Modified"), v && (pa.lastModified[f] = v), v = x.getResponseHeader("etag"), v && (pa.etag[f] = v)), 204 === b || "HEAD" === o.type ? w = "nocontent" : 304 === b ? w = "notmodified" : (w = u.state, m = u.data, n = u.error, j = !n)) : (n = w, !b && w || (w = "error", b < 0 && (b = 0))), x.status = b, x.statusText = (c || w) + "", j ? r.resolveWith(p, [m, w, x]) : r.rejectWith(p, [x, w, n]), x.statusCode(t), t = void 0, l && q.trigger(j ? "ajaxSuccess" : "ajaxError", [x, o, j ? m : n]), s.fireWith(p, [x, w]), l && (q.trigger("ajaxComplete", [x, o]), --pa.active || pa.event.trigger("ajaxStop")))
							}
							"object" == typeof b && (c = b, b = void 0), c = c || {};
							var e, f, g, h, i, j, k, l, m, n, o = pa.ajaxSetup({}, c),
								p = o.context || o,
								q = o.context && (p.nodeType || p.jquery) ? pa(p) : pa.event,
								r = pa.Deferred(),
								s = pa.Callbacks("once memory"),
								t = o.statusCode || {},
								u = {},
								v = {},
								w = "canceled",
								x = {
									readyState: 0,
									getResponseHeader: function(a) {
										var b;
										if (k) {
											if (!h)
												for (h = {}; b = Jb.exec(g);) h[b[1].toLowerCase()] = b[2];
											b = h[a.toLowerCase()]
										}
										return null == b ? null : b
									},
									getAllResponseHeaders: function() {
										return k ? g : null
									},
									setRequestHeader: function(a, b) {
										return null == k && (a = v[a.toLowerCase()] = v[a.toLowerCase()] || a, u[a] = b), this
									},
									overrideMimeType: function(a) {
										return null == k && (o.mimeType = a), this
									},
									statusCode: function(a) {
										var b;
										if (a)
											if (k) x.always(a[x.status]);
											else
												for (b in a) t[b] = [t[b], a[b]];
										return this
									},
									abort: function(a) {
										var b = a || w;
										return e && e.abort(b), d(0, b), this
									}
								};
							if (r.promise(x), o.url = ((b || o.url || zb.href) + "").replace(Mb, zb.protocol + "//"), o.type = c.method || c.type || o.method || o.type, o.dataTypes = (o.dataType || "*").toLowerCase().match(Fa) || [""], null == o.crossDomain) {
								j = ca.createElement("a");
								try {
									j.href = o.url, j.href = j.href, o.crossDomain = Qb.protocol + "//" + Qb.host != j.protocol + "//" + j.host
								} catch (a) {
									o.crossDomain = true
								}
							}
							if (o.data && o.processData && "string" != typeof o.data && (o.data = pa.param(o.data, o.traditional)), Z(Nb, o, c, x), k) return x;
							l = pa.event && o.global, l && 0 === pa.active++ && pa.event.trigger("ajaxStart"), o.type = o.type.toUpperCase(), o.hasContent = !Lb.test(o.type), f = o.url.replace(Hb, ""), o.hasContent ? o.data && o.processData && 0 === (o.contentType || "").indexOf("application/x-www-form-urlencoded") && (o.data = o.data.replace(Gb, "+")) : (n = o.url.slice(f.length), o.data && (f += (Bb.test(f) ? "&" : "?") + o.data, delete o.data), o.cache === false && (f = f.replace(Ib, "$1"), n = (Bb.test(f) ? "&" : "?") + "_=" + Ab++ + n), o.url = f + n), o.ifModified && (pa.lastModified[f] && x.setRequestHeader("If-Modified-Since", pa.lastModified[f]), pa.etag[f] && x.setRequestHeader("If-None-Match", pa.etag[f])), (o.data && o.hasContent && o.contentType !== false || c.contentType) && x.setRequestHeader("Content-Type", o.contentType), x.setRequestHeader("Accept", o.dataTypes[0] && o.accepts[o.dataTypes[0]] ? o.accepts[o.dataTypes[0]] + ("*" !== o.dataTypes[0] ? ", " + Pb + "; q=0.01" : "") : o.accepts["*"]);
							for (m in o.headers) x.setRequestHeader(m, o.headers[m]);
							if (o.beforeSend && (o.beforeSend.call(p, x, o) === false || k)) return x.abort();
							if (w = "abort", s.add(o.complete), x.done(o.success), x.fail(o.error), e = Z(Ob, o, c, x)) {
								if (x.readyState = 1, l && q.trigger("ajaxSend", [x, o]), k) return x;
								o.async && o.timeout > 0 && (i = a.setTimeout(function() {
									x.abort("timeout")
								}, o.timeout));
								try {
									k = false, e.send(u, d)
								} catch (a) {
									if (k) throw a;
									d(-1, a)
								}
							} else d(-1, "No Transport");
							return x
						},
						getJSON: function(a, b, c) {
							return pa.get(a, b, c, "json")
						},
						getScript: function(a, b) {
							return pa.get(a, void 0, b, "script")
						}
					}), pa.each(["get", "post"], function(a, b) {
						pa[b] = function(a, c, d, e) {
							return pa.isFunction(c) && (e = e || d, d = c, c = void 0), pa.ajax(pa.extend({
								url: a,
								type: b,
								dataType: e,
								data: c,
								success: d
							}, pa.isPlainObject(a) && a))
						}
					}), pa._evalUrl = function(a) {
						return pa.ajax({
							url: a,
							type: "GET",
							dataType: "script",
							cache: true,
							async: false,
							global: false,
							throws: true
						})
					}, pa.fn.extend({
						wrapAll: function(a) {
							var b;
							return this[0] && (pa.isFunction(a) && (a = a.call(this[0])), b = pa(a, this[0].ownerDocument).eq(0).clone(true), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
								for (var a = this; a.firstElementChild;) a = a.firstElementChild;
								return a
							}).append(this)), this
						},
						wrapInner: function(a) {
							return pa.isFunction(a) ? this.each(function(b) {
								pa(this).wrapInner(a.call(this, b))
							}) : this.each(function() {
								var b = pa(this),
									c = b.contents();
								c.length ? c.wrapAll(a) : b.append(a)
							})
						},
						wrap: function(a) {
							var b = pa.isFunction(a);
							return this.each(function(c) {
								pa(this).wrapAll(b ? a.call(this, c) : a)
							})
						},
						unwrap: function(a) {
							return this.parent(a).not("body").each(function() {
								pa(this).replaceWith(this.childNodes)
							}), this
						}
					}), pa.expr.pseudos.hidden = function(a) {
						return !pa.expr.pseudos.visible(a)
					}, pa.expr.pseudos.visible = function(a) {
						return !!(a.offsetWidth || a.offsetHeight || a.getClientRects().length)
					}, pa.ajaxSettings.xhr = function() {
						try {
							return new a.XMLHttpRequest
						} catch (a) {}
					};
					var Rb = {
							0: 200,
							1223: 204
						},
						Sb = pa.ajaxSettings.xhr();
					na.cors = !!Sb && "withCredentials" in Sb, na.ajax = Sb = !!Sb, pa.ajaxTransport(function(b) {
						var c, d;
						if (na.cors || Sb && !b.crossDomain) return {
							send: function(e, f) {
								var g, h = b.xhr();
								if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
									for (g in b.xhrFields) h[g] = b.xhrFields[g];
								b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");
								for (g in e) h.setRequestHeader(g, e[g]);
								c = function(a) {
									return function() {
										c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Rb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {
											binary: h.response
										} : {
											text: h.responseText
										}, h.getAllResponseHeaders()))
									}
								}, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function() {
									4 === h.readyState && a.setTimeout(function() {
										c && d()
									})
								}, c = c("abort");
								try {
									h.send(b.hasContent && b.data || null)
								} catch (a) {
									if (c) throw a
								}
							},
							abort: function() {
								c && c()
							}
						}
					}), pa.ajaxPrefilter(function(a) {
						a.crossDomain && (a.contents.script = false)
					}), pa.ajaxSetup({
						accepts: {
							script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
						},
						contents: {
							script: /\b(?:java|ecma)script\b/
						},
						converters: {
							"text script": function(a) {
								return pa.globalEval(a), a
							}
						}
					}), pa.ajaxPrefilter("script", function(a) {
						void 0 === a.cache && (a.cache = false), a.crossDomain && (a.type = "GET")
					}), pa.ajaxTransport("script", function(a) {
						if (a.crossDomain) {
							var b, c;
							return {
								send: function(d, e) {
									b = pa("<script>").prop({
										charset: a.scriptCharset,
										src: a.url
									}).on("load error", c = function(a) {
										b.remove(), c = null, a && e("error" === a.type ? 404 : 200, a.type)
									}), ca.head.appendChild(b[0])
								},
								abort: function() {
									c && c()
								}
							}
						}
					});
					var Tb = [],
						Ub = /(=)\?(?=&|$)|\?\?/;
					pa.ajaxSetup({
						jsonp: "callback",
						jsonpCallback: function() {
							var a = Tb.pop() || pa.expando + "_" + Ab++;
							return this[a] = true, a
						}
					}), pa.ajaxPrefilter("json jsonp", function(b, c, d) {
						var e, f, g, h = b.jsonp !== false && (Ub.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Ub.test(b.data) && "data");
						if (h || "jsonp" === b.dataTypes[0]) return e = b.jsonpCallback = pa.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Ub, "$1" + e) : b.jsonp !== false && (b.url += (Bb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
							return g || pa.error(e + " was not called"), g[0]
						}, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
							g = arguments
						}, d.always(function() {
							void 0 === f ? pa(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Tb.push(e)), g && pa.isFunction(f) && f(g[0]), g = f = void 0
						}), "script"
					}), na.createHTMLDocument = function() {
						var a = ca.implementation.createHTMLDocument("").body;
						return a.innerHTML = "<form></form><form></form>", 2 === a.childNodes.length
					}(), pa.parseHTML = function(a, b, c) {
						if ("string" != typeof a) return [];
						"boolean" == typeof b && (c = b, b = false);
						var d, e, f;
						return b || (na.createHTMLDocument ? (b = ca.implementation.createHTMLDocument(""), d = b.createElement("base"), d.href = ca.location.href, b.head.appendChild(d)) : b = ca), e = ya.exec(a), f = !c && [], e ? [b.createElement(e[1])] : (e = u([a], b, f), f && f.length && pa(f).remove(), pa.merge([], e.childNodes))
					}, pa.fn.load = function(a, b, c) {
						var d, e, f, g = this,
							h = a.indexOf(" ");
						return h > -1 && (d = V(a.slice(h)), a = a.slice(0, h)), pa.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && pa.ajax({
							url: a,
							type: e || "GET",
							dataType: "html",
							data: b
						}).done(function(a) {
							f = arguments, g.html(d ? pa("<div>").append(pa.parseHTML(a)).find(d) : a)
						}).always(c && function(a, b) {
							g.each(function() {
								c.apply(this, f || [a.responseText, b, a])
							})
						}), this
					}, pa.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
						pa.fn[b] = function(a) {
							return this.on(b, a)
						}
					}), pa.expr.pseudos.animated = function(a) {
						return pa.grep(pa.timers, function(b) {
							return a === b.elem
						}).length
					}, pa.offset = {
						setOffset: function(a, b, c) {
							var d, e, f, g, h, i, j, k = pa.css(a, "position"),
								l = pa(a),
								m = {};
							"static" === k && (a.style.position = "relative"), h = l.offset(), f = pa.css(a, "top"), i = pa.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), pa.isFunction(b) && (b = b.call(a, c, pa.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
						}
					}, pa.fn.extend({
						offset: function(a) {
							if (arguments.length) return void 0 === a ? this : this.each(function(b) {
								pa.offset.setOffset(this, a, b)
							});
							var b, c, d, e, f = this[0];
							return f ? f.getClientRects().length ? (d = f.getBoundingClientRect(), b = f.ownerDocument, c = b.documentElement, e = b.defaultView, {
								top: d.top + e.pageYOffset - c.clientTop,
								left: d.left + e.pageXOffset - c.clientLeft
							}) : {
								top: 0,
								left: 0
							} : void 0
						},
						position: function() {
							if (this[0]) {
								var a, b, c = this[0],
									d = {
										top: 0,
										left: 0
									};
								return "fixed" === pa.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), e(a[0], "html") || (d = a.offset()), d = {
									top: d.top + pa.css(a[0], "borderTopWidth", true),
									left: d.left + pa.css(a[0], "borderLeftWidth", true)
								}), {
									top: b.top - d.top - pa.css(c, "marginTop", true),
									left: b.left - d.left - pa.css(c, "marginLeft", true)
								}
							}
						},
						offsetParent: function() {
							return this.map(function() {
								for (var a = this.offsetParent; a && "static" === pa.css(a, "position");) a = a.offsetParent;
								return a || Za
							})
						}
					}), pa.each({
						scrollLeft: "pageXOffset",
						scrollTop: "pageYOffset"
					}, function(a, b) {
						var c = "pageYOffset" === b;
						pa.fn[a] = function(d) {
							return Ia(this, function(a, d, e) {
								var f;
								return pa.isWindow(a) ? f = a : 9 === a.nodeType && (f = a.defaultView), void 0 === e ? f ? f[b] : a[d] : void(f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e)
							}, a, d, arguments.length)
						}
					}), pa.each(["top", "left"], function(a, b) {
						pa.cssHooks[b] = H(na.pixelPosition, function(a, c) {
							if (c) return c = G(a, b), hb.test(c) ? pa(a).position()[b] + "px" : c
						})
					}), pa.each({
						Height: "height",
						Width: "width"
					}, function(a, b) {
						pa.each({
							padding: "inner" + a,
							content: b,
							"": "outer" + a
						}, function(c, d) {
							pa.fn[d] = function(e, f) {
								var g = arguments.length && (c || "boolean" != typeof e),
									h = c || (e === true || f === true ? "margin" : "border");
								return Ia(this, function(b, c, e) {
									var f;
									return pa.isWindow(b) ? 0 === d.indexOf("outer") ? b["inner" + a] : b.document.documentElement["client" + a] : 9 === b.nodeType ? (f = b.documentElement, Math.max(b.body["scroll" + a], f["scroll" + a], b.body["offset" + a], f["offset" + a], f["client" + a])) : void 0 === e ? pa.css(b, c, h) : pa.style(b, c, e, h)
								}, b, g ? e : void 0, g)
							}
						})
					}), pa.fn.extend({
						bind: function(a, b, c) {
							return this.on(a, null, b, c)
						},
						unbind: function(a, b) {
							return this.off(a, null, b)
						},
						delegate: function(a, b, c, d) {
							return this.on(b, a, c, d)
						},
						undelegate: function(a, b, c) {
							return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
						},
						holdReady: function(a) {
							a ? pa.readyWait++ : pa.ready(true)
						}
					}), pa.isArray = Array.isArray, pa.parseJSON = JSON.parse, pa.nodeName = e, "function" == typeof define && define.amd && define("jquery", [], function() {
						return pa
					});
					var Vb = a.jQuery,
						Wb = a.$;
					return pa.noConflict = function(b) {
						return a.$ === pa && (a.$ = Wb), b && a.jQuery === pa && (a.jQuery = Vb), pa
					}, b || (a.jQuery = a.$ = pa), pa
				}), ! function(a) {
					function b() {}

					function c(a, b) {
						return function() {
							a.apply(b, arguments)
						}
					}

					function d(a) {
						if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
						if ("function" != typeof a) throw new TypeError("not a function");
						this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], j(a, this)
					}

					function e(a, b) {
						for (; 3 === a._state;) a = a._value;
						return 0 === a._state ? void a._deferreds.push(b) : (a._handled = true, void d._immediateFn(function() {
							var c = 1 === a._state ? b.onFulfilled : b.onRejected;
							if (null === c) return void(1 === a._state ? f : g)(b.promise, a._value);
							var d;
							try {
								d = c(a._value)
							} catch (a) {
								return void g(b.promise, a)
							}
							f(b.promise, d)
						}))
					}

					function f(a, b) {
						try {
							if (b === a) throw new TypeError("A promise cannot be resolved with itself.");
							if (b && ("object" == typeof b || "function" == typeof b)) {
								var e = b.then;
								if (b instanceof d) return a._state = 3, a._value = b, void h(a);
								if ("function" == typeof e) return void j(c(e, b), a)
							}
							a._state = 1, a._value = b, h(a)
						} catch (b) {
							g(a, b)
						}
					}

					function g(a, b) {
						a._state = 2, a._value = b, h(a)
					}

					function h(a) {
						2 === a._state && 0 === a._deferreds.length && d._immediateFn(function() {
							a._handled || d._unhandledRejectionFn(a._value)
						});
						for (var b = 0, c = a._deferreds.length; b < c; b++) e(a, a._deferreds[b]);
						a._deferreds = null
					}

					function i(a, b, c) {
						this.onFulfilled = "function" == typeof a ? a : null, this.onRejected = "function" == typeof b ? b : null, this.promise = c
					}

					function j(a, b) {
						var c = false;
						try {
							a(function(a) {
								c || (c = true, f(b, a))
							}, function(a) {
								c || (c = true, g(b, a))
							})
						} catch (a) {
							if (c) return;
							c = true, g(b, a)
						}
					}
					var k = setTimeout;
					d.prototype.catch = function(a) {
						return this.then(null, a)
					}, d.prototype.then = function(a, c) {
						var d = new this.constructor(b);
						return e(this, new i(a, c, d)), d
					}, d.all = function(a) {
						var b = Array.prototype.slice.call(a);
						return new d(function(a, c) {
							function d(f, g) {
								try {
									if (g && ("object" == typeof g || "function" == typeof g)) {
										var h = g.then;
										if ("function" == typeof h) return void h.call(g, function(a) {
											d(f, a)
										}, c)
									}
									b[f] = g, 0 === --e && a(b)
								} catch (a) {
									c(a)
								}
							}
							if (0 === b.length) return a([]);
							for (var e = b.length, f = 0; f < b.length; f++) d(f, b[f])
						})
					}, d.resolve = function(a) {
						return a && "object" == typeof a && a.constructor === d ? a : new d(function(b) {
							b(a)
						})
					}, d.reject = function(a) {
						return new d(function(b, c) {
							c(a)
						})
					}, d.race = function(a) {
						return new d(function(b, c) {
							for (var d = 0, e = a.length; d < e; d++) a[d].then(b, c)
						})
					}, d._immediateFn = "function" == typeof setImmediate && function(a) {
						setImmediate(a)
					} || function(a) {
						k(a, 0)
					}, d._unhandledRejectionFn = function(a) {
						"undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", a)
					}, d._setImmediateFn = function(a) {
						d._immediateFn = a
					}, d._setUnhandledRejectionFn = function(a) {
						d._unhandledRejectionFn = a
					}, "undefined" != typeof module && module.exports ? module.exports = d : a.Promise || (a.Promise = d)
				}(this),
				function(a, b) {
					"object" == typeof exports && "undefined" != typeof module ? b(exports) : "function" == typeof define && define.amd ? define(["exports"], b) : b(a.THREE = a.THREE || {})
				}(this, function(a) {
					function b() {}

					function c(a, b) {
						this.x = a || 0, this.y = b || 0
					}

					function d(a, b, e, f, g, h, i, j, k, l) {
						Object.defineProperty(this, "id", {
							value: se++
						}), this.uuid = re.generateUUID(), this.name = "", this.image = void 0 !== a ? a : d.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== b ? b : d.DEFAULT_MAPPING, this.wrapS = void 0 !== e ? e : 1001, this.wrapT = void 0 !== f ? f : 1001, this.magFilter = void 0 !== g ? g : 1006, this.minFilter = void 0 !== h ? h : 1008, this.anisotropy = void 0 !== k ? k : 1, this.format = void 0 !== i ? i : 1023, this.type = void 0 !== j ? j : 1009, this.offset = new c(0, 0), this.repeat = new c(1, 1), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : 3e3, this.version = 0, this.onUpdate = null
					}

					function e(a, b, c, d) {
						this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1
					}

					function f(a, b, c) {
						this.uuid = re.generateUUID(), this.width = a, this.height = b, this.scissor = new e(0, 0, a, b), this.scissorTest = false, this.viewport = new e(0, 0, a, b), c = c || {}, void 0 === c.minFilter && (c.minFilter = 1006), this.texture = new d(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding), this.depthBuffer = void 0 === c.depthBuffer || c.depthBuffer, this.stencilBuffer = void 0 === c.stencilBuffer || c.stencilBuffer, this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null
					}

					function g(a, b, c) {
						f.call(this, a, b, c), this.activeMipMapLevel = this.activeCubeFace = 0
					}

					function h(a, b, c, d) {
						this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1
					}

					function i(a, b, c) {
						this.x = a || 0, this.y = b || 0, this.z = c || 0
					}

					function j() {
						this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
					}

					function k(a, b, c, e, f, g, h, i, j, k, l, m) {
						d.call(this, null, g, h, i, j, k, e, f, l, m),
							this.image = {
								data: a,
								width: b,
								height: c
							}, this.magFilter = void 0 !== j ? j : 1003, this.minFilter = void 0 !== k ? k : 1003, this.flipY = this.generateMipmaps = false, this.unpackAlignment = 1
					}

					function l(a, b, c, e, f, g, h, i, j, k) {
						a = void 0 !== a ? a : [], d.call(this, a, void 0 !== b ? b : 301, c, e, f, g, h, i, j, k), this.flipY = false
					}

					function m(a, b, c) {
						var d = a[0];
						if (0 >= d || 0 < d) return a;
						var e = b * c,
							f = ve[e];
						if (void 0 === f && (f = new Float32Array(e), ve[e] = f), 0 !== b)
							for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
						return f
					}

					function n(a, b) {
						var c = we[b];
						void 0 === c && (c = new Int32Array(b), we[b] = c);
						for (var d = 0; d !== b; ++d) c[d] = a.allocTextureUnit();
						return c
					}

					function o(a, b) {
						a.uniform1f(this.addr, b)
					}

					function p(a, b) {
						a.uniform1i(this.addr, b)
					}

					function q(a, b) {
						void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y)
					}

					function r(a, b) {
						void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b)
					}

					function s(a, b) {
						void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w)
					}

					function t(a, b) {
						a.uniformMatrix2fv(this.addr, false, b.elements || b)
					}

					function u(a, b) {
						void 0 === b.elements ? a.uniformMatrix3fv(this.addr, false, b) : (ye.set(b.elements), a.uniformMatrix3fv(this.addr, false, ye))
					}

					function v(a, b) {
						void 0 === b.elements ? a.uniformMatrix4fv(this.addr, false, b) : (xe.set(b.elements), a.uniformMatrix4fv(this.addr, false, xe))
					}

					function w(a, b, c) {
						var d = c.allocTextureUnit();
						a.uniform1i(this.addr, d), c.setTexture2D(b || te, d)
					}

					function x(a, b, c) {
						var d = c.allocTextureUnit();
						a.uniform1i(this.addr, d), c.setTextureCube(b || ue, d)
					}

					function y(a, b) {
						a.uniform2iv(this.addr, b)
					}

					function z(a, b) {
						a.uniform3iv(this.addr, b)
					}

					function A(a, b) {
						a.uniform4iv(this.addr, b)
					}

					function B(a) {
						switch (a) {
							case 5126:
								return o;
							case 35664:
								return q;
							case 35665:
								return r;
							case 35666:
								return s;
							case 35674:
								return t;
							case 35675:
								return u;
							case 35676:
								return v;
							case 35678:
								return w;
							case 35680:
								return x;
							case 5124:
							case 35670:
								return p;
							case 35667:
							case 35671:
								return y;
							case 35668:
							case 35672:
								return z;
							case 35669:
							case 35673:
								return A
						}
					}

					function C(a, b) {
						a.uniform1fv(this.addr, b)
					}

					function D(a, b) {
						a.uniform1iv(this.addr, b)
					}

					function E(a, b) {
						a.uniform2fv(this.addr, m(b, this.size, 2))
					}

					function F(a, b) {
						a.uniform3fv(this.addr, m(b, this.size, 3))
					}

					function G(a, b) {
						a.uniform4fv(this.addr, m(b, this.size, 4))
					}

					function H(a, b) {
						a.uniformMatrix2fv(this.addr, false, m(b, this.size, 4))
					}

					function I(a, b) {
						a.uniformMatrix3fv(this.addr, false, m(b, this.size, 9))
					}

					function J(a, b) {
						a.uniformMatrix4fv(this.addr, false, m(b, this.size, 16))
					}

					function K(a, b, c) {
						var d = b.length,
							e = n(c, d);
						for (a.uniform1iv(this.addr, e), a = 0; a !== d; ++a) c.setTexture2D(b[a] || te, e[a])
					}

					function L(a, b, c) {
						var d = b.length,
							e = n(c, d);
						for (a.uniform1iv(this.addr, e), a = 0; a !== d; ++a) c.setTextureCube(b[a] || ue, e[a])
					}

					function M(a) {
						switch (a) {
							case 5126:
								return C;
							case 35664:
								return E;
							case 35665:
								return F;
							case 35666:
								return G;
							case 35674:
								return H;
							case 35675:
								return I;
							case 35676:
								return J;
							case 35678:
								return K;
							case 35680:
								return L;
							case 5124:
							case 35670:
								return D;
							case 35667:
							case 35671:
								return y;
							case 35668:
							case 35672:
								return z;
							case 35669:
							case 35673:
								return A
						}
					}

					function N(a, b, c) {
						this.id = a, this.addr = c, this.setValue = B(b.type)
					}

					function O(a, b, c) {
						this.id = a, this.addr = c, this.size = b.size, this.setValue = M(b.type)
					}

					function P(a) {
						this.id = a, this.seq = [], this.map = {}
					}

					function Q(a, b, c) {
						this.seq = [], this.map = {}, this.renderer = c, c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
						for (var d = 0; d < c; ++d) {
							var e = a.getActiveUniform(b, d),
								f = a.getUniformLocation(b, e.name),
								g = this,
								h = e.name,
								i = h.length;
							for (ze.lastIndex = 0;;) {
								var j = ze.exec(h),
									k = ze.lastIndex,
									l = j[1],
									m = j[3];
								if ("]" === j[2] && (l |= 0), void 0 === m || "[" === m && k + 2 === i) {
									h = g, e = void 0 === m ? new N(l, e, f) : new O(l, e, f), h.seq.push(e), h.map[e.id] = e;
									break
								}
								m = g.map[l], void 0 === m && (m = new P(l), l = g, g = m, l.seq.push(g), l.map[g.id] = g), g = m
							}
						}
					}

					function R(a, b, c) {
						return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
					}

					function S(a, b) {
						this.min = void 0 !== a ? a : new c(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new c(-(1 / 0), -(1 / 0))
					}

					function T(a, b) {
						var d, e, f, g, h, j, k, l, m, n, o, p, q, r, s, t, u = a.context,
							v = a.state;
						this.render = function(w, x, y) {
							if (0 !== b.length) {
								w = new i;
								var z = y.w / y.z,
									A = .5 * y.z,
									B = .5 * y.w,
									C = 16 / y.w,
									D = new c(C * z, C),
									E = new i(1, 1, 0),
									F = new c(1, 1),
									G = new S;
								if (G.min.set(y.x, y.y), G.max.set(y.x + (y.z - 16), y.y + (y.w - 16)), void 0 === r) {
									var C = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
										H = new Uint16Array([0, 1, 2, 0, 2, 3]);
									o = u.createBuffer(), p = u.createBuffer(), u.bindBuffer(u.ARRAY_BUFFER, o), u.bufferData(u.ARRAY_BUFFER, C, u.STATIC_DRAW), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, p), u.bufferData(u.ELEMENT_ARRAY_BUFFER, H, u.STATIC_DRAW), s = u.createTexture(), t = u.createTexture(), v.bindTexture(u.TEXTURE_2D, s), u.texImage2D(u.TEXTURE_2D, 0, u.RGB, 16, 16, 0, u.RGB, u.UNSIGNED_BYTE, null), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST), v.bindTexture(u.TEXTURE_2D, t), u.texImage2D(u.TEXTURE_2D, 0, u.RGBA, 16, 16, 0, u.RGBA, u.UNSIGNED_BYTE, null), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST);
									var C = q = {
											vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
											fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
										},
										H = u.createProgram(),
										I = u.createShader(u.FRAGMENT_SHADER),
										J = u.createShader(u.VERTEX_SHADER),
										K = "precision " + a.getPrecision() + " float;\n";
									u.shaderSource(I, K + C.fragmentShader), u.shaderSource(J, K + C.vertexShader), u.compileShader(I), u.compileShader(J), u.attachShader(H, I), u.attachShader(H, J), u.linkProgram(H), r = H, m = u.getAttribLocation(r, "position"), n = u.getAttribLocation(r, "uv"), d = u.getUniformLocation(r, "renderType"), e = u.getUniformLocation(r, "map"), f = u.getUniformLocation(r, "occlusionMap"), g = u.getUniformLocation(r, "opacity"), h = u.getUniformLocation(r, "color"), j = u.getUniformLocation(r, "scale"), k = u.getUniformLocation(r, "rotation"), l = u.getUniformLocation(r, "screenPosition")
								}
								for (u.useProgram(r), v.initAttributes(), v.enableAttribute(m), v.enableAttribute(n), v.disableUnusedAttributes(), u.uniform1i(f, 0), u.uniform1i(e, 1), u.bindBuffer(u.ARRAY_BUFFER, o), u.vertexAttribPointer(m, 2, u.FLOAT, false, 16, 0), u.vertexAttribPointer(n, 2, u.FLOAT, false, 16, 8), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, p), v.disable(u.CULL_FACE), v.buffers.depth.setMask(false), H = 0, I = b.length; H < I; H++)
									if (C = 16 / y.w, D.set(C * z, C), J = b[H], w.set(J.matrixWorld.elements[12], J.matrixWorld.elements[13], J.matrixWorld.elements[14]), w.applyMatrix4(x.matrixWorldInverse), w.applyMatrix4(x.projectionMatrix), E.copy(w), F.x = y.x + E.x * A + A - 8, F.y = y.y + E.y * B + B - 8, true === G.containsPoint(F)) {
										v.activeTexture(u.TEXTURE0), v.bindTexture(u.TEXTURE_2D, null), v.activeTexture(u.TEXTURE1), v.bindTexture(u.TEXTURE_2D, s), u.copyTexImage2D(u.TEXTURE_2D, 0, u.RGB, F.x, F.y, 16, 16, 0), u.uniform1i(d, 0), u.uniform2f(j, D.x, D.y), u.uniform3f(l, E.x, E.y, E.z), v.disable(u.BLEND), v.enable(u.DEPTH_TEST), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0), v.activeTexture(u.TEXTURE0), v.bindTexture(u.TEXTURE_2D, t), u.copyTexImage2D(u.TEXTURE_2D, 0, u.RGBA, F.x, F.y, 16, 16, 0), u.uniform1i(d, 1), v.disable(u.DEPTH_TEST), v.activeTexture(u.TEXTURE1), v.bindTexture(u.TEXTURE_2D, s), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0), J.positionScreen.copy(E), J.customUpdateCallback ? J.customUpdateCallback(J) : J.updateLensFlares(), u.uniform1i(d, 2), v.enable(u.BLEND);
										for (var K = 0, L = J.lensFlares.length; K < L; K++) {
											var M = J.lensFlares[K];
											.001 < M.opacity && .001 < M.scale && (E.x = M.x, E.y = M.y, E.z = M.z, C = M.size * M.scale / y.w, D.x = C * z, D.y = C, u.uniform3f(l, E.x, E.y, E.z), u.uniform2f(j, D.x, D.y), u.uniform1f(k, M.rotation), u.uniform1f(g, M.opacity), u.uniform3f(h, M.color.r, M.color.g, M.color.b), v.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), a.setTexture2D(M.texture, 1), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0))
										}
									}
								v.enable(u.CULL_FACE), v.enable(u.DEPTH_TEST), v.buffers.depth.setMask(true), a.resetGLState()
							}
						}
					}

					function U(a, b) {
						function c(a, b) {
							return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
						}
						var e, f, g, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B = a.context,
							C = a.state,
							D = new i,
							E = new h,
							F = new i;
						this.render = function(h, i) {
							if (0 !== b.length) {
								if (void 0 === z) {
									var G = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
										H = new Uint16Array([0, 1, 2, 0, 2, 3]);
									x = B.createBuffer(), y = B.createBuffer(), B.bindBuffer(B.ARRAY_BUFFER, x), B.bufferData(B.ARRAY_BUFFER, G, B.STATIC_DRAW), B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, y), B.bufferData(B.ELEMENT_ARRAY_BUFFER, H, B.STATIC_DRAW);
									var G = B.createProgram(),
										H = B.createShader(B.VERTEX_SHADER),
										I = B.createShader(B.FRAGMENT_SHADER);
									B.shaderSource(H, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), B.shaderSource(I, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), B.compileShader(H), B.compileShader(I), B.attachShader(G, H), B.attachShader(G, I), B.linkProgram(G), z = G, v = B.getAttribLocation(z, "position"), w = B.getAttribLocation(z, "uv"), e = B.getUniformLocation(z, "uvOffset"), f = B.getUniformLocation(z, "uvScale"), g = B.getUniformLocation(z, "rotation"), j = B.getUniformLocation(z, "scale"), k = B.getUniformLocation(z, "color"), l = B.getUniformLocation(z, "map"), m = B.getUniformLocation(z, "opacity"), n = B.getUniformLocation(z, "modelViewMatrix"), o = B.getUniformLocation(z, "projectionMatrix"), p = B.getUniformLocation(z, "fogType"), q = B.getUniformLocation(z, "fogDensity"), r = B.getUniformLocation(z, "fogNear"), s = B.getUniformLocation(z, "fogFar"), t = B.getUniformLocation(z, "fogColor"), u = B.getUniformLocation(z, "alphaTest"), G = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), G.width = 8, G.height = 8, H = G.getContext("2d"), H.fillStyle = "white", H.fillRect(0, 0, 8, 8), A = new d(G), A.needsUpdate = true
								}
								B.useProgram(z), C.initAttributes(), C.enableAttribute(v), C.enableAttribute(w), C.disableUnusedAttributes(), C.disable(B.CULL_FACE), C.enable(B.BLEND), B.bindBuffer(B.ARRAY_BUFFER, x), B.vertexAttribPointer(v, 2, B.FLOAT, false, 16, 0), B.vertexAttribPointer(w, 2, B.FLOAT, false, 16, 8), B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, y), B.uniformMatrix4fv(o, false, i.projectionMatrix.elements), C.activeTexture(B.TEXTURE0), B.uniform1i(l, 0), H = G = 0, (I = h.fog) ? (B.uniform3f(t, I.color.r, I.color.g, I.color.b), I.isFog ? (B.uniform1f(r, I.near), B.uniform1f(s, I.far), B.uniform1i(p, 1), H = G = 1) : I.isFogExp2 && (B.uniform1f(q, I.density), B.uniform1i(p, 2), H = G = 2)) : (B.uniform1i(p, 0), H = G = 0);
								for (var I = 0, J = b.length; I < J; I++) {
									var K = b[I];
									K.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, K.matrixWorld), K.z = -K.modelViewMatrix.elements[14]
								}
								b.sort(c);
								for (var L = [], I = 0, J = b.length; I < J; I++) {
									var K = b[I],
										M = K.material;
									false !== M.visible && (B.uniform1f(u, M.alphaTest), B.uniformMatrix4fv(n, false, K.modelViewMatrix.elements), K.matrixWorld.decompose(D, E, F), L[0] = F.x, L[1] = F.y, K = 0, h.fog && M.fog && (K = H), G !== K && (B.uniform1i(p, K), G = K), null !== M.map ? (B.uniform2f(e, M.map.offset.x, M.map.offset.y), B.uniform2f(f, M.map.repeat.x, M.map.repeat.y)) : (B.uniform2f(e, 0, 0), B.uniform2f(f, 1, 1)), B.uniform1f(m, M.opacity), B.uniform3f(k, M.color.r, M.color.g, M.color.b), B.uniform1f(g, M.rotation), B.uniform2fv(j, L), C.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), C.buffers.depth.setTest(M.depthTest), C.buffers.depth.setMask(M.depthWrite), M.map ? a.setTexture2D(M.map, 0) : a.setTexture2D(A, 0), B.drawElements(B.TRIANGLES, 6, B.UNSIGNED_SHORT, 0))
								}
								C.enable(B.CULL_FACE), a.resetGLState()
							}
						}
					}

					function V() {
						Object.defineProperty(this, "id", {
							value: Fe++
						}), this.uuid = re.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = true, this.blending = 1, this.side = 0, this.shading = 2, this.vertexColors = 0, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = true, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = false, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = false, this.alphaTest = 0, this.premultipliedAlpha = false, this.overdraw = 0, this.needsUpdate = this.visible = true
					}

					function W(a) {
						V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = false, this.extensions = {
							derivatives: false,
							fragDepth: false,
							drawBuffers: false,
							shaderTextureLOD: false
						}, this.defaultAttributeValues = {
							color: [1, 1, 1],
							uv: [0, 0],
							uv2: [0, 0]
						}, this.index0AttributeName = void 0, void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
					}

					function X(a) {
						V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = false, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.lights = this.fog = false, this.setValues(a)
					}

					function Y(a, b) {
						this.min = void 0 !== a ? a : new i(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new i(-(1 / 0), -(1 / 0), -(1 / 0))
					}

					function Z(a, b) {
						this.center = void 0 !== a ? a : new i, this.radius = void 0 !== b ? b : 0
					}

					function $() {
						this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
					}

					function _(a, b) {
						this.normal = void 0 !== a ? a : new i(1, 0, 0), this.constant = void 0 !== b ? b : 0
					}

					function aa(a, b, c, d, e, f) {
						this.planes = [void 0 !== a ? a : new _, void 0 !== b ? b : new _, void 0 !== c ? c : new _, void 0 !== d ? d : new _, void 0 !== e ? e : new _, void 0 !== f ? f : new _]
					}

					function ba(a, b, d, g) {
						function h(b, c, d, e) {
							var f, g = b.geometry;
							f = u;
							var h = b.customDepthMaterial;
							return d && (f = v, h = b.customDistanceMaterial), h ? f = h : (h = false, c.morphTargets && (g && g.isBufferGeometry ? h = g.morphAttributes && g.morphAttributes.position && 0 < g.morphAttributes.position.length : g && g.isGeometry && (h = g.morphTargets && 0 < g.morphTargets.length)), b.isSkinnedMesh && false === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, g = 0, h && (g |= 1), b && (g |= 2), f = f[g]), a.localClippingEnabled && true === c.clipShadows && 0 !== c.clippingPlanes.length && (g = f.uuid, h = c.uuid, b = w[g], void 0 === b && (b = {}, w[g] = b), g = b[h], void 0 === g && (g = f.clone(), b[h] = g), f = g), f.visible = c.visible, f.wireframe = c.wireframe, h = c.side, F.renderSingleSided && 2 == h && (h = 0), F.renderReverseSided && (0 === h ? h = 1 : 1 === h && (h = 0)), f.side = h, f.clipShadows = c.clipShadows, f.clippingPlanes = c.clippingPlanes, f.wireframeLinewidth = c.wireframeLinewidth, f.linewidth = c.linewidth, d && void 0 !== f.uniforms.lightPos && f.uniforms.lightPos.value.copy(e), f
						}

						function k(b, c, e, f) {
							if (false !== b.visible) {
								if (b.layers.test(c.layers) && (b.isMesh || b.isLine || b.isPoints) && b.castShadow && (!b.frustumCulled || n.intersectsObject(b))) {
									b.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, b.matrixWorld);
									var g = d.update(b),
										i = b.material;
									if (Array.isArray(i))
										for (var j = g.groups, l = 0, m = j.length; l < m; l++) {
											var o = j[l],
												p = i[o.materialIndex];
											p && p.visible && (p = h(b, p, f, t), a.renderBufferDirect(e, null, g, p, b, o))
										} else i.visible && (p = h(b, i, f, t), a.renderBufferDirect(e, null, g, p, b, null))
								}
								for (b = b.children, g = 0, i = b.length; g < i; g++) k(b[g], c, e, f)
							}
						}
						var l = a.context,
							m = a.state,
							n = new aa,
							o = new j,
							p = b.shadows,
							q = new c,
							r = new c(g.maxTextureSize, g.maxTextureSize),
							s = new i,
							t = new i,
							u = Array(4),
							v = Array(4),
							w = {},
							x = [new i(1, 0, 0), new i(-1, 0, 0), new i(0, 0, 1), new i(0, 0, -1), new i(0, 1, 0), new i(0, -1, 0)],
							y = [new i(0, 1, 0), new i(0, 1, 0), new i(0, 1, 0), new i(0, 1, 0), new i(0, 0, 1), new i(0, 0, -1)],
							z = [new e, new e, new e, new e, new e, new e];
						b = new X, b.depthPacking = 3201, b.clipping = true, g = Ee.distanceRGBA;
						for (var A = Ce.clone(g.uniforms), B = 0; 4 !== B; ++B) {
							var C = 0 !== (1 & B),
								D = 0 !== (2 & B),
								E = b.clone();
							E.morphTargets = C, E.skinning = D, u[B] = E, C = new W({
								defines: {
									USE_SHADOWMAP: ""
								},
								uniforms: A,
								vertexShader: g.vertexShader,
								fragmentShader: g.fragmentShader,
								morphTargets: C,
								skinning: D,
								clipping: true
							}), v[B] = C
						}
						var F = this;
						this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.renderSingleSided = this.renderReverseSided = true, this.render = function(b, c) {
							if (false !== F.enabled && (false !== F.autoUpdate || false !== F.needsUpdate) && 0 !== p.length) {
								m.disable(l.BLEND), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(true), m.setScissorTest(false);
								for (var d, e, g = 0, h = p.length; g < h; g++) {
									var i = p[g],
										j = i.shadow;
									if (void 0 === j) console.warn("THREE.WebGLShadowMap:", i, "has no shadow.");
									else {
										var u = j.camera,
											v = j.matrix;
										if (t.setFromMatrixPosition(i.matrixWorld), u.position.copy(t), q.copy(j.mapSize), q.min(r), i && i.isPointLight) {
											d = 6, e = true;
											var w = q.x,
												A = q.y;
											z[0].set(2 * w, A, w, A), z[1].set(0, A, w, A), z[2].set(3 * w, A, w, A), z[3].set(w, A, w, A), z[4].set(3 * w, 0, w, A), z[5].set(w, 0, w, A), q.x *= 4, q.y *= 2, v.makeTranslation(-t.x, -t.y, -t.z)
										} else d = 1, e = false, s.setFromMatrixPosition(i.target.matrixWorld), u.lookAt(s), u.updateMatrixWorld(), u.matrixWorldInverse.getInverse(u.matrixWorld), v.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), v.multiply(u.projectionMatrix), v.multiply(u.matrixWorldInverse);
										for (null === j.map && (j.map = new f(q.x, q.y, {
												minFilter: 1003,
												magFilter: 1003,
												format: 1023
											}), j.map.texture.name = i.name + ".shadowMap", u.updateProjectionMatrix()), j.isSpotLightShadow && j.update(i), a.setRenderTarget(j.map), a.clear(), i = 0; i < d; i++) e && (s.copy(u.position), s.add(x[i]), u.up.copy(y[i]), u.lookAt(s), u.updateMatrixWorld(), u.matrixWorldInverse.getInverse(u.matrixWorld), m.viewport(z[i])), o.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), n.setFromMatrix(o), k(b, c, u, e)
									}
								}
								d = a.getClearColor(), e = a.getClearAlpha(), a.setClearColor(d, e), F.needsUpdate = false
							}
						}
					}

					function ca(a, b) {
						this.origin = void 0 !== a ? a : new i, this.direction = void 0 !== b ? b : new i
					}

					function da(a, b, c, d) {
						this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || da.DefaultOrder
					}

					function ea() {
						this.mask = 1
					}

					function fa() {
						Object.defineProperty(this, "id", {
							value: Ge++
						}), this.uuid = re.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fa.DefaultUp.clone();
						var a = new i,
							b = new da,
							c = new h,
							d = new i(1, 1, 1);
						b.onChange(function() {
							c.setFromEuler(b, false)
						}), c.onChange(function() {
							b.setFromQuaternion(c, void 0, false)
						}), Object.defineProperties(this, {
							position: {
								enumerable: true,
								value: a
							},
							rotation: {
								enumerable: true,
								value: b
							},
							quaternion: {
								enumerable: true,
								value: c
							},
							scale: {
								enumerable: true,
								value: d
							},
							modelViewMatrix: {
								value: new j
							},
							normalMatrix: {
								value: new $
							}
						}), this.matrix = new j, this.matrixWorld = new j, this.matrixAutoUpdate = fa.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new ea, this.visible = true, this.receiveShadow = this.castShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.userData = {}, this.onBeforeRender = function() {}, this.onAfterRender = function() {}
					}

					function ga(a, b) {
						this.start = void 0 !== a ? a : new i, this.end = void 0 !== b ? b : new i
					}

					function ha(a, b, c) {
						this.a = void 0 !== a ? a : new i, this.b = void 0 !== b ? b : new i, this.c = void 0 !== c ? c : new i
					}

					function ia(a, b, c, d, e, f) {
						this.a = a, this.b = b, this.c = c, this.normal = d && d.isVector3 ? d : new i, this.vertexNormals = Array.isArray(d) ? d : [], this.color = e && e.isColor ? e : new R, this.vertexColors = Array.isArray(e) ? e : [], this.materialIndex = void 0 !== f ? f : 0
					}

					function ja(a) {
						V.call(this), this.type = "MeshBasicMaterial", this.color = new R(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = false, this.setValues(a)
					}

					function ka(a, b, c) {
						if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
						this.uuid = re.generateUUID(), this.array = a, this.itemSize = b, this.count = void 0 !== a ? a.length / b : 0, this.normalized = true === c, this.dynamic = false, this.updateRange = {
							offset: 0,
							count: -1
						}, this.onUploadCallback = function() {}, this.version = 0
					}

					function la(a, b) {
						ka.call(this, new Int8Array(a), b)
					}

					function ma(a, b) {
						ka.call(this, new Uint8Array(a), b)
					}

					function na(a, b) {
						ka.call(this, new Uint8ClampedArray(a), b)
					}

					function oa(a, b) {
						ka.call(this, new Int16Array(a), b)
					}

					function pa(a, b) {
						ka.call(this, new Uint16Array(a), b)
					}

					function qa(a, b) {
						ka.call(this, new Int32Array(a), b)
					}

					function ra(a, b) {
						ka.call(this, new Uint32Array(a), b)
					}

					function sa(a, b) {
						ka.call(this, new Float32Array(a), b)
					}

					function ta(a, b) {
						ka.call(this, new Float64Array(a), b)
					}

					function ua() {
						this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = false
					}

					function va(a) {
						if (0 === a.length) return -(1 / 0);
						for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
						return b
					}

					function wa() {
						Object.defineProperty(this, "id", {
							value: He++
						}), this.uuid = re.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
							[]
						], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = false
					}

					function xa() {
						Object.defineProperty(this, "id", {
							value: He++
						}), this.uuid = re.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
							start: 0,
							count: 1 / 0
						}
					}

					function ya(a, b) {
						fa.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new xa, this.material = void 0 !== b ? b : new ja({
							color: 16777215 * Math.random()
						}), this.drawMode = 0, this.updateMorphTargets()
					}

					function za(a, b, c, d, e, f) {
						wa.call(this), this.type = "BoxGeometry", this.parameters = {
							width: a,
							height: b,
							depth: c,
							widthSegments: d,
							heightSegments: e,
							depthSegments: f
						}, this.fromBufferGeometry(new Aa(a, b, c, d, e, f)), this.mergeVertices()
					}

					function Aa(a, b, c, d, e, f) {
						function g(a, b, c, d, e, f, g, p, q, r, s) {
							var t = f / q,
								u = g / r,
								v = f / 2,
								w = g / 2,
								x = p / 2;
							g = q + 1;
							var y, z, A = r + 1,
								B = f = 0,
								C = new i;
							for (z = 0; z < A; z++) {
								var D = z * u - w;
								for (y = 0; y < g; y++) C[a] = (y * t - v) * d, C[b] = D * e, C[c] = x, k.push(C.x, C.y, C.z), C[a] = 0, C[b] = 0, C[c] = 0 < p ? 1 : -1, l.push(C.x, C.y, C.z), m.push(y / q), m.push(1 - z / r), f += 1
							}
							for (z = 0; z < r; z++)
								for (y = 0; y < q; y++) a = n + y + g * (z + 1), b = n + (y + 1) + g * (z + 1), c = n + (y + 1) + g * z, j.push(n + y + g * z, a, c), j.push(a, b, c), B += 6;
							h.addGroup(o, B, s), o += B, n += f
						}
						xa.call(this), this.type = "BoxBufferGeometry", this.parameters = {
							width: a,
							height: b,
							depth: c,
							widthSegments: d,
							heightSegments: e,
							depthSegments: f
						};
						var h = this;
						d = Math.floor(d) || 1, e = Math.floor(e) || 1, f = Math.floor(f) || 1;
						var j = [],
							k = [],
							l = [],
							m = [],
							n = 0,
							o = 0;
						g("z", "y", "x", -1, -1, c, b, a, f, e, 0), g("z", "y", "x", 1, -1, c, b, -a, f, e, 1), g("x", "z", "y", 1, 1, a, c, b, d, f, 2), g("x", "z", "y", 1, -1, a, c, -b, d, f, 3), g("x", "y", "z", 1, -1, a, b, c, d, e, 4), g("x", "y", "z", -1, -1, a, b, -c, d, e, 5), this.setIndex(j), this.addAttribute("position", new sa(k, 3)), this.addAttribute("normal", new sa(l, 3)), this.addAttribute("uv", new sa(m, 2))
					}

					function Ba(a, b, c, d) {
						wa.call(this), this.type = "PlaneGeometry", this.parameters = {
							width: a,
							height: b,
							widthSegments: c,
							heightSegments: d
						}, this.fromBufferGeometry(new Ca(a, b, c, d)), this.mergeVertices()
					}

					function Ca(a, b, c, d) {
						xa.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
							width: a,
							height: b,
							widthSegments: c,
							heightSegments: d
						};
						var e = a / 2,
							f = b / 2;
						c = Math.floor(c) || 1, d = Math.floor(d) || 1;
						var g = c + 1,
							h = d + 1,
							i = a / c,
							j = b / d,
							k = [],
							l = [],
							m = [],
							n = [];
						for (a = 0; a < h; a++) {
							var o = a * j - f;
							for (b = 0; b < g; b++) l.push(b * i - e, -o, 0), m.push(0, 0, 1), n.push(b / c), n.push(1 - a / d)
						}
						for (a = 0; a < d; a++)
							for (b = 0; b < c; b++) e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k.push(b + g * a, e, h), k.push(e, f, h);
						this.setIndex(k), this.addAttribute("position", new sa(l, 3)), this.addAttribute("normal", new sa(m, 3)), this.addAttribute("uv", new sa(n, 2))
					}

					function Da() {
						fa.call(this), this.type = "Camera", this.matrixWorldInverse = new j, this.projectionMatrix = new j
					}

					function Ea(a, b, c, d) {
						Da.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== a ? a : 50, this.zoom = 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, this.focus = 10, this.aspect = void 0 !== b ? b : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
					}

					function Fa(a, b, c, d, e, f) {
						Da.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = a, this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix()
					}

					function Ga(a) {
						var b = {};
						return {
							get: function(a) {
								return a.isInterleavedBufferAttribute && (a = a.data), b[a.uuid]
							},
							remove: function(c) {
								var d = b[c.uuid];
								d && (a.deleteBuffer(d.buffer), delete b[c.uuid])
							},
							update: function(c, d) {
								c.isInterleavedBufferAttribute && (c = c.data);
								var e = b[c.uuid];
								if (void 0 === e) {
									var e = c.uuid,
										f = c,
										g = f.array,
										h = f.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW,
										i = a.createBuffer();
									a.bindBuffer(d, i), a.bufferData(d, g, h), f.onUploadCallback(), h = a.FLOAT, g instanceof Float32Array ? h = a.FLOAT : g instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : g instanceof Uint16Array ? h = a.UNSIGNED_SHORT : g instanceof Int16Array ? h = a.SHORT : g instanceof Uint32Array ? h = a.UNSIGNED_INT : g instanceof Int32Array ? h = a.INT : g instanceof Int8Array ? h = a.BYTE : g instanceof Uint8Array && (h = a.UNSIGNED_BYTE), b[e] = {
										buffer: i,
										type: h,
										bytesPerElement: g.BYTES_PER_ELEMENT,
										version: f.version
									}
								} else e.version < c.version && (f = c, g = f.array, i = f.updateRange, a.bindBuffer(d, e.buffer), false === f.dynamic ? a.bufferData(d, g, a.STATIC_DRAW) : -1 === i.count ? a.bufferSubData(d, 0, g) : 0 === i.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, i.offset * g.BYTES_PER_ELEMENT, g.subarray(i.offset, i.offset + i.count)), i.count = 0), e.version = c.version)
							}
						}
					}

					function Ha(a, b) {
						return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
					}

					function Ia(a, b) {
						return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
					}

					function Ja() {
						var a = [],
							b = -1,
							c = [],
							d = -1;
						return {
							opaque: a,
							transparent: c,
							init: function() {
								d = b = -1
							},
							push: function(e, f, g, h, i) {
								var j, k;
								g.transparent ? (j = c, k = ++d) : (j = a, k = ++b), (k = j[k]) ? (k.id = e.id, k.object = e, k.geometry = f, k.material = g, k.program = g.program, k.renderOrder = e.renderOrder, k.z = h, k.group = i) : (k = {
									id: e.id,
									object: e,
									geometry: f,
									material: g,
									program: g.program,
									renderOrder: e.renderOrder,
									z: h,
									group: i
								}, j.push(k))
							},
							finish: function() {
								a.length = b + 1, c.length = d + 1
							},
							sort: function() {
								a.sort(Ha), c.sort(Ia)
							}
						}
					}

					function Ka() {
						var a = {};
						return {
							get: function(b, c) {
								var d = b.id + "," + c.id,
									e = a[d];
								return void 0 === e && (e = new Ja, a[d] = e), e
							},
							dispose: function() {
								a = {}
							}
						}
					}

					function La(a, b, c) {
						var d, e, f;
						this.setMode = function(a) {
							d = a
						}, this.setIndex = function(c) {
							c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (e = a.UNSIGNED_INT, f = 4) : c.array instanceof Uint16Array ? (e = a.UNSIGNED_SHORT, f = 2) : (e = a.UNSIGNED_BYTE, f = 1)
						}, this.render = function(b, g) {
							a.drawElements(d, g, e, b * f), c.calls++, c.vertices += g, d === a.TRIANGLES && (c.faces += g / 3)
						}, this.renderInstances = function(g, h, i) {
							var j = b.get("ANGLE_instanced_arrays");
							null === j ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (j.drawElementsInstancedANGLE(d, i, e, h * f, g.maxInstancedCount), c.calls++, c.vertices += i * g.maxInstancedCount, d === a.TRIANGLES && (c.faces += g.maxInstancedCount * i / 3))
						}
					}

					function Ma(a, b, c) {
						var d;
						this.setMode = function(a) {
							d = a
						}, this.render = function(b, e) {
							a.drawArrays(d, b, e), c.calls++, c.vertices += e, d === a.TRIANGLES && (c.faces += e / 3)
						}, this.renderInstances = function(e, f, g) {
							var h = b.get("ANGLE_instanced_arrays");
							if (null === h) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
							else {
								var i = e.attributes.position;
								i.isInterleavedBufferAttribute ? (g = i.data.count, h.drawArraysInstancedANGLE(d, 0, g, e.maxInstancedCount)) : h.drawArraysInstancedANGLE(d, f, g, e.maxInstancedCount), c.calls++, c.vertices += g * e.maxInstancedCount, d === a.TRIANGLES && (c.faces += e.maxInstancedCount * g / 3)
							}
						}
					}

					function Na(a, b, c) {
						function d(a) {
							a = a.target;
							var g = e[a.id];
							null !== g.index && b.remove(g.index);
							for (var h in g.attributes) b.remove(g.attributes[h]);
							a.removeEventListener("dispose", d), delete e[a.id], (h = f[a.id]) && (b.remove(h), delete f[a.id]), (h = f[g.id]) && (b.remove(h), delete f[g.id]), c.geometries--
						}
						var e = {},
							f = {};
						return {
							get: function(a, b) {
								var f = e[b.id];
								return f ? f : (b.addEventListener("dispose", d), b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new xa).setFromObject(a)), f = b._bufferGeometry), e[b.id] = f, c.geometries++, f)
							},
							update: function(c) {
								var d = c.index,
									e = c.attributes;
								null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER);
								for (var f in e) b.update(e[f], a.ARRAY_BUFFER);
								c = c.morphAttributes;
								for (f in c)
									for (var d = c[f], e = 0, g = d.length; e < g; e++) b.update(d[e], a.ARRAY_BUFFER)
							},
							getWireframeAttribute: function(c) {
								var d = f[c.id];
								if (d) return d;
								var d = [],
									e = c.index,
									g = c.attributes;
								if (null !== e)
									for (var e = e.array, g = 0, h = e.length; g < h; g += 3) {
										var i = e[g + 0],
											j = e[g + 1],
											k = e[g + 2];
										d.push(i, j, j, k, k, i)
									} else
										for (e = g.position.array, g = 0, h = e.length / 3 - 1; g < h; g += 3) i = g + 0, j = g + 1, k = g + 2, d.push(i, j, j, k, k, i);
								return d = new(65535 < va(d) ? ra : pa)(d, 1), b.update(d, a.ELEMENT_ARRAY_BUFFER), f[c.id] = d
							}
						}
					}

					function Oa() {
						var a = {};
						return {
							get: function(b) {
								if (void 0 !== a[b.id]) return a[b.id];
								var d;
								switch (b.type) {
									case "DirectionalLight":
										d = {
											direction: new i,
											color: new R,
											shadow: false,
											shadowBias: 0,
											shadowRadius: 1,
											shadowMapSize: new c
										};
										break;
									case "SpotLight":
										d = {
											position: new i,
											direction: new i,
											color: new R,
											distance: 0,
											coneCos: 0,
											penumbraCos: 0,
											decay: 0,
											shadow: false,
											shadowBias: 0,
											shadowRadius: 1,
											shadowMapSize: new c
										};
										break;
									case "PointLight":
										d = {
											position: new i,
											color: new R,
											distance: 0,
											decay: 0,
											shadow: false,
											shadowBias: 0,
											shadowRadius: 1,
											shadowMapSize: new c
										};
										break;
									case "HemisphereLight":
										d = {
											direction: new i,
											skyColor: new R,
											groundColor: new R
										};
										break;
									case "RectAreaLight":
										d = {
											color: new R,
											position: new i,
											halfWidth: new i,
											halfHeight: new i
										}
								}
								return a[b.id] = d
							}
						}
					}

					function Pa(a, b, c) {
						var d = {};
						return {
							update: function(a) {
								var e = c.frame,
									f = a.geometry,
									g = b.get(a, f);
								return d[g.id] !== e && (f.isGeometry && g.updateFromObject(a), b.update(g), d[g.id] = e), g
							},
							clear: function() {
								d = {}
							}
						}
					}

					function Qa(a) {
						a = a.split("\n");
						for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
						return a.join("\n")
					}

					function Ra(a, b, c) {
						var d = a.createShader(b);
						return a.shaderSource(d, c), a.compileShader(d), false === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), Qa(c)), d
					}

					function Sa(a) {
						switch (a) {
							case 3e3:
								return ["Linear", "( value )"];
							case 3001:
								return ["sRGB", "( value )"];
							case 3002:
								return ["RGBE", "( value )"];
							case 3004:
								return ["RGBM", "( value, 7.0 )"];
							case 3005:
								return ["RGBM", "( value, 16.0 )"];
							case 3006:
								return ["RGBD", "( value, 256.0 )"];
							case 3007:
								return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
							default:
								throw Error("unsupported encoding: " + a)
						}
					}

					function Ta(a, b) {
						var c = Sa(b);
						return "vec4 " + a + "( vec4 value ) { return " + c[0] + "ToLinear" + c[1] + "; }"
					}

					function Ua(a, b) {
						var c = Sa(b);
						return "vec4 " + a + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"
					}

					function Va(a, b) {
						var c;
						switch (b) {
							case 1:
								c = "Linear";
								break;
							case 2:
								c = "Reinhard";
								break;
							case 3:
								c = "Uncharted2";
								break;
							case 4:
								c = "OptimizedCineon";
								break;
							default:
								throw Error("unsupported toneMapping: " + b)
						}
						return "vec3 " + a + "( vec3 color ) { return " + c + "ToneMapping( color ); }"
					}

					function Wa(a, b, c) {
						return a = a || {}, [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ya).join("\n")
					}

					function Xa(a) {
						var b, c = [];
						for (b in a) {
							var d = a[b];
							false !== d && c.push("#define " + b + " " + d)
						}
						return c.join("\n")
					}

					function Ya(a) {
						return "" !== a
					}

					function Za(a, b) {
						return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
					}

					function $a(a) {
						return a.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(a, b) {
							var c = De[b];
							if (void 0 === c) throw Error("Can not resolve #include <" + b + ">");
							return $a(c)
						})
					}

					function _a(a) {
						return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, b, c, d) {
							for (a = "", b = parseInt(b); b < parseInt(c); b++) a += d.replace(/\[ i \]/g, "[ " + b + " ]");
							return a
						})
					}

					function ab(a, b, c, d) {
						var e = a.context,
							f = c.extensions,
							g = c.defines,
							h = c.__webglShader.vertexShader,
							i = c.__webglShader.fragmentShader,
							j = "SHADOWMAP_TYPE_BASIC";
						1 === d.shadowMapType ? j = "SHADOWMAP_TYPE_PCF" : 2 === d.shadowMapType && (j = "SHADOWMAP_TYPE_PCF_SOFT");
						var k = "ENVMAP_TYPE_CUBE",
							l = "ENVMAP_MODE_REFLECTION",
							m = "ENVMAP_BLENDING_MULTIPLY";
						if (d.envMap) {
							switch (c.envMap.mapping) {
								case 301:
								case 302:
									k = "ENVMAP_TYPE_CUBE";
									break;
								case 306:
								case 307:
									k = "ENVMAP_TYPE_CUBE_UV";
									break;
								case 303:
								case 304:
									k = "ENVMAP_TYPE_EQUIREC";
									break;
								case 305:
									k = "ENVMAP_TYPE_SPHERE"
							}
							switch (c.envMap.mapping) {
								case 302:
								case 304:
									l = "ENVMAP_MODE_REFRACTION"
							}
							switch (c.combine) {
								case 0:
									m = "ENVMAP_BLENDING_MULTIPLY";
									break;
								case 1:
									m = "ENVMAP_BLENDING_MIX";
									break;
								case 2:
									m = "ENVMAP_BLENDING_ADD"
							}
						}
						var n = 0 < a.gammaFactor ? a.gammaFactor : 1,
							f = Wa(f, d, a.extensions),
							o = Xa(g),
							p = e.createProgram();
						c.isRawShaderMaterial ? (g = [o, "\n"].filter(Ya).join("\n"), j = [f, o, "\n"].filter(Ya).join("\n")) : (g = ["precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, o, d.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + n, "#define MAX_BONES " + d.maxBones, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + l : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.displacementMap && d.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.skinning ? "#define USE_SKINNING" : "", d.useVertexTexture ? "#define BONE_TEXTURE" : "", d.morphTargets ? "#define USE_MORPHTARGETS" : "", d.morphNormals && false === d.flatShading ? "#define USE_MORPHNORMALS" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + j : "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ya).join("\n"), j = [f, "precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, o, d.alphaTest ? "#define ALPHATEST " + d.alphaTest : "", "#define GAMMA_FACTOR " + n, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + k : "", d.envMap ? "#define " + l : "", d.envMap ? "#define " + m : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.gradientMap ? "#define USE_GRADIENTMAP" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (d.numClippingPlanes - d.numClipIntersection), d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + j : "", d.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", d.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", d.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== d.toneMapping ? "#define TONE_MAPPING" : "", 0 !== d.toneMapping ? De.tonemapping_pars_fragment : "", 0 !== d.toneMapping ? Va("toneMapping", d.toneMapping) : "", d.dithering ? "#define DITHERING" : "", d.outputEncoding || d.mapEncoding || d.envMapEncoding || d.emissiveMapEncoding ? De.encodings_pars_fragment : "", d.mapEncoding ? Ta("mapTexelToLinear", d.mapEncoding) : "", d.envMapEncoding ? Ta("envMapTexelToLinear", d.envMapEncoding) : "", d.emissiveMapEncoding ? Ta("emissiveMapTexelToLinear", d.emissiveMapEncoding) : "", d.outputEncoding ? Ua("linearToOutputTexel", d.outputEncoding) : "", d.depthPacking ? "#define DEPTH_PACKING " + c.depthPacking : "", "\n"].filter(Ya).join("\n")), h = $a(h, d), h = Za(h, d), i = $a(i, d), i = Za(i, d), c.isShaderMaterial || (h = _a(h), i = _a(i)), i = j + i, h = Ra(e, e.VERTEX_SHADER, g + h), i = Ra(e, e.FRAGMENT_SHADER, i), e.attachShader(p, h), e.attachShader(p, i), void 0 !== c.index0AttributeName ? e.bindAttribLocation(p, 0, c.index0AttributeName) : true === d.morphTargets && e.bindAttribLocation(p, 0, "position"), e.linkProgram(p), d = e.getProgramInfoLog(p), k = e.getShaderInfoLog(h), l = e.getShaderInfoLog(i), n = m = true, false === e.getProgramParameter(p, e.LINK_STATUS) ? (m = false, console.error("THREE.WebGLProgram: shader error: ", e.getError(), "gl.VALIDATE_STATUS", e.getProgramParameter(p, e.VALIDATE_STATUS), "gl.getProgramInfoLog", d, k, l)) : "" !== d ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", d) : "" !== k && "" !== l || (n = false), n && (this.diagnostics = {
							runnable: m,
							material: c,
							programLog: d,
							vertexShader: {
								log: k,
								prefix: g
							},
							fragmentShader: {
								log: l,
								prefix: j
							}
						}), e.deleteShader(h), e.deleteShader(i);
						var q;
						this.getUniforms = function() {
							return void 0 === q && (q = new Q(e, p, a)), q
						};
						var r;
						return this.getAttributes = function() {
							if (void 0 === r) {
								for (var a = {}, b = e.getProgramParameter(p, e.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) {
									var d = e.getActiveAttrib(p, c).name;
									a[d] = e.getAttribLocation(p, d)
								}
								r = a
							}
							return r
						}, this.destroy = function() {
							e.deleteProgram(p), this.program = void 0
						}, Object.defineProperties(this, {
							uniforms: {
								get: function() {
									return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
								}
							},
							attributes: {
								get: function() {
									return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
								}
							}
						}), this.id = Ie++, this.code = b, this.usedTimes = 1, this.program = p, this.vertexShader = h, this.fragmentShader = i, this
					}

					function bb(a, b) {
						function c(a, b) {
							var c;
							return a ? a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding) : c = 3e3, 3e3 === c && b && (c = 3007), c
						}
						var d = [],
							e = {
								MeshDepthMaterial: "depth",
								MeshNormalMaterial: "normal",
								MeshBasicMaterial: "basic",
								MeshLambertMaterial: "lambert",
								MeshPhongMaterial: "phong",
								MeshToonMaterial: "phong",
								MeshStandardMaterial: "physical",
								MeshPhysicalMaterial: "physical",
								LineBasicMaterial: "basic",
								LineDashedMaterial: "dashed",
								PointsMaterial: "points"
							},
							f = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
						this.getParameters = function(d, f, g, h, i, j) {
							var k, l = e[d.type];
							if (j.isSkinnedMesh)
								if (k = j.skeleton.bones, b.floatVertexTextures) k = 1024;
								else {
									var m = Math.min(Math.floor((b.maxVertexUniforms - 20) / 4), k.length);
									m < k.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + k.length + " bones. This GPU supports " + m + "."), k = 0) : k = m
								}
							else k = 0;
							m = a.getPrecision(), null !== d.precision && (m = b.getMaxPrecision(d.precision), m !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", m, "instead."));
							var n = a.getRenderTarget();
							return {
								shaderID: l,
								precision: m,
								supportsVertexTextures: b.vertexTextures,
								outputEncoding: c(n ? n.texture : null, a.gammaOutput),
								map: !!d.map,
								mapEncoding: c(d.map, a.gammaInput),
								envMap: !!d.envMap,
								envMapMode: d.envMap && d.envMap.mapping,
								envMapEncoding: c(d.envMap, a.gammaInput),
								envMapCubeUV: !!d.envMap && (306 === d.envMap.mapping || 307 === d.envMap.mapping),
								lightMap: !!d.lightMap,
								aoMap: !!d.aoMap,
								emissiveMap: !!d.emissiveMap,
								emissiveMapEncoding: c(d.emissiveMap, a.gammaInput),
								bumpMap: !!d.bumpMap,
								normalMap: !!d.normalMap,
								displacementMap: !!d.displacementMap,
								roughnessMap: !!d.roughnessMap,
								metalnessMap: !!d.metalnessMap,
								specularMap: !!d.specularMap,
								alphaMap: !!d.alphaMap,
								gradientMap: !!d.gradientMap,
								combine: d.combine,
								vertexColors: d.vertexColors,
								fog: !!g,
								useFog: d.fog,
								fogExp: g && g.isFogExp2,
								flatShading: 1 === d.shading,
								sizeAttenuation: d.sizeAttenuation,
								logarithmicDepthBuffer: b.logarithmicDepthBuffer,
								skinning: d.skinning && 0 < k,
								maxBones: k,
								useVertexTexture: b.floatVertexTextures,
								morphTargets: d.morphTargets,
								morphNormals: d.morphNormals,
								maxMorphTargets: a.maxMorphTargets,
								maxMorphNormals: a.maxMorphNormals,
								numDirLights: f.directional.length,
								numPointLights: f.point.length,
								numSpotLights: f.spot.length,
								numRectAreaLights: f.rectArea.length,
								numHemiLights: f.hemi.length,
								numClippingPlanes: h,
								numClipIntersection: i,
								dithering: d.dithering,
								shadowMapEnabled: a.shadowMap.enabled && j.receiveShadow && 0 < f.shadows.length,
								shadowMapType: a.shadowMap.type,
								toneMapping: a.toneMapping,
								physicallyCorrectLights: a.physicallyCorrectLights,
								premultipliedAlpha: d.premultipliedAlpha,
								alphaTest: d.alphaTest,
								doubleSided: 2 === d.side,
								flipSided: 1 === d.side,
								depthPacking: void 0 !== d.depthPacking && d.depthPacking
							}
						}, this.getProgramCode = function(a, b) {
							var c = [];
							if (b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader)), void 0 !== a.defines)
								for (var d in a.defines) c.push(d), c.push(a.defines[d]);
							for (d = 0; d < f.length; d++) c.push(b[f[d]]);
							return c.join()
						}, this.acquireProgram = function(b, c, e) {
							for (var f, g = 0, h = d.length; g < h; g++) {
								var i = d[g];
								if (i.code === e) {
									f = i, ++f.usedTimes;
									break
								}
							}
							return void 0 === f && (f = new ab(a, e, b, c), d.push(f)), f
						}, this.releaseProgram = function(a) {
							if (0 === --a.usedTimes) {
								var b = d.indexOf(a);
								d[b] = d[d.length - 1], d.pop(), a.destroy()
							}
						}, this.programs = d
					}

					function cb(a, b, c, d, e, f, g) {
						function h(a, b) {
							if (a.width > b || a.height > b) {
								var c = b / Math.max(a.width, a.height),
									d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
								return d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c), d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a), d
							}
							return a
						}

						function i(a) {
							return re.isPowerOfTwo(a.width) && re.isPowerOfTwo(a.height)
						}

						function j(b) {
							return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR
						}

						function k(b) {
							b = b.target, b.removeEventListener("dispose", k);
							a: {
								var c = d.get(b);
								if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube);
								else {
									if (void 0 === c.__webglInit) break a;
									a.deleteTexture(c.__webglTexture)
								}
								d.remove(b)
							}
							g.textures--
						}

						function l(b) {
							b = b.target, b.removeEventListener("dispose", l);
							var c = d.get(b),
								e = d.get(b.texture);
							if (b) {
								if (void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture), b.depthTexture && b.depthTexture.dispose(), b.isWebGLRenderTargetCube)
									for (e = 0; 6 > e; e++) a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
								else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
								d.remove(b.texture), d.remove(b)
							}
							g.textures--
						}

						function m(b, j) {
							var l = d.get(b);
							if (0 < b.version && l.__version !== b.version) {
								var m = b.image;
								if (void 0 === m) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", b);
								else {
									if (false !== m.complete) {
										void 0 === l.__webglInit && (l.__webglInit = true, b.addEventListener("dispose", k), l.__webglTexture = a.createTexture(), g.textures++), c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_2D, l.__webglTexture), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment);
										var o = h(b.image, e.maxTextureSize);
										if ((1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && false === i(o))
											if (m = o, m instanceof HTMLImageElement || m instanceof HTMLCanvasElement) {
												var p = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
												p.width = re.nearestPowerOfTwo(m.width), p.height = re.nearestPowerOfTwo(m.height), p.getContext("2d").drawImage(m, 0, 0, p.width, p.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + m.width + "x" + m.height + "). Resized to " + p.width + "x" + p.height, m), o = p
											} else o = m;
										var m = i(o),
											p = f(b.format),
											r = f(b.type);
										n(a.TEXTURE_2D, b, m);
										var s = b.mipmaps;
										if (b.isDepthTexture) {
											if (s = a.DEPTH_COMPONENT, 1015 === b.type) {
												if (!q) throw Error("Float Depth Texture only supported in WebGL2.0");
												s = a.DEPTH_COMPONENT32F
											} else q && (s = a.DEPTH_COMPONENT16);
											1026 === b.format && s === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), b.type = 1012, r = f(b.type)), 1027 === b.format && (s = a.DEPTH_STENCIL, 1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, r = f(b.type))), c.texImage2D(a.TEXTURE_2D, 0, s, o.width, o.height, 0, p, r, null)
										} else if (b.isDataTexture)
											if (0 < s.length && m) {
												for (var t = 0, u = s.length; t < u; t++) o = s[t], c.texImage2D(a.TEXTURE_2D, t, p, o.width, o.height, 0, p, r, o.data);
												b.generateMipmaps = false
											} else c.texImage2D(a.TEXTURE_2D, 0, p, o.width, o.height, 0, p, r, o.data);
										else if (b.isCompressedTexture)
											for (t = 0, u = s.length; t < u; t++) o = s[t], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(p) ? c.compressedTexImage2D(a.TEXTURE_2D, t, p, o.width, o.height, 0, o.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, t, p, o.width, o.height, 0, p, r, o.data);
										else if (0 < s.length && m) {
											for (t = 0, u = s.length; t < u; t++) o = s[t], c.texImage2D(a.TEXTURE_2D, t, p, p, r, o);
											b.generateMipmaps = false
										} else c.texImage2D(a.TEXTURE_2D, 0, p, p, r, o);
										return b.generateMipmaps && m && a.generateMipmap(a.TEXTURE_2D), l.__version = b.version, void(b.onUpdate && b.onUpdate(b))
									}
									console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", b)
								}
							}
							c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_2D, l.__webglTexture)
						}

						function n(c, g, h) {
							h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", g), a.texParameteri(c, a.TEXTURE_MAG_FILTER, j(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, j(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", g)), !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === b.get("OES_texture_half_float_linear") || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy)
						}

						function o(b, e, g, h) {
							var i = f(e.texture.format),
								j = f(e.texture.type);
							c.texImage2D(h, 0, i, e.width, e.height, 0, i, j, null), a.bindFramebuffer(a.FRAMEBUFFER, b), a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0), a.bindFramebuffer(a.FRAMEBUFFER, null)
						}

						function p(b, c) {
							a.bindRenderbuffer(a.RENDERBUFFER, b), c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height), a.bindRenderbuffer(a.RENDERBUFFER, null)
						}
						var q = "undefined" != typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext;
						this.setTexture2D = m, this.setTextureCube = function(b, j) {
							var l = d.get(b);
							if (6 === b.image.length)
								if (0 < b.version && l.__version !== b.version) {
									l.__image__webglTextureCube || (b.addEventListener("dispose", k), l.__image__webglTextureCube = a.createTexture(), g.textures++), c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_CUBE_MAP, l.__image__webglTextureCube), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
									for (var m = b && b.isCompressedTexture, o = b.image[0] && b.image[0].isDataTexture, p = [], q = 0; 6 > q; q++) p[q] = m || o ? o ? b.image[q].image : b.image[q] : h(b.image[q], e.maxCubemapSize);
									var r = i(p[0]),
										s = f(b.format),
										t = f(b.type);
									for (n(a.TEXTURE_CUBE_MAP, b, r), q = 0; 6 > q; q++)
										if (m)
											for (var u, v = p[q].mipmaps, w = 0, x = v.length; w < x; w++) u = v[w], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(s) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, w, s, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, w, s, u.width, u.height, 0, s, t, u.data);
										else o ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, 0, s, p[q].width, p[q].height, 0, s, t, p[q].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, 0, s, s, t, p[q]);
									b.generateMipmaps && r && a.generateMipmap(a.TEXTURE_CUBE_MAP), l.__version = b.version, b.onUpdate && b.onUpdate(b)
								} else c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_CUBE_MAP, l.__image__webglTextureCube)
						}, this.setTextureCubeDynamic = function(b, e) {
							c.activeTexture(a.TEXTURE0 + e), c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture)
						}, this.setupRenderTarget = function(b) {
							var e = d.get(b),
								f = d.get(b.texture);
							b.addEventListener("dispose", l), f.__webglTexture = a.createTexture(), g.textures++;
							var h = true === b.isWebGLRenderTargetCube,
								j = i(b);
							if (h) {
								e.__webglFramebuffer = [];
								for (var k = 0; 6 > k; k++) e.__webglFramebuffer[k] = a.createFramebuffer()
							} else e.__webglFramebuffer = a.createFramebuffer();
							if (h) {
								for (c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture), n(a.TEXTURE_CUBE_MAP, b.texture, j), k = 0; 6 > k; k++) o(e.__webglFramebuffer[k], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + k);
								b.texture.generateMipmaps && j && a.generateMipmap(a.TEXTURE_CUBE_MAP), c.bindTexture(a.TEXTURE_CUBE_MAP, null)
							} else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), n(a.TEXTURE_2D, b.texture, j), o(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), b.texture.generateMipmaps && j && a.generateMipmap(a.TEXTURE_2D), c.bindTexture(a.TEXTURE_2D, null);
							if (b.depthBuffer) {
								if (e = d.get(b), f = true === b.isWebGLRenderTargetCube, b.depthTexture) {
									if (f) throw Error("target.depthTexture not supported in Cube render targets");
									if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
									if (a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), !b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
									if (d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = true), m(b.depthTexture, 0), e = d.get(b.depthTexture).__webglTexture, 1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0);
									else {
										if (1027 !== b.depthTexture.format) throw Error("Unknown depthTexture format");
										a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0)
									}
								} else if (f)
									for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++) a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), p(e.__webglDepthbuffer[f], b);
								else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), p(e.__webglDepthbuffer, b);
								a.bindFramebuffer(a.FRAMEBUFFER, null)
							}
						}, this.updateRenderTargetMipmap = function(b) {
							var e = b.texture;
							e.generateMipmaps && i(b) && 1003 !== e.minFilter && 1006 !== e.minFilter && (b = b && b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D, e = d.get(e).__webglTexture, c.bindTexture(b, e), a.generateMipmap(b), c.bindTexture(b, null))
						}
					}

					function db() {
						var a = {};
						return {
							get: function(b) {
								b = b.uuid;
								var c = a[b];
								return void 0 === c && (c = {}, a[b] = c), c
							},
							remove: function(b) {
								delete a[b.uuid]
							},
							clear: function() {
								a = {}
							}
						}
					}

					function eb(a, b, c) {
						function d(b, c, d) {
							var e = new Uint8Array(4),
								f = a.createTexture();
							for (a.bindTexture(b, f), a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST), b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
							return f
						}

						function f(b) {
							true !== t[b] && (a.enable(b), t[b] = true)
						}

						function g(b) {
							false !== t[b] && (a.disable(b), t[b] = false)
						}

						function h(b, d, e, h, i, j, k, l) {
							0 !== b ? f(a.BLEND) : g(a.BLEND), b === v && l === C || (2 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : 3 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : 4 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), v = b, C = l), 5 === b ? (i = i || d, j = j || e, k = k || h, d === w && i === z || (a.blendEquationSeparate(c(d), c(i)), w = d, z = i), e === x && h === y && j === A && k === B || (a.blendFuncSeparate(c(e), c(h), c(j), c(k)), x = e, y = h, A = j, B = k)) : B = A = z = y = x = w = null
						}

						function i(b) {
							D !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), D = b)
						}

						function j(b) {
							0 !== b ? (f(a.CULL_FACE), b !== E && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : g(a.CULL_FACE), E = b
						}

						function k(b, c, d) {
							b ? (f(a.POLYGON_OFFSET_FILL), (G !== c || H !== d) && (a.polygonOffset(c, d), G = c, H = d)) : g(a.POLYGON_OFFSET_FILL)
						}

						function l(b) {
							void 0 === b && (b = a.TEXTURE0 + J - 1), L !== b && (a.activeTexture(b), L = b)
						}
						var m = new function() {
								var b = false,
									c = new e,
									d = null,
									f = new e;
								return {
									setMask: function(c) {
										d === c || b || (a.colorMask(c, c, c, c), d = c)
									},
									setLocked: function(a) {
										b = a
									},
									setClear: function(b, d, e, g, h) {
										true === h && (b *= g, d *= g, e *= g), c.set(b, d, e, g), false === f.equals(c) && (a.clearColor(b, d, e, g), f.copy(c))
									},
									reset: function() {
										b = false, d = null, f.set(0, 0, 0, 1)
									}
								}
							},
							n = new function() {
								var b = false,
									c = null,
									d = null,
									e = null;
								return {
									setTest: function(b) {
										b ? f(a.DEPTH_TEST) : g(a.DEPTH_TEST)
									},
									setMask: function(d) {
										c === d || b || (a.depthMask(d), c = d)
									},
									setFunc: function(b) {
										if (d !== b) {
											if (b) switch (b) {
												case 0:
													a.depthFunc(a.NEVER);
													break;
												case 1:
													a.depthFunc(a.ALWAYS);
													break;
												case 2:
													a.depthFunc(a.LESS);
													break;
												case 3:
													a.depthFunc(a.LEQUAL);
													break;
												case 4:
													a.depthFunc(a.EQUAL);
													break;
												case 5:
													a.depthFunc(a.GEQUAL);
													break;
												case 6:
													a.depthFunc(a.GREATER);
													break;
												case 7:
													a.depthFunc(a.NOTEQUAL);
													break;
												default:
													a.depthFunc(a.LEQUAL)
											} else a.depthFunc(a.LEQUAL);
											d = b
										}
									},
									setLocked: function(a) {
										b = a
									},
									setClear: function(b) {
										e !== b && (a.clearDepth(b), e = b)
									},
									reset: function() {
										b = false, e = d = c = null
									}
								}
							},
							o = new function() {
								var b = false,
									c = null,
									d = null,
									e = null,
									h = null,
									i = null,
									j = null,
									k = null,
									l = null;
								return {
									setTest: function(b) {
										b ? f(a.STENCIL_TEST) : g(a.STENCIL_TEST)
									},
									setMask: function(d) {
										c === d || b || (a.stencilMask(d), c = d)
									},
									setFunc: function(b, c, f) {
										d === b && e === c && h === f || (a.stencilFunc(b, c, f), d = b, e = c, h = f)
									},
									setOp: function(b, c, d) {
										i === b && j === c && k === d || (a.stencilOp(b, c, d), i = b, j = c, k = d)
									},
									setLocked: function(a) {
										b = a
									},
									setClear: function(b) {
										l !== b && (a.clearStencil(b), l = b)
									},
									reset: function() {
										b = false, l = k = j = i = h = e = d = c = null
									}
								}
							},
							p = a.getParameter(a.MAX_VERTEX_ATTRIBS),
							q = new Uint8Array(p),
							r = new Uint8Array(p),
							s = new Uint8Array(p),
							t = {},
							u = null,
							v = null,
							w = null,
							x = null,
							y = null,
							z = null,
							A = null,
							B = null,
							C = false,
							D = null,
							E = null,
							F = null,
							G = null,
							H = null,
							I = null,
							J = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
							p = parseFloat(/^WebGL\ ([0-9])/.exec(a.getParameter(a.VERSION))[1]),
							K = 1 <= parseFloat(p),
							L = null,
							M = {},
							N = new e,
							O = new e,
							P = {};
						return P[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1), P[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
							buffers: {
								color: m,
								depth: n,
								stencil: o
							},
							init: function() {
								m.setClear(0, 0, 0, 1), n.setClear(1), o.setClear(0), f(a.DEPTH_TEST), n.setFunc(3), i(false), j(1), f(a.CULL_FACE), f(a.BLEND), h(1)
							},
							initAttributes: function() {
								for (var a = 0, b = q.length; a < b; a++) q[a] = 0
							},
							enableAttribute: function(c) {
								q[c] = 1, 0 === r[c] && (a.enableVertexAttribArray(c), r[c] = 1), 0 !== s[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), s[c] = 0)
							},
							enableAttributeAndDivisor: function(c, d) {
								q[c] = 1, 0 === r[c] && (a.enableVertexAttribArray(c), r[c] = 1), s[c] !== d && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, d), s[c] = d)
							},
							disableUnusedAttributes: function() {
								for (var b = 0, c = r.length; b !== c; ++b) r[b] !== q[b] && (a.disableVertexAttribArray(b), r[b] = 0)
							},
							enable: f,
							disable: g,
							getCompressedTextureFormats: function() {
								if (null === u && (u = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1")))
									for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) u.push(c[d]);
								return u
							},
							setBlending: h,
							setMaterial: function(b) {
								2 === b.side ? g(a.CULL_FACE) : f(a.CULL_FACE), i(1 === b.side), true === b.transparent ? h(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha) : h(0), n.setFunc(b.depthFunc), n.setTest(b.depthTest), n.setMask(b.depthWrite), m.setMask(b.colorWrite), k(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits)
							},
							setFlipSided: i,
							setCullFace: j,
							setLineWidth: function(b) {
								b !== F && (K && a.lineWidth(b), F = b)
							},
							setPolygonOffset: k,
							getScissorTest: function() {
								return I
							},
							setScissorTest: function(b) {
								(I = b) ? f(a.SCISSOR_TEST): g(a.SCISSOR_TEST)
							},
							activeTexture: l,
							bindTexture: function(b, c) {
								null === L && l();
								var d = M[L];
								void 0 === d && (d = {
									type: void 0,
									texture: void 0
								}, M[L] = d), d.type === b && d.texture === c || (a.bindTexture(b, c || P[b]), d.type = b, d.texture = c)
							},
							compressedTexImage2D: function() {
								try {
									a.compressedTexImage2D.apply(a, arguments)
								} catch (a) {
									console.error(a)
								}
							},
							texImage2D: function() {
								try {
									a.texImage2D.apply(a, arguments)
								} catch (a) {
									console.error(a)
								}
							},
							scissor: function(b) {
								false === N.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), N.copy(b))
							},
							viewport: function(b) {
								false === O.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), O.copy(b))
							},
							reset: function() {
								for (var b = 0; b < r.length; b++) 1 === r[b] && (a.disableVertexAttribArray(b), r[b] = 0);
								t = {}, L = u = null, M = {}, E = D = v = null, m.reset(), n.reset(), o.reset()
							}
						}
					}

					function fb(a, b, c) {
						function d(b) {
							if ("highp" === b) {
								if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
								b = "mediump"
							}
							return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
						}
						var e, f = void 0 !== c.precision ? c.precision : "highp",
							g = d(f);
						g !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", g, "instead."), f = g), c = true === c.logarithmicDepthBuffer && !!b.get("EXT_frag_depth");
						var g = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
							h = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
							i = a.getParameter(a.MAX_TEXTURE_SIZE),
							j = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
							k = a.getParameter(a.MAX_VERTEX_ATTRIBS),
							l = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
							m = a.getParameter(a.MAX_VARYING_VECTORS),
							n = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
							o = 0 < h,
							p = !!b.get("OES_texture_float");
						return {
							getMaxAnisotropy: function() {
								if (void 0 !== e) return e;
								var c = b.get("EXT_texture_filter_anisotropic");
								return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
							},
							getMaxPrecision: d,
							precision: f,
							logarithmicDepthBuffer: c,
							maxTextures: g,
							maxVertexTextures: h,
							maxTextureSize: i,
							maxCubemapSize: j,
							maxAttributes: k,
							maxVertexUniforms: l,
							maxVaryings: m,
							maxFragmentUniforms: n,
							vertexTextures: o,
							floatFragmentTextures: p,
							floatVertexTextures: o && p
						}
					}

					function gb(a) {
						var b = {};
						return {
							get: function(c) {
								if (void 0 !== b[c]) return b[c];
								var d;
								switch (c) {
									case "WEBGL_depth_texture":
										d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
										break;
									case "EXT_texture_filter_anisotropic":
										d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
										break;
									case "WEBGL_compressed_texture_s3tc":
										d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
										break;
									case "WEBGL_compressed_texture_pvrtc":
										d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
										break;
									case "WEBGL_compressed_texture_etc1":
										d = a.getExtension("WEBGL_compressed_texture_etc1");
										break;
									default:
										d = a.getExtension(c)
								}
								return null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."), b[c] = d
							}
						}
					}

					function hb() {
						function a() {
							j.value !== d && (j.value = d, j.needsUpdate = 0 < e), c.numPlanes = e, c.numIntersection = 0
						}

						function b(a, b, d, e) {
							var f = null !== a ? a.length : 0,
								g = null;
							if (0 !== f) {
								if (g = j.value, true !== e || null === g)
									for (e = d + 4 * f, b = b.matrixWorldInverse, i.getNormalMatrix(b), (null === g || g.length < e) && (g = new Float32Array(e)), e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, i), h.normal.toArray(g, d), g[d + 3] = h.constant;
								j.value = g, j.needsUpdate = true
							}
							return c.numPlanes = f, g
						}
						var c = this,
							d = null,
							e = 0,
							f = false,
							g = false,
							h = new _,
							i = new $,
							j = {
								value: null,
								needsUpdate: false
							};
						this.uniform = j, this.numIntersection = this.numPlanes = 0, this.init = function(a, c, g) {
							var h = 0 !== a.length || c || 0 !== e || f;
							return f = c, d = b(a, g, 0), e = a.length, h
						}, this.beginShadows = function() {
							g = true, b(null)
						}, this.endShadows = function() {
							g = false, a()
						}, this.setState = function(c, h, i, k, l, m) {
							if (!f || null === c || 0 === c.length || g && !i) g ? b(null) : a();
							else {
								i = g ? 0 : e;
								var n = 4 * i,
									o = l.clippingState || null;
								for (j.value = o, o = b(c, k, n, m), c = 0; c !== n; ++c) o[c] = d[c];
								l.clippingState = o, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += i
							}
						}
					}

					function ib(a) {
						function b() {
							va.init(), va.scissor(P.copy(da).multiplyScalar(ca)), va.viewport(V.copy(fa).multiplyScalar(ca)), va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B)
						}

						function c() {
							O = J = null, N = "", M = -1, va.reset()
						}

						function d(a) {
							a.preventDefault(), c(), b(), wa.clear(), Ha.clear()
						}

						function f(a) {
							a = a.target, a.removeEventListener("dispose", f), g(a), wa.remove(a)
						}

						function g(a) {
							var b = wa.get(a).program;
							a.program = void 0, void 0 !== b && Ia.releaseProgram(b)
						}

						function h(a, b, c) {
							a.render(function(a) {
								I.renderBufferImmediate(a, b, c)
							})
						}

						function l(a, b) {
							return Math.abs(b[0]) - Math.abs(a[0])
						}

						function m(a, b, c) {
							if (a.visible) {
								if (a.layers.test(b.layers))
									if (a.isLight) D.push(a);
									else if (a.isSprite) a.frustumCulled && !ga.intersectsSprite(a) || G.push(a);
								else if (a.isLensFlare) H.push(a);
								else if (a.isImmediateRenderObject) c && ma.setFromMatrixPosition(a.matrixWorld).applyMatrix4(la), E.push(a, null, a.material, ma.z, null);
								else if ((a.isMesh || a.isLine || a.isPoints) && (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || ga.intersectsObject(a))) {
									c && ma.setFromMatrixPosition(a.matrixWorld).applyMatrix4(la);
									var d = Ha.update(a),
										e = a.material;
									if (Array.isArray(e))
										for (var f = d.groups, g = 0, h = f.length; g < h; g++) {
											var i = f[g],
												j = e[i.materialIndex];
											j && j.visible && E.push(a, d, j, ma.z, i)
										} else e.visible && E.push(a, d, e, ma.z, null)
								}
								for (a = a.children, g = 0, h = a.length; g < h; g++) m(a[g], b, c)
							}
						}

						function n(a, b, c, d) {
							for (var e = 0, f = a.length; e < f; e++) {
								var g = a[e],
									h = g.object,
									i = g.geometry,
									j = void 0 === d ? g.material : d,
									g = g.group;
								if (h.onBeforeRender(I, b, c, i, j, g), c.isArrayCamera && c.enabled)
									for (var k = c.cameras, l = 0, m = k.length; l < m; l++) {
										var n = k[l],
											p = n.bounds;
										I.setViewport(p.x * $ * ca, p.y * _ * ca, p.z * $ * ca, p.w * _ * ca), I.setScissor(p.x * $ * ca, p.y * _ * ca, p.z * $ * ca, p.w * _ * ca), I.setScissorTest(true), o(h, b, n, i, j, g)
									} else o(h, b, c, i, j, g);
								h.onAfterRender(I, b, c, i, j, g)
							}
						}

						function o(a, b, c, d, e, f) {
							a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), a.normalMatrix.getNormalMatrix(a.modelViewMatrix), a.isImmediateRenderObject ? (va.setMaterial(e), b = q(c, b.fog, e, a), N = "", h(a, b, e)) : I.renderBufferDirect(c, b.fog, d, e, a, f)
						}

						function p(a, b, c) {
							var d = wa.get(a);
							c = Ia.getParameters(a, pa, b, ha.numPlanes, ha.numIntersection, c);
							var e = Ia.getProgramCode(a, c),
								h = d.program,
								i = true;
							if (void 0 === h) a.addEventListener("dispose", f);
							else if (h.code !== e) g(a);
							else {
								if (void 0 !== c.shaderID) return;
								i = false
							}
							if (i && (c.shaderID ? (h = Ee[c.shaderID], d.__webglShader = {
									name: a.type,
									uniforms: Ce.clone(h.uniforms),
									vertexShader: h.vertexShader,
									fragmentShader: h.fragmentShader
								}) : d.__webglShader = {
									name: a.type,
									uniforms: a.uniforms,
									vertexShader: a.vertexShader,
									fragmentShader: a.fragmentShader
								}, a.__webglShader = d.__webglShader, h = Ia.acquireProgram(a, c, e), d.program = h, a.program = h), c = h.getAttributes(), a.morphTargets)
								for (e = a.numSupportedMorphTargets = 0; e < I.maxMorphTargets; e++) 0 <= c["morphTarget" + e] && a.numSupportedMorphTargets++;
							if (a.morphNormals)
								for (e = a.numSupportedMorphNormals = 0; e < I.maxMorphNormals; e++) 0 <= c["morphNormal" + e] && a.numSupportedMorphNormals++;
							c = d.__webglShader.uniforms, (a.isShaderMaterial || a.isRawShaderMaterial) && true !== a.clipping || (d.numClippingPlanes = ha.numPlanes, d.numIntersection = ha.numIntersection, c.clippingPlanes = ha.uniform), d.fog = b, d.lightsHash = pa.hash, a.lights && (c.ambientLightColor.value = pa.ambient, c.directionalLights.value = pa.directional, c.spotLights.value = pa.spot, c.rectAreaLights.value = pa.rectArea, c.pointLights.value = pa.point, c.hemisphereLights.value = pa.hemi, c.directionalShadowMap.value = pa.directionalShadowMap, c.directionalShadowMatrix.value = pa.directionalShadowMatrix, c.spotShadowMap.value = pa.spotShadowMap, c.spotShadowMatrix.value = pa.spotShadowMatrix, c.pointShadowMap.value = pa.pointShadowMap, c.pointShadowMatrix.value = pa.pointShadowMatrix), a = d.program.getUniforms(), a = Q.seqWithValue(a.seq, c), d.uniformsList = a
						}

						function q(a, b, c, d) {
							X = 0;
							var e = wa.get(c);
							ia && (ka || a !== O) && ha.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === O && c.id === M), false === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = true : c.fog && e.fog !== b ? c.needsUpdate = true : c.lights && e.lightsHash !== pa.hash ? c.needsUpdate = true : void 0 === e.numClippingPlanes || e.numClippingPlanes === ha.numPlanes && e.numIntersection === ha.numIntersection || (c.needsUpdate = true)), c.needsUpdate && (p(c, b, d), c.needsUpdate = false);
							var f = false,
								g = false,
								h = false,
								i = e.program,
								j = i.getUniforms(),
								l = e.__webglShader.uniforms;
							if (i.id !== J && (sa.useProgram(i.program), J = i.id, h = g = f = true), c.id !== M && (M = c.id, g = true), (f || a !== O) && (j.setValue(sa, "projectionMatrix", a.projectionMatrix), ua.logarithmicDepthBuffer && j.setValue(sa, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)), a !== O && (O = a, h = g = true), (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) && (f = j.map.cameraPosition, void 0 !== f && f.setValue(sa, ma.setFromMatrixPosition(a.matrixWorld))), (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && j.setValue(sa, "viewMatrix", a.matrixWorldInverse), j.setValue(sa, "toneMappingExposure", I.toneMappingExposure), j.setValue(sa, "toneMappingWhitePoint", I.toneMappingWhitePoint)), c.skinning && (j.setOptional(sa, d, "bindMatrix"), j.setOptional(sa, d, "bindMatrixInverse"), a = d.skeleton))
								if (f = a.bones, ua.floatVertexTextures) {
									if (void 0 === a.boneTexture) {
										var f = Math.sqrt(4 * f.length),
											f = re.nextPowerOfTwo(Math.ceil(f)),
											f = Math.max(f, 4),
											m = new Float32Array(f * f * 4);
										m.set(a.boneMatrices);
										var n = new k(m, f, f, 1023, 1015);
										a.boneMatrices = m, a.boneTexture = n, a.boneTextureSize = f
									}
									j.setValue(sa, "boneTexture", a.boneTexture), j.setValue(sa, "boneTextureSize", a.boneTextureSize)
								} else j.setOptional(sa, a, "boneMatrices");
							if (g) {
								if (c.lights && (g = h, l.ambientLightColor.needsUpdate = g, l.directionalLights.needsUpdate = g, l.pointLights.needsUpdate = g, l.spotLights.needsUpdate = g, l.rectAreaLights.needsUpdate = g, l.hemisphereLights.needsUpdate = g), b && c.fog && (l.fogColor.value = b.color, b.isFog ? (l.fogNear.value = b.near, l.fogFar.value = b.far) : b.isFogExp2 && (l.fogDensity.value = b.density)), c.isMeshBasicMaterial || c.isMeshLambertMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.isMeshNormalMaterial || c.isMeshDepthMaterial) {
									l.opacity.value = c.opacity, l.diffuse.value = c.color, c.emissive && l.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity), l.map.value = c.map, l.specularMap.value = c.specularMap, l.alphaMap.value = c.alphaMap, c.lightMap && (l.lightMap.value = c.lightMap, l.lightMapIntensity.value = c.lightMapIntensity), c.aoMap && (l.aoMap.value = c.aoMap, l.aoMapIntensity.value = c.aoMapIntensity);
									var o;
									c.map ? o = c.map : c.specularMap ? o = c.specularMap : c.displacementMap ? o = c.displacementMap : c.normalMap ? o = c.normalMap : c.bumpMap ? o = c.bumpMap : c.roughnessMap ? o = c.roughnessMap : c.metalnessMap ? o = c.metalnessMap : c.alphaMap ? o = c.alphaMap : c.emissiveMap && (o = c.emissiveMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), b = o.offset, o = o.repeat, l.offsetRepeat.value.set(b.x, b.y, o.x, o.y)), l.envMap.value = c.envMap, l.flipEnvMap.value = c.envMap && c.envMap.isCubeTexture ? -1 : 1, l.reflectivity.value = c.reflectivity, l.refractionRatio.value = c.refractionRatio
								}
								c.isLineBasicMaterial ? (l.diffuse.value = c.color, l.opacity.value = c.opacity) : c.isLineDashedMaterial ? (l.diffuse.value = c.color, l.opacity.value = c.opacity, l.dashSize.value = c.dashSize, l.totalSize.value = c.dashSize + c.gapSize, l.scale.value = c.scale) : c.isPointsMaterial ? (l.diffuse.value = c.color, l.opacity.value = c.opacity, l.size.value = c.size * ca, l.scale.value = .5 * _, l.map.value = c.map, null !== c.map && (o = c.map.offset, c = c.map.repeat, l.offsetRepeat.value.set(o.x, o.y, c.x, c.y))) : c.isMeshLambertMaterial ? c.emissiveMap && (l.emissiveMap.value = c.emissiveMap) : c.isMeshToonMaterial ? (r(l, c), c.gradientMap && (l.gradientMap.value = c.gradientMap)) : c.isMeshPhongMaterial ? r(l, c) : c.isMeshPhysicalMaterial ? (l.clearCoat.value = c.clearCoat, l.clearCoatRoughness.value = c.clearCoatRoughness, s(l, c)) : c.isMeshStandardMaterial ? s(l, c) : c.isMeshDepthMaterial ? c.displacementMap && (l.displacementMap.value = c.displacementMap, l.displacementScale.value = c.displacementScale, l.displacementBias.value = c.displacementBias) : c.isMeshNormalMaterial && (c.bumpMap && (l.bumpMap.value = c.bumpMap, l.bumpScale.value = c.bumpScale), c.normalMap && (l.normalMap.value = c.normalMap, l.normalScale.value.copy(c.normalScale)), c.displacementMap && (l.displacementMap.value = c.displacementMap, l.displacementScale.value = c.displacementScale, l.displacementBias.value = c.displacementBias)), void 0 !== l.ltcMat && (l.ltcMat.value = Be.LTC_MAT_TEXTURE), void 0 !== l.ltcMag && (l.ltcMag.value = Be.LTC_MAG_TEXTURE), Q.upload(sa, e.uniformsList, l, I)
							}
							return j.setValue(sa, "modelViewMatrix", d.modelViewMatrix), j.setValue(sa, "normalMatrix", d.normalMatrix), j.setValue(sa, "modelMatrix", d.matrixWorld), i
						}

						function r(a, b) {
							a.specular.value = b.specular, a.shininess.value = Math.max(b.shininess, 1e-4), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias)
						}

						function s(a, b) {
							a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
						}

						function t(a, b) {
							var c, d, e, f, g, h, i, j = 0,
								k = 0,
								l = 0,
								m = b.matrixWorldInverse,
								n = 0,
								o = 0,
								p = 0,
								q = 0,
								r = 0;
							for (c = 0, d = a.length; c < d; c++)
								if (e = a[c], f = e.color, g = e.intensity, h = e.distance, i = e.shadow && e.shadow.map ? e.shadow.map.texture : null, e.isAmbientLight) j += f.r * g, k += f.g * g, l += f.b * g;
								else if (e.isDirectionalLight) {
								var s = Ja.get(e);
								s.color.copy(e.color).multiplyScalar(e.intensity), s.direction.setFromMatrixPosition(e.matrixWorld), ma.setFromMatrixPosition(e.target.matrixWorld), s.direction.sub(ma), s.direction.transformDirection(m), (s.shadow = e.castShadow) && (f = e.shadow, s.shadowBias = f.bias, s.shadowRadius = f.radius, s.shadowMapSize = f.mapSize), pa.directionalShadowMap[n] = i, pa.directionalShadowMatrix[n] = e.shadow.matrix, pa.directional[n] = s, n++
							} else e.isSpotLight ? (s = Ja.get(e), s.position.setFromMatrixPosition(e.matrixWorld), s.position.applyMatrix4(m), s.color.copy(f).multiplyScalar(g), s.distance = h, s.direction.setFromMatrixPosition(e.matrixWorld), ma.setFromMatrixPosition(e.target.matrixWorld), s.direction.sub(ma), s.direction.transformDirection(m), s.coneCos = Math.cos(e.angle), s.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), s.decay = 0 === e.distance ? 0 : e.decay, (s.shadow = e.castShadow) && (f = e.shadow, s.shadowBias = f.bias, s.shadowRadius = f.radius, s.shadowMapSize = f.mapSize), pa.spotShadowMap[p] = i, pa.spotShadowMatrix[p] = e.shadow.matrix, pa.spot[p] = s, p++) : e.isRectAreaLight ? (s = Ja.get(e), s.color.copy(f).multiplyScalar(g / (e.width * e.height)), s.position.setFromMatrixPosition(e.matrixWorld), s.position.applyMatrix4(m), oa.identity(), na.copy(e.matrixWorld), na.premultiply(m), oa.extractRotation(na), s.halfWidth.set(.5 * e.width, 0, 0), s.halfHeight.set(0, .5 * e.height, 0), s.halfWidth.applyMatrix4(oa), s.halfHeight.applyMatrix4(oa), pa.rectArea[q] = s, q++) : e.isPointLight ? (s = Ja.get(e), s.position.setFromMatrixPosition(e.matrixWorld), s.position.applyMatrix4(m), s.color.copy(e.color).multiplyScalar(e.intensity), s.distance = e.distance, s.decay = 0 === e.distance ? 0 : e.decay, (s.shadow = e.castShadow) && (f = e.shadow, s.shadowBias = f.bias, s.shadowRadius = f.radius, s.shadowMapSize = f.mapSize), pa.pointShadowMap[o] = i, pa.pointShadowMatrix[o] = e.shadow.matrix, pa.point[o] = s, o++) : e.isHemisphereLight && (s = Ja.get(e), s.direction.setFromMatrixPosition(e.matrixWorld), s.direction.transformDirection(m), s.direction.normalize(), s.skyColor.copy(e.color).multiplyScalar(g), s.groundColor.copy(e.groundColor).multiplyScalar(g), pa.hemi[r] = s, r++);
							pa.ambient[0] = j, pa.ambient[1] = k, pa.ambient[2] = l, pa.directional.length = n, pa.spot.length = p, pa.rectArea.length = q, pa.point.length = o, pa.hemi.length = r, pa.hash = n + "," + o + "," + p + "," + q + "," + r + "," + pa.shadows.length
						}

						function u(a) {
							var b;
							if (1e3 === a) return sa.REPEAT;
							if (1001 === a) return sa.CLAMP_TO_EDGE;
							if (1002 === a) return sa.MIRRORED_REPEAT;
							if (1003 === a) return sa.NEAREST;
							if (1004 === a) return sa.NEAREST_MIPMAP_NEAREST;
							if (1005 === a) return sa.NEAREST_MIPMAP_LINEAR;
							if (1006 === a) return sa.LINEAR;
							if (1007 === a) return sa.LINEAR_MIPMAP_NEAREST;
							if (1008 === a) return sa.LINEAR_MIPMAP_LINEAR;
							if (1009 === a) return sa.UNSIGNED_BYTE;
							if (1017 === a) return sa.UNSIGNED_SHORT_4_4_4_4;
							if (1018 === a) return sa.UNSIGNED_SHORT_5_5_5_1;
							if (1019 === a) return sa.UNSIGNED_SHORT_5_6_5;
							if (1010 === a) return sa.BYTE;
							if (1011 === a) return sa.SHORT;
							if (1012 === a) return sa.UNSIGNED_SHORT;
							if (1013 === a) return sa.INT;
							if (1014 === a) return sa.UNSIGNED_INT;
							if (1015 === a) return sa.FLOAT;
							if (1016 === a && (b = ta.get("OES_texture_half_float"), null !== b)) return b.HALF_FLOAT_OES;
							if (1021 === a) return sa.ALPHA;
							if (1022 === a) return sa.RGB;
							if (1023 === a) return sa.RGBA;
							if (1024 === a) return sa.LUMINANCE;
							if (1025 === a) return sa.LUMINANCE_ALPHA;
							if (1026 === a) return sa.DEPTH_COMPONENT;
							if (1027 === a) return sa.DEPTH_STENCIL;
							if (100 === a) return sa.FUNC_ADD;
							if (101 === a) return sa.FUNC_SUBTRACT;
							if (102 === a) return sa.FUNC_REVERSE_SUBTRACT;
							if (200 === a) return sa.ZERO;
							if (201 === a) return sa.ONE;
							if (202 === a) return sa.SRC_COLOR;
							if (203 === a) return sa.ONE_MINUS_SRC_COLOR;
							if (204 === a) return sa.SRC_ALPHA;
							if (205 === a) return sa.ONE_MINUS_SRC_ALPHA;
							if (206 === a) return sa.DST_ALPHA;
							if (207 === a) return sa.ONE_MINUS_DST_ALPHA;
							if (208 === a) return sa.DST_COLOR;
							if (209 === a) return sa.ONE_MINUS_DST_COLOR;
							if (210 === a) return sa.SRC_ALPHA_SATURATE;
							if ((2001 === a || 2002 === a || 2003 === a || 2004 === a) && (b = ta.get("WEBGL_compressed_texture_s3tc"), null !== b)) {
								if (2001 === a) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
								if (2002 === a) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
								if (2003 === a) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
								if (2004 === a) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
							}
							if ((2100 === a || 2101 === a || 2102 === a || 2103 === a) && (b = ta.get("WEBGL_compressed_texture_pvrtc"), null !== b)) {
								if (2100 === a) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
								if (2101 === a) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
								if (2102 === a) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
								if (2103 === a) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
							}
							if (2151 === a && (b = ta.get("WEBGL_compressed_texture_etc1"), null !== b)) return b.COMPRESSED_RGB_ETC1_WEBGL;
							if ((103 === a || 104 === a) && (b = ta.get("EXT_blend_minmax"), null !== b)) {
								if (103 === a) return b.MIN_EXT;
								if (104 === a) return b.MAX_EXT
							}
							return 1020 === a && (b = ta.get("WEBGL_depth_texture"), null !== b) ? b.UNSIGNED_INT_24_8_WEBGL : 0
						}
						console.log("THREE.WebGLRenderer", "85"), a = a || {};
						var v = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
							w = void 0 !== a.context ? a.context : null,
							x = void 0 !== a.alpha && a.alpha,
							y = void 0 === a.depth || a.depth,
							z = void 0 === a.stencil || a.stencil,
							A = void 0 !== a.antialias && a.antialias,
							B = void 0 === a.premultipliedAlpha || a.premultipliedAlpha,
							C = void 0 !== a.preserveDrawingBuffer && a.preserveDrawingBuffer,
							D = [],
							E = null,
							F = new Float32Array(8),
							G = [],
							H = [];
						this.domElement = v, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = false, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
						var I = this,
							J = null,
							K = null,
							L = null,
							M = -1,
							N = "",
							O = null,
							P = new e,
							S = null,
							V = new e,
							X = 0,
							Y = new R(0),
							Z = 0,
							$ = v.width,
							_ = v.height,
							ca = 1,
							da = new e(0, 0, $, _),
							ea = false,
							fa = new e(0, 0, $, _),
							ga = new aa,
							ha = new hb,
							ia = false,
							ka = false,
							la = new j,
							ma = new i,
							na = new j,
							oa = new j,
							pa = {
								hash: "",
								ambient: [0, 0, 0],
								directional: [],
								directionalShadowMap: [],
								directionalShadowMatrix: [],
								spot: [],
								spotShadowMap: [],
								spotShadowMatrix: [],
								rectArea: [],
								point: [],
								pointShadowMap: [],
								pointShadowMatrix: [],
								hemi: [],
								shadows: []
							},
							qa = {
								geometries: 0,
								textures: 0
							},
							ra = {
								frame: 0,
								calls: 0,
								vertices: 0,
								faces: 0,
								points: 0
							};
						this.info = {
							render: ra,
							memory: qa,
							programs: null
						};
						var sa;
						try {
							if (x = {
									alpha: x,
									depth: y,
									stencil: z,
									antialias: A,
									premultipliedAlpha: B,
									preserveDrawingBuffer: C
								}, sa = w || v.getContext("webgl", x) || v.getContext("experimental-webgl", x), null === sa) {
								if (null !== v.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
								throw "Error creating WebGL context."
							}
							void 0 === sa.getShaderPrecisionFormat && (sa.getShaderPrecisionFormat = function() {
								return {
									rangeMin: 1,
									rangeMax: 1,
									precision: 1
								}
							}), v.addEventListener("webglcontextlost", d, false)
						} catch (a) {
							console.error("THREE.WebGLRenderer: " + a)
						}
						var ta = new gb(sa);
						ta.get("WEBGL_depth_texture"), ta.get("OES_texture_float"), ta.get("OES_texture_float_linear"), ta.get("OES_texture_half_float"), ta.get("OES_texture_half_float_linear"), ta.get("OES_standard_derivatives"), ta.get("ANGLE_instanced_arrays"), ta.get("OES_element_index_uint") && (xa.MaxIndex = 4294967296);
						var ua = new fb(sa, ta, a),
							va = new eb(sa, ta, u),
							wa = new db,
							za = new cb(sa, ta, va, wa, ua, u, qa),
							Ba = new Ga(sa),
							Da = new Na(sa, Ba, qa),
							Ha = new Pa(sa, Da, ra),
							Ia = new bb(this, ua),
							Ja = new Oa,
							Qa = new Ka;
						this.info.programs = Ia.programs;
						var Ra, Sa, Ta, Ua, Va = new Ma(sa, ta, ra),
							Wa = new La(sa, ta, ra);
						b(), this.context = sa, this.capabilities = ua, this.extensions = ta, this.properties = wa, this.state = va;
						var Xa = new ba(this, pa, Ha, ua);
						this.shadowMap = Xa;
						var Ya = new U(this, G),
							Za = new T(this, H);
						this.getContext = function() {
							return sa
						}, this.getContextAttributes = function() {
							return sa.getContextAttributes()
						}, this.forceContextLoss = function() {
							var a = ta.get("WEBGL_lose_context");
							a && a.loseContext()
						}, this.getMaxAnisotropy = function() {
							return ua.getMaxAnisotropy()
						}, this.getPrecision = function() {
							return ua.precision
						}, this.getPixelRatio = function() {
							return ca
						}, this.setPixelRatio = function(a) {
							void 0 !== a && (ca = a, this.setSize(fa.z, fa.w, false))
						}, this.getSize = function() {
							return {
								width: $,
								height: _
							}
						}, this.setSize = function(a, b, c) {
							$ = a, _ = b, v.width = a * ca, v.height = b * ca, false !== c && (v.style.width = a + "px", v.style.height = b + "px"), this.setViewport(0, 0, a, b)
						}, this.setViewport = function(a, b, c, d) {
							va.viewport(fa.set(a, b, c, d))
						}, this.setScissor = function(a, b, c, d) {
							va.scissor(da.set(a, b, c, d))
						}, this.setScissorTest = function(a) {
							va.setScissorTest(ea = a)
						}, this.getClearColor = function() {
							return Y
						}, this.setClearColor = function(a, b) {
							Y.set(a), Z = void 0 !== b ? b : 1, va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B)
						}, this.getClearAlpha = function() {
							return Z
						}, this.setClearAlpha = function(a) {
							Z = a, va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B)
						}, this.clear = function(a, b, c) {
							var d = 0;
							(void 0 === a || a) && (d |= sa.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= sa.DEPTH_BUFFER_BIT), (void 0 === c || c) && (d |= sa.STENCIL_BUFFER_BIT), sa.clear(d)
						}, this.clearColor = function() {
							this.clear(true, false, false)
						}, this.clearDepth = function() {
							this.clear(false, true, false)
						}, this.clearStencil = function() {
							this.clear(false, false, true)
						}, this.clearTarget = function(a, b, c, d) {
							this.setRenderTarget(a), this.clear(b, c, d)
						}, this.resetGLState = c, this.dispose = function() {
							v.removeEventListener("webglcontextlost", d, false), Qa.dispose()
						}, this.renderBufferImmediate = function(a, b, c) {
							va.initAttributes();
							var d = wa.get(a);
							if (a.hasPositions && !d.position && (d.position = sa.createBuffer()), a.hasNormals && !d.normal && (d.normal = sa.createBuffer()), a.hasUvs && !d.uv && (d.uv = sa.createBuffer()), a.hasColors && !d.color && (d.color = sa.createBuffer()), b = b.getAttributes(), a.hasPositions && (sa.bindBuffer(sa.ARRAY_BUFFER, d.position), sa.bufferData(sa.ARRAY_BUFFER, a.positionArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.position), sa.vertexAttribPointer(b.position, 3, sa.FLOAT, false, 0, 0)), a.hasNormals) {
								if (sa.bindBuffer(sa.ARRAY_BUFFER, d.normal), !c.isMeshPhongMaterial && !c.isMeshStandardMaterial && !c.isMeshNormalMaterial && 1 === c.shading)
									for (var e = 0, f = 3 * a.count; e < f; e += 9) {
										var g = a.normalArray,
											h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3,
											i = (g[e + 1] + g[e + 4] + g[e + 7]) / 3,
											j = (g[e + 2] + g[e + 5] + g[e + 8]) / 3;
										g[e + 0] = h, g[e + 1] = i, g[e + 2] = j, g[e + 3] = h, g[e + 4] = i, g[e + 5] = j, g[e + 6] = h, g[e + 7] = i, g[e + 8] = j
									}
								sa.bufferData(sa.ARRAY_BUFFER, a.normalArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.normal), sa.vertexAttribPointer(b.normal, 3, sa.FLOAT, false, 0, 0)
							}
							a.hasUvs && c.map && (sa.bindBuffer(sa.ARRAY_BUFFER, d.uv), sa.bufferData(sa.ARRAY_BUFFER, a.uvArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.uv), sa.vertexAttribPointer(Ba.uv, 2, sa.FLOAT, false, 0, 0)), a.hasColors && 0 !== c.vertexColors && (sa.bindBuffer(sa.ARRAY_BUFFER, d.color), sa.bufferData(sa.ARRAY_BUFFER, a.colorArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.color), sa.vertexAttribPointer(b.color, 3, sa.FLOAT, false, 0, 0)), va.disableUnusedAttributes(), sa.drawArrays(sa.TRIANGLES, 0, a.count), a.count = 0
						}, this.renderBufferDirect = function(a, b, c, d, e, f) {
							va.setMaterial(d);
							var g = q(a, b, d, e);
							a = c.id + "_" + g.id + "_" + (true === d.wireframe);
							var h = false;
							if (a !== N && (N = a, h = true), b = e.morphTargetInfluences, void 0 !== b) {
								var i = [];
								a = 0;
								for (var j = b.length; a < j; a++) h = b[a], i.push([h, a]);
								i.sort(l), 8 < i.length && (i.length = 8);
								var k = c.morphAttributes;
								for (a = 0, j = i.length; a < j; a++) h = i[a], F[a] = h[0], 0 !== h[0] ? (b = h[1], true === d.morphTargets && k.position && c.addAttribute("morphTarget" + a, k.position[b]), true === d.morphNormals && k.normal && c.addAttribute("morphNormal" + a, k.normal[b])) : (true === d.morphTargets && c.removeAttribute("morphTarget" + a), true === d.morphNormals && c.removeAttribute("morphNormal" + a));
								for (a = i.length, b = F.length; a < b; a++) F[a] = 0;
								g.getUniforms().setValue(sa, "morphTargetInfluences", F), h = true
							}
							if (b = c.index, j = c.attributes.position, i = 1, true === d.wireframe && (b = Da.getWireframeAttribute(c), i = 2), a = Va, null !== b && (a = Wa, a.setIndex(b)), h) {
								if (h = void 0, c && c.isInstancedBufferGeometry && null === ta.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
								else {
									void 0 === h && (h = 0), va.initAttributes();
									var m, k = c.attributes,
										g = g.getAttributes(),
										n = d.defaultAttributeValues;
									for (m in g) {
										var o = g[m];
										if (0 <= o) {
											var p = k[m];
											if (void 0 !== p) {
												var r = p.normalized,
													s = p.itemSize,
													t = Ba.get(p),
													u = t.buffer,
													v = t.type,
													t = t.bytesPerElement;
												if (p.isInterleavedBufferAttribute) {
													var w = p.data,
														x = w.stride,
														p = p.offset;
													w && w.isInstancedInterleavedBuffer ? (va.enableAttributeAndDivisor(o, w.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = w.meshPerAttribute * w.count)) : va.enableAttribute(o), sa.bindBuffer(sa.ARRAY_BUFFER, u), sa.vertexAttribPointer(o, s, v, r, x * t, (h * x + p) * t)
												} else p.isInstancedBufferAttribute ? (va.enableAttributeAndDivisor(o, p.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = p.meshPerAttribute * p.count)) : va.enableAttribute(o), sa.bindBuffer(sa.ARRAY_BUFFER, u), sa.vertexAttribPointer(o, s, v, r, 0, h * s * t)
											} else if (void 0 !== n && (r = n[m], void 0 !== r)) switch (r.length) {
												case 2:
													sa.vertexAttrib2fv(o, r);
													break;
												case 3:
													sa.vertexAttrib3fv(o, r);
													break;
												case 4:
													sa.vertexAttrib4fv(o, r);
													break;
												default:
													sa.vertexAttrib1fv(o, r)
											}
										}
									}
									va.disableUnusedAttributes()
								}
								null !== b && sa.bindBuffer(sa.ELEMENT_ARRAY_BUFFER, Ba.get(b).buffer)
							}
							if (m = 0, null !== b ? m = b.count : void 0 !== j && (m = j.count), j = c.drawRange.start * i, h = null !== f ? f.start * i : 0, b = Math.max(j, h), f = Math.max(0, Math.min(m, j + c.drawRange.count * i, h + (null !== f ? f.count * i : 1 / 0)) - 1 - b + 1), 0 !== f) {
								if (e.isMesh)
									if (true === d.wireframe) va.setLineWidth(d.wireframeLinewidth * (null === K ? ca : 1)), a.setMode(sa.LINES);
									else switch (e.drawMode) {
										case 0:
											a.setMode(sa.TRIANGLES);
											break;
										case 1:
											a.setMode(sa.TRIANGLE_STRIP);
											break;
										case 2:
											a.setMode(sa.TRIANGLE_FAN)
									} else e.isLine ? (d = d.linewidth, void 0 === d && (d = 1), va.setLineWidth(d * (null === K ? ca : 1)), e.isLineSegments ? a.setMode(sa.LINES) : e.isLineLoop ? a.setMode(sa.LINE_LOOP) : a.setMode(sa.LINE_STRIP)) : e.isPoints && a.setMode(sa.POINTS);
								c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, b, f) : a.render(b, f)
							}
						}, this.compile = function(a, b) {
							D = [], a.traverse(function(a) {
								a.isLight && D.push(a)
							}), t(D, b), a.traverse(function(b) {
								if (b.material)
									if (Array.isArray(b.material))
										for (var c = 0; c < b.material.length; c++) p(b.material[c], a.fog, b);
									else p(b.material, a.fog, b)
							})
						}, this.render = function(a, b, c, d) {
							if (void 0 !== b && true !== b.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
							else {
								N = "", M = -1, O = null, true === a.autoUpdate && a.updateMatrixWorld(), b.onBeforeRender(I), null === b.parent && b.updateMatrixWorld(), b.matrixWorldInverse.getInverse(b.matrixWorld), la.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), ga.setFromMatrix(la), D.length = 0, G.length = 0, H.length = 0, ka = this.localClippingEnabled, ia = ha.init(this.clippingPlanes, ka, b), E = Qa.get(a, b), E.init(), m(a, b, I.sortObjects), E.finish(), true === I.sortObjects && E.sort(), ia && ha.beginShadows();
								for (var e = D, f = 0, g = 0, h = e.length; g < h; g++) {
									var i = e[g];
									i.castShadow && (pa.shadows[f] = i, f++)
								}
								pa.shadows.length = f, Xa.render(a, b), t(D, b), ia && ha.endShadows(), ra.frame++, ra.calls = 0, ra.vertices = 0, ra.faces = 0, ra.points = 0, void 0 === c && (c = null), this.setRenderTarget(c), e = a.background, null === e ? va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B) : e && e.isColor && (va.buffers.color.setClear(e.r, e.g, e.b, 1, B), d = true), (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), e && e.isCubeTexture ? (void 0 === Ta && (Ta = new Ea, Ua = new ya(new Aa(5, 5, 5), new W({
									uniforms: Ee.cube.uniforms,
									vertexShader: Ee.cube.vertexShader,
									fragmentShader: Ee.cube.fragmentShader,
									side: 1,
									depthTest: false,
									depthWrite: false,
									fog: false
								}))), Ta.projectionMatrix.copy(b.projectionMatrix), Ta.matrixWorld.extractRotation(b.matrixWorld), Ta.matrixWorldInverse.getInverse(Ta.matrixWorld), Ua.material.uniforms.tCube.value = e, Ua.modelViewMatrix.multiplyMatrices(Ta.matrixWorldInverse, Ua.matrixWorld), Ha.update(Ua), I.renderBufferDirect(Ta, null, Ua.geometry, Ua.material, Ua, null)) : e && e.isTexture && (void 0 === Ra && (Ra = new Fa(-1, 1, 1, -1, 0, 1), Sa = new ya(new Ca(2, 2), new ja({
									depthTest: false,
									depthWrite: false,
									fog: false
								}))), Sa.material.map = e, Ha.update(Sa), I.renderBufferDirect(Ra, null, Sa.geometry, Sa.material, Sa, null)), d = E.opaque, e = E.transparent, a.overrideMaterial ? (f = a.overrideMaterial, d.length && n(d, a, b, f), e.length && n(e, a, b, f)) : (d.length && n(d, a, b), e.length && n(e, a, b)), Ya.render(a, b), Za.render(a, b, V), c && za.updateRenderTargetMipmap(c), va.buffers.depth.setTest(true), va.buffers.depth.setMask(true), va.buffers.color.setMask(true), b.isArrayCamera && b.enabled && I.setScissorTest(false), b.onAfterRender(I)
							}
						}, this.setFaceCulling = function(a, b) {
							va.setCullFace(a), va.setFlipSided(0 === b)
						}, this.allocTextureUnit = function() {
							var a = X;
							return a >= ua.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + ua.maxTextures), X += 1, a
						}, this.setTexture2D = function() {
							var a = false;
							return function(b, c) {
								b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = true), b = b.texture), za.setTexture2D(b, c)
							}
						}(), this.setTexture = function() {
							var a = false;
							return function(b, c) {
								a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = true), za.setTexture2D(b, c)
							}
						}(), this.setTextureCube = function() {
							var a = false;
							return function(b, c) {
								b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = true), b = b.texture), b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? za.setTextureCube(b, c) : za.setTextureCubeDynamic(b, c)
							}
						}(), this.getRenderTarget = function() {
							return K
						}, this.setRenderTarget = function(a) {
							(K = a) && void 0 === wa.get(a).__webglFramebuffer && za.setupRenderTarget(a);
							var b, c = a && a.isWebGLRenderTargetCube;
							a ? (b = wa.get(a), b = c ? b.__webglFramebuffer[a.activeCubeFace] : b.__webglFramebuffer, P.copy(a.scissor), S = a.scissorTest, V.copy(a.viewport)) : (b = null, P.copy(da).multiplyScalar(ca), S = ea, V.copy(fa).multiplyScalar(ca)), L !== b && (sa.bindFramebuffer(sa.FRAMEBUFFER, b), L = b), va.scissor(P), va.setScissorTest(S), va.viewport(V), c && (c = wa.get(a.texture), sa.framebufferTexture2D(sa.FRAMEBUFFER, sa.COLOR_ATTACHMENT0, sa.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel))
						}, this.readRenderTargetPixels = function(a, b, c, d, e, f) {
							if (false === (a && a.isWebGLRenderTarget)) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
							else {
								var g = wa.get(a).__webglFramebuffer;
								if (g) {
									var h = false;
									g !== L && (sa.bindFramebuffer(sa.FRAMEBUFFER, g), h = true);
									try {
										var i = a.texture,
											j = i.format,
											k = i.type;
										1023 !== j && u(j) !== sa.getParameter(sa.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === k || u(k) === sa.getParameter(sa.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === k && (ta.get("OES_texture_float") || ta.get("WEBGL_color_buffer_float")) || 1016 === k && ta.get("EXT_color_buffer_half_float") ? sa.checkFramebufferStatus(sa.FRAMEBUFFER) === sa.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && sa.readPixels(b, c, d, e, u(j), u(k), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
									} finally {
										h && sa.bindFramebuffer(sa.FRAMEBUFFER, L)
									}
								}
							}
						}
					}

					function jb(a, b) {
						this.name = "", this.color = new R(a), this.density = void 0 !== b ? b : 25e-5
					}

					function kb(a, b, c) {
						this.name = "", this.color = new R(a), this.near = void 0 !== b ? b : 1, this.far = void 0 !== c ? c : 1e3
					}

					function lb() {
						fa.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = true
					}

					function mb(a, b, c, d, e) {
						fa.call(this), this.lensFlares = [], this.positionScreen = new i, this.customUpdateCallback = void 0, void 0 !== a && this.add(a, b, c, d, e)
					}

					function nb(a) {
						V.call(this), this.type = "SpriteMaterial", this.color = new R(16777215), this.map = null, this.rotation = 0, this.lights = this.fog = false, this.setValues(a)
					}

					function ob(a) {
						fa.call(this), this.type = "Sprite", this.material = void 0 !== a ? a : new nb
					}

					function pb() {
						fa.call(this), this.type = "LOD", Object.defineProperties(this, {
							levels: {
								enumerable: true,
								value: []
							}
						})
					}

					function qb(a, b) {
						if (a = a || [], this.bones = a.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === b) this.calculateInverses();
						else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
						else {
							console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
							for (var c = 0, d = this.bones.length; c < d; c++) this.boneInverses.push(new j)
						}
					}

					function rb() {
						fa.call(this), this.type = "Bone"
					}

					function sb(a, b) {
						ya.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new j, this.bindMatrixInverse = new j;
						var c = this.initBones(),
							c = new qb(c);
						this.bind(c, this.matrixWorld), this.normalizeSkinWeights()
					}

					function tb(a) {
						V.call(this), this.type = "LineBasicMaterial", this.color = new R(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = false, this.setValues(a)
					}

					function ub(a, b, c) {
						return 1 === c ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new vb(a, b)) : (fa.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new xa, void(this.material = void 0 !== b ? b : new tb({
							color: 16777215 * Math.random()
						})))
					}

					function vb(a, b) {
						ub.call(this, a, b), this.type = "LineSegments"
					}

					function wb(a, b) {
						ub.call(this, a, b), this.type = "LineLoop"
					}

					function xb(a) {
						V.call(this), this.type = "PointsMaterial", this.color = new R(16777215), this.map = null, this.size = 1, this.sizeAttenuation = true, this.lights = false, this.setValues(a)
					}

					function yb(a, b) {
						fa.call(this), this.type = "Points", this.geometry = void 0 !== a ? a : new xa, this.material = void 0 !== b ? b : new xb({
							color: 16777215 * Math.random()
						})
					}

					function zb() {
						fa.call(this), this.type = "Group"
					}

					function Ab(a, b, c, e, f, g, h, i, j) {
						function k() {
							requestAnimationFrame(k), a.readyState >= a.HAVE_CURRENT_DATA && (l.needsUpdate = true)
						}
						d.call(this, a, b, c, e, f, g, h, i, j), this.generateMipmaps = false;
						var l = this;
						k()
					}

					function Bb(a, b, c, e, f, g, h, i, j, k, l, m) {
						d.call(this, null, g, h, i, j, k, e, f, l, m), this.image = {
							width: b,
							height: c
						}, this.mipmaps = a, this.generateMipmaps = this.flipY = false
					}

					function Cb(a, b, c, e, f, g, h, i, j) {
						d.call(this, a, b, c, e, f, g, h, i, j), this.needsUpdate = true
					}

					function Db(a, b, c, e, f, g, h, i, j, k) {
						if (k = void 0 !== k ? k : 1026, 1026 !== k && 1027 !== k) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
						void 0 === c && 1026 === k && (c = 1012), void 0 === c && 1027 === k && (c = 1020), d.call(this, null, e, f, g, h, i, k, c, j), this.image = {
							width: a,
							height: b
						}, this.magFilter = void 0 !== h ? h : 1003, this.minFilter = void 0 !== i ? i : 1003, this.generateMipmaps = this.flipY = false
					}

					function Eb(a) {
						xa.call(this), this.type = "WireframeGeometry";
						var b, c, d, e, f, g, h = [],
							j = [0, 0],
							k = {},
							l = ["a", "b", "c"];
						if (a && a.isGeometry) {
							var m = a.faces;
							for (b = 0, d = m.length; b < d; b++) {
								var n = m[b];
								for (c = 0; 3 > c; c++) f = n[l[c]], g = n[l[(c + 1) % 3]], j[0] = Math.min(f, g), j[1] = Math.max(f, g), f = j[0] + "," + j[1], void 0 === k[f] && (k[f] = {
									index1: j[0],
									index2: j[1]
								})
							}
							for (f in k) b = k[f], l = a.vertices[b.index1], h.push(l.x, l.y, l.z), l = a.vertices[b.index2], h.push(l.x, l.y, l.z)
						} else if (a && a.isBufferGeometry) {
							var o, l = new i;
							if (null !== a.index) {
								for (m = a.attributes.position, n = a.index, o = a.groups, 0 === o.length && (o = [{
										start: 0,
										count: n.count,
										materialIndex: 0
									}]), a = 0, e = o.length; a < e; ++a)
									for (b = o[a], c = b.start, d = b.count, b = c, d = c + d; b < d; b += 3)
										for (c = 0; 3 > c; c++) f = n.getX(b + c), g = n.getX(b + (c + 1) % 3), j[0] = Math.min(f, g), j[1] = Math.max(f, g), f = j[0] + "," + j[1], void 0 === k[f] && (k[f] = {
											index1: j[0],
											index2: j[1]
										});
								for (f in k) b = k[f], l.fromBufferAttribute(m, b.index1), h.push(l.x, l.y, l.z), l.fromBufferAttribute(m, b.index2), h.push(l.x, l.y, l.z)
							} else
								for (m = a.attributes.position, b = 0, d = m.count / 3; b < d; b++)
									for (c = 0; 3 > c; c++) k = 3 * b + c, l.fromBufferAttribute(m, k), h.push(l.x, l.y, l.z), k = 3 * b + (c + 1) % 3, l.fromBufferAttribute(m, k), h.push(l.x, l.y, l.z)
						}
						this.addAttribute("position", new sa(h, 3))
					}

					function Fb(a, b, c) {
						wa.call(this), this.type = "ParametricGeometry", this.parameters = {
							func: a,
							slices: b,
							stacks: c
						}, this.fromBufferGeometry(new Gb(a, b, c)), this.mergeVertices()
					}

					function Gb(a, b, c) {
						xa.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
							func: a,
							slices: b,
							stacks: c
						};
						var d, e, f = [],
							g = [],
							h = [],
							j = [],
							k = new i,
							l = new i,
							m = new i,
							n = new i,
							o = new i,
							p = b + 1;
						for (d = 0; d <= c; d++) {
							var q = d / c;
							for (e = 0; e <= b; e++) {
								var r = e / b,
									l = a(r, q, l);
								g.push(l.x, l.y, l.z), 0 <= r - 1e-5 ? (m = a(r - 1e-5, q, m), n.subVectors(l, m)) : (m = a(r + 1e-5, q, m), n.subVectors(m, l)), 0 <= q - 1e-5 ? (m = a(r, q - 1e-5, m), o.subVectors(l, m)) : (m = a(r, q + 1e-5, m), o.subVectors(m, l)), k.crossVectors(n, o).normalize(), h.push(k.x, k.y, k.z), j.push(r, q)
							}
						}
						for (d = 0; d < c; d++)
							for (e = 0; e < b; e++) a = d * p + e + 1, k = (d + 1) * p + e + 1, l = (d + 1) * p + e, f.push(d * p + e, a, l), f.push(a, k, l);
						this.setIndex(f), this.addAttribute("position", new sa(g, 3)), this.addAttribute("normal", new sa(h, 3)), this.addAttribute("uv", new sa(j, 2))
					}

					function Hb(a, b, c, d) {
						wa.call(this), this.type = "PolyhedronGeometry", this.parameters = {
							vertices: a,
							indices: b,
							radius: c,
							detail: d
						}, this.fromBufferGeometry(new Ib(a, b, c, d)), this.mergeVertices()
					}

					function Ib(a, b, d, e) {
						function f(a) {
							j.push(a.x, a.y, a.z)
						}

						function g(b, c) {
							var d = 3 * b;
							c.x = a[d + 0], c.y = a[d + 1], c.z = a[d + 2]
						}

						function h(a, b, c, d) {
							0 > d && 1 === a.x && (k[b] = a.x - 1), 0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5)
						}
						xa.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
							vertices: a,
							indices: b,
							radius: d,
							detail: e
						}, d = d || 1;
						var j = [],
							k = [];
						! function(a) {
							for (var c = new i, d = new i, e = new i, h = 0; h < b.length; h += 3) {
								g(b[h + 0], c), g(b[h + 1], d), g(b[h + 2], e);
								var j, k, l = c,
									m = d,
									n = e,
									o = Math.pow(2, a),
									p = [];
								for (j = 0; j <= o; j++) {
									p[j] = [];
									var q = l.clone().lerp(n, j / o),
										r = m.clone().lerp(n, j / o),
										s = o - j;
									for (k = 0; k <= s; k++) p[j][k] = 0 === k && j === o ? q : q.clone().lerp(r, k / s)
								}
								for (j = 0; j < o; j++)
									for (k = 0; k < 2 * (o - j) - 1; k++) l = Math.floor(k / 2), 0 === k % 2 ? (f(p[j][l + 1]), f(p[j + 1][l]), f(p[j][l])) : (f(p[j][l + 1]), f(p[j + 1][l + 1]), f(p[j + 1][l]))
							}
						}(e || 0),
						function(a) {
							for (var b = new i, c = 0; c < j.length; c += 3) b.x = j[c + 0], b.y = j[c + 1], b.z = j[c + 2], b.normalize().multiplyScalar(a), j[c + 0] = b.x, j[c + 1] = b.y, j[c + 2] = b.z
						}(d),
						function() {
							for (var a = new i, b = 0; b < j.length; b += 3) a.x = j[b + 0], a.y = j[b + 1], a.z = j[b + 2], k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
							for (var a = new i, b = new i, d = new i, e = new i, f = new c, g = new c, l = new c, m = 0, n = 0; m < j.length; m += 9, n += 6) {
								a.set(j[m + 0], j[m + 1], j[m + 2]), b.set(j[m + 3], j[m + 4], j[m + 5]), d.set(j[m + 6], j[m + 7], j[m + 8]), f.set(k[n + 0], k[n + 1]), g.set(k[n + 2], k[n + 3]), l.set(k[n + 4], k[n + 5]), e.copy(a).add(b).add(d).divideScalar(3);
								var o = Math.atan2(e.z, -e.x);
								h(f, n + 0, a, o), h(g, n + 2, b, o), h(l, n + 4, d, o)
							}
							for (a = 0; a < k.length; a += 6) b = k[a + 0], d = k[a + 2], e = k[a + 4], f = Math.min(b, d, e), .9 < Math.max(b, d, e) && .1 > f && (.2 > b && (k[a + 0] += 1), .2 > d && (k[a + 2] += 1), .2 > e && (k[a + 4] += 1))
						}(), this.addAttribute("position", new sa(j, 3)), this.addAttribute("normal", new sa(j.slice(), 3)), this.addAttribute("uv", new sa(k, 2)), this.normalizeNormals()
					}

					function Jb(a, b) {
						wa.call(this), this.type = "TetrahedronGeometry", this.parameters = {
							radius: a,
							detail: b
						}, this.fromBufferGeometry(new Kb(a, b)), this.mergeVertices()
					}

					function Kb(a, b) {
						Ib.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b), this.type = "TetrahedronBufferGeometry", this.parameters = {
							radius: a,
							detail: b
						}
					}

					function Lb(a, b) {
						wa.call(this), this.type = "OctahedronGeometry", this.parameters = {
							radius: a,
							detail: b
						}, this.fromBufferGeometry(new Mb(a, b)), this.mergeVertices()
					}

					function Mb(a, b) {
						Ib.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b), this.type = "OctahedronBufferGeometry", this.parameters = {
							radius: a,
							detail: b
						}
					}

					function Nb(a, b) {
						wa.call(this), this.type = "IcosahedronGeometry", this.parameters = {
							radius: a,
							detail: b
						}, this.fromBufferGeometry(new Ob(a, b)), this.mergeVertices()
					}

					function Ob(a, b) {
						var c = (1 + Math.sqrt(5)) / 2;
						Ib.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b), this.type = "IcosahedronBufferGeometry", this.parameters = {
							radius: a,
							detail: b
						}
					}

					function Pb(a, b) {
						wa.call(this), this.type = "DodecahedronGeometry", this.parameters = {
							radius: a,
							detail: b
						}, this.fromBufferGeometry(new Qb(a, b)), this.mergeVertices()
					}

					function Qb(a, b) {
						var c = (1 + Math.sqrt(5)) / 2,
							d = 1 / c;
						Ib.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b), this.type = "DodecahedronBufferGeometry", this.parameters = {
							radius: a,
							detail: b
						}
					}

					function Rb(a, b, c, d, e, f) {
						wa.call(this), this.type = "TubeGeometry", this.parameters = {
							path: a,
							tubularSegments: b,
							radius: c,
							radialSegments: d,
							closed: e
						}, void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."), a = new Sb(a, b, c, d, e), this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
					}

					function Sb(a, b, d, e, f) {
						function g(c) {
							var f = a.getPointAt(c / b),
								g = h.normals[c];
							for (c = h.binormals[c], k = 0; k <= e; k++) {
								var i = k / e * Math.PI * 2,
									j = Math.sin(i),
									i = -Math.cos(i);
								m.x = i * g.x + j * c.x, m.y = i * g.y + j * c.y, m.z = i * g.z + j * c.z, m.normalize(), p.push(m.x, m.y, m.z), l.x = f.x + d * m.x, l.y = f.y + d * m.y, l.z = f.z + d * m.z, o.push(l.x, l.y, l.z)
							}
						}
						xa.call(this), this.type = "TubeBufferGeometry", this.parameters = {
							path: a,
							tubularSegments: b,
							radius: d,
							radialSegments: e,
							closed: f
						}, b = b || 64, d = d || 1, e = e || 8, f = f || false;
						var h = a.computeFrenetFrames(b, f);
						this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals;
						var j, k, l = new i,
							m = new i,
							n = new c,
							o = [],
							p = [],
							q = [],
							r = [];
						for (j = 0; j < b; j++) g(j);
						for (g(false === f ? b : 0), j = 0; j <= b; j++)
							for (k = 0; k <= e; k++) n.x = j / b, n.y = k / e, q.push(n.x, n.y);
						! function() {
							for (k = 1; k <= b; k++)
								for (j = 1; j <= e; j++) {
									var a = (e + 1) * k + (j - 1),
										c = (e + 1) * k + j,
										d = (e + 1) * (k - 1) + j;
									r.push((e + 1) * (k - 1) + (j - 1), a, d), r.push(a, c, d)
								}
						}(), this.setIndex(r), this.addAttribute("position", new sa(o, 3)), this.addAttribute("normal", new sa(p, 3)), this.addAttribute("uv", new sa(q, 2))
					}

					function Tb(a, b, c, d, e, f, g) {
						wa.call(this), this.type = "TorusKnotGeometry", this.parameters = {
							radius: a,
							tube: b,
							tubularSegments: c,
							radialSegments: d,
							p: e,
							q: f
						}, void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Ub(a, b, c, d, e, f)), this.mergeVertices()
					}

					function Ub(a, b, c, d, e, f) {
						function g(a, b, c, d, e) {
							var f = Math.sin(a);
							b = c / b * a, c = Math.cos(b), e.x = d * (2 + c) * .5 * Math.cos(a), e.y = d * (2 + c) * f * .5, e.z = d * Math.sin(b) * .5
						}
						xa.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
							radius: a,
							tube: b,
							tubularSegments: c,
							radialSegments: d,
							p: e,
							q: f
						}, a = a || 100, b = b || 40, c = Math.floor(c) || 64, d = Math.floor(d) || 8, e = e || 2, f = f || 3;
						var h, j, k = [],
							l = [],
							m = [],
							n = [],
							o = new i,
							p = new i,
							q = new i,
							r = new i,
							s = new i,
							t = new i,
							u = new i;
						for (h = 0; h <= c; ++h)
							for (j = h / c * e * Math.PI * 2, g(j, e, f, a, q), g(j + .01, e, f, a, r), t.subVectors(r, q), u.addVectors(r, q), s.crossVectors(t, u), u.crossVectors(s, t), s.normalize(), u.normalize(), j = 0; j <= d; ++j) {
								var v = j / d * Math.PI * 2,
									w = -b * Math.cos(v),
									v = b * Math.sin(v);
								o.x = q.x + (w * u.x + v * s.x), o.y = q.y + (w * u.y + v * s.y), o.z = q.z + (w * u.z + v * s.z), l.push(o.x, o.y, o.z), p.subVectors(o, q).normalize(), m.push(p.x, p.y, p.z), n.push(h / c), n.push(j / d)
							}
						for (j = 1; j <= c; j++)
							for (h = 1; h <= d; h++) a = (d + 1) * j + (h - 1), b = (d + 1) * j + h, e = (d + 1) * (j - 1) + h, k.push((d + 1) * (j - 1) + (h - 1), a, e), k.push(a, b, e);
						this.setIndex(k), this.addAttribute("position", new sa(l, 3)), this.addAttribute("normal", new sa(m, 3)), this.addAttribute("uv", new sa(n, 2))
					}

					function Vb(a, b, c, d, e) {
						wa.call(this), this.type = "TorusGeometry", this.parameters = {
							radius: a,
							tube: b,
							radialSegments: c,
							tubularSegments: d,
							arc: e
						}, this.fromBufferGeometry(new Wb(a, b, c, d, e)), this.mergeVertices()
					}

					function Wb(a, b, c, d, e) {
						xa.call(this), this.type = "TorusBufferGeometry", this.parameters = {
							radius: a,
							tube: b,
							radialSegments: c,
							tubularSegments: d,
							arc: e
						}, a = a || 100, b = b || 40, c = Math.floor(c) || 8, d = Math.floor(d) || 6, e = e || 2 * Math.PI;
						var f, g, h = [],
							j = [],
							k = [],
							l = [],
							m = new i,
							n = new i,
							o = new i;
						for (f = 0; f <= c; f++)
							for (g = 0; g <= d; g++) {
								var p = g / d * e,
									q = f / c * Math.PI * 2;
								n.x = (a + b * Math.cos(q)) * Math.cos(p), n.y = (a + b * Math.cos(q)) * Math.sin(p), n.z = b * Math.sin(q), j.push(n.x, n.y, n.z), m.x = a * Math.cos(p), m.y = a * Math.sin(p), o.subVectors(n, m).normalize(), k.push(o.x, o.y, o.z), l.push(g / d), l.push(f / c)
							}
						for (f = 1; f <= c; f++)
							for (g = 1; g <= d; g++) a = (d + 1) * (f - 1) + g - 1, b = (d + 1) * (f - 1) + g, e = (d + 1) * f + g, h.push((d + 1) * f + g - 1, a, e), h.push(a, b, e);
						this.setIndex(h), this.addAttribute("position", new sa(j, 3)), this.addAttribute("normal", new sa(k, 3)), this.addAttribute("uv", new sa(l, 2))
					}

					function Xb(a, b) {
						wa.call(this), this.type = "ExtrudeGeometry", this.parameters = {
							shapes: a,
							options: b
						}, this.fromBufferGeometry(new Yb(a, b)), this.mergeVertices()
					}

					function Yb(a, b) {
						"undefined" != typeof a && (xa.call(this), this.type = "ExtrudeBufferGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeVertexNormals())
					}

					function Zb(a, b) {
						wa.call(this), this.type = "TextGeometry", this.parameters = {
							text: a,
							parameters: b
						}, this.fromBufferGeometry(new $b(a, b)), this.mergeVertices()
					}

					function $b(a, b) {
						b = b || {};
						var c = b.font;
						return false === (c && c.isFont) ? (console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new wa) : (c = c.generateShapes(a, b.size, b.curveSegments), b.amount = void 0 !== b.height ? b.height : 50, void 0 === b.bevelThickness && (b.bevelThickness = 10), void 0 === b.bevelSize && (b.bevelSize = 8), void 0 === b.bevelEnabled && (b.bevelEnabled = false), Yb.call(this, c, b), void(this.type = "TextBufferGeometry"))
					}

					function _b(a, b, c, d, e, f, g) {
						wa.call(this), this.type = "SphereGeometry", this.parameters = {
							radius: a,
							widthSegments: b,
							heightSegments: c,
							phiStart: d,
							phiLength: e,
							thetaStart: f,
							thetaLength: g
						}, this.fromBufferGeometry(new ac(a, b, c, d, e, f, g)), this.mergeVertices()
					}

					function ac(a, b, c, d, e, f, g) {
						xa.call(this), this.type = "SphereBufferGeometry", this.parameters = {
							radius: a,
							widthSegments: b,
							heightSegments: c,
							phiStart: d,
							phiLength: e,
							thetaStart: f,
							thetaLength: g
						}, a = a || 50, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : Math.PI;
						var h, j, k = f + g,
							l = 0,
							m = [],
							n = new i,
							o = new i,
							p = [],
							q = [],
							r = [],
							s = [];
						for (j = 0; j <= c; j++) {
							var t = [],
								u = j / c;
							for (h = 0; h <= b; h++) {
								var v = h / b;
								n.x = -a * Math.cos(d + v * e) * Math.sin(f + u * g), n.y = a * Math.cos(f + u * g), n.z = a * Math.sin(d + v * e) * Math.sin(f + u * g), q.push(n.x, n.y, n.z), o.set(n.x, n.y, n.z).normalize(), r.push(o.x, o.y, o.z), s.push(v, 1 - u), t.push(l++)
							}
							m.push(t)
						}
						for (j = 0; j < c; j++)
							for (h = 0; h < b; h++) a = m[j][h + 1], d = m[j][h], e = m[j + 1][h], g = m[j + 1][h + 1], (0 !== j || 0 < f) && p.push(a, d, g), (j !== c - 1 || k < Math.PI) && p.push(d, e, g);
						this.setIndex(p), this.addAttribute("position", new sa(q, 3)), this.addAttribute("normal", new sa(r, 3)), this.addAttribute("uv", new sa(s, 2))
					}

					function bc(a, b, c, d, e, f) {
						wa.call(this), this.type = "RingGeometry", this.parameters = {
							innerRadius: a,
							outerRadius: b,
							thetaSegments: c,
							phiSegments: d,
							thetaStart: e,
							thetaLength: f
						}, this.fromBufferGeometry(new cc(a, b, c, d, e, f)), this.mergeVertices()
					}

					function cc(a, b, d, e, f, g) {
						xa.call(this), this.type = "RingBufferGeometry", this.parameters = {
							innerRadius: a,
							outerRadius: b,
							thetaSegments: d,
							phiSegments: e,
							thetaStart: f,
							thetaLength: g
						}, a = a || 20, b = b || 50, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : 2 * Math.PI, d = void 0 !== d ? Math.max(3, d) : 8, e = void 0 !== e ? Math.max(1, e) : 1;
						var h, j, k = [],
							l = [],
							m = [],
							n = [],
							o = a,
							p = (b - a) / e,
							q = new i,
							r = new c;
						for (h = 0; h <= e; h++) {
							for (j = 0; j <= d; j++) a = f + j / d * g, q.x = o * Math.cos(a), q.y = o * Math.sin(a), l.push(q.x, q.y, q.z), m.push(0, 0, 1), r.x = (q.x / b + 1) / 2, r.y = (q.y / b + 1) / 2, n.push(r.x, r.y);
							o += p
						}
						for (h = 0; h < e; h++)
							for (b = h * (d + 1), j = 0; j < d; j++) a = j + b, f = a + d + 1, g = a + d + 2, o = a + 1, k.push(a, f, o), k.push(f, g, o);
						this.setIndex(k), this.addAttribute("position", new sa(l, 3)), this.addAttribute("normal", new sa(m, 3)), this.addAttribute("uv", new sa(n, 2))
					}

					function dc(a, b, c, d) {
						wa.call(this), this.type = "LatheGeometry", this.parameters = {
							points: a,
							segments: b,
							phiStart: c,
							phiLength: d
						}, this.fromBufferGeometry(new ec(a, b, c, d)), this.mergeVertices()
					}

					function ec(a, b, d, e) {
						xa.call(this), this.type = "LatheBufferGeometry", this.parameters = {
							points: a,
							segments: b,
							phiStart: d,
							phiLength: e
						}, b = Math.floor(b) || 12, d = d || 0, e = e || 2 * Math.PI, e = re.clamp(e, 0, 2 * Math.PI);
						var f, g, h = [],
							j = [],
							k = [],
							l = 1 / b,
							m = new i,
							n = new c;
						for (f = 0; f <= b; f++) {
							g = d + f * l * e;
							var o = Math.sin(g),
								p = Math.cos(g);
							for (g = 0; g <= a.length - 1; g++) m.x = a[g].x * o, m.y = a[g].y, m.z = a[g].x * p, j.push(m.x, m.y, m.z), n.x = f / b, n.y = g / (a.length - 1), k.push(n.x, n.y)
						}
						for (f = 0; f < b; f++)
							for (g = 0; g < a.length - 1; g++) d = g + f * a.length, l = d + a.length, m = d + a.length + 1, n = d + 1, h.push(d, l, n), h.push(l, m, n);
						if (this.setIndex(h), this.addAttribute("position", new sa(j, 3)), this.addAttribute("uv", new sa(k, 2)), this.computeVertexNormals(), e === 2 * Math.PI)
							for (e = this.attributes.normal.array, h = new i, j = new i, k = new i, d = b * a.length * 3, g = f = 0; f < a.length; f++, g += 3) h.x = e[g + 0], h.y = e[g + 1], h.z = e[g + 2], j.x = e[d + g + 0], j.y = e[d + g + 1], j.z = e[d + g + 2], k.addVectors(h, j).normalize(), e[g + 0] = e[d + g + 0] = k.x, e[g + 1] = e[d + g + 1] = k.y, e[g + 2] = e[d + g + 2] = k.z
					}

					function fc(a, b) {
						wa.call(this), this.type = "ShapeGeometry", "object" == typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments), this.parameters = {
							shapes: a,
							curveSegments: b
						}, this.fromBufferGeometry(new gc(a, b)), this.mergeVertices()
					}

					function gc(a, b) {
						function c(a) {
							var c, h, j = e.length / 3;
							a = a.extractPoints(b);
							var k = a.shape,
								l = a.holes;
							if (false === Je.isClockWise(k))
								for (k = k.reverse(), a = 0, c = l.length; a < c; a++) h = l[a], true === Je.isClockWise(h) && (l[a] = h.reverse());
							var m = Je.triangulateShape(k, l);
							for (a = 0, c = l.length; a < c; a++) h = l[a], k = k.concat(h);
							for (a = 0, c = k.length; a < c; a++) h = k[a], e.push(h.x, h.y, 0), f.push(0, 0, 1), g.push(h.x, h.y);
							for (a = 0, c = m.length; a < c; a++) k = m[a], d.push(k[0] + j, k[1] + j, k[2] + j), i += 3
						}
						xa.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
							shapes: a,
							curveSegments: b
						}, b = b || 12;
						var d = [],
							e = [],
							f = [],
							g = [],
							h = 0,
							i = 0;
						if (false === Array.isArray(a)) c(a);
						else
							for (var j = 0; j < a.length; j++) c(a[j]), this.addGroup(h, i, j), h += i, i = 0;
						this.setIndex(d), this.addAttribute("position", new sa(e, 3)), this.addAttribute("normal", new sa(f, 3)), this.addAttribute("uv", new sa(g, 2))
					}

					function hc(a, b) {
						xa.call(this), this.type = "EdgesGeometry", this.parameters = {
							thresholdAngle: b
						};
						var c, d, e, f = [],
							g = Math.cos(re.DEG2RAD * (void 0 !== b ? b : 1)),
							h = [0, 0],
							i = {},
							j = ["a", "b", "c"];
						a.isBufferGeometry ? (e = new wa, e.fromBufferGeometry(a)) : e = a.clone(), e.mergeVertices(), e.computeFaceNormals();
						var k = e.vertices;
						e = e.faces;
						for (var l = 0, m = e.length; l < m; l++)
							for (var n = e[l], o = 0; 3 > o; o++) c = n[j[o]], d = n[j[(o + 1) % 3]], h[0] = Math.min(c, d), h[1] = Math.max(c, d), c = h[0] + "," + h[1], void 0 === i[c] ? i[c] = {
								index1: h[0],
								index2: h[1],
								face1: l,
								face2: void 0
							} : i[c].face2 = l;
						for (c in i) h = i[c], (void 0 === h.face2 || e[h.face1].normal.dot(e[h.face2].normal) <= g) && (j = k[h.index1], f.push(j.x, j.y, j.z), j = k[h.index2], f.push(j.x, j.y, j.z));
						this.addAttribute("position", new sa(f, 3))
					}

					function ic(a, b, c, d, e, f, g, h) {
						wa.call(this), this.type = "CylinderGeometry", this.parameters = {
							radiusTop: a,
							radiusBottom: b,
							height: c,
							radialSegments: d,
							heightSegments: e,
							openEnded: f,
							thetaStart: g,
							thetaLength: h
						}, this.fromBufferGeometry(new jc(a, b, c, d, e, f, g, h)), this.mergeVertices()
					}

					function jc(a, b, d, e, f, g, h, j) {
						function k(d) {
							var f, g, k, r = new c,
								u = new i,
								v = 0,
								w = true === d ? a : b,
								x = true === d ? 1 : -1;
							for (g = q, f = 1; f <= e; f++) n.push(0, s * x, 0), o.push(0, x, 0), p.push(.5, .5), q++;
							for (k = q, f = 0; f <= e; f++) {
								var y = f / e * j + h,
									z = Math.cos(y),
									y = Math.sin(y);
								u.x = w * y, u.y = s * x, u.z = w * z, n.push(u.x, u.y, u.z), o.push(0, x, 0), r.x = .5 * z + .5, r.y = .5 * y * x + .5, p.push(r.x, r.y), q++
							}
							for (f = 0; f < e; f++) r = g + f, u = k + f, true === d ? m.push(u, u + 1, r) : m.push(u + 1, u, r), v += 3;
							l.addGroup(t, v, true === d ? 1 : 2), t += v
						}
						xa.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
							radiusTop: a,
							radiusBottom: b,
							height: d,
							radialSegments: e,
							heightSegments: f,
							openEnded: g,
							thetaStart: h,
							thetaLength: j
						};
						var l = this;
						a = void 0 !== a ? a : 20, b = void 0 !== b ? b : 20, d = void 0 !== d ? d : 100, e = Math.floor(e) || 8, f = Math.floor(f) || 1, g = void 0 !== g && g, h = void 0 !== h ? h : 0, j = void 0 !== j ? j : 2 * Math.PI;
						var m = [],
							n = [],
							o = [],
							p = [],
							q = 0,
							r = [],
							s = d / 2,
							t = 0;
						! function() {
							var c, g, k = new i,
								u = new i,
								v = 0,
								w = (b - a) / d;
							for (g = 0; g <= f; g++) {
								var x = [],
									y = g / f,
									z = y * (b - a) + a;
								for (c = 0; c <= e; c++) {
									var A = c / e,
										B = A * j + h,
										C = Math.sin(B),
										B = Math.cos(B);
									u.x = z * C, u.y = -y * d + s, u.z = z * B, n.push(u.x, u.y, u.z), k.set(C, w, B).normalize(), o.push(k.x, k.y, k.z), p.push(A, 1 - y), x.push(q++)
								}
								r.push(x)
							}
							for (c = 0; c < e; c++)
								for (g = 0; g < f; g++) k = r[g + 1][c], u = r[g + 1][c + 1], w = r[g][c + 1], m.push(r[g][c], k, w), m.push(k, u, w), v += 6;
							l.addGroup(t, v, 0), t += v
						}(), false === g && (0 < a && k(true), 0 < b && k(false)), this.setIndex(m), this.addAttribute("position", new sa(n, 3)), this.addAttribute("normal", new sa(o, 3)), this.addAttribute("uv", new sa(p, 2))
					}

					function kc(a, b, c, d, e, f, g) {
						ic.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeGeometry", this.parameters = {
							radius: a,
							height: b,
							radialSegments: c,
							heightSegments: d,
							openEnded: e,
							thetaStart: f,
							thetaLength: g
						}
					}

					function lc(a, b, c, d, e, f, g) {
						jc.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeBufferGeometry", this.parameters = {
							radius: a,
							height: b,
							radialSegments: c,
							heightSegments: d,
							openEnded: e,
							thetaStart: f,
							thetaLength: g
						}
					}

					function mc(a, b, c, d) {
						wa.call(this), this.type = "CircleGeometry", this.parameters = {
							radius: a,
							segments: b,
							thetaStart: c,
							thetaLength: d
						}, this.fromBufferGeometry(new nc(a, b, c, d)), this.mergeVertices()
					}

					function nc(a, b, d, e) {
						xa.call(this), this.type = "CircleBufferGeometry", this.parameters = {
							radius: a,
							segments: b,
							thetaStart: d,
							thetaLength: e
						}, a = a || 50, b = void 0 !== b ? Math.max(3, b) : 8, d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI;
						var f, g, h = [],
							j = [],
							k = [],
							l = [],
							m = new i,
							n = new c;
						for (j.push(0, 0, 0), k.push(0, 0, 1), l.push(.5, .5), g = 0, f = 3; g <= b; g++, f += 3) {
							var o = d + g / b * e;
							m.x = a * Math.cos(o), m.y = a * Math.sin(o), j.push(m.x, m.y, m.z), k.push(0, 0, 1), n.x = (j[f] / a + 1) / 2, n.y = (j[f + 1] / a + 1) / 2, l.push(n.x, n.y)
						}
						for (f = 1; f <= b; f++) h.push(f, f + 1, 0);
						this.setIndex(h), this.addAttribute("position", new sa(j, 3)), this.addAttribute("normal", new sa(k, 3)), this.addAttribute("uv", new sa(l, 2))
					}

					function oc(a) {
						W.call(this, {
							uniforms: Ce.merge([Be.lights, {
								opacity: {
									value: 1
								}
							}]),
							vertexShader: De.shadow_vert,
							fragmentShader: De.shadow_frag
						}), this.transparent = this.lights = true, Object.defineProperties(this, {
							opacity: {
								enumerable: true,
								get: function() {
									return this.uniforms.opacity.value
								},
								set: function(a) {
									this.uniforms.opacity.value = a
								}
							}
						}), this.setValues(a)
					}

					function pc(a) {
						W.call(this, a), this.type = "RawShaderMaterial"
					}

					function qc(a) {
						V.call(this), this.defines = {
							STANDARD: ""
						}, this.type = "MeshStandardMaterial", this.color = new R(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new R(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = false, this.setValues(a)
					}

					function rc(a) {
						qc.call(this), this.defines = {
							PHYSICAL: ""
						}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(a)
					}

					function sc(a) {
						V.call(this), this.type = "MeshPhongMaterial", this.color = new R(16777215), this.specular = new R(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new R(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = false, this.setValues(a)
					}

					function tc(a) {
						sc.call(this), this.defines = {
							TOON: ""
						}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(a)
					}

					function uc(a) {
						V.call(this, a), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = false, this.setValues(a)
					}

					function vc(a) {
						V.call(this), this.type = "MeshLambertMaterial", this.color = new R(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new R(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = false, this.setValues(a)
					}

					function wc(a) {
						V.call(this), this.type = "LineDashedMaterial", this.color = new R(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.lights = false, this.setValues(a)
					}

					function xc(a, b, c) {
						var d = this,
							e = false,
							f = 0,
							g = 0;
						this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function(a) {
							g++, false === e && void 0 !== d.onStart && d.onStart(a, f, g), e = true
						}, this.itemEnd = function(a) {
							f++, void 0 !== d.onProgress && d.onProgress(a, f, g), f === g && (e = false, void 0 !== d.onLoad) && d.onLoad()
						}, this.itemError = function(a) {
							void 0 !== d.onError && d.onError(a)
						}
					}

					function yc(a) {
						this.manager = void 0 !== a ? a : Ne
					}

					function zc(a) {
						this.manager = void 0 !== a ? a : Ne, this._parser = null
					}

					function Ac(a) {
						this.manager = void 0 !== a ? a : Ne, this._parser = null
					}

					function Bc(a) {
						this.manager = void 0 !== a ? a : Ne
					}

					function Cc(a) {
						this.manager = void 0 !== a ? a : Ne
					}

					function Dc(a) {
						this.manager = void 0 !== a ? a : Ne
					}

					function Ec(a, b) {
						fa.call(this), this.type = "Light", this.color = new R(a), this.intensity = void 0 !== b ? b : 1, this.receiveShadow = void 0
					}

					function Fc(a, b, c) {
						Ec.call(this, a, c), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(fa.DefaultUp), this.updateMatrix(), this.groundColor = new R(b)
					}

					function Gc(a) {
						this.camera = a, this.bias = 0, this.radius = 1, this.mapSize = new c(512, 512), this.map = null, this.matrix = new j
					}

					function Hc() {
						Gc.call(this, new Ea(50, 1, .5, 500))
					}

					function Ic(a, b, c, d, e, f) {
						Ec.call(this, a, b), this.type = "SpotLight", this.position.copy(fa.DefaultUp), this.updateMatrix(), this.target = new fa, Object.defineProperty(this, "power", {
							get: function() {
								return this.intensity * Math.PI
							},
							set: function(a) {
								this.intensity = a / Math.PI
							}
						}), this.distance = void 0 !== c ? c : 0, this.angle = void 0 !== d ? d : Math.PI / 3, this.penumbra = void 0 !== e ? e : 0, this.decay = void 0 !== f ? f : 1, this.shadow = new Hc
					}

					function Jc(a, b, c, d) {
						Ec.call(this, a, b), this.type = "PointLight", Object.defineProperty(this, "power", {
							get: function() {
								return 4 * this.intensity * Math.PI
							},
							set: function(a) {
								this.intensity = a / (4 * Math.PI)
							}
						}), this.distance = void 0 !== c ? c : 0, this.decay = void 0 !== d ? d : 1, this.shadow = new Gc(new Ea(90, 1, .5, 500))
					}

					function Kc() {
						Gc.call(this, new Fa(-5, 5, 5, -5, .5, 500))
					}

					function Lc(a, b) {
						Ec.call(this, a, b), this.type = "DirectionalLight", this.position.copy(fa.DefaultUp), this.updateMatrix(), this.target = new fa, this.shadow = new Kc
					}

					function Mc(a, b) {
						Ec.call(this, a, b), this.type = "AmbientLight", this.castShadow = void 0
					}

					function Nc(a, b, c, d) {
						Ec.call(this, a, b), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== c ? c : 10, this.height = void 0 !== d ? d : 10
					}

					function Oc(a, b, c, d) {
						this.parameterPositions = a, this._cachedIndex = 0, this.resultBuffer = void 0 !== d ? d : new b.constructor(c), this.sampleValues = b, this.valueSize = c
					}

					function Pc(a, b, c, d) {
						Oc.call(this, a, b, c, d), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
					}

					function Qc(a, b, c, d) {
						Oc.call(this, a, b, c, d)
					}

					function Rc(a, b, c, d) {
						Oc.call(this, a, b, c, d)
					}

					function Sc(a, b, c, d) {
						if (void 0 === a) throw Error("track name is undefined");
						if (void 0 === b || 0 === b.length) throw Error("no keyframes in track named " + a);
						this.name = a, this.times = Oe.convertArray(b, this.TimeBufferType), this.values = Oe.convertArray(c, this.ValueBufferType), this.setInterpolation(d || this.DefaultInterpolation), this.validate(), this.optimize()
					}

					function Tc(a, b, c, d) {
						Sc.call(this, a, b, c, d)
					}

					function Uc(a, b, c, d) {
						Oc.call(this, a, b, c, d)
					}

					function Vc(a, b, c, d) {
						Sc.call(this, a, b, c, d)
					}

					function Wc(a, b, c, d) {
						Sc.call(this, a, b, c, d)
					}

					function Xc(a, b, c, d) {
						Sc.call(this, a, b, c, d)
					}

					function Yc(a, b, c) {
						Sc.call(this, a, b, c)
					}

					function Zc(a, b, c, d) {
						Sc.call(this, a, b, c, d)
					}

					function $c(a, b, c, d) {
						Sc.apply(this, arguments)
					}

					function _c(a, b, c) {
						this.name = a, this.tracks = c, this.duration = void 0 !== b ? b : -1, this.uuid = re.generateUUID(), 0 > this.duration && this.resetDuration(), this.optimize()
					}

					function ad(a) {
						this.manager = void 0 !== a ? a : Ne, this.textures = {}
					}

					function bd(a) {
						this.manager = void 0 !== a ? a : Ne
					}

					function cd() {
						this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
					}

					function dd(a) {
						"boolean" == typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0), this.manager = void 0 !== a ? a : Ne, this.withCredentials = false
					}

					function ed(a) {
						this.manager = void 0 !== a ? a : Ne, this.texturePath = ""
					}

					function fd(a, b, c, d, e) {
						b = .5 * (d - b), e = .5 * (e - c);
						var f = a * a;
						return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c
					}

					function gd(a, b, c, d) {
						var e = 1 - a;
						return e * e * b + 2 * (1 - a) * a * c + a * a * d
					}

					function hd(a, b, c, d, e) {
						var f = 1 - a,
							g = 1 - a;
						return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
					}

					function id() {
						this.arcLengthDivisions = 200
					}

					function jd(a, b) {
						this.arcLengthDivisions = 200, this.v1 = a, this.v2 = b
					}

					function kd() {
						this.arcLengthDivisions = 200, this.curves = [], this.autoClose = false
					}

					function ld(a, b, c, d, e, f, g, h) {
						this.arcLengthDivisions = 200, this.aX = a, this.aY = b, this.xRadius = c, this.yRadius = d, this.aStartAngle = e, this.aEndAngle = f, this.aClockwise = g, this.aRotation = h || 0
					}

					function md(a) {
						this.arcLengthDivisions = 200, this.points = void 0 === a ? [] : a
					}

					function nd(a, b, c, d) {
						this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
					}

					function od(a, b, c) {
						this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c
					}

					function pd(a) {
						kd.call(this), this.currentPoint = new c, a && this.fromPoints(a)
					}

					function qd() {
						pd.apply(this, arguments), this.holes = []
					}

					function rd() {
						this.subPaths = [], this.currentPath = null
					}

					function sd(a) {
						this.data = a
					}

					function td(a) {
						this.manager = void 0 !== a ? a : Ne
					}

					function ud(a) {
						this.manager = void 0 !== a ? a : Ne
					}

					function vd() {
						this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Ea, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Ea, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false
					}

					function wd(a, b, c) {
						fa.call(this), this.type = "CubeCamera";
						var d = new Ea(90, 1, a, b);
						d.up.set(0, -1, 0), d.lookAt(new i(1, 0, 0)), this.add(d);
						var e = new Ea(90, 1, a, b);
						e.up.set(0, -1, 0), e.lookAt(new i(-1, 0, 0)), this.add(e);
						var f = new Ea(90, 1, a, b);
						f.up.set(0, 0, 1), f.lookAt(new i(0, 1, 0)), this.add(f);
						var h = new Ea(90, 1, a, b);
						h.up.set(0, 0, -1), h.lookAt(new i(0, -1, 0)), this.add(h);
						var j = new Ea(90, 1, a, b);
						j.up.set(0, -1, 0), j.lookAt(new i(0, 0, 1)), this.add(j);
						var k = new Ea(90, 1, a, b);
						k.up.set(0, -1, 0), k.lookAt(new i(0, 0, -1)), this.add(k), this.renderTarget = new g(c, c, {
							format: 1022,
							magFilter: 1006,
							minFilter: 1006
						}), this.renderTarget.texture.name = "CubeCamera", this.updateCubeMap = function(a, b) {
							null === this.parent && this.updateMatrixWorld();
							var c = this.renderTarget,
								g = c.texture.generateMipmaps;
							c.texture.generateMipmaps = false, c.activeCubeFace = 0, a.render(b, d, c), c.activeCubeFace = 1, a.render(b, e, c), c.activeCubeFace = 2, a.render(b, f, c), c.activeCubeFace = 3, a.render(b, h, c), c.activeCubeFace = 4, a.render(b, j, c), c.texture.generateMipmaps = g, c.activeCubeFace = 5, a.render(b, k, c), a.setRenderTarget(null)
						}
					}

					function xd(a) {
						Ea.call(this), this.enabled = false, this.cameras = a || []
					}

					function yd() {
						fa.call(this), this.type = "AudioListener", this.context = We.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
					}

					function zd(a) {
						fa.call(this), this.type = "Audio", this.context = a.context, this.gain = this.context.createGain(), this.gain.connect(a.getInput()), this.autoplay = false, this.buffer = null, this.loop = false, this.startTime = 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.sourceType = "empty", this.filters = []
					}

					function Ad(a) {
						zd.call(this, a), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
					}

					function Bd(a, b) {
						this.analyser = a.context.createAnalyser(), this.analyser.fftSize = void 0 !== b ? b : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), a.getOutput().connect(this.analyser)
					}

					function Cd(a, b, c) {
						switch (this.binding = a, this.valueSize = c, a = Float64Array, b) {
							case "quaternion":
								b = this._slerp;
								break;
							case "string":
							case "bool":
								a = Array, b = this._select;
								break;
							default:
								b = this._lerp
						}
						this.buffer = new a(4 * c), this._mixBufferRegion = b, this.referenceCount = this.useCount = this.cumulativeWeight = 0
					}

					function Dd(a, b, c) {
						c = c || Ed.parseTrackName(b), this._targetGroup = a, this._bindings = a.subscribe_(b, c)
					}

					function Ed(a, b, c) {
						this.path = b, this.parsedPath = c || Ed.parseTrackName(b), this.node = Ed.findNode(a, this.parsedPath.nodeName) || a, this.rootNode = a
					}

					function Fd(a) {
						this.uuid = re.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
						var b = {};
						this._indicesByUUID = b;
						for (var c = 0, d = arguments.length; c !== d; ++c) b[arguments[c].uuid] = c;
						this._paths = [], this._parsedPaths = [],
							this._bindings = [], this._bindingsIndicesByPath = {};
						var e = this;
						this.stats = {
							objects: {
								get total() {
									return e._objects.length
								},
								get inUse() {
									return this.total - e.nCachedObjects_
								}
							},
							get bindingsPerObject() {
								return e._bindings.length
							}
						}
					}

					function Gd(a, b, c) {
						this._mixer = a, this._clip = b, this._localRoot = c || null, a = b.tracks, b = a.length, c = Array(b);
						for (var d = {
								endingStart: 2400,
								endingEnd: 2400
							}, e = 0; e !== b; ++e) {
							var f = a[e].createInterpolant(null);
							c[e] = f, f.settings = d
						}
						this._interpolantSettings = d, this._interpolants = c, this._propertyBindings = Array(b), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = true
					}

					function Hd(a) {
						this._root = a, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
					}

					function Id(a, b) {
						"string" == typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b), this.value = a
					}

					function Jd() {
						xa.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
					}

					function Kd(a, b, c, d) {
						this.uuid = re.generateUUID(), this.data = a, this.itemSize = b, this.offset = c, this.normalized = true === d
					}

					function Ld(a, b) {
						this.uuid = re.generateUUID(), this.array = a, this.stride = b, this.count = void 0 !== a ? a.length / b : 0, this.dynamic = false, this.updateRange = {
							offset: 0,
							count: -1
						}, this.onUploadCallback = function() {}, this.version = 0
					}

					function Md(a, b, c) {
						Ld.call(this, a, b), this.meshPerAttribute = c || 1
					}

					function Nd(a, b, c) {
						ka.call(this, a, b), this.meshPerAttribute = c || 1
					}

					function Od(a, b, c, d) {
						this.ray = new ca(a, b), this.near = c || 0, this.far = d || 1 / 0, this.params = {
							Mesh: {},
							Line: {},
							LOD: {},
							Points: {
								threshold: 1
							},
							Sprite: {}
						}, Object.defineProperties(this.params, {
							PointCloud: {
								get: function() {
									return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
								}
							}
						})
					}

					function Pd(a, b) {
						return a.distance - b.distance
					}

					function Qd(a, b, c, d) {
						if (false !== a.visible && (a.raycast(b, c), true === d)) {
							a = a.children, d = 0;
							for (var e = a.length; d < e; d++) Qd(a[d], b, c, true)
						}
					}

					function Rd(a) {
						this.autoStart = void 0 === a || a, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = false
					}

					function Sd(a, b, c) {
						return this.radius = void 0 !== a ? a : 1, this.phi = void 0 !== b ? b : 0, this.theta = void 0 !== c ? c : 0, this
					}

					function Td(a, b, c) {
						return this.radius = void 0 !== a ? a : 1, this.theta = void 0 !== b ? b : 0, this.y = void 0 !== c ? c : 0, this
					}

					function Ud(a, b) {
						ya.call(this, a, b), this.animationsMap = {}, this.animationsList = [];
						var c = this.geometry.morphTargets.length;
						this.createAnimation("__default", 0, c - 1, c / 1), this.setAnimationWeight("__default", 1)
					}

					function Vd(a) {
						fa.call(this), this.material = a, this.render = function(a) {}
					}

					function Wd(a, b, c, d) {
						this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16711680, d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count), c = new xa, b = new sa(6 * b, 3), c.addAttribute("position", b), vb.call(this, c, new tb({
							color: a,
							linewidth: d
						})), this.matrixAutoUpdate = false, this.update()
					}

					function Xd(a) {
						fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = false, a = new xa;
						for (var b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], c = 0, d = 1; 32 > c; c++, d++) {
							var e = c / 32 * Math.PI * 2,
								f = d / 32 * Math.PI * 2;
							b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
						}
						a.addAttribute("position", new sa(b, 3)), b = new tb({
							fog: false
						}), this.cone = new vb(a, b), this.add(this.cone), this.update()
					}

					function Yd(a) {
						this.bones = this.getBoneList(a);
						for (var b = new xa, c = [], d = [], e = new R(0, 0, 1), f = new R(0, 1, 0), g = 0; g < this.bones.length; g++) {
							var h = this.bones[g];
							h.parent && h.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), d.push(e.r, e.g, e.b), d.push(f.r, f.g, f.b))
						}
						b.addAttribute("position", new sa(c, 3)), b.addAttribute("color", new sa(d, 3)), c = new tb({
							vertexColors: 2,
							depthTest: false,
							depthWrite: false,
							transparent: true
						}), vb.call(this, b, c), this.root = a, this.matrix = a.matrixWorld, this.matrixAutoUpdate = false, this.update()
					}

					function Zd(a, b) {
						this.light = a, this.light.updateMatrixWorld();
						var c = new ac(b, 4, 2),
							d = new ja({
								wireframe: true,
								fog: false
							});
						d.color.copy(this.light.color), ya.call(this, c, d), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false
					}

					function $d(a) {
						fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = false, a = new tb({
							color: a.color
						});
						var b = new xa;
						b.addAttribute("position", new ka(new Float32Array(15), 3)), this.add(new ub(b, a)), this.update()
					}

					function _d(a, b) {
						fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = false;
						var c = new Mb(b);
						c.rotateY(.5 * Math.PI);
						var d = new ja({
								vertexColors: 2,
								wireframe: true
							}),
							e = c.getAttribute("position"),
							e = new Float32Array(3 * e.count);
						c.addAttribute("color", new ka(e, 3)), this.add(new ya(c, d)), this.update()
					}

					function ae(a, b, c, d) {
						a = a || 10, b = b || 10, c = new R(void 0 !== c ? c : 4473924), d = new R(void 0 !== d ? d : 8947848);
						var e = b / 2,
							f = a / b,
							g = a / 2;
						a = [];
						for (var h = [], i = 0, j = 0, k = -g; i <= b; i++, k += f) {
							a.push(-g, 0, k, g, 0, k), a.push(k, 0, -g, k, 0, g);
							var l = i === e ? c : d;
							l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), j += 3
						}
						b = new xa, b.addAttribute("position", new sa(a, 3)), b.addAttribute("color", new sa(h, 3)), c = new tb({
							vertexColors: 2
						}), vb.call(this, b, c)
					}

					function be(a, b, c, d, e, f) {
						a = a || 10, b = b || 16, c = c || 8, d = d || 64, e = new R(void 0 !== e ? e : 4473924), f = new R(void 0 !== f ? f : 8947848);
						var g, h, i, j, k, l = [],
							m = [];
						for (i = 0; i <= b; i++) h = i / b * 2 * Math.PI, g = Math.sin(h) * a, h = Math.cos(h) * a, l.push(0, 0, 0), l.push(g, 0, h), k = 1 & i ? e : f, m.push(k.r, k.g, k.b), m.push(k.r, k.g, k.b);
						for (i = 0; i <= c; i++)
							for (k = 1 & i ? e : f, j = a - a / c * i, b = 0; b < d; b++) h = b / d * 2 * Math.PI, g = Math.sin(h) * j, h = Math.cos(h) * j, l.push(g, 0, h), m.push(k.r, k.g, k.b), h = (b + 1) / d * 2 * Math.PI, g = Math.sin(h) * j, h = Math.cos(h) * j, l.push(g, 0, h), m.push(k.r, k.g, k.b);
						a = new xa, a.addAttribute("position", new sa(l, 3)), a.addAttribute("color", new sa(m, 3)), l = new tb({
							vertexColors: 2
						}), vb.call(this, a, l)
					}

					function ce(a, b, c, d) {
						this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16776960, d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), c = new xa, b = new sa(6 * b, 3), c.addAttribute("position", b), vb.call(this, c, new tb({
							color: a,
							linewidth: d
						})), this.matrixAutoUpdate = false, this.update()
					}

					function de(a, b) {
						fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = false, void 0 === b && (b = 1);
						var c = new xa;
						c.addAttribute("position", new sa([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
						var d = new tb({
							fog: false
						});
						this.add(new ub(c, d)), c = new xa, c.addAttribute("position", new sa([0, 0, 0, 0, 0, 1], 3)), this.add(new ub(c, d)), this.update()
					}

					function ee(a) {
						function b(a, b, d) {
							c(a, d), c(b, d)
						}

						function c(a, b) {
							f.push(0, 0, 0), g.push(b.r, b.g, b.b), void 0 === h[a] && (h[a] = []), h[a].push(f.length / 3 - 1)
						}
						var d = new xa,
							e = new tb({
								color: 16777215,
								vertexColors: 1
							}),
							f = [],
							g = [],
							h = {},
							i = new R(16755200),
							j = new R(16711680),
							k = new R(43775),
							l = new R(16777215),
							m = new R(3355443);
						b("n1", "n2", i), b("n2", "n4", i), b("n4", "n3", i), b("n3", "n1", i), b("f1", "f2", i), b("f2", "f4", i), b("f4", "f3", i), b("f3", "f1", i), b("n1", "f1", i), b("n2", "f2", i), b("n3", "f3", i), b("n4", "f4", i), b("p", "n1", j), b("p", "n2", j), b("p", "n3", j), b("p", "n4", j), b("u1", "u2", k), b("u2", "u3", k), b("u3", "u1", k), b("c", "t", l), b("p", "c", m), b("cn1", "cn2", m), b("cn3", "cn4", m), b("cf1", "cf2", m), b("cf3", "cf4", m), d.addAttribute("position", new sa(f, 3)), d.addAttribute("color", new sa(g, 3)), vb.call(this, d, e), this.camera = a, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = h, this.update()
					}

					function fe(a, b) {
						this.object = a, void 0 === b && (b = 16776960);
						var c = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
							d = new Float32Array(24),
							e = new xa;
						e.setIndex(new ka(c, 1)), e.addAttribute("position", new ka(d, 3)), vb.call(this, e, new tb({
							color: b
						})), this.matrixAutoUpdate = false, this.update()
					}

					function ge(a, b, c, d, e, f) {
						fa.call(this), void 0 === d && (d = 16776960), void 0 === c && (c = 1), void 0 === e && (e = .2 * c), void 0 === f && (f = .2 * e), void 0 === Xe && (Xe = new xa, Xe.addAttribute("position", new sa([0, 0, 0, 0, 1, 0], 3)), Ye = new jc(0, .5, 1, 5, 1), Ye.translate(0, -.5, 0)), this.position.copy(b), this.line = new ub(Xe, new tb({
							color: d
						})), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new ya(Ye, new ja({
							color: d
						})), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(a), this.setLength(c, e, f)
					}

					function he(a) {
						a = a || 1;
						var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
						a = new xa, a.addAttribute("position", new sa(b, 3)), a.addAttribute("color", new sa([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), b = new tb({
							vertexColors: 2
						}), vb.call(this, a, b)
					}

					function ie() {
						var a = 0,
							b = 0,
							c = 0,
							d = 0;
						return {
							initCatmullRom: function(e, f, g, h, i) {
								e = i * (g - e), h = i * (h - f), a = f, b = e, c = -3 * f + 3 * g - 2 * e - h, d = 2 * f - 2 * g + e + h
							},
							initNonuniformCatmullRom: function(e, f, g, h, i, j, k) {
								e = ((f - e) / i - (g - e) / (i + j) + (g - f) / j) * j, h = ((g - f) / j - (h - f) / (j + k) + (h - g) / k) * j, a = f, b = e, c = -3 * f + 3 * g - 2 * e - h, d = 2 * f - 2 * g + e + h
							},
							calc: function(e) {
								var f = e * e;
								return a + b * e + c * f + d * f * e
							}
						}
					}

					function je(a) {
						this.arcLengthDivisions = 200, this.points = a || [], this.closed = false
					}

					function ke(a, b, c, d) {
						this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
					}

					function le(a, b, c) {
						this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c
					}

					function me(a, b) {
						this.arcLengthDivisions = 200, this.v1 = a, this.v2 = b
					}

					function ne(a, b, c, d, e, f) {
						ld.call(this, a, b, c, c, d, e, f)
					}

					function oe(a) {
						console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), je.call(this, a), this.type = "catmullrom", this.closed = true
					}

					function pe(a) {
						console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), je.call(this, a), this.type = "catmullrom"
					}

					function qe(a) {
						console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), je.call(this, a), this.type = "catmullrom"
					}
					void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(a) {
						return "number" == typeof a && isFinite(a) && Math.floor(a) === a
					}), void 0 === Math.sign && (Math.sign = function(a) {
						return 0 > a ? -1 : 0 < a ? 1 : +a
					}), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
						get: function() {
							return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
						}
					}), void 0 === Object.assign && function() {
						Object.assign = function(a) {
							if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
							for (var b = Object(a), c = 1; c < arguments.length; c++) {
								var d = arguments[c];
								if (void 0 !== d && null !== d)
									for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
							}
							return b
						}
					}(), Object.assign(b.prototype, {
						addEventListener: function(a, b) {
							void 0 === this._listeners && (this._listeners = {});
							var c = this._listeners;
							void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b)
						},
						hasEventListener: function(a, b) {
							if (void 0 === this._listeners) return false;
							var c = this._listeners;
							return void 0 !== c[a] && -1 !== c[a].indexOf(b)
						},
						removeEventListener: function(a, b) {
							if (void 0 !== this._listeners) {
								var c = this._listeners[a];
								if (void 0 !== c) {
									var d = c.indexOf(b); - 1 !== d && c.splice(d, 1)
								}
							}
						},
						dispatchEvent: function(a) {
							if (void 0 !== this._listeners) {
								var b = this._listeners[a.type];
								if (void 0 !== b) {
									a.target = this;
									var c, d = [],
										e = b.length;
									for (c = 0; c < e; c++) d[c] = b[c];
									for (c = 0; c < e; c++) d[c].call(this, a)
								}
							}
						}
					});
					var re = {
						DEG2RAD: Math.PI / 180,
						RAD2DEG: 180 / Math.PI,
						generateUUID: function() {
							var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
								c = Array(36),
								d = 0;
							return function() {
								for (var e = 0; 36 > e; e++) 8 === e || 13 === e || 18 === e || 23 === e ? c[e] = "-" : 14 === e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), a = 15 & d, d >>= 4, c[e] = b[19 === e ? 3 & a | 8 : a]);
								return c.join("")
							}
						}(),
						clamp: function(a, b, c) {
							return Math.max(b, Math.min(c, a))
						},
						euclideanModulo: function(a, b) {
							return (a % b + b) % b
						},
						mapLinear: function(a, b, c, d, e) {
							return d + (a - b) * (e - d) / (c - b)
						},
						lerp: function(a, b, c) {
							return (1 - c) * a + c * b
						},
						smoothstep: function(a, b, c) {
							return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a))
						},
						smootherstep: function(a, b, c) {
							return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10))
						},
						randInt: function(a, b) {
							return a + Math.floor(Math.random() * (b - a + 1))
						},
						randFloat: function(a, b) {
							return a + Math.random() * (b - a)
						},
						randFloatSpread: function(a) {
							return a * (.5 - Math.random())
						},
						degToRad: function(a) {
							return a * re.DEG2RAD
						},
						radToDeg: function(a) {
							return a * re.RAD2DEG
						},
						isPowerOfTwo: function(a) {
							return 0 === (a & a - 1) && 0 !== a
						},
						nearestPowerOfTwo: function(a) {
							return Math.pow(2, Math.round(Math.log(a) / Math.LN2))
						},
						nextPowerOfTwo: function(a) {
							return a--, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, a++, a
						}
					};
					Object.defineProperties(c.prototype, {
						width: {
							get: function() {
								return this.x
							},
							set: function(a) {
								this.x = a
							}
						},
						height: {
							get: function() {
								return this.y
							},
							set: function(a) {
								this.y = a
							}
						}
					}), Object.assign(c.prototype, {
						isVector2: true,
						set: function(a, b) {
							return this.x = a, this.y = b, this
						},
						setScalar: function(a) {
							return this.y = this.x = a, this
						},
						setX: function(a) {
							return this.x = a, this
						},
						setY: function(a) {
							return this.y = a, this
						},
						setComponent: function(a, b) {
							switch (a) {
								case 0:
									this.x = b;
									break;
								case 1:
									this.y = b;
									break;
								default:
									throw Error("index is out of range: " + a)
							}
							return this
						},
						getComponent: function(a) {
							switch (a) {
								case 0:
									return this.x;
								case 1:
									return this.y;
								default:
									throw Error("index is out of range: " + a)
							}
						},
						clone: function() {
							return new this.constructor(this.x, this.y)
						},
						copy: function(a) {
							return this.x = a.x, this.y = a.y, this
						},
						add: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this)
						},
						addScalar: function(a) {
							return this.x += a, this.y += a, this
						},
						addVectors: function(a, b) {
							return this.x = a.x + b.x, this.y = a.y + b.y, this
						},
						addScaledVector: function(a, b) {
							return this.x += a.x * b, this.y += a.y * b, this
						},
						sub: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this)
						},
						subScalar: function(a) {
							return this.x -= a, this.y -= a, this
						},
						subVectors: function(a, b) {
							return this.x = a.x - b.x, this.y = a.y - b.y, this
						},
						multiply: function(a) {
							return this.x *= a.x, this.y *= a.y, this
						},
						multiplyScalar: function(a) {
							return this.x *= a, this.y *= a, this
						},
						divide: function(a) {
							return this.x /= a.x, this.y /= a.y, this
						},
						divideScalar: function(a) {
							return this.multiplyScalar(1 / a)
						},
						min: function(a) {
							return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this
						},
						max: function(a) {
							return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this
						},
						clamp: function(a, b) {
							return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this
						},
						clampScalar: function() {
							var a = new c,
								b = new c;
							return function(c, d) {
								return a.set(c, c), b.set(d, d), this.clamp(a, b)
							}
						}(),
						clampLength: function(a, b) {
							var c = this.length();
							return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
						},
						floor: function() {
							return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
						},
						ceil: function() {
							return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
						},
						round: function() {
							return this.x = Math.round(this.x), this.y = Math.round(this.y), this
						},
						roundToZero: function() {
							return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
						},
						negate: function() {
							return this.x = -this.x, this.y = -this.y, this
						},
						dot: function(a) {
							return this.x * a.x + this.y * a.y
						},
						lengthSq: function() {
							return this.x * this.x + this.y * this.y
						},
						length: function() {
							return Math.sqrt(this.x * this.x + this.y * this.y)
						},
						lengthManhattan: function() {
							return Math.abs(this.x) + Math.abs(this.y)
						},
						normalize: function() {
							return this.divideScalar(this.length())
						},
						angle: function() {
							var a = Math.atan2(this.y, this.x);
							return 0 > a && (a += 2 * Math.PI), a
						},
						distanceTo: function(a) {
							return Math.sqrt(this.distanceToSquared(a))
						},
						distanceToSquared: function(a) {
							var b = this.x - a.x;
							return a = this.y - a.y, b * b + a * a
						},
						distanceToManhattan: function(a) {
							return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
						},
						setLength: function(a) {
							return this.multiplyScalar(a / this.length())
						},
						lerp: function(a, b) {
							return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this
						},
						lerpVectors: function(a, b, c) {
							return this.subVectors(b, a).multiplyScalar(c).add(a)
						},
						equals: function(a) {
							return a.x === this.x && a.y === this.y
						},
						fromArray: function(a, b) {
							return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this
						},
						toArray: function(a, b) {
							return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a
						},
						fromBufferAttribute: function(a, b, c) {
							return void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this
						},
						rotateAround: function(a, b) {
							var c = Math.cos(b),
								d = Math.sin(b),
								e = this.x - a.x,
								f = this.y - a.y;
							return this.x = e * c - f * d + a.x, this.y = e * d + f * c + a.y, this
						}
					});
					var se = 0;
					d.DEFAULT_IMAGE = void 0, d.DEFAULT_MAPPING = 300, Object.defineProperty(d.prototype, "needsUpdate", {
						set: function(a) {
							true === a && this.version++
						}
					}), Object.assign(d.prototype, b.prototype, {
						constructor: d,
						isTexture: true,
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.name = a.name, this.image = a.image, this.mipmaps = a.mipmaps.slice(0), this.mapping = a.mapping, this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, this.minFilter = a.minFilter, this.anisotropy = a.anisotropy, this.format = a.format, this.type = a.type, this.offset.copy(a.offset), this.repeat.copy(a.repeat), this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this.encoding = a.encoding, this
						},
						toJSON: function(a) {
							if (void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
							var b = {
								metadata: {
									version: 4.5,
									type: "Texture",
									generator: "Texture.toJSON"
								},
								uuid: this.uuid,
								name: this.name,
								mapping: this.mapping,
								repeat: [this.repeat.x, this.repeat.y],
								offset: [this.offset.x, this.offset.y],
								wrap: [this.wrapS, this.wrapT],
								minFilter: this.minFilter,
								magFilter: this.magFilter,
								anisotropy: this.anisotropy,
								flipY: this.flipY
							};
							if (void 0 !== this.image) {
								var c = this.image;
								if (void 0 === c.uuid && (c.uuid = re.generateUUID()), void 0 === a.images[c.uuid]) {
									var d, e = a.images,
										f = c.uuid,
										g = c.uuid;
									void 0 !== c.toDataURL ? d = c : (d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), d.width = c.width, d.height = c.height, d.getContext("2d").drawImage(c, 0, 0, c.width, c.height)), d = 2048 < d.width || 2048 < d.height ? d.toDataURL("image/jpeg", .6) : d.toDataURL("image/png"), e[f] = {
										uuid: g,
										url: d
									}
								}
								b.image = c.uuid
							}
							return a.textures[this.uuid] = b
						},
						dispose: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						},
						transformUv: function(a) {
							if (300 === this.mapping) {
								if (a.multiply(this.repeat), a.add(this.offset), 0 > a.x || 1 < a.x) switch (this.wrapS) {
									case 1e3:
										a.x -= Math.floor(a.x);
										break;
									case 1001:
										a.x = 0 > a.x ? 0 : 1;
										break;
									case 1002:
										a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
								}
								if (0 > a.y || 1 < a.y) switch (this.wrapT) {
									case 1e3:
										a.y -= Math.floor(a.y);
										break;
									case 1001:
										a.y = 0 > a.y ? 0 : 1;
										break;
									case 1002:
										a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
								}
								this.flipY && (a.y = 1 - a.y)
							}
						}
					}), Object.assign(e.prototype, {
						isVector4: true,
						set: function(a, b, c, d) {
							return this.x = a, this.y = b, this.z = c, this.w = d, this
						},
						setScalar: function(a) {
							return this.w = this.z = this.y = this.x = a, this
						},
						setX: function(a) {
							return this.x = a, this
						},
						setY: function(a) {
							return this.y = a, this
						},
						setZ: function(a) {
							return this.z = a, this
						},
						setW: function(a) {
							return this.w = a, this
						},
						setComponent: function(a, b) {
							switch (a) {
								case 0:
									this.x = b;
									break;
								case 1:
									this.y = b;
									break;
								case 2:
									this.z = b;
									break;
								case 3:
									this.w = b;
									break;
								default:
									throw Error("index is out of range: " + a)
							}
							return this
						},
						getComponent: function(a) {
							switch (a) {
								case 0:
									return this.x;
								case 1:
									return this.y;
								case 2:
									return this.z;
								case 3:
									return this.w;
								default:
									throw Error("index is out of range: " + a)
							}
						},
						clone: function() {
							return new this.constructor(this.x, this.y, this.z, this.w)
						},
						copy: function(a) {
							return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, this
						},
						add: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this)
						},
						addScalar: function(a) {
							return this.x += a, this.y += a, this.z += a, this.w += a, this
						},
						addVectors: function(a, b) {
							return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
						},
						addScaledVector: function(a, b) {
							return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, this
						},
						sub: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this)
						},
						subScalar: function(a) {
							return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this
						},
						subVectors: function(a, b) {
							return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
						},
						multiplyScalar: function(a) {
							return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this
						},
						applyMatrix4: function(a) {
							var b = this.x,
								c = this.y,
								d = this.z,
								e = this.w;
							return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e, this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e, this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e, this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e, this
						},
						divideScalar: function(a) {
							return this.multiplyScalar(1 / a)
						},
						setAxisAngleFromQuaternion: function(a) {
							this.w = 2 * Math.acos(a.w);
							var b = Math.sqrt(1 - a.w * a.w);
							return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b), this
						},
						setAxisAngleFromRotationMatrix: function(a) {
							var b, c, d;
							a = a.elements;
							var e = a[0];
							d = a[4];
							var f = a[8],
								g = a[1],
								h = a[5],
								i = a[9];
							c = a[2], b = a[6];
							var j = a[10];
							return .01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(i - b) ? .1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(i + b) && .1 > Math.abs(e + h + j - 3) ? (this.set(1, 0, 0, 0), this) : (a = Math.PI, e = (e + 1) / 2, h = (h + 1) / 2, j = (j + 1) / 2, d = (d + g) / 4, f = (f + c) / 4, i = (i + b) / 4, e > h && e > j ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > j ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = i / c) : .01 > j ? (c = b = .707106781, d = 0) : (d = Math.sqrt(j), b = f / d, c = i / d), this.set(b, c, d, a), this) : (a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (g - d) * (g - d)), .001 > Math.abs(a) && (a = 1), this.x = (b - i) / a, this.y = (f - c) / a, this.z = (g - d) / a, this.w = Math.acos((e + h + j - 1) / 2), this)
						},
						min: function(a) {
							return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this.w = Math.min(this.w, a.w), this
						},
						max: function(a) {
							return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this.w = Math.max(this.w, a.w), this
						},
						clamp: function(a, b) {
							return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), this
						},
						clampScalar: function() {
							var a = new e,
								b = new e;
							return function(c, d) {
								return a.set(c, c, c, c), b.set(d, d, d, d), this.clamp(a, b)
							}
						}(),
						floor: function() {
							return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
						},
						ceil: function() {
							return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
						},
						round: function() {
							return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
						},
						roundToZero: function() {
							return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
						},
						negate: function() {
							return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
						},
						dot: function(a) {
							return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
						},
						lengthSq: function() {
							return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
						},
						length: function() {
							return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
						},
						lengthManhattan: function() {
							return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
						},
						normalize: function() {
							return this.divideScalar(this.length())
						},
						setLength: function(a) {
							return this.multiplyScalar(a / this.length())
						},
						lerp: function(a, b) {
							return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this.w += (a.w - this.w) * b, this
						},
						lerpVectors: function(a, b, c) {
							return this.subVectors(b, a).multiplyScalar(c).add(a)
						},
						equals: function(a) {
							return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
						},
						fromArray: function(a, b) {
							return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this
						},
						toArray: function(a, b) {
							return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a
						},
						fromBufferAttribute: function(a, b, c) {
							return void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this.w = a.getW(b), this
						}
					}), Object.assign(f.prototype, b.prototype, {
						isWebGLRenderTarget: true,
						setSize: function(a, b) {
							this.width === a && this.height === b || (this.width = a, this.height = b, this.dispose()), this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b)
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, this.depthTexture = a.depthTexture, this
						},
						dispose: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), g.prototype = Object.create(f.prototype), g.prototype.constructor = g, g.prototype.isWebGLRenderTargetCube = true, Object.assign(h, {
						slerp: function(a, b, c, d) {
							return c.copy(a).slerp(b, d)
						},
						slerpFlat: function(a, b, c, d, e, f, g) {
							var h = c[d + 0],
								i = c[d + 1],
								j = c[d + 2];
							c = c[d + 3], d = e[f + 0];
							var k = e[f + 1],
								l = e[f + 2];
							if (e = e[f + 3], c !== e || h !== d || i !== k || j !== l) {
								f = 1 - g;
								var m = h * d + i * k + j * l + c * e,
									n = 0 <= m ? 1 : -1,
									o = 1 - m * m;
								o > Number.EPSILON && (o = Math.sqrt(o), m = Math.atan2(o, m * n), f = Math.sin(f * m) / o, g = Math.sin(g * m) / o), n *= g, h = h * f + d * n, i = i * f + k * n, j = j * f + l * n, c = c * f + e * n, f === 1 - g && (g = 1 / Math.sqrt(h * h + i * i + j * j + c * c), h *= g, i *= g, j *= g, c *= g)
							}
							a[b] = h, a[b + 1] = i, a[b + 2] = j, a[b + 3] = c
						}
					}), Object.defineProperties(h.prototype, {
						x: {
							get: function() {
								return this._x
							},
							set: function(a) {
								this._x = a, this.onChangeCallback()
							}
						},
						y: {
							get: function() {
								return this._y
							},
							set: function(a) {
								this._y = a, this.onChangeCallback()
							}
						},
						z: {
							get: function() {
								return this._z
							},
							set: function(a) {
								this._z = a, this.onChangeCallback()
							}
						},
						w: {
							get: function() {
								return this._w
							},
							set: function(a) {
								this._w = a, this.onChangeCallback()
							}
						}
					}), Object.assign(h.prototype, {
						set: function(a, b, c, d) {
							return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), this
						},
						clone: function() {
							return new this.constructor(this._x, this._y, this._z, this._w)
						},
						copy: function(a) {
							return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), this
						},
						setFromEuler: function(a, b) {
							if (false === (a && a.isEuler)) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
							var c = a._x,
								d = a._y,
								e = a._z,
								f = a.order,
								g = Math.cos,
								h = Math.sin,
								i = g(c / 2),
								j = g(d / 2),
								g = g(e / 2),
								c = h(c / 2),
								d = h(d / 2),
								e = h(e / 2);
							return "XYZ" === f ? (this._x = c * j * g + i * d * e, this._y = i * d * g - c * j * e, this._z = i * j * e + c * d * g, this._w = i * j * g - c * d * e) : "YXZ" === f ? (this._x = c * j * g + i * d * e, this._y = i * d * g - c * j * e, this._z = i * j * e - c * d * g, this._w = i * j * g + c * d * e) : "ZXY" === f ? (this._x = c * j * g - i * d * e, this._y = i * d * g + c * j * e, this._z = i * j * e + c * d * g, this._w = i * j * g - c * d * e) : "ZYX" === f ? (this._x = c * j * g - i * d * e, this._y = i * d * g + c * j * e, this._z = i * j * e - c * d * g, this._w = i * j * g + c * d * e) : "YZX" === f ? (this._x = c * j * g + i * d * e, this._y = i * d * g + c * j * e, this._z = i * j * e - c * d * g, this._w = i * j * g - c * d * e) : "XZY" === f && (this._x = c * j * g - i * d * e, this._y = i * d * g - c * j * e, this._z = i * j * e + c * d * g, this._w = i * j * g + c * d * e), false !== b && this.onChangeCallback(), this
						},
						setFromAxisAngle: function(a, b) {
							var c = b / 2,
								d = Math.sin(c);
							return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), this.onChangeCallback(), this
						},
						setFromRotationMatrix: function(a) {
							var b = a.elements,
								c = b[0];
							a = b[4];
							var d = b[8],
								e = b[1],
								f = b[5],
								g = b[9],
								h = b[2],
								i = b[6],
								b = b[10],
								j = c + f + b;
							return 0 < j ? (c = .5 / Math.sqrt(j + 1), this._w = .25 / c, this._x = (i - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (i - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + i) / c, this._z = .25 * c), this.onChangeCallback(), this
						},
						setFromUnitVectors: function() {
							var a, b = new i;
							return function(c, d) {
								return void 0 === b && (b = new i), a = c.dot(d) + 1, 1e-6 > a ? (a = 0, Math.abs(c.x) > Math.abs(c.z) ? b.set(-c.y, c.x, 0) : b.set(0, -c.z, c.y)) : b.crossVectors(c, d), this._x = b.x, this._y = b.y, this._z = b.z, this._w = a, this.normalize()
							}
						}(),
						inverse: function() {
							return this.conjugate().normalize()
						},
						conjugate: function() {
							return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
						},
						dot: function(a) {
							return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
						},
						lengthSq: function() {
							return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
						},
						length: function() {
							return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
						},
						normalize: function() {
							var a = this.length();
							return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a), this.onChangeCallback(), this
						},
						multiply: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
						},
						premultiply: function(a) {
							return this.multiplyQuaternions(a, this)
						},
						multiplyQuaternions: function(a, b) {
							var c = a._x,
								d = a._y,
								e = a._z,
								f = a._w,
								g = b._x,
								h = b._y,
								i = b._z,
								j = b._w;
							return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, this.onChangeCallback(), this
						},
						slerp: function(a, b) {
							if (0 === b) return this;
							if (1 === b) return this.copy(a);
							var c = this._x,
								d = this._y,
								e = this._z,
								f = this._w,
								g = f * a._w + c * a._x + d * a._y + e * a._z;
							if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a), 1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
							var h = Math.sqrt(1 - g * g);
							if (.001 > Math.abs(h)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
							var i = Math.atan2(h, g),
								g = Math.sin((1 - b) * i) / h,
								h = Math.sin(b * i) / h;
							return this._w = f * g + this._w * h, this._x = c * g + this._x * h, this._y = d * g + this._y * h, this._z = e * g + this._z * h, this.onChangeCallback(), this
						},
						equals: function(a) {
							return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
						},
						fromArray: function(a, b) {
							return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], this._w = a[b + 3], this.onChangeCallback(), this
						},
						toArray: function(a, b) {
							return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._w, a
						},
						onChange: function(a) {
							return this.onChangeCallback = a, this
						},
						onChangeCallback: function() {}
					}), Object.assign(i.prototype, {
						isVector3: true,
						set: function(a, b, c) {
							return this.x = a, this.y = b, this.z = c, this
						},
						setScalar: function(a) {
							return this.z = this.y = this.x = a, this
						},
						setX: function(a) {
							return this.x = a, this
						},
						setY: function(a) {
							return this.y = a, this
						},
						setZ: function(a) {
							return this.z = a, this
						},
						setComponent: function(a, b) {
							switch (a) {
								case 0:
									this.x = b;
									break;
								case 1:
									this.y = b;
									break;
								case 2:
									this.z = b;
									break;
								default:
									throw Error("index is out of range: " + a)
							}
							return this
						},
						getComponent: function(a) {
							switch (a) {
								case 0:
									return this.x;
								case 1:
									return this.y;
								case 2:
									return this.z;
								default:
									throw Error("index is out of range: " + a)
							}
						},
						clone: function() {
							return new this.constructor(this.x, this.y, this.z)
						},
						copy: function(a) {
							return this.x = a.x, this.y = a.y, this.z = a.z, this
						},
						add: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this)
						},
						addScalar: function(a) {
							return this.x += a, this.y += a, this.z += a, this
						},
						addVectors: function(a, b) {
							return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
						},
						addScaledVector: function(a, b) {
							return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this
						},
						sub: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this)
						},
						subScalar: function(a) {
							return this.x -= a, this.y -= a, this.z -= a, this
						},
						subVectors: function(a, b) {
							return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
						},
						multiply: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this)
						},
						multiplyScalar: function(a) {
							return this.x *= a, this.y *= a, this.z *= a, this
						},
						multiplyVectors: function(a, b) {
							return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
						},
						applyEuler: function() {
							var a = new h;
							return function(b) {
								return false === (b && b.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(a.setFromEuler(b))
							}
						}(),
						applyAxisAngle: function() {
							var a = new h;
							return function(b, c) {
								return this.applyQuaternion(a.setFromAxisAngle(b, c))
							}
						}(),
						applyMatrix3: function(a) {
							var b = this.x,
								c = this.y,
								d = this.z;
							return a = a.elements, this.x = a[0] * b + a[3] * c + a[6] * d, this.y = a[1] * b + a[4] * c + a[7] * d, this.z = a[2] * b + a[5] * c + a[8] * d, this
						},
						applyMatrix4: function(a) {
							var b = this.x,
								c = this.y,
								d = this.z;
							return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12], this.y = a[1] * b + a[5] * c + a[9] * d + a[13], this.z = a[2] * b + a[6] * c + a[10] * d + a[14], this.divideScalar(a[3] * b + a[7] * c + a[11] * d + a[15])
						},
						applyQuaternion: function(a) {
							var b = this.x,
								c = this.y,
								d = this.z,
								e = a.x,
								f = a.y,
								g = a.z;
							a = a.w;
							var h = a * b + f * d - g * c,
								i = a * c + g * b - e * d,
								j = a * d + e * c - f * b,
								b = -e * b - f * c - g * d;
							return this.x = h * a + b * -e + i * -g - j * -f, this.y = i * a + b * -f + j * -e - h * -g, this.z = j * a + b * -g + h * -f - i * -e, this
						},
						project: function() {
							var a = new j;
							return function(b) {
								return a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), this.applyMatrix4(a)
							}
						}(),
						unproject: function() {
							var a = new j;
							return function(b) {
								return a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), this.applyMatrix4(a)
							}
						}(),
						transformDirection: function(a) {
							var b = this.x,
								c = this.y,
								d = this.z;
							return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d, this.y = a[1] * b + a[5] * c + a[9] * d, this.z = a[2] * b + a[6] * c + a[10] * d, this.normalize()
						},
						divide: function(a) {
							return this.x /= a.x, this.y /= a.y, this.z /= a.z, this
						},
						divideScalar: function(a) {
							return this.multiplyScalar(1 / a)
						},
						min: function(a) {
							return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this
						},
						max: function(a) {
							return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this
						},
						clamp: function(a, b) {
							return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this
						},
						clampScalar: function() {
							var a = new i,
								b = new i;
							return function(c, d) {
								return a.set(c, c, c), b.set(d, d, d), this.clamp(a, b)
							}
						}(),
						clampLength: function(a, b) {
							var c = this.length();
							return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
						},
						floor: function() {
							return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
						},
						ceil: function() {
							return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
						},
						round: function() {
							return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
						},
						roundToZero: function() {
							return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
						},
						negate: function() {
							return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
						},
						dot: function(a) {
							return this.x * a.x + this.y * a.y + this.z * a.z
						},
						lengthSq: function() {
							return this.x * this.x + this.y * this.y + this.z * this.z
						},
						length: function() {
							return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
						},
						lengthManhattan: function() {
							return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
						},
						normalize: function() {
							return this.divideScalar(this.length())
						},
						setLength: function(a) {
							return this.multiplyScalar(a / this.length())
						},
						lerp: function(a, b) {
							return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this
						},
						lerpVectors: function(a, b, c) {
							return this.subVectors(b, a).multiplyScalar(c).add(a)
						},
						cross: function(a, b) {
							if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
							var c = this.x,
								d = this.y,
								e = this.z;
							return this.x = d * a.z - e * a.y, this.y = e * a.x - c * a.z, this.z = c * a.y - d * a.x, this
						},
						crossVectors: function(a, b) {
							var c = a.x,
								d = a.y,
								e = a.z,
								f = b.x,
								g = b.y,
								h = b.z;
							return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this
						},
						projectOnVector: function(a) {
							var b = a.dot(this) / a.lengthSq();
							return this.copy(a).multiplyScalar(b)
						},
						projectOnPlane: function() {
							var a = new i;
							return function(b) {
								return a.copy(this).projectOnVector(b), this.sub(a)
							}
						}(),
						reflect: function() {
							var a = new i;
							return function(b) {
								return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
							}
						}(),
						angleTo: function(a) {
							return a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq()), Math.acos(re.clamp(a, -1, 1))
						},
						distanceTo: function(a) {
							return Math.sqrt(this.distanceToSquared(a))
						},
						distanceToSquared: function(a) {
							var b = this.x - a.x,
								c = this.y - a.y;
							return a = this.z - a.z, b * b + c * c + a * a
						},
						distanceToManhattan: function(a) {
							return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
						},
						setFromSpherical: function(a) {
							var b = Math.sin(a.phi) * a.radius;
							return this.x = b * Math.sin(a.theta), this.y = Math.cos(a.phi) * a.radius, this.z = b * Math.cos(a.theta), this
						},
						setFromCylindrical: function(a) {
							return this.x = a.radius * Math.sin(a.theta), this.y = a.y, this.z = a.radius * Math.cos(a.theta), this
						},
						setFromMatrixPosition: function(a) {
							return this.setFromMatrixColumn(a, 3)
						},
						setFromMatrixScale: function(a) {
							var b = this.setFromMatrixColumn(a, 0).length(),
								c = this.setFromMatrixColumn(a, 1).length();
							return a = this.setFromMatrixColumn(a, 2).length(), this.x = b, this.y = c, this.z = a, this
						},
						setFromMatrixColumn: function(a, b) {
							return this.fromArray(a.elements, 4 * b)
						},
						equals: function(a) {
							return a.x === this.x && a.y === this.y && a.z === this.z
						},
						fromArray: function(a, b) {
							return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this
						},
						toArray: function(a, b) {
							return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a
						},
						fromBufferAttribute: function(a, b, c) {
							return void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this
						}
					}), Object.assign(j.prototype, {
						isMatrix4: true,
						set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
							var q = this.elements;
							return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, this
						},
						identity: function() {
							return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
						},
						clone: function() {
							return (new j).fromArray(this.elements)
						},
						copy: function(a) {
							var b = this.elements;
							return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], this
						},
						copyPosition: function(a) {
							var b = this.elements;
							return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this
						},
						extractBasis: function(a, b, c) {
							return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), this
						},
						makeBasis: function(a, b, c) {
							return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), this
						},
						extractRotation: function() {
							var a = new i;
							return function(b) {
								var c = this.elements,
									d = b.elements,
									e = 1 / a.setFromMatrixColumn(b, 0).length(),
									f = 1 / a.setFromMatrixColumn(b, 1).length();
								return b = 1 / a.setFromMatrixColumn(b, 2).length(), c[0] = d[0] * e, c[1] = d[1] * e, c[2] = d[2] * e, c[4] = d[4] * f, c[5] = d[5] * f, c[6] = d[6] * f, c[8] = d[8] * b, c[9] = d[9] * b, c[10] = d[10] * b, this
							}
						}(),
						makeRotationFromEuler: function(a) {
							false === (a && a.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
							var b = this.elements,
								c = a.x,
								d = a.y,
								e = a.z,
								f = Math.cos(c),
								c = Math.sin(c),
								g = Math.cos(d),
								d = Math.sin(d),
								h = Math.cos(e),
								e = Math.sin(e);
							if ("XYZ" === a.order) {
								a = f * h;
								var i = f * e,
									j = c * h,
									k = c * e;
								b[0] = g * h, b[4] = -g * e, b[8] = d, b[1] = i + j * d, b[5] = a - k * d, b[9] = -c * g, b[2] = k - a * d, b[6] = j + i * d, b[10] = f * g
							} else "YXZ" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a + k * c, b[4] = j * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = i * c - j, b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = j + i * c, b[1] = i + j * c, b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, i = f * e, j = c * h, k = c * e, b[0] = g * h, b[4] = j * d - i, b[8] = a * d + k, b[1] = g * e, b[5] = k * d + a, b[9] = i * d - j, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = j * e + i, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = i * e + j, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, b[5] = f * h, b[9] = i * e - j, b[2] = j * e - i, b[6] = c * h, b[10] = k * e + a);
							return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
						},
						makeRotationFromQuaternion: function(a) {
							var b = this.elements,
								c = a._x,
								d = a._y,
								e = a._z,
								f = a._w,
								g = c + c,
								h = d + d,
								i = e + e;
							a = c * g;
							var j = c * h,
								c = c * i,
								k = d * h,
								d = d * i,
								e = e * i,
								g = f * g,
								h = f * h,
								f = f * i;
							return b[0] = 1 - (k + e), b[4] = j - f, b[8] = c + h, b[1] = j + f, b[5] = 1 - (a + e), b[9] = d - g, b[2] = c - h, b[6] = d + g, b[10] = 1 - (a + k), b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
						},
						lookAt: function() {
							var a = new i,
								b = new i,
								c = new i;
							return function(d, e, f) {
								var g = this.elements;
								return c.subVectors(d, e), 0 === c.lengthSq() && (c.z = 1), c.normalize(), a.crossVectors(f, c), 0 === a.lengthSq() && (c.z += 1e-4, a.crossVectors(f, c)), a.normalize(), b.crossVectors(c, a), g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, g[6] = b.z, g[10] = c.z, this
							}
						}(),
						multiply: function(a, b) {
							return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
						},
						premultiply: function(a) {
							return this.multiplyMatrices(a, this)
						},
						multiplyMatrices: function(a, b) {
							var c = a.elements,
								d = b.elements,
								e = this.elements,
								f = c[0],
								g = c[4],
								h = c[8],
								i = c[12],
								j = c[1],
								k = c[5],
								l = c[9],
								m = c[13],
								n = c[2],
								o = c[6],
								p = c[10],
								q = c[14],
								r = c[3],
								s = c[7],
								t = c[11],
								c = c[15],
								u = d[0],
								v = d[4],
								w = d[8],
								x = d[12],
								y = d[1],
								z = d[5],
								A = d[9],
								B = d[13],
								C = d[2],
								D = d[6],
								E = d[10],
								F = d[14],
								G = d[3],
								H = d[7],
								I = d[11],
								d = d[15];
							return e[0] = f * u + g * y + h * C + i * G, e[4] = f * v + g * z + h * D + i * H, e[8] = f * w + g * A + h * E + i * I, e[12] = f * x + g * B + h * F + i * d, e[1] = j * u + k * y + l * C + m * G, e[5] = j * v + k * z + l * D + m * H, e[9] = j * w + k * A + l * E + m * I, e[13] = j * x + k * B + l * F + m * d, e[2] = n * u + o * y + p * C + q * G, e[6] = n * v + o * z + p * D + q * H, e[10] = n * w + o * A + p * E + q * I, e[14] = n * x + o * B + p * F + q * d, e[3] = r * u + s * y + t * C + c * G, e[7] = r * v + s * z + t * D + c * H, e[11] = r * w + s * A + t * E + c * I, e[15] = r * x + s * B + t * F + c * d, this
						},
						multiplyScalar: function(a) {
							var b = this.elements;
							return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, b[11] *= a, b[15] *= a, this
						},
						applyToBufferAttribute: function() {
							var a = new i;
							return function(b) {
								for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);
								return b
							}
						}(),
						determinant: function() {
							var a = this.elements,
								b = a[0],
								c = a[4],
								d = a[8],
								e = a[12],
								f = a[1],
								g = a[5],
								h = a[9],
								i = a[13],
								j = a[2],
								k = a[6],
								l = a[10],
								m = a[14];
							return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j)
						},
						transpose: function() {
							var a, b = this.elements;
							return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this
						},
						setPosition: function(a) {
							var b = this.elements;
							return b[12] = a.x, b[13] = a.y, b[14] = a.z, this
						},
						getInverse: function(a, b) {
							var c = this.elements,
								d = a.elements,
								e = d[0],
								f = d[1],
								g = d[2],
								h = d[3],
								i = d[4],
								j = d[5],
								k = d[6],
								l = d[7],
								m = d[8],
								n = d[9],
								o = d[10],
								p = d[11],
								q = d[12],
								r = d[13],
								s = d[14],
								d = d[15],
								t = n * s * l - r * o * l + r * k * p - j * s * p - n * k * d + j * o * d,
								u = q * o * l - m * s * l - q * k * p + i * s * p + m * k * d - i * o * d,
								v = m * r * l - q * n * l + q * j * p - i * r * p - m * j * d + i * n * d,
								w = q * n * k - m * r * k - q * j * o + i * r * o + m * j * s - i * n * s,
								x = e * t + f * u + g * v + h * w;
							if (0 === x) {
								if (true === b) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
								return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity()
							}
							return x = 1 / x, c[0] = t * x, c[1] = (r * o * h - n * s * h - r * g * p + f * s * p + n * g * d - f * o * d) * x, c[2] = (j * s * h - r * k * h + r * g * l - f * s * l - j * g * d + f * k * d) * x, c[3] = (n * k * h - j * o * h - n * g * l + f * o * l + j * g * p - f * k * p) * x, c[4] = u * x, c[5] = (m * s * h - q * o * h + q * g * p - e * s * p - m * g * d + e * o * d) * x, c[6] = (q * k * h - i * s * h - q * g * l + e * s * l + i * g * d - e * k * d) * x, c[7] = (i * o * h - m * k * h + m * g * l - e * o * l - i * g * p + e * k * p) * x, c[8] = v * x, c[9] = (q * n * h - m * r * h - q * f * p + e * r * p + m * f * d - e * n * d) * x, c[10] = (i * r * h - q * j * h + q * f * l - e * r * l - i * f * d + e * j * d) * x, c[11] = (m * j * h - i * n * h - m * f * l + e * n * l + i * f * p - e * j * p) * x, c[12] = w * x, c[13] = (m * r * g - q * n * g + q * f * o - e * r * o - m * f * s + e * n * s) * x, c[14] = (q * j * g - i * r * g - q * f * k + e * r * k + i * f * s - e * j * s) * x, c[15] = (i * n * g - m * j * g + m * f * k - e * n * k - i * f * o + e * j * o) * x, this
						},
						scale: function(a) {
							var b = this.elements,
								c = a.x,
								d = a.y;
							return a = a.z, b[0] *= c, b[4] *= d, b[8] *= a, b[1] *= c, b[5] *= d, b[9] *= a, b[2] *= c, b[6] *= d, b[10] *= a, b[3] *= c, b[7] *= d, b[11] *= a, this
						},
						getMaxScaleOnAxis: function() {
							var a = this.elements;
							return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
						},
						makeTranslation: function(a, b, c) {
							return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this
						},
						makeRotationX: function(a) {
							var b = Math.cos(a);
							return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), this
						},
						makeRotationY: function(a) {
							var b = Math.cos(a);
							return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), this
						},
						makeRotationZ: function(a) {
							var b = Math.cos(a);
							return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
						},
						makeRotationAxis: function(a, b) {
							var c = Math.cos(b),
								d = Math.sin(b),
								e = 1 - c,
								f = a.x,
								g = a.y,
								h = a.z,
								i = e * f,
								j = e * g;
							return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), this
						},
						makeScale: function(a, b, c) {
							return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this
						},
						makeShear: function(a, b, c) {
							return this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1), this
						},
						compose: function(a, b, c) {
							return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this
						},
						decompose: function() {
							var a = new i,
								b = new j;
							return function(c, d, e) {
								var f = this.elements,
									g = a.set(f[0], f[1], f[2]).length(),
									h = a.set(f[4], f[5], f[6]).length(),
									i = a.set(f[8], f[9], f[10]).length();
								0 > this.determinant() && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.copy(this), c = 1 / g;
								var f = 1 / h,
									j = 1 / i;
								return b.elements[0] *= c, b.elements[1] *= c, b.elements[2] *= c, b.elements[4] *= f, b.elements[5] *= f, b.elements[6] *= f, b.elements[8] *= j, b.elements[9] *= j, b.elements[10] *= j, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this
							}
						}(),
						makePerspective: function(a, b, c, d, e, f) {
							void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
							var g = this.elements;
							return g[0] = 2 * e / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, g[5] = 2 * e / (c - d), g[9] = (c + d) / (c - d), g[13] = 0, g[2] = 0, g[6] = 0, g[10] = -(f + e) / (f - e), g[14] = -2 * f * e / (f - e), g[3] = 0, g[7] = 0, g[11] = -1, g[15] = 0, this
						},
						makeOrthographic: function(a, b, c, d, e, f) {
							var g = this.elements,
								h = 1 / (b - a),
								i = 1 / (c - d),
								j = 1 / (f - e);
							return g[0] = 2 * h, g[4] = 0, g[8] = 0, g[12] = -((b + a) * h), g[1] = 0, g[5] = 2 * i, g[9] = 0, g[13] = -((c + d) * i), g[2] = 0, g[6] = 0, g[10] = -2 * j, g[14] = -((f + e) * j), g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this
						},
						equals: function(a) {
							var b = this.elements;
							a = a.elements;
							for (var c = 0; 16 > c; c++)
								if (b[c] !== a[c]) return false;
							return true
						},
						fromArray: function(a, b) {
							void 0 === b && (b = 0);
							for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
							return this
						},
						toArray: function(a, b) {
							void 0 === a && (a = []), void 0 === b && (b = 0);
							var c = this.elements;
							return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], a[b + 15] = c[15], a
						}
					}), k.prototype = Object.create(d.prototype), k.prototype.constructor = k, k.prototype.isDataTexture = true, l.prototype = Object.create(d.prototype), l.prototype.constructor = l, l.prototype.isCubeTexture = true, Object.defineProperty(l.prototype, "images", {
						get: function() {
							return this.image
						},
						set: function(a) {
							this.image = a
						}
					});
					var te = new d,
						ue = new l,
						ve = [],
						we = [],
						xe = new Float32Array(16),
						ye = new Float32Array(9);
					P.prototype.setValue = function(a, b) {
						for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
							var f = c[d];
							f.setValue(a, b[f.id])
						}
					};
					var ze = /([\w\d_]+)(\])?(\[|\.)?/g;
					Q.prototype.setValue = function(a, b, c) {
						b = this.map[b], void 0 !== b && b.setValue(a, c, this.renderer)
					}, Q.prototype.setOptional = function(a, b, c) {
						b = b[c], void 0 !== b && this.setValue(a, c, b)
					}, Q.upload = function(a, b, c, d) {
						for (var e = 0, f = b.length; e !== f; ++e) {
							var g = b[e],
								h = c[g.id];
							false !== h.needsUpdate && g.setValue(a, h.value, d)
						}
					}, Q.seqWithValue = function(a, b) {
						for (var c = [], d = 0, e = a.length; d !== e; ++d) {
							var f = a[d];
							f.id in b && c.push(f)
						}
						return c
					};
					var Ae = {
						aliceblue: 15792383,
						antiquewhite: 16444375,
						aqua: 65535,
						aquamarine: 8388564,
						azure: 15794175,
						beige: 16119260,
						bisque: 16770244,
						black: 0,
						blanchedalmond: 16772045,
						blue: 255,
						blueviolet: 9055202,
						brown: 10824234,
						burlywood: 14596231,
						cadetblue: 6266528,
						chartreuse: 8388352,
						chocolate: 13789470,
						coral: 16744272,
						cornflowerblue: 6591981,
						cornsilk: 16775388,
						crimson: 14423100,
						cyan: 65535,
						darkblue: 139,
						darkcyan: 35723,
						darkgoldenrod: 12092939,
						darkgray: 11119017,
						darkgreen: 25600,
						darkgrey: 11119017,
						darkkhaki: 12433259,
						darkmagenta: 9109643,
						darkolivegreen: 5597999,
						darkorange: 16747520,
						darkorchid: 10040012,
						darkred: 9109504,
						darksalmon: 15308410,
						darkseagreen: 9419919,
						darkslateblue: 4734347,
						darkslategray: 3100495,
						darkslategrey: 3100495,
						darkturquoise: 52945,
						darkviolet: 9699539,
						deeppink: 16716947,
						deepskyblue: 49151,
						dimgray: 6908265,
						dimgrey: 6908265,
						dodgerblue: 2003199,
						firebrick: 11674146,
						floralwhite: 16775920,
						forestgreen: 2263842,
						fuchsia: 16711935,
						gainsboro: 14474460,
						ghostwhite: 16316671,
						gold: 16766720,
						goldenrod: 14329120,
						gray: 8421504,
						green: 32768,
						greenyellow: 11403055,
						grey: 8421504,
						honeydew: 15794160,
						hotpink: 16738740,
						indianred: 13458524,
						indigo: 4915330,
						ivory: 16777200,
						khaki: 15787660,
						lavender: 15132410,
						lavenderblush: 16773365,
						lawngreen: 8190976,
						lemonchiffon: 16775885,
						lightblue: 11393254,
						lightcoral: 15761536,
						lightcyan: 14745599,
						lightgoldenrodyellow: 16448210,
						lightgray: 13882323,
						lightgreen: 9498256,
						lightgrey: 13882323,
						lightpink: 16758465,
						lightsalmon: 16752762,
						lightseagreen: 2142890,
						lightskyblue: 8900346,
						lightslategray: 7833753,
						lightslategrey: 7833753,
						lightsteelblue: 11584734,
						lightyellow: 16777184,
						lime: 65280,
						limegreen: 3329330,
						linen: 16445670,
						magenta: 16711935,
						maroon: 8388608,
						mediumaquamarine: 6737322,
						mediumblue: 205,
						mediumorchid: 12211667,
						mediumpurple: 9662683,
						mediumseagreen: 3978097,
						mediumslateblue: 8087790,
						mediumspringgreen: 64154,
						mediumturquoise: 4772300,
						mediumvioletred: 13047173,
						midnightblue: 1644912,
						mintcream: 16121850,
						mistyrose: 16770273,
						moccasin: 16770229,
						navajowhite: 16768685,
						navy: 128,
						oldlace: 16643558,
						olive: 8421376,
						olivedrab: 7048739,
						orange: 16753920,
						orangered: 16729344,
						orchid: 14315734,
						palegoldenrod: 15657130,
						palegreen: 10025880,
						paleturquoise: 11529966,
						palevioletred: 14381203,
						papayawhip: 16773077,
						peachpuff: 16767673,
						peru: 13468991,
						pink: 16761035,
						plum: 14524637,
						powderblue: 11591910,
						purple: 8388736,
						red: 16711680,
						rosybrown: 12357519,
						royalblue: 4286945,
						saddlebrown: 9127187,
						salmon: 16416882,
						sandybrown: 16032864,
						seagreen: 3050327,
						seashell: 16774638,
						sienna: 10506797,
						silver: 12632256,
						skyblue: 8900331,
						slateblue: 6970061,
						slategray: 7372944,
						slategrey: 7372944,
						snow: 16775930,
						springgreen: 65407,
						steelblue: 4620980,
						tan: 13808780,
						teal: 32896,
						thistle: 14204888,
						tomato: 16737095,
						turquoise: 4251856,
						violet: 15631086,
						wheat: 16113331,
						white: 16777215,
						whitesmoke: 16119285,
						yellow: 16776960,
						yellowgreen: 10145074
					};
					Object.assign(R.prototype, {
						isColor: true,
						r: 1,
						g: 1,
						b: 1,
						set: function(a) {
							return a && a.isColor ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), this
						},
						setScalar: function(a) {
							return this.b = this.g = this.r = a, this
						},
						setHex: function(a) {
							return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, this.b = (255 & a) / 255, this
						},
						setRGB: function(a, b, c) {
							return this.r = a, this.g = b, this.b = c, this
						},
						setHSL: function() {
							function a(a, b, c) {
								return 0 > c && (c += 1), 1 < c && --c, c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
							}
							return function(b, c, d) {
								return b = re.euclideanModulo(b, 1), c = re.clamp(c, 0, 1), d = re.clamp(d, 0, 1), 0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3)), this
							}
						}(),
						setStyle: function(a) {
							function b(b) {
								void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
							}
							var c;
							if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
								var d = c[2];
								switch (c[1]) {
									case "rgb":
									case "rgba":
										if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
										if (c = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
										break;
									case "hsl":
									case "hsla":
										if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
											var d = parseFloat(c[1]) / 360,
												e = parseInt(c[2], 10) / 100,
												f = parseInt(c[3], 10) / 100;
											return b(c[5]), this.setHSL(d, e, f)
										}
								}
							} else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
								if (c = c[1], d = c.length, 3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
								if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
							}
							return a && 0 < a.length && (c = Ae[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a)), this
						},
						clone: function() {
							return new this.constructor(this.r, this.g, this.b)
						},
						copy: function(a) {
							return this.r = a.r, this.g = a.g, this.b = a.b, this
						},
						copyGammaToLinear: function(a, b) {
							return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this
						},
						copyLinearToGamma: function(a, b) {
							void 0 === b && (b = 2);
							var c = 0 < b ? 1 / b : 1;
							return this.r = Math.pow(a.r, c), this.g = Math.pow(a.g, c), this.b = Math.pow(a.b, c), this
						},
						convertGammaToLinear: function() {
							var a = this.r,
								b = this.g,
								c = this.b;
							return this.r = a * a, this.g = b * b, this.b = c * c, this
						},
						convertLinearToGamma: function() {
							return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
						},
						getHex: function() {
							return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
						},
						getHexString: function() {
							return ("000000" + this.getHex().toString(16)).slice(-6)
						},
						getHSL: function(a) {
							a = a || {
								h: 0,
								s: 0,
								l: 0
							};
							var b, c = this.r,
								d = this.g,
								e = this.b,
								f = Math.max(c, d, e),
								g = Math.min(c, d, e),
								h = (g + f) / 2;
							if (g === f) g = b = 0;
							else {
								var i = f - g,
									g = .5 >= h ? i / (f + g) : i / (2 - f - g);
								switch (f) {
									case c:
										b = (d - e) / i + (d < e ? 6 : 0);
										break;
									case d:
										b = (e - c) / i + 2;
										break;
									case e:
										b = (c - d) / i + 4
								}
								b /= 6
							}
							return a.h = b, a.s = g, a.l = h, a
						},
						getStyle: function() {
							return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
						},
						offsetHSL: function(a, b, c) {
							var d = this.getHSL();
							return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this
						},
						add: function(a) {
							return this.r += a.r, this.g += a.g, this.b += a.b, this
						},
						addColors: function(a, b) {
							return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this
						},
						addScalar: function(a) {
							return this.r += a, this.g += a, this.b += a, this
						},
						sub: function(a) {
							return this.r = Math.max(0, this.r - a.r), this.g = Math.max(0, this.g - a.g), this.b = Math.max(0, this.b - a.b), this
						},
						multiply: function(a) {
							return this.r *= a.r, this.g *= a.g, this.b *= a.b, this
						},
						multiplyScalar: function(a) {
							return this.r *= a, this.g *= a, this.b *= a, this
						},
						lerp: function(a, b) {
							return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, this
						},
						equals: function(a) {
							return a.r === this.r && a.g === this.g && a.b === this.b
						},
						fromArray: function(a, b) {
							return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], this
						},
						toArray: function(a, b) {
							return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b, a
						},
						toJSON: function() {
							return this.getHex()
						}
					});
					var Be = {
							common: {
								diffuse: {
									value: new R(15658734)
								},
								opacity: {
									value: 1
								},
								map: {
									value: null
								},
								offsetRepeat: {
									value: new e(0, 0, 1, 1)
								},
								specularMap: {
									value: null
								},
								alphaMap: {
									value: null
								},
								envMap: {
									value: null
								},
								flipEnvMap: {
									value: -1
								},
								reflectivity: {
									value: 1
								},
								refractionRatio: {
									value: .98
								}
							},
							aomap: {
								aoMap: {
									value: null
								},
								aoMapIntensity: {
									value: 1
								}
							},
							lightmap: {
								lightMap: {
									value: null
								},
								lightMapIntensity: {
									value: 1
								}
							},
							emissivemap: {
								emissiveMap: {
									value: null
								}
							},
							bumpmap: {
								bumpMap: {
									value: null
								},
								bumpScale: {
									value: 1
								}
							},
							normalmap: {
								normalMap: {
									value: null
								},
								normalScale: {
									value: new c(1, 1)
								}
							},
							displacementmap: {
								displacementMap: {
									value: null
								},
								displacementScale: {
									value: 1
								},
								displacementBias: {
									value: 0
								}
							},
							roughnessmap: {
								roughnessMap: {
									value: null
								}
							},
							metalnessmap: {
								metalnessMap: {
									value: null
								}
							},
							gradientmap: {
								gradientMap: {
									value: null
								}
							},
							fog: {
								fogDensity: {
									value: 25e-5
								},
								fogNear: {
									value: 1
								},
								fogFar: {
									value: 2e3
								},
								fogColor: {
									value: new R(16777215)
								}
							},
							lights: {
								ambientLightColor: {
									value: []
								},
								directionalLights: {
									value: [],
									properties: {
										direction: {},
										color: {},
										shadow: {},
										shadowBias: {},
										shadowRadius: {},
										shadowMapSize: {}
									}
								},
								directionalShadowMap: {
									value: []
								},
								directionalShadowMatrix: {
									value: []
								},
								spotLights: {
									value: [],
									properties: {
										color: {},
										position: {},
										direction: {},
										distance: {},
										coneCos: {},
										penumbraCos: {},
										decay: {},
										shadow: {},
										shadowBias: {},
										shadowRadius: {},
										shadowMapSize: {}
									}
								},
								spotShadowMap: {
									value: []
								},
								spotShadowMatrix: {
									value: []
								},
								pointLights: {
									value: [],
									properties: {
										color: {},
										position: {},
										decay: {},
										distance: {},
										shadow: {},
										shadowBias: {},
										shadowRadius: {},
										shadowMapSize: {}
									}
								},
								pointShadowMap: {
									value: []
								},
								pointShadowMatrix: {
									value: []
								},
								hemisphereLights: {
									value: [],
									properties: {
										direction: {},
										skyColor: {},
										groundColor: {}
									}
								},
								rectAreaLights: {
									value: [],
									properties: {
										color: {},
										position: {},
										width: {},
										height: {}
									}
								}
							},
							points: {
								diffuse: {
									value: new R(15658734)
								},
								opacity: {
									value: 1
								},
								size: {
									value: 1
								},
								scale: {
									value: 1
								},
								map: {
									value: null
								},
								offsetRepeat: {
									value: new e(0, 0, 1, 1)
								}
							}
						},
						Ce = {
							merge: function(a) {
								for (var b = {}, c = 0; c < a.length; c++) {
									var d, e = this.clone(a[c]);
									for (d in e) b[d] = e[d]
								}
								return b
							},
							clone: function(a) {
								var b, c = {};
								for (b in a) {
									c[b] = {};
									for (var d in a[b]) {
										var e = a[b][d];
										e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? c[b][d] = e.clone() : Array.isArray(e) ? c[b][d] = e.slice() : c[b][d] = e
									}
								}
								return c
							}
						},
						De = {
							alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
							alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
							alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
							aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
							aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
							begin_vertex: "\nvec3 transformed = vec3( position );\n",
							beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
							bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
							bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
							clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
							clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
							clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
							clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
							color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
							color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
							color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
							color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
							common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
							cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
							defaultnormal_vertex: "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
							displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
							displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
							emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
							emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
							encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
							encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
							envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
							envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
							envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
							envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
							fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
							fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
							fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
							fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
							gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
							lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
							lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
							lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
							lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
							lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
							lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
							lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
							lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
							lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
							logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
							logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
							logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
							logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
							map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
							map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
							map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
							map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
							metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
							metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
							morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
							morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
							morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
							normal_flip: "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
							normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
							normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
							packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
							premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
							project_vertex: "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
							dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
							dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
							roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
							roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
							shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
							shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
							shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
							shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
							skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
							skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
							skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
							skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
							specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
							specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
							tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
							tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
							uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
							uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
							uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
							uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
							uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
							uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
							worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
							cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
							cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
							depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
							depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
							distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
							distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
							equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
							equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
							linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
							linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
							meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
							meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
							meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
							meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
							meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
							meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
							meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
							meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
							normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
							normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
							points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
							points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
							shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
							shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
						},
						Ee = {
							basic: {
								uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.fog]),
								vertexShader: De.meshbasic_vert,
								fragmentShader: De.meshbasic_frag
							},
							lambert: {
								uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.emissivemap, Be.fog, Be.lights, {
									emissive: {
										value: new R(0)
									}
								}]),
								vertexShader: De.meshlambert_vert,
								fragmentShader: De.meshlambert_frag
							},
							phong: {
								uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.gradientmap, Be.fog, Be.lights, {
									emissive: {
										value: new R(0)
									},
									specular: {
										value: new R(1118481)
									},
									shininess: {
										value: 30
									}
								}]),
								vertexShader: De.meshphong_vert,
								fragmentShader: De.meshphong_frag
							},
							standard: {
								uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.roughnessmap, Be.metalnessmap, Be.fog, Be.lights, {
									emissive: {
										value: new R(0)
									},
									roughness: {
										value: .5
									},
									metalness: {
										value: .5
									},
									envMapIntensity: {
										value: 1
									}
								}]),
								vertexShader: De.meshphysical_vert,
								fragmentShader: De.meshphysical_frag
							},
							points: {
								uniforms: Ce.merge([Be.points, Be.fog]),
								vertexShader: De.points_vert,
								fragmentShader: De.points_frag
							},
							dashed: {
								uniforms: Ce.merge([Be.common, Be.fog, {
									scale: {
										value: 1
									},
									dashSize: {
										value: 1
									},
									totalSize: {
										value: 2
									}
								}]),
								vertexShader: De.linedashed_vert,
								fragmentShader: De.linedashed_frag
							},
							depth: {
								uniforms: Ce.merge([Be.common, Be.displacementmap]),
								vertexShader: De.depth_vert,
								fragmentShader: De.depth_frag
							},
							normal: {
								uniforms: Ce.merge([Be.common, Be.bumpmap, Be.normalmap, Be.displacementmap, {
									opacity: {
										value: 1
									}
								}]),
								vertexShader: De.normal_vert,
								fragmentShader: De.normal_frag
							},
							cube: {
								uniforms: {
									tCube: {
										value: null
									},
									tFlip: {
										value: -1
									},
									opacity: {
										value: 1
									}
								},
								vertexShader: De.cube_vert,
								fragmentShader: De.cube_frag
							},
							equirect: {
								uniforms: {
									tEquirect: {
										value: null
									},
									tFlip: {
										value: -1
									}
								},
								vertexShader: De.equirect_vert,
								fragmentShader: De.equirect_frag
							},
							distanceRGBA: {
								uniforms: {
									lightPos: {
										value: new i
									}
								},
								vertexShader: De.distanceRGBA_vert,
								fragmentShader: De.distanceRGBA_frag
							}
						};
					Ee.physical = {
						uniforms: Ce.merge([Ee.standard.uniforms, {
							clearCoat: {
								value: 0
							},
							clearCoatRoughness: {
								value: 0
							}
						}]),
						vertexShader: De.meshphysical_vert,
						fragmentShader: De.meshphysical_frag
					}, Object.assign(S.prototype, {
						set: function(a, b) {
							return this.min.copy(a), this.max.copy(b), this
						},
						setFromPoints: function(a) {
							this.makeEmpty();
							for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
							return this
						},
						setFromCenterAndSize: function() {
							var a = new c;
							return function(b, c) {
								var d = a.copy(c).multiplyScalar(.5);
								return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
							}
						}(),
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.min.copy(a.min), this.max.copy(a.max), this
						},
						makeEmpty: function() {
							return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this
						},
						isEmpty: function() {
							return this.max.x < this.min.x || this.max.y < this.min.y
						},
						getCenter: function(a) {
							return a = a || new c, this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
						},
						getSize: function(a) {
							return a = a || new c, this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
						},
						expandByPoint: function(a) {
							return this.min.min(a), this.max.max(a), this
						},
						expandByVector: function(a) {
							return this.min.sub(a), this.max.add(a), this
						},
						expandByScalar: function(a) {
							return this.min.addScalar(-a), this.max.addScalar(a), this
						},
						containsPoint: function(a) {
							return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y)
						},
						containsBox: function(a) {
							return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
						},
						getParameter: function(a, b) {
							return (b || new c).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
						},
						intersectsBox: function(a) {
							return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y)
						},
						clampPoint: function(a, b) {
							return (b || new c).copy(a).clamp(this.min, this.max)
						},
						distanceToPoint: function() {
							var a = new c;
							return function(b) {
								return a.copy(b).clamp(this.min, this.max).sub(b).length()
							}
						}(),
						intersect: function(a) {
							return this.min.max(a.min), this.max.min(a.max), this
						},
						union: function(a) {
							return this.min.min(a.min), this.max.max(a.max), this
						},
						translate: function(a) {
							return this.min.add(a), this.max.add(a), this
						},
						equals: function(a) {
							return a.min.equals(this.min) && a.max.equals(this.max)
						}
					});
					var Fe = 0;
					Object.assign(V.prototype, b.prototype, {
						isMaterial: true,
						setValues: function(a) {
							if (void 0 !== a)
								for (var b in a) {
									var c = a[b];
									if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
									else {
										var d = this[b];
										void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c
									}
								}
						},
						toJSON: function(a) {
							function b(a) {
								var b, c = [];
								for (b in a) {
									var d = a[b];
									delete d.metadata, c.push(d)
								}
								return c
							}
							var c = void 0 === a;
							c && (a = {
								textures: {},
								images: {}
							});
							var d = {
								metadata: {
									version: 4.5,
									type: "Material",
									generator: "Material.toJSON"
								}
							};
							return d.uuid = this.uuid, d.type = this.type, "" !== this.name && (d.name = this.name), this.color && this.color.isColor && (d.color = this.color.getHex()), void 0 !== this.roughness && (d.roughness = this.roughness), void 0 !== this.metalness && (d.metalness = this.metalness), this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (d.specular = this.specular.getHex()), void 0 !== this.shininess && (d.shininess = this.shininess), void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid), this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid), this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid), this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid), this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid), this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid), this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid), this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid), void 0 !== this.size && (d.size = this.size), void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (d.blending = this.blending), 2 !== this.shading && (d.shading = this.shading), 0 !== this.side && (d.side = this.side), 0 !== this.vertexColors && (d.vertexColors = this.vertexColors), 1 > this.opacity && (d.opacity = this.opacity), true === this.transparent && (d.transparent = this.transparent), d.depthFunc = this.depthFunc, d.depthTest = this.depthTest, d.depthWrite = this.depthWrite, 0 < this.alphaTest && (d.alphaTest = this.alphaTest), true === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (d.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin), d.skinning = this.skinning, d.morphTargets = this.morphTargets, d.dithering = this.dithering, c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)), d
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							this.name = a.name, this.fog = a.fog, this.lights = a.lights, this.blending = a.blending, this.side = a.side, this.shading = a.shading, this.vertexColors = a.vertexColors, this.opacity = a.opacity, this.transparent = a.transparent, this.blendSrc = a.blendSrc, this.blendDst = a.blendDst, this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, this.blendDstAlpha = a.blendDstAlpha, this.blendEquationAlpha = a.blendEquationAlpha, this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, this.depthWrite = a.depthWrite, this.colorWrite = a.colorWrite, this.precision = a.precision, this.polygonOffset = a.polygonOffset, this.polygonOffsetFactor = a.polygonOffsetFactor, this.polygonOffsetUnits = a.polygonOffsetUnits, this.dithering = a.dithering, this.alphaTest = a.alphaTest, this.premultipliedAlpha = a.premultipliedAlpha, this.overdraw = a.overdraw, this.visible = a.visible, this.clipShadows = a.clipShadows, this.clipIntersection = a.clipIntersection, a = a.clippingPlanes;
							var b = null;
							if (null !== a)
								for (var c = a.length, b = Array(c), d = 0; d !== c; ++d) b[d] = a[d].clone();
							return this.clippingPlanes = b, this
						},
						dispose: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = true, W.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.fragmentShader = a.fragmentShader, this.vertexShader = a.vertexShader, this.uniforms = Ce.clone(a.uniforms), this.defines = a.defines, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.lights = a.lights, this.clipping = a.clipping, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this.extensions = a.extensions, this
					}, W.prototype.toJSON = function(a) {
						return a = V.prototype.toJSON.call(this, a), a.uniforms = this.uniforms, a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader, a
					}, X.prototype = Object.create(V.prototype), X.prototype.constructor = X, X.prototype.isMeshDepthMaterial = true, X.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.depthPacking = a.depthPacking, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this
					}, Object.assign(Y.prototype, {
						isBox3: true,
						set: function(a, b) {
							return this.min.copy(a), this.max.copy(b), this
						},
						setFromArray: function(a) {
							for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.length; h < i; h += 3) {
								var j = a[h],
									k = a[h + 1],
									l = a[h + 2];
								j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), l > g && (g = l)
							}
							return this.min.set(b, c, d), this.max.set(e, f, g), this
						},
						setFromBufferAttribute: function(a) {
							for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.count; h < i; h++) {
								var j = a.getX(h),
									k = a.getY(h),
									l = a.getZ(h);
								j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), l > g && (g = l)
							}
							return this.min.set(b, c, d), this.max.set(e, f, g), this
						},
						setFromPoints: function(a) {
							this.makeEmpty();
							for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
							return this
						},
						setFromCenterAndSize: function() {
							var a = new i;
							return function(b, c) {
								var d = a.copy(c).multiplyScalar(.5);
								return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
							}
						}(),
						setFromObject: function(a) {
							return this.makeEmpty(), this.expandByObject(a)
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.min.copy(a.min), this.max.copy(a.max), this
						},
						makeEmpty: function() {
							return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), this
						},
						isEmpty: function() {
							return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
						},
						getCenter: function(a) {
							return a = a || new i, this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
						},
						getSize: function(a) {
							return a = a || new i, this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
						},
						expandByPoint: function(a) {
							return this.min.min(a), this.max.max(a), this
						},
						expandByVector: function(a) {
							return this.min.sub(a), this.max.add(a), this
						},
						expandByScalar: function(a) {
							return this.min.addScalar(-a), this.max.addScalar(a), this
						},
						expandByObject: function() {
							var a = new i;
							return function(b) {
								var c = this;
								return b.updateMatrixWorld(true), b.traverse(function(b) {
									var d, e;
									if (d = b.geometry, void 0 !== d)
										if (d.isGeometry) {
											var f = d.vertices;
											for (d = 0, e = f.length; d < e; d++) a.copy(f[d]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
										} else if (d.isBufferGeometry && (f = d.attributes.position, void 0 !== f))
										for (d = 0, e = f.count; d < e; d++) a.fromBufferAttribute(f, d).applyMatrix4(b.matrixWorld), c.expandByPoint(a)
								}), this
							}
						}(),
						containsPoint: function(a) {
							return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z)
						},
						containsBox: function(a) {
							return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
						},
						getParameter: function(a, b) {
							return (b || new i).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
						},
						intersectsBox: function(a) {
							return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z)
						},
						intersectsSphere: function() {
							var a = new i;
							return function(b) {
								return this.clampPoint(b.center, a), a.distanceToSquared(b.center) <= b.radius * b.radius
							}
						}(),
						intersectsPlane: function(a) {
							var b, c;
							return 0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x), 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y), 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z), b <= a.constant && c >= a.constant
						},
						clampPoint: function(a, b) {
							return (b || new i).copy(a).clamp(this.min, this.max)
						},
						distanceToPoint: function() {
							var a = new i;
							return function(b) {
								return a.copy(b).clamp(this.min, this.max).sub(b).length()
							}
						}(),
						getBoundingSphere: function() {
							var a = new i;
							return function(b) {
								return b = b || new Z, this.getCenter(b.center), b.radius = .5 * this.getSize(a).length(), b
							}
						}(),
						intersect: function(a) {
							return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), this
						},
						union: function(a) {
							return this.min.min(a.min), this.max.max(a.max), this
						},
						applyMatrix4: function() {
							var a = [new i, new i, new i, new i, new i, new i, new i, new i];
							return function(b) {
								return this.isEmpty() ? this : (a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), this.setFromPoints(a), this)
							}
						}(),
						translate: function(a) {
							return this.min.add(a), this.max.add(a), this
						},
						equals: function(a) {
							return a.min.equals(this.min) && a.max.equals(this.max)
						}
					}), Object.assign(Z.prototype, {
						set: function(a, b) {
							return this.center.copy(a), this.radius = b, this
						},
						setFromPoints: function() {
							var a = new Y;
							return function(b, c) {
								var d = this.center;
								void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
								for (var e = 0, f = 0, g = b.length; f < g; f++) e = Math.max(e, d.distanceToSquared(b[f]));
								return this.radius = Math.sqrt(e), this
							}
						}(),
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.center.copy(a.center), this.radius = a.radius, this
						},
						empty: function() {
							return 0 >= this.radius
						},
						containsPoint: function(a) {
							return a.distanceToSquared(this.center) <= this.radius * this.radius
						},
						distanceToPoint: function(a) {
							return a.distanceTo(this.center) - this.radius
						},
						intersectsSphere: function(a) {
							var b = this.radius + a.radius;
							return a.center.distanceToSquared(this.center) <= b * b
						},
						intersectsBox: function(a) {
							return a.intersectsSphere(this)
						},
						intersectsPlane: function(a) {
							return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
						},
						clampPoint: function(a, b) {
							var c = this.center.distanceToSquared(a),
								d = b || new i;
							return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center)), d
						},
						getBoundingBox: function(a) {
							return a = a || new Y, a.set(this.center, this.center), a.expandByScalar(this.radius), a
						},
						applyMatrix4: function(a) {
							return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this
						},
						translate: function(a) {
							return this.center.add(a), this
						},
						equals: function(a) {
							return a.center.equals(this.center) && a.radius === this.radius
						}
					}), Object.assign($.prototype, {
						isMatrix3: true,
						set: function(a, b, c, d, e, f, g, h, i) {
							var j = this.elements;
							return j[0] = a, j[1] = d, j[2] = g, j[3] = b, j[4] = e, j[5] = h, j[6] = c, j[7] = f, j[8] = i, this
						},
						identity: function() {
							return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
						},
						clone: function() {
							return (new this.constructor).fromArray(this.elements)
						},
						copy: function(a) {
							var b = this.elements;
							return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], this
						},
						setFromMatrix4: function(a) {
							return a = a.elements, this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), this
						},
						applyToBufferAttribute: function() {
							var a = new i;
							return function(b) {
								for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);
								return b
							}
						}(),
						multiply: function(a) {
							return this.multiplyMatrices(this, a)
						},
						premultiply: function(a) {
							return this.multiplyMatrices(a, this)
						},
						multiplyMatrices: function(a, b) {
							var c = a.elements,
								d = b.elements,
								e = this.elements,
								f = c[0],
								g = c[3],
								h = c[6],
								i = c[1],
								j = c[4],
								k = c[7],
								l = c[2],
								m = c[5],
								c = c[8],
								n = d[0],
								o = d[3],
								p = d[6],
								q = d[1],
								r = d[4],
								s = d[7],
								t = d[2],
								u = d[5],
								d = d[8];
							return e[0] = f * n + g * q + h * t, e[3] = f * o + g * r + h * u, e[6] = f * p + g * s + h * d, e[1] = i * n + j * q + k * t, e[4] = i * o + j * r + k * u, e[7] = i * p + j * s + k * d, e[2] = l * n + m * q + c * t, e[5] = l * o + m * r + c * u, e[8] = l * p + m * s + c * d, this
						},
						multiplyScalar: function(a) {
							var b = this.elements;
							return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, b[5] *= a, b[8] *= a, this
						},
						determinant: function() {
							var a = this.elements,
								b = a[0],
								c = a[1],
								d = a[2],
								e = a[3],
								f = a[4],
								g = a[5],
								h = a[6],
								i = a[7],
								a = a[8];
							return b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h
						},
						getInverse: function(a, b) {
							a && a.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
							var c = a.elements,
								d = this.elements,
								e = c[0],
								f = c[1],
								g = c[2],
								h = c[3],
								i = c[4],
								j = c[5],
								k = c[6],
								l = c[7],
								c = c[8],
								m = c * i - j * l,
								n = j * k - c * h,
								o = l * h - i * k,
								p = e * m + f * n + g * o;
							if (0 === p) {
								if (true === b) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
								return console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity()
							}
							return p = 1 / p, d[0] = m * p, d[1] = (g * l - c * f) * p, d[2] = (j * f - g * i) * p, d[3] = n * p, d[4] = (c * e - g * k) * p, d[5] = (g * h - j * e) * p, d[6] = o * p, d[7] = (f * k - l * e) * p, d[8] = (i * e - f * h) * p, this
						},
						transpose: function() {
							var a, b = this.elements;
							return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], b[5] = b[7], b[7] = a, this
						},
						getNormalMatrix: function(a) {
							return this.setFromMatrix4(a).getInverse(this).transpose()
						},
						transposeIntoArray: function(a) {
							var b = this.elements;
							return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8], this
						},
						equals: function(a) {
							var b = this.elements;
							a = a.elements;
							for (var c = 0; 9 > c; c++)
								if (b[c] !== a[c]) return false;
							return true
						},
						fromArray: function(a, b) {
							void 0 === b && (b = 0);
							for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
							return this
						},
						toArray: function(a, b) {
							void 0 === a && (a = []), void 0 === b && (b = 0);
							var c = this.elements;
							return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a
						}
					}), Object.assign(_.prototype, {
						set: function(a, b) {
							return this.normal.copy(a), this.constant = b, this
						},
						setComponents: function(a, b, c, d) {
							return this.normal.set(a, b, c), this.constant = d, this
						},
						setFromNormalAndCoplanarPoint: function(a, b) {
							return this.normal.copy(a), this.constant = -b.dot(this.normal), this
						},
						setFromCoplanarPoints: function() {
							var a = new i,
								b = new i;
							return function(c, d, e) {
								return d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(), this.setFromNormalAndCoplanarPoint(d, c), this
							}
						}(),
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.normal.copy(a.normal), this.constant = a.constant, this
						},
						normalize: function() {
							var a = 1 / this.normal.length();
							return this.normal.multiplyScalar(a), this.constant *= a, this
						},
						negate: function() {
							return this.constant *= -1, this.normal.negate(), this
						},
						distanceToPoint: function(a) {
							return this.normal.dot(a) + this.constant
						},
						distanceToSphere: function(a) {
							return this.distanceToPoint(a.center) - a.radius
						},
						projectPoint: function(a, b) {
							return this.orthoPoint(a, b).sub(a).negate()
						},
						orthoPoint: function(a, b) {
							var c = this.distanceToPoint(a);
							return (b || new i).copy(this.normal).multiplyScalar(c)
						},
						intersectLine: function() {
							var a = new i;
							return function(b, c) {
								var d = c || new i,
									e = b.delta(a),
									f = this.normal.dot(e);
								return 0 !== f ? (f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)) : 0 === this.distanceToPoint(b.start) ? d.copy(b.start) : void 0
							}
						}(),
						intersectsLine: function(a) {
							var b = this.distanceToPoint(a.start);
							return a = this.distanceToPoint(a.end), 0 > b && 0 < a || 0 > a && 0 < b
						},
						intersectsBox: function(a) {
							return a.intersectsPlane(this)
						},
						intersectsSphere: function(a) {
							return a.intersectsPlane(this)
						},
						coplanarPoint: function(a) {
							return (a || new i).copy(this.normal).multiplyScalar(-this.constant)
						},
						applyMatrix4: function() {
							var a = new i,
								b = new $;
							return function(c, d) {
								var e = this.coplanarPoint(a).applyMatrix4(c),
									f = d || b.getNormalMatrix(c),
									f = this.normal.applyMatrix3(f).normalize();
								return this.constant = -e.dot(f), this
							}
						}(),
						translate: function(a) {
							return this.constant -= a.dot(this.normal), this
						},
						equals: function(a) {
							return a.normal.equals(this.normal) && a.constant === this.constant
						}
					}), Object.assign(aa.prototype, {
						set: function(a, b, c, d, e, f) {
							var g = this.planes;
							return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
							return this
						},
						setFromMatrix: function(a) {
							var b = this.planes,
								c = a.elements;
							a = c[0];
							var d = c[1],
								e = c[2],
								f = c[3],
								g = c[4],
								h = c[5],
								i = c[6],
								j = c[7],
								k = c[8],
								l = c[9],
								m = c[10],
								n = c[11],
								o = c[12],
								p = c[13],
								q = c[14],
								c = c[15];
							return b[0].setComponents(f - a, j - g, n - k, c - o).normalize(), b[1].setComponents(f + a, j + g, n + k, c + o).normalize(), b[2].setComponents(f + d, j + h, n + l, c + p).normalize(), b[3].setComponents(f - d, j - h, n - l, c - p).normalize(), b[4].setComponents(f - e, j - i, n - m, c - q).normalize(), b[5].setComponents(f + e, j + i, n + m, c + q).normalize(), this
						},
						intersectsObject: function() {
							var a = new Z;
							return function(b) {
								var c = b.geometry;
								return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld), this.intersectsSphere(a)
							}
						}(),
						intersectsSprite: function() {
							var a = new Z;
							return function(b) {
								return a.center.set(0, 0, 0), a.radius = .7071067811865476, a.applyMatrix4(b.matrixWorld), this.intersectsSphere(a)
							}
						}(),
						intersectsSphere: function(a) {
							var b = this.planes,
								c = a.center;
							a = -a.radius;
							for (var d = 0; 6 > d; d++)
								if (b[d].distanceToPoint(c) < a) return false;
							return true
						},
						intersectsBox: function() {
							var a = new i,
								b = new i;
							return function(c) {
								for (var d = this.planes, e = 0; 6 > e; e++) {
									var f = d[e];
									a.x = 0 < f.normal.x ? c.min.x : c.max.x, b.x = 0 < f.normal.x ? c.max.x : c.min.x, a.y = 0 < f.normal.y ? c.min.y : c.max.y, b.y = 0 < f.normal.y ? c.max.y : c.min.y, a.z = 0 < f.normal.z ? c.min.z : c.max.z, b.z = 0 < f.normal.z ? c.max.z : c.min.z;
									var g = f.distanceToPoint(a),
										f = f.distanceToPoint(b);
									if (0 > g && 0 > f) return false
								}
								return true
							}
						}(),
						containsPoint: function(a) {
							for (var b = this.planes, c = 0; 6 > c; c++)
								if (0 > b[c].distanceToPoint(a)) return false;
							return true
						}
					}), Object.assign(ca.prototype, {
						set: function(a, b) {
							return this.origin.copy(a), this.direction.copy(b), this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.origin.copy(a.origin), this.direction.copy(a.direction), this
						},
						at: function(a, b) {
							return (b || new i).copy(this.direction).multiplyScalar(a).add(this.origin)
						},
						lookAt: function(a) {
							return this.direction.copy(a).sub(this.origin).normalize(), this
						},
						recast: function() {
							var a = new i;
							return function(b) {
								return this.origin.copy(this.at(b, a)), this
							}
						}(),
						closestPointToPoint: function(a, b) {
							var c = b || new i;
							c.subVectors(a, this.origin);
							var d = c.dot(this.direction);
							return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
						},
						distanceToPoint: function(a) {
							return Math.sqrt(this.distanceSqToPoint(a))
						},
						distanceSqToPoint: function() {
							var a = new i;
							return function(b) {
								var c = a.subVectors(b, this.origin).dot(this.direction);
								return 0 > c ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), a.distanceToSquared(b))
							}
						}(),
						distanceSqToSegment: function() {
							var a = new i,
								b = new i,
								c = new i;
							return function(d, e, f, g) {
								a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
								var h, i = .5 * d.distanceTo(e),
									j = -this.direction.dot(b),
									k = c.dot(this.direction),
									l = -c.dot(b),
									m = c.lengthSq(),
									n = Math.abs(1 - j * j);
								return 0 < n ? (d = j * l - k, e = j * k - l, h = i * n, 0 <= d ? e >= -h ? e <= h ? (i = 1 / n, d *= i, e *= i, j = d * (d + j * e + 2 * k) + e * (j * d + e + 2 * l) + m) : (e = i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : (e = -i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : e <= -h ? (d = Math.max(0, -(-j * i + k)), e = 0 < d ? -i : Math.min(Math.max(-i, -l), i), j = -d * d + e * (e + 2 * l) + m) : e <= h ? (d = 0, e = Math.min(Math.max(-i, -l), i), j = e * (e + 2 * l) + m) : (d = Math.max(0, -(j * i + k)), e = 0 < d ? i : Math.min(Math.max(-i, -l), i), j = -d * d + e * (e + 2 * l) + m)) : (e = 0 < j ? -i : i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m), f && f.copy(this.direction).multiplyScalar(d).add(this.origin), g && g.copy(b).multiplyScalar(e).add(a), j
							}
						}(),
						intersectSphere: function() {
							var a = new i;
							return function(b, c) {
								a.subVectors(b.center, this.origin);
								var d = a.dot(this.direction),
									e = a.dot(a) - d * d,
									f = b.radius * b.radius;
								return e > f ? null : (f = Math.sqrt(f - e), e = d - f, d += f, 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c))
							}
						}(),
						intersectsSphere: function(a) {
							return this.distanceToPoint(a.center) <= a.radius
						},
						distanceToPlane: function(a) {
							var b = a.normal.dot(this.direction);
							return 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b, 0 <= a ? a : null)
						},
						intersectPlane: function(a, b) {
							var c = this.distanceToPlane(a);
							return null === c ? null : this.at(c, b)
						},
						intersectsPlane: function(a) {
							var b = a.distanceToPoint(this.origin);
							return 0 === b || 0 > a.normal.dot(this.direction) * b
						},
						intersectBox: function(a, b) {
							var c, d, e, f, g;
							d = 1 / this.direction.x, f = 1 / this.direction.y, g = 1 / this.direction.z;
							var h = this.origin;
							return 0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x), 0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (f < d || d !== d) && (d = f), 0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z), c > g || e > d ? null : ((e > c || c !== c) && (c = e), (g < d || d !== d) && (d = g), 0 > d ? null : this.at(0 <= c ? c : d, b)))
						},
						intersectsBox: function() {
							var a = new i;
							return function(b) {
								return null !== this.intersectBox(b, a)
							}
						}(),
						intersectTriangle: function() {
							var a = new i,
								b = new i,
								c = new i,
								d = new i;
							return function(e, f, g, h, i) {
								if (b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c), f = this.direction.dot(d), 0 < f) {
									if (h) return null;
									h = 1
								} else {
									if (!(0 > f)) return null;
									h = -1, f = -f
								}
								return a.subVectors(this.origin, e), e = h * this.direction.dot(c.crossVectors(a, c)), 0 > e ? null : (g = h * this.direction.dot(b.cross(a)), 0 > g || e + g > f ? null : (e = -h * a.dot(d), 0 > e ? null : this.at(e / f, i)))
							}
						}(),
						applyMatrix4: function(a) {
							return this.direction.add(this.origin).applyMatrix4(a), this.origin.applyMatrix4(a), this.direction.sub(this.origin), this.direction.normalize(), this
						},
						equals: function(a) {
							return a.origin.equals(this.origin) && a.direction.equals(this.direction)
						}
					}), da.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), da.DefaultOrder = "XYZ", Object.defineProperties(da.prototype, {
						x: {
							get: function() {
								return this._x
							},
							set: function(a) {
								this._x = a, this.onChangeCallback()
							}
						},
						y: {
							get: function() {
								return this._y
							},
							set: function(a) {
								this._y = a, this.onChangeCallback()
							}
						},
						z: {
							get: function() {
								return this._z
							},
							set: function(a) {
								this._z = a, this.onChangeCallback()
							}
						},
						order: {
							get: function() {
								return this._order
							},
							set: function(a) {
								this._order = a, this.onChangeCallback()
							}
						}
					}), Object.assign(da.prototype, {
						isEuler: true,
						set: function(a, b, c, d) {
							return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), this
						},
						clone: function() {
							return new this.constructor(this._x, this._y, this._z, this._order)
						},
						copy: function(a) {
							return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), this
						},
						setFromRotationMatrix: function(a, b, c) {
							var d = re.clamp,
								e = a.elements;
							a = e[0];
							var f = e[4],
								g = e[8],
								h = e[1],
								i = e[5],
								j = e[9],
								k = e[2],
								l = e[6],
								e = e[10];
							return b = b || this._order, "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-j, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(j, -1, 1)), .99999 > Math.abs(j) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(-k, e), this._z = Math.atan2(-f, i)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), .99999 > Math.abs(k) ? (this._x = Math.atan2(l, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-j, i), this._y = Math.atan2(-k, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-j, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), this._order = b, false !== c && this.onChangeCallback(), this
						},
						setFromQuaternion: function() {
							var a = new j;
							return function(b, c, d) {
								return a.makeRotationFromQuaternion(b), this.setFromRotationMatrix(a, c, d)
							}
						}(),
						setFromVector3: function(a, b) {
							return this.set(a.x, a.y, a.z, b || this._order)
						},
						reorder: function() {
							var a = new h;
							return function(b) {
								return a.setFromEuler(this), this.setFromQuaternion(a, b)
							}
						}(),
						equals: function(a) {
							return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
						},
						fromArray: function(a) {
							return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), this.onChangeCallback(), this
						},
						toArray: function(a, b) {
							return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._order, a
						},
						toVector3: function(a) {
							return a ? a.set(this._x, this._y, this._z) : new i(this._x, this._y, this._z)
						},
						onChange: function(a) {
							return this.onChangeCallback = a, this
						},
						onChangeCallback: function() {}
					}), Object.assign(ea.prototype, {
						set: function(a) {
							this.mask = 1 << a | 0
						},
						enable: function(a) {
							this.mask = this.mask | 1 << a | 0
						},
						toggle: function(a) {
							this.mask ^= 1 << a | 0
						},
						disable: function(a) {
							this.mask &= ~(1 << a | 0)
						},
						test: function(a) {
							return 0 !== (this.mask & a.mask)
						}
					});
					var Ge = 0;
					fa.DefaultUp = new i(0, 1, 0), fa.DefaultMatrixAutoUpdate = true, Object.assign(fa.prototype, b.prototype, {
						isObject3D: true,
						applyMatrix: function(a) {
							this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
						},
						setRotationFromAxisAngle: function(a, b) {
							this.quaternion.setFromAxisAngle(a, b)
						},
						setRotationFromEuler: function(a) {
							this.quaternion.setFromEuler(a, true)
						},
						setRotationFromMatrix: function(a) {
							this.quaternion.setFromRotationMatrix(a)
						},
						setRotationFromQuaternion: function(a) {
							this.quaternion.copy(a)
						},
						rotateOnAxis: function() {
							var a = new h;
							return function(b, c) {
								return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this
							}
						}(),
						rotateX: function() {
							var a = new i(1, 0, 0);
							return function(b) {
								return this.rotateOnAxis(a, b)
							}
						}(),
						rotateY: function() {
							var a = new i(0, 1, 0);
							return function(b) {
								return this.rotateOnAxis(a, b)
							}
						}(),
						rotateZ: function() {
							var a = new i(0, 0, 1);
							return function(b) {
								return this.rotateOnAxis(a, b)
							}
						}(),
						translateOnAxis: function() {
							var a = new i;
							return function(b, c) {
								return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), this
							}
						}(),
						translateX: function() {
							var a = new i(1, 0, 0);
							return function(b) {
								return this.translateOnAxis(a, b)
							}
						}(),
						translateY: function() {
							var a = new i(0, 1, 0);
							return function(b) {
								return this.translateOnAxis(a, b)
							}
						}(),
						translateZ: function() {
							var a = new i(0, 0, 1);
							return function(b) {
								return this.translateOnAxis(a, b)
							}
						}(),
						localToWorld: function(a) {
							return a.applyMatrix4(this.matrixWorld)
						},
						worldToLocal: function() {
							var a = new j;
							return function(b) {
								return b.applyMatrix4(a.getInverse(this.matrixWorld))
							}
						}(),
						lookAt: function() {
							var a = new j;
							return function(b) {
								this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a)
							}
						}(),
						add: function(a) {
							if (1 < arguments.length) {
								for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
								return this
							}
							return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this) : (a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
								type: "added"
							}), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), this)
						},
						remove: function(a) {
							if (1 < arguments.length)
								for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
							b = this.children.indexOf(a), -1 !== b && (a.parent = null, a.dispatchEvent({
								type: "removed"
							}), this.children.splice(b, 1))
						},
						getObjectById: function(a) {
							return this.getObjectByProperty("id", a)
						},
						getObjectByName: function(a) {
							return this.getObjectByProperty("name", a)
						},
						getObjectByProperty: function(a, b) {
							if (this[a] === b) return this;
							for (var c = 0, d = this.children.length; c < d; c++) {
								var e = this.children[c].getObjectByProperty(a, b);
								if (void 0 !== e) return e
							}
						},
						getWorldPosition: function(a) {
							return a = a || new i, this.updateMatrixWorld(true), a.setFromMatrixPosition(this.matrixWorld)
						},
						getWorldQuaternion: function() {
							var a = new i,
								b = new i;
							return function(c) {
								return c = c || new h, this.updateMatrixWorld(true), this.matrixWorld.decompose(a, c, b), c
							}
						}(),
						getWorldRotation: function() {
							var a = new h;
							return function(b) {
								return b = b || new da, this.getWorldQuaternion(a), b.setFromQuaternion(a, this.rotation.order, false)
							}
						}(),
						getWorldScale: function() {
							var a = new i,
								b = new h;
							return function(c) {
								return c = c || new i, this.updateMatrixWorld(true), this.matrixWorld.decompose(a, b, c), c
							}
						}(),
						getWorldDirection: function() {
							var a = new h;
							return function(b) {
								return b = b || new i, this.getWorldQuaternion(a), b.set(0, 0, 1).applyQuaternion(a)
							}
						}(),
						raycast: function() {},
						traverse: function(a) {
							a(this);
							for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
						},
						traverseVisible: function(a) {
							if (false !== this.visible) {
								a(this);
								for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
							}
						},
						traverseAncestors: function(a) {
							var b = this.parent;
							null !== b && (a(b), b.traverseAncestors(a))
						},
						updateMatrix: function() {
							this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true
						},
						updateMatrixWorld: function(a) {
							this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || a) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, a = true);
							for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a)
						},
						toJSON: function(a) {
							function b(b, c) {
								return void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)), c.uuid
							}

							function c(a) {
								var b, c = [];
								for (b in a) {
									var d = a[b];
									delete d.metadata, c.push(d)
								}
								return c
							}
							var d = void 0 === a || "" === a,
								e = {};
							d && (a = {
								geometries: {},
								materials: {},
								textures: {},
								images: {}
							}, e.metadata = {
								version: 4.5,
								type: "Object",
								generator: "Object3D.toJSON"
							});
							var f = {};
							if (f.uuid = this.uuid, f.type = this.type, "" !== this.name && (f.name = this.name), "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData), true === this.castShadow && (f.castShadow = true), true === this.receiveShadow && (f.receiveShadow = true), false === this.visible && (f.visible = false), f.matrix = this.matrix.toArray(), void 0 !== this.geometry && (f.geometry = b(a.geometries, this.geometry)), void 0 !== this.material)
								if (Array.isArray(this.material)) {
									for (var g = [], h = 0, i = this.material.length; h < i; h++) g.push(b(a.materials, this.material[h]));
									f.material = g
								} else f.material = b(a.materials, this.material);
							if (0 < this.children.length)
								for (f.children = [], h = 0; h < this.children.length; h++) f.children.push(this.children[h].toJSON(a).object);
							return d && (d = c(a.geometries), g = c(a.materials), h = c(a.textures), i = c(a.images), 0 < d.length && (e.geometries = d), 0 < g.length && (e.materials = g), 0 < h.length && (e.textures = h), 0 < i.length && (e.images = i)), e.object = f, e
						},
						clone: function(a) {
							return (new this.constructor).copy(this, a)
						},
						copy: function(a, b) {
							if (void 0 === b && (b = true), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.matrix.copy(a.matrix), this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.layers.mask = a.layers.mask, this.visible = a.visible, this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, this.frustumCulled = a.frustumCulled, this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), true === b)
								for (var c = 0; c < a.children.length; c++) this.add(a.children[c].clone());
							return this
						}
					}), Object.assign(ga.prototype, {
						set: function(a, b) {
							return this.start.copy(a), this.end.copy(b), this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.start.copy(a.start), this.end.copy(a.end), this
						},
						getCenter: function(a) {
							return (a || new i).addVectors(this.start, this.end).multiplyScalar(.5)
						},
						delta: function(a) {
							return (a || new i).subVectors(this.end, this.start)
						},
						distanceSq: function() {
							return this.start.distanceToSquared(this.end)
						},
						distance: function() {
							return this.start.distanceTo(this.end)
						},
						at: function(a, b) {
							var c = b || new i;
							return this.delta(c).multiplyScalar(a).add(this.start)
						},
						closestPointToPointParameter: function() {
							var a = new i,
								b = new i;
							return function(c, d) {
								a.subVectors(c, this.start), b.subVectors(this.end, this.start);
								var e = b.dot(b),
									e = b.dot(a) / e;
								return d && (e = re.clamp(e, 0, 1)), e
							}
						}(),
						closestPointToPoint: function(a, b, c) {
							return a = this.closestPointToPointParameter(a, b), c = c || new i, this.delta(c).multiplyScalar(a).add(this.start)
						},
						applyMatrix4: function(a) {
							return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this
						},
						equals: function(a) {
							return a.start.equals(this.start) && a.end.equals(this.end)
						}
					}), Object.assign(ha, {
						normal: function() {
							var a = new i;
							return function(b, c, d, e) {
								return e = e || new i, e.subVectors(d, c), a.subVectors(b, c), e.cross(a), b = e.lengthSq(), 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
							}
						}(),
						barycoordFromPoint: function() {
							var a = new i,
								b = new i,
								c = new i;
							return function(d, e, f, g, h) {
								a.subVectors(g, e), b.subVectors(f, e), c.subVectors(d, e), d = a.dot(a), e = a.dot(b), f = a.dot(c);
								var j = b.dot(b);
								g = b.dot(c);
								var k = d * j - e * e;
								return h = h || new i, 0 === k ? h.set(-2, -1, -1) : (k = 1 / k, j = (j * f - e * g) * k, d = (d * g - e * f) * k, h.set(1 - j - d, d, j))
							}
						}(),
						containsPoint: function() {
							var a = new i;
							return function(b, c, d, e) {
								return b = ha.barycoordFromPoint(b, c, d, e, a), 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
							}
						}()
					}), Object.assign(ha.prototype, {
						set: function(a, b, c) {
							return this.a.copy(a), this.b.copy(b), this.c.copy(c), this
						},
						setFromPointsAndIndices: function(a, b, c, d) {
							return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this
						},
						area: function() {
							var a = new i,
								b = new i;
							return function() {
								return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length()
							}
						}(),
						midpoint: function(a) {
							return (a || new i).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
						},
						normal: function(a) {
							return ha.normal(this.a, this.b, this.c, a)
						},
						plane: function(a) {
							return (a || new _).setFromCoplanarPoints(this.a, this.b, this.c)
						},
						barycoordFromPoint: function(a, b) {
							return ha.barycoordFromPoint(a, this.a, this.b, this.c, b)
						},
						containsPoint: function(a) {
							return ha.containsPoint(a, this.a, this.b, this.c)
						},
						closestPointToPoint: function() {
							var a = new _,
								b = [new ga, new ga, new ga],
								c = new i,
								d = new i;
							return function(e, f) {
								var g = f || new i,
									h = 1 / 0;
								if (a.setFromCoplanarPoints(this.a, this.b, this.c), a.projectPoint(e, c), true === this.containsPoint(c)) g.copy(c);
								else {
									b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a);
									for (var j = 0; j < b.length; j++) {
										b[j].closestPointToPoint(c, true, d);
										var k = c.distanceToSquared(d);
										k < h && (h = k, g.copy(d))
									}
								}
								return g
							}
						}(),
						equals: function(a) {
							return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
						}
					}), Object.assign(ia.prototype, {
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), this.materialIndex = a.materialIndex;
							for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
							for (b = 0, c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
							return this
						}
					}), ja.prototype = Object.create(V.prototype), ja.prototype.constructor = ja, ja.prototype.isMeshBasicMaterial = true, ja.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this
					}, Object.defineProperty(ka.prototype, "needsUpdate", {
						set: function(a) {
							true === a && this.version++
						}
					}), Object.assign(ka.prototype, {
						isBufferAttribute: true,
						setArray: function(a) {
							if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
							this.count = void 0 !== a ? a.length / this.itemSize : 0, this.array = a
						},
						setDynamic: function(a) {
							return this.dynamic = a, this
						},
						copy: function(a) {
							return this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, this.count = a.count, this.normalized = a.normalized, this.dynamic = a.dynamic, this
						},
						copyAt: function(a, b, c) {
							a *= this.itemSize, c *= b.itemSize;
							for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
							return this
						},
						copyArray: function(a) {
							return this.array.set(a), this
						},
						copyColorsArray: function(a) {
							for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
								var f = a[d];
								void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new R), b[c++] = f.r, b[c++] = f.g, b[c++] = f.b
							}
							return this
						},
						copyIndicesArray: function(a) {
							for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
								var f = a[d];
								b[c++] = f.a, b[c++] = f.b, b[c++] = f.c
							}
							return this
						},
						copyVector2sArray: function(a) {
							for (var b = this.array, d = 0, e = 0, f = a.length; e < f; e++) {
								var g = a[e];
								void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", e), g = new c), b[d++] = g.x, b[d++] = g.y
							}
							return this
						},
						copyVector3sArray: function(a) {
							for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
								var f = a[d];
								void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new i), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z
							}
							return this
						},
						copyVector4sArray: function(a) {
							for (var b = this.array, c = 0, d = 0, f = a.length; d < f; d++) {
								var g = a[d];
								void 0 === g && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), g = new e), b[c++] = g.x, b[c++] = g.y, b[c++] = g.z, b[c++] = g.w
							}
							return this
						},
						set: function(a, b) {
							return void 0 === b && (b = 0), this.array.set(a, b), this
						},
						getX: function(a) {
							return this.array[a * this.itemSize]
						},
						setX: function(a, b) {
							return this.array[a * this.itemSize] = b, this
						},
						getY: function(a) {
							return this.array[a * this.itemSize + 1]
						},
						setY: function(a, b) {
							return this.array[a * this.itemSize + 1] = b, this
						},
						getZ: function(a) {
							return this.array[a * this.itemSize + 2]
						},
						setZ: function(a, b) {
							return this.array[a * this.itemSize + 2] = b, this
						},
						getW: function(a) {
							return this.array[a * this.itemSize + 3]
						},
						setW: function(a, b) {
							return this.array[a * this.itemSize + 3] = b, this
						},
						setXY: function(a, b, c) {
							return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this
						},
						setXYZ: function(a, b, c, d) {
							return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this
						},
						setXYZW: function(a, b, c, d, e) {
							return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this.array[a + 3] = e, this
						},
						onUpload: function(a) {
							return this.onUploadCallback = a, this
						},
						clone: function() {
							return new this.constructor(this.array, this.itemSize).copy(this)
						}
					}), la.prototype = Object.create(ka.prototype), la.prototype.constructor = la, ma.prototype = Object.create(ka.prototype), ma.prototype.constructor = ma, na.prototype = Object.create(ka.prototype), na.prototype.constructor = na, oa.prototype = Object.create(ka.prototype), oa.prototype.constructor = oa, pa.prototype = Object.create(ka.prototype), pa.prototype.constructor = pa, qa.prototype = Object.create(ka.prototype), qa.prototype.constructor = qa, ra.prototype = Object.create(ka.prototype), ra.prototype.constructor = ra, sa.prototype = Object.create(ka.prototype), sa.prototype.constructor = sa, ta.prototype = Object.create(ka.prototype), ta.prototype.constructor = ta, Object.assign(ua.prototype, {
						computeGroups: function(a) {
							var b, c = [],
								d = void 0;
							a = a.faces;
							for (var e = 0; e < a.length; e++) {
								var f = a[e];
								f.materialIndex !== d && (d = f.materialIndex, void 0 !== b && (b.count = 3 * e - b.start, c.push(b)), b = {
									start: 3 * e,
									materialIndex: d
								})
							}
							void 0 !== b && (b.count = 3 * e - b.start, c.push(b)), this.groups = c
						},
						fromGeometry: function(a) {
							var b, d = a.faces,
								e = a.vertices,
								f = a.faceVertexUvs,
								g = f[0] && 0 < f[0].length,
								h = f[1] && 0 < f[1].length,
								i = a.morphTargets,
								j = i.length;
							if (0 < j) {
								b = [];
								for (var k = 0; k < j; k++) b[k] = [];
								this.morphTargets.position = b
							}
							var l, m = a.morphNormals,
								n = m.length;
							if (0 < n) {
								for (l = [], k = 0; k < n; k++) l[k] = [];
								this.morphTargets.normal = l
							}
							for (var o = a.skinIndices, p = a.skinWeights, q = o.length === e.length, r = p.length === e.length, k = 0; k < d.length; k++) {
								var s = d[k];
								this.vertices.push(e[s.a], e[s.b], e[s.c]);
								var t = s.vertexNormals;
								for (3 === t.length ? this.normals.push(t[0], t[1], t[2]) : (t = s.normal, this.normals.push(t, t, t)), t = s.vertexColors, 3 === t.length ? this.colors.push(t[0], t[1], t[2]) : (t = s.color, this.colors.push(t, t, t)), true === g && (t = f[0][k], void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", k), this.uvs.push(new c, new c, new c))), true === h && (t = f[1][k], void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", k), this.uvs2.push(new c, new c, new c))), t = 0; t < j; t++) {
									var u = i[t].vertices;
									b[t].push(u[s.a], u[s.b], u[s.c])
								}
								for (t = 0; t < n; t++) u = m[t].vertexNormals[k], l[t].push(u.a, u.b, u.c);
								q && this.skinIndices.push(o[s.a], o[s.b], o[s.c]), r && this.skinWeights.push(p[s.a], p[s.b], p[s.c])
							}
							return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this
						}
					});
					var He = 0;
					Object.assign(wa.prototype, b.prototype, {
						isGeometry: true,
						applyMatrix: function(a) {
							for (var b = (new $).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
							for (c = 0, d = this.faces.length; c < d; c++) {
								a = this.faces[c], a.normal.applyMatrix3(b).normalize();
								for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
							}
							return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = true, this
						},
						rotateX: function() {
							var a = new j;
							return function(b) {
								return a.makeRotationX(b), this.applyMatrix(a), this
							}
						}(),
						rotateY: function() {
							var a = new j;
							return function(b) {
								return a.makeRotationY(b), this.applyMatrix(a), this
							}
						}(),
						rotateZ: function() {
							var a = new j;
							return function(b) {
								return a.makeRotationZ(b), this.applyMatrix(a), this
							}
						}(),
						translate: function() {
							var a = new j;
							return function(b, c, d) {
								return a.makeTranslation(b, c, d), this.applyMatrix(a), this
							}
						}(),
						scale: function() {
							var a = new j;
							return function(b, c, d) {
								return a.makeScale(b, c, d), this.applyMatrix(a), this
							}
						}(),
						lookAt: function() {
							var a = new fa;
							return function(b) {
								a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
							}
						}(),
						fromBufferGeometry: function(a) {
							function b(a, b, c, e) {
								var f = void 0 !== h ? [m[a].clone(), m[b].clone(), m[c].clone()] : [],
									g = void 0 !== j ? [d.colors[a].clone(), d.colors[b].clone(), d.colors[c].clone()] : [];
								e = new ia(a, b, c, f, g, e), d.faces.push(e), void 0 !== k && d.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[c].clone()]), void 0 !== l && d.faceVertexUvs[1].push([o[a].clone(), o[b].clone(), o[c].clone()])
							}
							var d = this,
								e = null !== a.index ? a.index.array : void 0,
								f = a.attributes,
								g = f.position.array,
								h = void 0 !== f.normal ? f.normal.array : void 0,
								j = void 0 !== f.color ? f.color.array : void 0,
								k = void 0 !== f.uv ? f.uv.array : void 0,
								l = void 0 !== f.uv2 ? f.uv2.array : void 0;
							void 0 !== l && (this.faceVertexUvs[1] = []);
							for (var m = [], n = [], o = [], p = f = 0; f < g.length; f += 3, p += 2) d.vertices.push(new i(g[f], g[f + 1], g[f + 2])), void 0 !== h && m.push(new i(h[f], h[f + 1], h[f + 2])), void 0 !== j && d.colors.push(new R(j[f], j[f + 1], j[f + 2])), void 0 !== k && n.push(new c(k[p], k[p + 1])), void 0 !== l && o.push(new c(l[p], l[p + 1]));
							var q = a.groups;
							if (0 < q.length)
								for (f = 0; f < q.length; f++)
									for (var g = q[f], r = g.start, s = g.count, p = r, r = r + s; p < r; p += 3) void 0 !== e ? b(e[p], e[p + 1], e[p + 2], g.materialIndex) : b(p, p + 1, p + 2, g.materialIndex);
							else if (void 0 !== e)
								for (f = 0; f < e.length; f += 3) b(e[f], e[f + 1], e[f + 2]);
							else
								for (f = 0; f < g.length / 3; f += 3) b(f, f + 1, f + 2);
							return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this
						},
						center: function() {
							this.computeBoundingBox();
							var a = this.boundingBox.getCenter().negate();
							return this.translate(a.x, a.y, a.z), a
						},
						normalize: function() {
							this.computeBoundingSphere();
							var a = this.boundingSphere.center,
								b = this.boundingSphere.radius,
								b = 0 === b ? 1 : 1 / b,
								c = new j;
							return c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1), this.applyMatrix(c), this
						},
						computeFaceNormals: function() {
							for (var a = new i, b = new i, c = 0, d = this.faces.length; c < d; c++) {
								var e = this.faces[c],
									f = this.vertices[e.a],
									g = this.vertices[e.b];
								a.subVectors(this.vertices[e.c], g), b.subVectors(f, g), a.cross(b), a.normalize(), e.normal.copy(a)
							}
						},
						computeVertexNormals: function(a) {
							void 0 === a && (a = true);
							var b, c, d;
							for (d = Array(this.vertices.length), b = 0, c = this.vertices.length; b < c; b++) d[b] = new i;
							if (a) {
								var e, f, g, h = new i,
									j = new i;
								for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), j.subVectors(e, f), h.cross(j), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
							} else
								for (this.computeFaceNormals(), a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
							for (b = 0, c = this.vertices.length; b < c; b++) d[b].normalize();
							for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = c.vertexNormals, 3 === e.length ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c])) : (e[0] = d[c.a].clone(), e[1] = d[c.b].clone(), e[2] = d[c.c].clone());
							0 < this.faces.length && (this.normalsNeedUpdate = true)
						},
						computeFlatVertexNormals: function() {
							var a, b, c;
							for (this.computeFaceNormals(), a = 0, b = this.faces.length; a < b; a++) {
								c = this.faces[a];
								var d = c.vertexNormals;
								3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone())
							}
							0 < this.faces.length && (this.normalsNeedUpdate = true)
						},
						computeMorphNormals: function() {
							var a, b, c, d, e;
							for (c = 0, d = this.faces.length; c < d; c++)
								for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
							var f = new wa;
							for (f.faces = this.faces, a = 0, b = this.morphTargets.length; a < b; a++) {
								if (!this.morphNormals[a]) {
									this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [], e = this.morphNormals[a].faceNormals;
									var g, h, j = this.morphNormals[a].vertexNormals;
									for (c = 0, d = this.faces.length; c < d; c++) g = new i, h = {
										a: new i,
										b: new i,
										c: new i
									}, e.push(g), j.push(h)
								}
								for (j = this.morphNormals[a], f.vertices = this.morphTargets[a].vertices, f.computeFaceNormals(), f.computeVertexNormals(), c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], g = j.faceNormals[c], h = j.vertexNormals[c], g.copy(e.normal), h.a.copy(e.vertexNormals[0]), h.b.copy(e.vertexNormals[1]), h.c.copy(e.vertexNormals[2])
							}
							for (c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
						},
						computeLineDistances: function() {
							for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
						},
						computeBoundingBox: function() {
							null === this.boundingBox && (this.boundingBox = new Y), this.boundingBox.setFromPoints(this.vertices)
						},
						computeBoundingSphere: function() {
							null === this.boundingSphere && (this.boundingSphere = new Z), this.boundingSphere.setFromPoints(this.vertices)
						},
						merge: function(a, b, c) {
							if (false === (a && a.isGeometry)) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
							else {
								var d, e = this.vertices.length,
									f = this.vertices,
									g = a.vertices,
									h = this.faces,
									i = a.faces,
									j = this.faceVertexUvs[0],
									k = a.faceVertexUvs[0],
									l = this.colors,
									m = a.colors;
								void 0 === c && (c = 0), void 0 !== b && (d = (new $).getNormalMatrix(b)), a = 0;
								for (var n = g.length; a < n; a++) {
									var o = g[a].clone();
									void 0 !== b && o.applyMatrix4(b), f.push(o)
								}
								for (a = 0, n = m.length; a < n; a++) l.push(m[a].clone());
								for (a = 0, n = i.length; a < n; a++) {
									var g = i[a],
										p = g.vertexNormals,
										m = g.vertexColors,
										l = new ia(g.a + e, g.b + e, g.c + e);
									for (l.normal.copy(g.normal), void 0 !== d && l.normal.applyMatrix3(d).normalize(), b = 0, f = p.length; b < f; b++) o = p[b].clone(), void 0 !== d && o.applyMatrix3(d).normalize(), l.vertexNormals.push(o);
									for (l.color.copy(g.color), b = 0, f = m.length; b < f; b++) o = m[b], l.vertexColors.push(o.clone());
									l.materialIndex = g.materialIndex + c, h.push(l)
								}
								for (a = 0, n = k.length; a < n; a++)
									if (c = k[a], d = [], void 0 !== c) {
										for (b = 0, f = c.length; b < f; b++) d.push(c[b].clone());
										j.push(d)
									}
							}
						},
						mergeMesh: function(a) {
							false === (a && a.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(),
								this.merge(a.geometry, a.matrix))
						},
						mergeVertices: function() {
							var a, b, c, d = {},
								e = [],
								f = [],
								g = Math.pow(10, 4);
							for (b = 0, c = this.vertices.length; b < c; b++) a = this.vertices[b], a = Math.round(a.x * g) + "_" + Math.round(a.y * g) + "_" + Math.round(a.z * g), void 0 === d[a] ? (d[a] = b, e.push(this.vertices[b]), f[b] = e.length - 1) : f[b] = f[d[a]];
							for (d = [], b = 0, c = this.faces.length; b < c; b++)
								for (g = this.faces[b], g.a = f[g.a], g.b = f[g.b], g.c = f[g.c], g = [g.a, g.b, g.c], a = 0; 3 > a; a++)
									if (g[a] === g[(a + 1) % 3]) {
										d.push(b);
										break
									}
							for (b = d.length - 1; 0 <= b; b--)
								for (g = d[b], this.faces.splice(g, 1), f = 0, c = this.faceVertexUvs.length; f < c; f++) this.faceVertexUvs[f].splice(g, 1);
							return b = this.vertices.length - e.length, this.vertices = e, b
						},
						sortFacesByMaterialIndex: function() {
							for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
							a.sort(function(a, b) {
								return a.materialIndex - b.materialIndex
							});
							var d, e, f = this.faceVertexUvs[0],
								g = this.faceVertexUvs[1];
							for (f && f.length === b && (d = []), g && g.length === b && (e = []), c = 0; c < b; c++) {
								var h = a[c]._id;
								d && d.push(f[h]), e && e.push(g[h])
							}
							d && (this.faceVertexUvs[0] = d), e && (this.faceVertexUvs[1] = e)
						},
						toJSON: function() {
							function a(a, b, c) {
								return c ? a | 1 << b : a & ~(1 << b)
							}

							function b(a) {
								var b = a.x.toString() + a.y.toString() + a.z.toString();
								return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3, i.push(a.x, a.y, a.z), j[b])
							}

							function c(a) {
								var b = a.r.toString() + a.g.toString() + a.b.toString();
								return void 0 !== l[b] ? l[b] : (l[b] = k.length, k.push(a.getHex()), l[b])
							}

							function d(a) {
								var b = a.x.toString() + a.y.toString();
								return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2, m.push(a.x, a.y), n[b])
							}
							var e = {
								metadata: {
									version: 4.5,
									type: "Geometry",
									generator: "Geometry.toJSON"
								}
							};
							if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
								var f, g = this.parameters;
								for (f in g) void 0 !== g[f] && (e[f] = g[f]);
								return e
							}
							for (g = [], f = 0; f < this.vertices.length; f++) {
								var h = this.vertices[f];
								g.push(h.x, h.y, h.z)
							}
							var h = [],
								i = [],
								j = {},
								k = [],
								l = {},
								m = [],
								n = {};
							for (f = 0; f < this.faces.length; f++) {
								var o = this.faces[f],
									p = void 0 !== this.faceVertexUvs[0][f],
									q = 0 < o.normal.length(),
									r = 0 < o.vertexNormals.length,
									s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b,
									t = 0 < o.vertexColors.length,
									u = 0,
									u = a(u, 0, 0),
									u = a(u, 1, true),
									u = a(u, 2, false),
									u = a(u, 3, p),
									u = a(u, 4, q),
									u = a(u, 5, r),
									u = a(u, 6, s),
									u = a(u, 7, t);
								h.push(u), h.push(o.a, o.b, o.c), h.push(o.materialIndex), p && (p = this.faceVertexUvs[0][f], h.push(d(p[0]), d(p[1]), d(p[2]))), q && h.push(b(o.normal)), r && (q = o.vertexNormals, h.push(b(q[0]), b(q[1]), b(q[2]))), s && h.push(c(o.color)), t && (o = o.vertexColors, h.push(c(o[0]), c(o[1]), c(o[2])))
							}
							return e.data = {}, e.data.vertices = g, e.data.normals = i, 0 < k.length && (e.data.colors = k), 0 < m.length && (e.data.uvs = [m]), e.data.faces = h, e
						},
						clone: function() {
							return (new wa).copy(this)
						},
						copy: function(a) {
							var b, c, d, e, f, g;
							for (this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
									[]
								], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = a.name, d = a.vertices, b = 0, c = d.length; b < c; b++) this.vertices.push(d[b].clone());
							for (d = a.colors, b = 0, c = d.length; b < c; b++) this.colors.push(d[b].clone());
							for (d = a.faces, b = 0, c = d.length; b < c; b++) this.faces.push(d[b].clone());
							for (b = 0, c = a.faceVertexUvs.length; b < c; b++) {
								var h = a.faceVertexUvs[b];
								for (void 0 === this.faceVertexUvs[b] && (this.faceVertexUvs[b] = []), d = 0, e = h.length; d < e; d++) {
									var i = h[d],
										j = [];
									for (f = 0, g = i.length; f < g; f++) j.push(i[f].clone());
									this.faceVertexUvs[b].push(j)
								}
							}
							for (f = a.morphTargets, b = 0, c = f.length; b < c; b++) {
								if (g = {}, g.name = f[b].name, void 0 !== f[b].vertices)
									for (g.vertices = [], d = 0, e = f[b].vertices.length; d < e; d++) g.vertices.push(f[b].vertices[d].clone());
								if (void 0 !== f[b].normals)
									for (g.normals = [], d = 0, e = f[b].normals.length; d < e; d++) g.normals.push(f[b].normals[d].clone());
								this.morphTargets.push(g)
							}
							for (f = a.morphNormals, b = 0, c = f.length; b < c; b++) {
								if (g = {}, void 0 !== f[b].vertexNormals)
									for (g.vertexNormals = [], d = 0, e = f[b].vertexNormals.length; d < e; d++) h = f[b].vertexNormals[d], i = {}, i.a = h.a.clone(), i.b = h.b.clone(), i.c = h.c.clone(), g.vertexNormals.push(i);
								if (void 0 !== f[b].faceNormals)
									for (g.faceNormals = [], d = 0, e = f[b].faceNormals.length; d < e; d++) g.faceNormals.push(f[b].faceNormals[d].clone());
								this.morphNormals.push(g)
							}
							for (d = a.skinWeights, b = 0, c = d.length; b < c; b++) this.skinWeights.push(d[b].clone());
							for (d = a.skinIndices, b = 0, c = d.length; b < c; b++) this.skinIndices.push(d[b].clone());
							for (d = a.lineDistances, b = 0, c = d.length; b < c; b++) this.lineDistances.push(d[b]);
							return b = a.boundingBox, null !== b && (this.boundingBox = b.clone()), b = a.boundingSphere, null !== b && (this.boundingSphere = b.clone()), this.elementsNeedUpdate = a.elementsNeedUpdate, this.verticesNeedUpdate = a.verticesNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this
						},
						dispose: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), xa.MaxIndex = 65535, Object.assign(xa.prototype, b.prototype, {
						isBufferGeometry: true,
						getIndex: function() {
							return this.index
						},
						setIndex: function(a) {
							Array.isArray(a) ? this.index = new(65535 < va(a) ? ra : pa)(a, 1) : this.index = a
						},
						addAttribute: function(a, b, c) {
							if (false === (b && b.isBufferAttribute) && false === (b && b.isInterleavedBufferAttribute)) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new ka(b, c));
							else {
								if ("index" !== a) return this.attributes[a] = b, this;
								console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b)
							}
						},
						getAttribute: function(a) {
							return this.attributes[a]
						},
						removeAttribute: function(a) {
							return delete this.attributes[a], this
						},
						addGroup: function(a, b, c) {
							this.groups.push({
								start: a,
								count: b,
								materialIndex: void 0 !== c ? c : 0
							})
						},
						clearGroups: function() {
							this.groups = []
						},
						setDrawRange: function(a, b) {
							this.drawRange.start = a, this.drawRange.count = b
						},
						applyMatrix: function(a) {
							var b = this.attributes.position;
							return void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = true), b = this.attributes.normal, void 0 !== b && ((new $).getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
						},
						rotateX: function() {
							var a = new j;
							return function(b) {
								return a.makeRotationX(b), this.applyMatrix(a), this
							}
						}(),
						rotateY: function() {
							var a = new j;
							return function(b) {
								return a.makeRotationY(b), this.applyMatrix(a), this
							}
						}(),
						rotateZ: function() {
							var a = new j;
							return function(b) {
								return a.makeRotationZ(b), this.applyMatrix(a), this
							}
						}(),
						translate: function() {
							var a = new j;
							return function(b, c, d) {
								return a.makeTranslation(b, c, d), this.applyMatrix(a), this
							}
						}(),
						scale: function() {
							var a = new j;
							return function(b, c, d) {
								return a.makeScale(b, c, d), this.applyMatrix(a), this
							}
						}(),
						lookAt: function() {
							var a = new fa;
							return function(b) {
								a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
							}
						}(),
						center: function() {
							this.computeBoundingBox();
							var a = this.boundingBox.getCenter().negate();
							return this.translate(a.x, a.y, a.z), a
						},
						setFromObject: function(a) {
							var b = a.geometry;
							if (a.isPoints || a.isLine) {
								a = new sa(3 * b.vertices.length, 3);
								var c = new sa(3 * b.colors.length, 3);
								this.addAttribute("position", a.copyVector3sArray(b.vertices)), this.addAttribute("color", c.copyColorsArray(b.colors)), b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new sa(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances))), null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
							} else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
							return this
						},
						updateFromObject: function(a) {
							var b = a.geometry;
							if (a.isMesh) {
								var c = b.__directGeometry;
								if (true === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = false), void 0 === c) return this.fromGeometry(b);
								c.verticesNeedUpdate = b.verticesNeedUpdate, c.normalsNeedUpdate = b.normalsNeedUpdate, c.colorsNeedUpdate = b.colorsNeedUpdate, c.uvsNeedUpdate = b.uvsNeedUpdate, c.groupsNeedUpdate = b.groupsNeedUpdate, b.verticesNeedUpdate = false, b.normalsNeedUpdate = false, b.colorsNeedUpdate = false, b.uvsNeedUpdate = false, b.groupsNeedUpdate = false, b = c
							}
							return true === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = true), b.verticesNeedUpdate = false), true === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = true), b.normalsNeedUpdate = false), true === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = true), b.colorsNeedUpdate = false), b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = true), b.uvsNeedUpdate = false), b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = true), b.lineDistancesNeedUpdate = false), b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = false), this
						},
						fromGeometry: function(a) {
							return a.__directGeometry = (new ua).fromGeometry(a), this.fromDirectGeometry(a.__directGeometry)
						},
						fromDirectGeometry: function(a) {
							var b = new Float32Array(3 * a.vertices.length);
							this.addAttribute("position", new ka(b, 3).copyVector3sArray(a.vertices)), 0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", new ka(b, 3).copyVector3sArray(a.normals))), 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", new ka(b, 3).copyColorsArray(a.colors))), 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", new ka(b, 2).copyVector2sArray(a.uvs))), 0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", new ka(b, 2).copyVector2sArray(a.uvs2))), 0 < a.indices.length && (b = new(65535 < va(a.indices) ? Uint32Array : Uint16Array)(3 * a.indices.length), this.setIndex(new ka(b, 1).copyIndicesArray(a.indices))), this.groups = a.groups;
							for (var c in a.morphTargets) {
								for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
									var g = d[e],
										h = new sa(3 * g.length, 3);
									b.push(h.copyVector3sArray(g))
								}
								this.morphAttributes[c] = b
							}
							return 0 < a.skinIndices.length && (c = new sa(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))), 0 < a.skinWeights.length && (c = new sa(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this
						},
						computeBoundingBox: function() {
							null === this.boundingBox && (this.boundingBox = new Y);
							var a = this.attributes.position;
							void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
						},
						computeBoundingSphere: function() {
							var a = new Y,
								b = new i;
							return function() {
								null === this.boundingSphere && (this.boundingSphere = new Z);
								var c = this.attributes.position;
								if (c) {
									var d = this.boundingSphere.center;
									a.setFromBufferAttribute(c), a.getCenter(d);
									for (var e = 0, f = 0, g = c.count; f < g; f++) b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));
									this.boundingSphere.radius = Math.sqrt(e), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
								}
							}
						}(),
						computeFaceNormals: function() {},
						computeVertexNormals: function() {
							var a = this.index,
								b = this.attributes,
								c = this.groups;
							if (b.position) {
								var d = b.position.array;
								if (void 0 === b.normal) this.addAttribute("normal", new ka(new Float32Array(d.length), 3));
								else
									for (var e = b.normal.array, f = 0, g = e.length; f < g; f++) e[f] = 0;
								var h, j, k, e = b.normal.array,
									l = new i,
									m = new i,
									n = new i,
									o = new i,
									p = new i;
								if (a) {
									a = a.array, 0 === c.length && this.addGroup(0, a.length);
									for (var q = 0, r = c.length; q < r; ++q)
										for (f = c[q], g = f.start, h = f.count, f = g, g += h; f < g; f += 3) h = 3 * a[f + 0], j = 3 * a[f + 1], k = 3 * a[f + 2], l.fromArray(d, h), m.fromArray(d, j), n.fromArray(d, k), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), e[h] += o.x, e[h + 1] += o.y, e[h + 2] += o.z, e[j] += o.x, e[j + 1] += o.y, e[j + 2] += o.z, e[k] += o.x, e[k + 1] += o.y, e[k + 2] += o.z
								} else
									for (f = 0, g = d.length; f < g; f += 9) l.fromArray(d, f), m.fromArray(d, f + 3), n.fromArray(d, f + 6), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), e[f] = o.x, e[f + 1] = o.y, e[f + 2] = o.z, e[f + 3] = o.x, e[f + 4] = o.y, e[f + 5] = o.z, e[f + 6] = o.x, e[f + 7] = o.y, e[f + 8] = o.z;
								this.normalizeNormals(), b.normal.needsUpdate = true
							}
						},
						merge: function(a, b) {
							if (false !== (a && a.isBufferGeometry)) {
								void 0 === b && (b = 0);
								var c, d = this.attributes;
								for (c in d)
									if (void 0 !== a.attributes[c])
										for (var e = d[c].array, f = a.attributes[c], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h];
								return this
							}
							console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
						},
						normalizeNormals: function() {
							for (var a, b, c, d, e = this.attributes.normal, f = 0, g = e.count; f < g; f++) a = e.getX(f), b = e.getY(f), c = e.getZ(f), d = 1 / Math.sqrt(a * a + b * b + c * c), e.setXYZ(f, a * d, b * d, c * d)
						},
						toNonIndexed: function() {
							if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
							var a, b = new xa,
								c = this.index.array,
								d = this.attributes;
							for (a in d) {
								for (var e, f = d[a], g = f.array, f = f.itemSize, h = new g.constructor(c.length * f), i = 0, j = 0, k = c.length; j < k; j++) {
									e = c[j] * f;
									for (var l = 0; l < f; l++) h[i++] = g[e++]
								}
								b.addAttribute(a, new ka(h, f))
							}
							return b
						},
						toJSON: function() {
							var a = {
								metadata: {
									version: 4.5,
									type: "BufferGeometry",
									generator: "BufferGeometry.toJSON"
								}
							};
							if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), void 0 !== this.parameters) {
								var b, c = this.parameters;
								for (b in c) void 0 !== c[b] && (a[b] = c[b]);
								return a
							}
							a.data = {
								attributes: {}
							};
							var d = this.index;
							null !== d && (c = Array.prototype.slice.call(d.array), a.data.index = {
								type: d.array.constructor.name,
								array: c
							}), d = this.attributes;
							for (b in d) {
								var e = d[b],
									c = Array.prototype.slice.call(e.array);
								a.data.attributes[b] = {
									itemSize: e.itemSize,
									type: e.array.constructor.name,
									array: c,
									normalized: e.normalized
								}
							}
							return b = this.groups, 0 < b.length && (a.data.groups = JSON.parse(JSON.stringify(b))), b = this.boundingSphere, null !== b && (a.data.boundingSphere = {
								center: b.center.toArray(),
								radius: b.radius
							}), a
						},
						clone: function() {
							return (new xa).copy(this)
						},
						copy: function(a) {
							var b, c, d;
							this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = a.name, c = a.index, null !== c && this.setIndex(c.clone()), c = a.attributes;
							for (b in c) this.addAttribute(b, c[b].clone());
							var e = a.morphAttributes;
							for (b in e) {
								var f = [],
									g = e[b];
								for (c = 0, d = g.length; c < d; c++) f.push(g[c].clone());
								this.morphAttributes[b] = f
							}
							for (b = a.groups, c = 0, d = b.length; c < d; c++) e = b[c], this.addGroup(e.start, e.count, e.materialIndex);
							return b = a.boundingBox, null !== b && (this.boundingBox = b.clone()), b = a.boundingSphere, null !== b && (this.boundingSphere = b.clone()), this.drawRange.start = a.drawRange.start, this.drawRange.count = a.drawRange.count, this
						},
						dispose: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), ya.prototype = Object.assign(Object.create(fa.prototype), {
						constructor: ya,
						isMesh: true,
						setDrawMode: function(a) {
							this.drawMode = a
						},
						copy: function(a) {
							return fa.prototype.copy.call(this, a), this.drawMode = a.drawMode, this
						},
						updateMorphTargets: function() {
							var a = this.geometry.morphTargets;
							if (void 0 !== a && 0 < a.length) {
								this.morphTargetInfluences = [], this.morphTargetDictionary = {};
								for (var b = 0, c = a.length; b < c; b++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[a[b].name] = b
							}
						},
						raycast: function() {
							function a(a, b, c, d, e, f, g) {
								return ha.barycoordFromPoint(a, b, c, d, s), e.multiplyScalar(s.x), f.multiplyScalar(s.y), g.multiplyScalar(s.z), e.add(f).add(g), e.clone()
							}

							function b(a, b, c, d, e, f, g) {
								var h = a.material;
								return null === (1 === h.side ? c.intersectTriangle(f, e, d, true, g) : c.intersectTriangle(d, e, f, 2 !== h.side, g)) ? null : (u.copy(g), u.applyMatrix4(a.matrixWorld), c = b.ray.origin.distanceTo(u), c < b.near || c > b.far ? null : {
									distance: c,
									point: u.clone(),
									object: a
								})
							}

							function d(c, d, e, f, g, i, j, m) {
								return h.fromBufferAttribute(f, i), k.fromBufferAttribute(f, j), l.fromBufferAttribute(f, m), (c = b(c, d, e, h, k, l, t)) && (g && (p.fromBufferAttribute(g, i), q.fromBufferAttribute(g, j), r.fromBufferAttribute(g, m), c.uv = a(t, h, k, l, p, q, r)), c.face = new ia(i, j, m, ha.normal(h, k, l)), c.faceIndex = i), c
							}
							var e = new j,
								f = new ca,
								g = new Z,
								h = new i,
								k = new i,
								l = new i,
								m = new i,
								n = new i,
								o = new i,
								p = new c,
								q = new c,
								r = new c,
								s = new i,
								t = new i,
								u = new i;
							return function(c, i) {
								var j = this.geometry,
									s = this.material,
									u = this.matrixWorld;
								if (void 0 !== s && (null === j.boundingSphere && j.computeBoundingSphere(), g.copy(j.boundingSphere), g.applyMatrix4(u), false !== c.ray.intersectsSphere(g) && (e.getInverse(u), f.copy(c.ray).applyMatrix4(e), null === j.boundingBox || false !== f.intersectsBox(j.boundingBox)))) {
									var v;
									if (j.isBufferGeometry) {
										var w, x, y, z, s = j.index,
											A = j.attributes.position,
											u = j.attributes.uv;
										if (null !== s)
											for (y = 0, z = s.count; y < z; y += 3) j = s.getX(y), w = s.getX(y + 1), x = s.getX(y + 2), (v = d(this, c, f, A, u, j, w, x)) && (v.faceIndex = Math.floor(y / 3), i.push(v));
										else
											for (y = 0, z = A.count; y < z; y += 3) j = y, w = y + 1, x = y + 2, (v = d(this, c, f, A, u, j, w, x)) && (v.index = j, i.push(v))
									} else if (j.isGeometry) {
										var B, u = Array.isArray(s);
										y = j.vertices, z = j.faces, w = j.faceVertexUvs[0], 0 < w.length && (A = w);
										for (var C = 0, D = z.length; C < D; C++) {
											var E = z[C];
											if (v = u ? s[E.materialIndex] : s, void 0 !== v) {
												if (w = y[E.a], x = y[E.b], B = y[E.c], true === v.morphTargets) {
													v = j.morphTargets;
													var F = this.morphTargetInfluences;
													h.set(0, 0, 0), k.set(0, 0, 0), l.set(0, 0, 0);
													for (var G = 0, H = v.length; G < H; G++) {
														var I = F[G];
														if (0 !== I) {
															var J = v[G].vertices;
															h.addScaledVector(m.subVectors(J[E.a], w), I), k.addScaledVector(n.subVectors(J[E.b], x), I), l.addScaledVector(o.subVectors(J[E.c], B), I)
														}
													}
													h.add(w), k.add(x), l.add(B), w = h, x = k, B = l
												}(v = b(this, c, f, w, x, B, t)) && (A && A[C] && (F = A[C], p.copy(F[0]), q.copy(F[1]), r.copy(F[2]), v.uv = a(t, w, x, B, p, q, r)), v.face = E, v.faceIndex = C, i.push(v))
											}
										}
									}
								}
							}
						}(),
						clone: function() {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), za.prototype = Object.create(wa.prototype), za.prototype.constructor = za, Aa.prototype = Object.create(xa.prototype), Aa.prototype.constructor = Aa, Ba.prototype = Object.create(wa.prototype), Ba.prototype.constructor = Ba, Ca.prototype = Object.create(xa.prototype), Ca.prototype.constructor = Ca, Da.prototype = Object.assign(Object.create(fa.prototype), {
						constructor: Da,
						isCamera: true,
						copy: function(a) {
							return fa.prototype.copy.call(this, a), this.matrixWorldInverse.copy(a.matrixWorldInverse), this.projectionMatrix.copy(a.projectionMatrix), this
						},
						getWorldDirection: function() {
							var a = new h;
							return function(b) {
								return b = b || new i, this.getWorldQuaternion(a), b.set(0, 0, -1).applyQuaternion(a)
							}
						}(),
						clone: function() {
							return (new this.constructor).copy(this)
						}
					}), Ea.prototype = Object.assign(Object.create(Da.prototype), {
						constructor: Ea,
						isPerspectiveCamera: true,
						copy: function(a) {
							return Da.prototype.copy.call(this, a), this.fov = a.fov, this.zoom = a.zoom, this.near = a.near, this.far = a.far, this.focus = a.focus, this.aspect = a.aspect, this.view = null === a.view ? null : Object.assign({}, a.view), this.filmGauge = a.filmGauge, this.filmOffset = a.filmOffset, this
						},
						setFocalLength: function(a) {
							a = .5 * this.getFilmHeight() / a, this.fov = 2 * re.RAD2DEG * Math.atan(a), this.updateProjectionMatrix()
						},
						getFocalLength: function() {
							var a = Math.tan(.5 * re.DEG2RAD * this.fov);
							return .5 * this.getFilmHeight() / a
						},
						getEffectiveFOV: function() {
							return 2 * re.RAD2DEG * Math.atan(Math.tan(.5 * re.DEG2RAD * this.fov) / this.zoom)
						},
						getFilmWidth: function() {
							return this.filmGauge * Math.min(this.aspect, 1)
						},
						getFilmHeight: function() {
							return this.filmGauge / Math.max(this.aspect, 1)
						},
						setViewOffset: function(a, b, c, d, e, f) {
							this.aspect = a / b, this.view = {
								fullWidth: a,
								fullHeight: b,
								offsetX: c,
								offsetY: d,
								width: e,
								height: f
							}, this.updateProjectionMatrix()
						},
						clearViewOffset: function() {
							this.view = null, this.updateProjectionMatrix()
						},
						updateProjectionMatrix: function() {
							var a = this.near,
								b = a * Math.tan(.5 * re.DEG2RAD * this.fov) / this.zoom,
								c = 2 * b,
								d = this.aspect * c,
								e = -.5 * d,
								f = this.view;
							if (null !== f) var g = f.fullWidth,
								h = f.fullHeight,
								e = e + f.offsetX * d / g,
								b = b - f.offsetY * c / h,
								d = f.width / g * d,
								c = f.height / h * c;
							f = this.filmOffset, 0 !== f && (e += a * f / this.getFilmWidth()), this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far)
						},
						toJSON: function(a) {
							return a = fa.prototype.toJSON.call(this, a), a.object.fov = this.fov, a.object.zoom = this.zoom, a.object.near = this.near, a.object.far = this.far, a.object.focus = this.focus, a.object.aspect = this.aspect, null !== this.view && (a.object.view = Object.assign({}, this.view)), a.object.filmGauge = this.filmGauge, a.object.filmOffset = this.filmOffset, a
						}
					}), Fa.prototype = Object.assign(Object.create(Da.prototype), {
						constructor: Fa,
						isOrthographicCamera: true,
						copy: function(a) {
							return Da.prototype.copy.call(this, a), this.left = a.left, this.right = a.right, this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, this.zoom = a.zoom, this.view = null === a.view ? null : Object.assign({}, a.view), this
						},
						setViewOffset: function(a, b, c, d, e, f) {
							this.view = {
								fullWidth: a,
								fullHeight: b,
								offsetX: c,
								offsetY: d,
								width: e,
								height: f
							}, this.updateProjectionMatrix()
						},
						clearViewOffset: function() {
							this.view = null, this.updateProjectionMatrix()
						},
						updateProjectionMatrix: function() {
							var a = (this.right - this.left) / (2 * this.zoom),
								b = (this.top - this.bottom) / (2 * this.zoom),
								c = (this.right + this.left) / 2,
								d = (this.top + this.bottom) / 2,
								e = c - a,
								c = c + a,
								a = d + b,
								b = d - b;
							if (null !== this.view) var c = this.zoom / (this.view.width / this.view.fullWidth),
								b = this.zoom / (this.view.height / this.view.fullHeight),
								f = (this.right - this.left) / this.view.width,
								d = (this.top - this.bottom) / this.view.height,
								e = e + this.view.offsetX / c * f,
								c = e + this.view.width / c * f,
								a = a - this.view.offsetY / b * d,
								b = a - this.view.height / b * d;
							this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far)
						},
						toJSON: function(a) {
							return a = fa.prototype.toJSON.call(this, a), a.object.zoom = this.zoom, a.object.left = this.left, a.object.right = this.right, a.object.top = this.top, a.object.bottom = this.bottom, a.object.near = this.near, a.object.far = this.far, null !== this.view && (a.object.view = Object.assign({}, this.view)), a
						}
					});
					var Ie = 0;
					jb.prototype.isFogExp2 = true, jb.prototype.clone = function() {
							return new jb(this.color.getHex(), this.density)
						}, jb.prototype.toJSON = function(a) {
							return {
								type: "FogExp2",
								color: this.color.getHex(),
								density: this.density
							}
						}, kb.prototype.isFog = true, kb.prototype.clone = function() {
							return new kb(this.color.getHex(), this.near, this.far)
						}, kb.prototype.toJSON = function(a) {
							return {
								type: "Fog",
								color: this.color.getHex(),
								near: this.near,
								far: this.far
							}
						}, lb.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: lb,
							copy: function(a, b) {
								return fa.prototype.copy.call(this, a, b), null !== a.background && (this.background = a.background.clone()), null !== a.fog && (this.fog = a.fog.clone()), null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this
							},
							toJSON: function(a) {
								var b = fa.prototype.toJSON.call(this, a);
								return null !== this.background && (b.object.background = this.background.toJSON(a)), null !== this.fog && (b.object.fog = this.fog.toJSON()), b
							}
						}), mb.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: mb,
							isLensFlare: true,
							copy: function(a) {
								fa.prototype.copy.call(this, a), this.positionScreen.copy(a.positionScreen), this.customUpdateCallback = a.customUpdateCallback;
								for (var b = 0, c = a.lensFlares.length; b < c; b++) this.lensFlares.push(a.lensFlares[b]);
								return this
							},
							add: function(a, b, c, d, e, f) {
								void 0 === b && (b = -1), void 0 === c && (c = 0), void 0 === f && (f = 1), void 0 === e && (e = new R(16777215)), void 0 === d && (d = 1), c = Math.min(c, Math.max(0, c)), this.lensFlares.push({
									texture: a,
									size: b,
									distance: c,
									x: 0,
									y: 0,
									z: 0,
									scale: 1,
									rotation: 0,
									opacity: f,
									color: e,
									blending: d
								})
							},
							updateLensFlares: function() {
								var a, b, c = this.lensFlares.length,
									d = 2 * -this.positionScreen.x,
									e = 2 * -this.positionScreen.y;
								for (a = 0; a < c; a++) b = this.lensFlares[a], b.x = this.positionScreen.x + d * b.distance, b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, b.rotation += .25 * (b.wantedRotation - b.rotation)
							}
						}), nb.prototype = Object.create(V.prototype), nb.prototype.constructor = nb, nb.prototype.isSpriteMaterial = true, nb.prototype.copy = function(a) {
							return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.rotation = a.rotation, this
						}, ob.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: ob,
							isSprite: true,
							raycast: function() {
								var a = new i,
									b = new i,
									c = new i;
								return function(d, e) {
									b.setFromMatrixPosition(this.matrixWorld), d.ray.closestPointToPoint(b, a), c.setFromMatrixScale(this.matrixWorld);
									var f = c.x * c.y / 4;
									b.distanceToSquared(a) > f || (f = d.ray.origin.distanceTo(a), f < d.near || f > d.far || e.push({
										distance: f,
										point: a.clone(),
										face: null,
										object: this
									}))
								}
							}(),
							clone: function() {
								return new this.constructor(this.material).copy(this)
							}
						}), pb.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: pb,
							copy: function(a) {
								fa.prototype.copy.call(this, a, false), a = a.levels;
								for (var b = 0, c = a.length; b < c; b++) {
									var d = a[b];
									this.addLevel(d.object.clone(), d.distance)
								}
								return this
							},
							addLevel: function(a, b) {
								void 0 === b && (b = 0), b = Math.abs(b);
								for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
								c.splice(d, 0, {
									distance: b,
									object: a
								}), this.add(a)
							},
							getObjectForDistance: function(a) {
								for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
								return b[c - 1].object
							},
							raycast: function() {
								var a = new i;
								return function(b, c) {
									a.setFromMatrixPosition(this.matrixWorld);
									var d = b.ray.origin.distanceTo(a);
									this.getObjectForDistance(d).raycast(b, c)
								}
							}(),
							update: function() {
								var a = new i,
									b = new i;
								return function(c) {
									var d = this.levels;
									if (1 < d.length) {
										a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld), c = a.distanceTo(b), d[0].object.visible = true;
										for (var e = 1, f = d.length; e < f && c >= d[e].distance; e++) d[e - 1].object.visible = false, d[e].object.visible = true;
										for (; e < f; e++) d[e].object.visible = false
									}
								}
							}(),
							toJSON: function(a) {
								a = fa.prototype.toJSON.call(this, a), a.object.levels = [];
								for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
									var e = b[c];
									a.object.levels.push({
										object: e.object.uuid,
										distance: e.distance
									})
								}
								return a
							}
						}), Object.assign(qb.prototype, {
							calculateInverses: function() {
								this.boneInverses = [];
								for (var a = 0, b = this.bones.length; a < b; a++) {
									var c = new j;
									this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c)
								}
							},
							pose: function() {
								var a, b, c;
								for (b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
								for (b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
							},
							update: function() {
								var a = new j,
									b = new j;
								return function() {
									for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++) a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), a.toArray(e, 16 * g);
									void 0 !== f && (f.needsUpdate = true)
								}
							}(),
							clone: function() {
								return new qb(this.bones, this.boneInverses)
							}
						}), rb.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: rb,
							isBone: true
						}), sb.prototype = Object.assign(Object.create(ya.prototype), {
							constructor: sb,
							isSkinnedMesh: true,
							initBones: function() {
								var a, b, c, d, e = [];
								if (this.geometry && void 0 !== this.geometry.bones) {
									for (c = 0, d = this.geometry.bones.length; c < d; c++) b = this.geometry.bones[c], a = new rb, e.push(a), a.name = b.name, a.position.fromArray(b.pos), a.quaternion.fromArray(b.rotq), void 0 !== b.scl && a.scale.fromArray(b.scl);
									for (c = 0, d = this.geometry.bones.length; c < d; c++) b = this.geometry.bones[c], -1 !== b.parent && null !== b.parent && void 0 !== e[b.parent] ? e[b.parent].add(e[c]) : this.add(e[c])
								}
								return this.updateMatrixWorld(true), e
							},
							bind: function(a, b) {
								this.skeleton = a, void 0 === b && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b)
							},
							pose: function() {
								this.skeleton.pose()
							},
							normalizeSkinWeights: function() {
								var a, b;
								if (this.geometry && this.geometry.isGeometry)
									for (b = 0; b < this.geometry.skinWeights.length; b++) {
										var c = this.geometry.skinWeights[b];
										a = 1 / c.lengthManhattan(), 1 / 0 !== a ? c.multiplyScalar(a) : c.set(1, 0, 0, 0)
									} else if (this.geometry && this.geometry.isBufferGeometry) {
										var c = new e,
											d = this.geometry.attributes.skinWeight;
										for (b = 0; b < d.count; b++) c.x = d.getX(b), c.y = d.getY(b), c.z = d.getZ(b), c.w = d.getW(b), a = 1 / c.lengthManhattan(), 1 / 0 !== a ? c.multiplyScalar(a) : c.set(1, 0, 0, 0), d.setXYZW(b, c.x, c.y, c.z, c.w)
									}
							},
							updateMatrixWorld: function(a) {
								ya.prototype.updateMatrixWorld.call(this, a), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
							},
							clone: function() {
								return new this.constructor(this.geometry, this.material).copy(this)
							}
						}), tb.prototype = Object.create(V.prototype), tb.prototype.constructor = tb, tb.prototype.isLineBasicMaterial = true, tb.prototype.copy = function(a) {
							return V.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.linecap = a.linecap, this.linejoin = a.linejoin, this
						}, ub.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: ub,
							isLine: true,
							raycast: function() {
								var a = new j,
									b = new ca,
									c = new Z;
								return function(d, e) {
									var f = d.linePrecision,
										f = f * f,
										g = this.geometry,
										h = this.matrixWorld;
									if (null === g.boundingSphere && g.computeBoundingSphere(), c.copy(g.boundingSphere), c.applyMatrix4(h), false !== d.ray.intersectsSphere(c)) {
										a.getInverse(h), b.copy(d.ray).applyMatrix4(a);
										var j = new i,
											k = new i,
											h = new i,
											l = new i,
											m = this && this.isLineSegments ? 2 : 1;
										if (g.isBufferGeometry) {
											var n = g.index,
												o = g.attributes.position.array;
											if (null !== n)
												for (var n = n.array, g = 0, p = n.length - 1; g < p; g += m) {
													var q = n[g + 1];
													j.fromArray(o, 3 * n[g]), k.fromArray(o, 3 * q), q = b.distanceSqToSegment(j, k, l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
														distance: q,
														point: h.clone().applyMatrix4(this.matrixWorld),
														index: g,
														face: null,
														faceIndex: null,
														object: this
													}))
												} else
													for (g = 0, p = o.length / 3 - 1; g < p; g += m) j.fromArray(o, 3 * g), k.fromArray(o, 3 * g + 3), q = b.distanceSqToSegment(j, k, l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
														distance: q,
														point: h.clone().applyMatrix4(this.matrixWorld),
														index: g,
														face: null,
														faceIndex: null,
														object: this
													}))
										} else if (g.isGeometry)
											for (j = g.vertices, k = j.length, g = 0; g < k - 1; g += m) q = b.distanceSqToSegment(j[g], j[g + 1], l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
												distance: q,
												point: h.clone().applyMatrix4(this.matrixWorld),
												index: g,
												face: null,
												faceIndex: null,
												object: this
											}))
									}
								}
							}(),
							clone: function() {
								return new this.constructor(this.geometry, this.material).copy(this)
							}
						}), vb.prototype = Object.assign(Object.create(ub.prototype), {
							constructor: vb,
							isLineSegments: true
						}), wb.prototype = Object.assign(Object.create(ub.prototype), {
							constructor: wb,
							isLineLoop: true
						}), xb.prototype = Object.create(V.prototype), xb.prototype.constructor = xb, xb.prototype.isPointsMaterial = true, xb.prototype.copy = function(a) {
							return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.size = a.size, this.sizeAttenuation = a.sizeAttenuation, this
						}, yb.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: yb,
							isPoints: true,
							raycast: function() {
								var a = new j,
									b = new ca,
									c = new Z;
								return function(d, e) {
									function f(a, c) {
										var f = b.distanceSqToPoint(a);
										if (f < l) {
											var h = b.closestPointToPoint(a);
											h.applyMatrix4(j);
											var i = d.ray.origin.distanceTo(h);
											i < d.near || i > d.far || e.push({
												distance: i,
												distanceToRay: Math.sqrt(f),
												point: h.clone(),
												index: c,
												face: null,
												object: g
											})
										}
									}
									var g = this,
										h = this.geometry,
										j = this.matrixWorld,
										k = d.params.Points.threshold;
									if (null === h.boundingSphere && h.computeBoundingSphere(), c.copy(h.boundingSphere), c.applyMatrix4(j), c.radius += k, false !== d.ray.intersectsSphere(c)) {
										a.getInverse(j), b.copy(d.ray).applyMatrix4(a);
										var k = k / ((this.scale.x + this.scale.y + this.scale.z) / 3),
											l = k * k,
											k = new i;
										if (h.isBufferGeometry) {
											var m = h.index,
												h = h.attributes.position.array;
											if (null !== m)
												for (var n = m.array, m = 0, o = n.length; m < o; m++) {
													var p = n[m];
													k.fromArray(h, 3 * p), f(k, p)
												} else
													for (m = 0, n = h.length / 3; m < n; m++) k.fromArray(h, 3 * m), f(k, m)
										} else
											for (k = h.vertices, m = 0, n = k.length; m < n; m++) f(k[m], m)
									}
								}
							}(),
							clone: function() {
								return new this.constructor(this.geometry, this.material).copy(this)
							}
						}), zb.prototype = Object.assign(Object.create(fa.prototype), {
							constructor: zb
						}), Ab.prototype = Object.create(d.prototype), Ab.prototype.constructor = Ab, Bb.prototype = Object.create(d.prototype), Bb.prototype.constructor = Bb, Bb.prototype.isCompressedTexture = true, Cb.prototype = Object.create(d.prototype), Cb.prototype.constructor = Cb, Db.prototype = Object.create(d.prototype), Db.prototype.constructor = Db, Db.prototype.isDepthTexture = true, Eb.prototype = Object.create(xa.prototype), Eb.prototype.constructor = Eb, Fb.prototype = Object.create(wa.prototype), Fb.prototype.constructor = Fb, Gb.prototype = Object.create(xa.prototype),
						Gb.prototype.constructor = Gb, Hb.prototype = Object.create(wa.prototype), Hb.prototype.constructor = Hb, Ib.prototype = Object.create(xa.prototype), Ib.prototype.constructor = Ib, Jb.prototype = Object.create(wa.prototype), Jb.prototype.constructor = Jb, Kb.prototype = Object.create(Ib.prototype), Kb.prototype.constructor = Kb, Lb.prototype = Object.create(wa.prototype), Lb.prototype.constructor = Lb, Mb.prototype = Object.create(Ib.prototype), Mb.prototype.constructor = Mb, Nb.prototype = Object.create(wa.prototype), Nb.prototype.constructor = Nb, Ob.prototype = Object.create(Ib.prototype), Ob.prototype.constructor = Ob, Pb.prototype = Object.create(wa.prototype), Pb.prototype.constructor = Pb, Qb.prototype = Object.create(Ib.prototype), Qb.prototype.constructor = Qb, Rb.prototype = Object.create(wa.prototype), Rb.prototype.constructor = Rb, Sb.prototype = Object.create(xa.prototype), Sb.prototype.constructor = Sb, Tb.prototype = Object.create(wa.prototype), Tb.prototype.constructor = Tb, Ub.prototype = Object.create(xa.prototype), Ub.prototype.constructor = Ub, Vb.prototype = Object.create(wa.prototype), Vb.prototype.constructor = Vb, Wb.prototype = Object.create(xa.prototype), Wb.prototype.constructor = Wb;
					var Je = {
						area: function(a) {
							for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
							return .5 * c
						},
						triangulate: function() {
							return function(a, b) {
								var c = a.length;
								if (3 > c) return null;
								var d, e, f, g = [],
									h = [],
									i = [];
								if (0 < Je.area(a))
									for (e = 0; e < c; e++) h[e] = e;
								else
									for (e = 0; e < c; e++) h[e] = c - 1 - e;
								var j = 2 * c;
								for (e = c - 1; 2 < c;) {
									if (0 >= j--) {
										console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
										break
									}
									d = e, c <= d && (d = 0), e = d + 1, c <= e && (e = 0), f = e + 1, c <= f && (f = 0);
									var k;
									a: {
										var l, m, n, o, p, q, r, s;
										if (l = a[h[d]].x, m = a[h[d]].y, n = a[h[e]].x, o = a[h[e]].y, p = a[h[f]].x, q = a[h[f]].y, 0 >= (n - l) * (q - m) - (o - m) * (p - l)) k = false;
										else {
											var t, u, v, w, x, y, z, A, B, C;
											for (t = p - n, u = q - o, v = l - p, w = m - q, x = n - l, y = o - m, k = 0; k < c; k++)
												if (r = a[h[k]].x, s = a[h[k]].y, !(r === l && s === m || r === n && s === o || r === p && s === q) && (z = r - l, A = s - m, B = r - n, C = s - o, r -= p, s -= q, B = t * C - u * B, z = x * A - y * z, A = v * s - w * r, B >= -Number.EPSILON && A >= -Number.EPSILON && z >= -Number.EPSILON)) {
													k = false;
													break a
												}
											k = true
										}
									}
									if (k) {
										for (g.push([a[h[d]], a[h[e]], a[h[f]]]), i.push([h[d], h[e], h[f]]), d = e, f = e + 1; f < c; d++, f++) h[d] = h[f];
										c--, j = 2 * c
									}
								}
								return b ? i : g
							}
						}(),
						triangulateShape: function(a, b) {
							function c(a) {
								var b = a.length;
								2 < b && a[b - 1].equals(a[0]) && a.pop()
							}

							function d(a, b, c) {
								return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
							}

							function e(a, b, c, e, f) {
								var g = b.x - a.x,
									h = b.y - a.y,
									i = e.x - c.x,
									j = e.y - c.y,
									k = a.x - c.x,
									l = a.y - c.y,
									m = h * i - g * j,
									n = h * k - g * l;
								if (Math.abs(m) > Number.EPSILON) {
									if (0 < m) {
										if (0 > n || n > m) return [];
										if (i = j * k - i * l, 0 > i || i > m) return []
									} else {
										if (0 < n || n < m) return [];
										if (i = j * k - i * l, 0 < i || i < m) return []
									}
									return 0 === i ? !f || 0 !== n && n !== m ? [a] : [] : i === m ? !f || 0 !== n && n !== m ? [b] : [] : 0 === n ? [c] : n === m ? [e] : (f = i / m, [{
										x: a.x + f * g,
										y: a.y + f * h
									}])
								}
								return 0 !== n || j * k !== i * l ? [] : (h = 0 === g && 0 === h, i = 0 === i && 0 === j, h && i ? a.x !== c.x || a.y !== c.y ? [] : [a] : h ? d(c, e, a) ? [a] : [] : i ? d(a, b, c) ? [c] : [] : (0 !== g ? (a.x < b.x ? (g = a, i = a.x, h = b, a = b.x) : (g = b, i = b.x, h = a, a = a.x), c.x < e.x ? (b = c, m = c.x, j = e, c = e.x) : (b = e, m = e.x, j = c, c = c.x)) : (a.y < b.y ? (g = a, i = a.y, h = b, a = b.y) : (g = b, i = b.y, h = a, a = a.y), c.y < e.y ? (b = c, m = c.y, j = e, c = e.y) : (b = e, m = e.y, j = c, c = c.y)), i <= m ? a < m ? [] : a === m ? f ? [] : [b] : a <= c ? [b, h] : [b, j] : i > c ? [] : i === c ? f ? [] : [g] : a <= c ? [g, h] : [g, j]))
							}

							function f(a, b, c, d) {
								var e = b.x - a.x,
									f = b.y - a.y;
								b = c.x - a.x, c = c.y - a.y;
								var g = d.x - a.x;
								return d = d.y - a.y, a = e * c - f * b, e = e * d - f * g, Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
							}
							c(a), b.forEach(c);
							var g, h, i, j, k, l = {};
							for (i = a.concat(), g = 0, h = b.length; g < h; g++) Array.prototype.push.apply(i, b[g]);
							for (g = 0, h = i.length; g < h; g++) k = i[g].x + ":" + i[g].y, void 0 !== l[k] && console.warn("THREE.ShapeUtils: Duplicate point", k, g), l[k] = g;
							g = function(a, b) {
								function c(a, b) {
									var c = q.length - 1,
										d = a - 1;
									0 > d && (d = c);
									var e = a + 1;
									return e > c && (e = 0), !!(c = f(q[a], q[d], q[e], h[b])) && (c = h.length - 1, d = b - 1, 0 > d && (d = c), e = b + 1, e > c && (e = 0), !!(c = f(h[b], h[d], h[e], q[a])))
								}

								function d(a, b) {
									var c, d;
									for (c = 0; c < q.length; c++)
										if (d = c + 1, d %= q.length, d = e(a, b, q[c], q[d], true), 0 < d.length) return true;
									return false
								}

								function g(a, c) {
									var d, f, g, h;
									for (d = 0; d < r.length; d++)
										for (f = b[r[d]], g = 0; g < f.length; g++)
											if (h = g + 1, h %= f.length, h = e(a, c, f[g], f[h], true), 0 < h.length) return true;
									return false
								}
								var h, i, j, k, l, m, n, o, p, q = a.concat(),
									r = [],
									s = [],
									t = 0;
								for (i = b.length; t < i; t++) r.push(t);
								n = 0;
								for (var u = 2 * r.length; 0 < r.length;) {
									if (u--, 0 > u) {
										console.log("Infinite Loop! Holes left:" + r.length + ", Probably Hole outside Shape!");
										break
									}
									for (j = n; j < q.length; j++) {
										for (k = q[j], i = -1, t = 0; t < r.length; t++)
											if (l = r[t], m = k.x + ":" + k.y + ":" + l, void 0 === s[m]) {
												for (h = b[l], o = 0; o < h.length; o++)
													if (l = h[o], c(j, o) && !d(k, l) && !g(k, l)) {
														i = o, r.splice(t, 1), n = q.slice(0, j + 1), l = q.slice(j), o = h.slice(i), p = h.slice(0, i + 1), q = n.concat(o).concat(p).concat(l), n = j;
														break
													}
												if (0 <= i) break;
												s[m] = true
											}
										if (0 <= i) break
									}
								}
								return q
							}(a, b);
							var m = Je.triangulate(g, false);
							for (g = 0, h = m.length; g < h; g++)
								for (j = m[g], i = 0; 3 > i; i++) k = j[i].x + ":" + j[i].y, k = l[k], void 0 !== k && (j[i] = k);
							return m.concat()
						},
						isClockWise: function(a) {
							return 0 > Je.area(a)
						}
					};
					Xb.prototype = Object.create(wa.prototype), Xb.prototype.constructor = Xb, Yb.prototype = Object.create(xa.prototype), Yb.prototype.constructor = Yb, Yb.prototype.getArrays = function() {
						var a = this.getAttribute("position"),
							a = a ? Array.prototype.slice.call(a.array) : [],
							b = this.getAttribute("uv"),
							b = b ? Array.prototype.slice.call(b.array) : [],
							c = this.index,
							c = c ? Array.prototype.slice.call(c.array) : [];
						return {
							position: a,
							uv: b,
							index: c
						}
					}, Yb.prototype.addShapeList = function(a, b) {
						var c = a.length;
						b.arrays = this.getArrays();
						for (var d = 0; d < c; d++) this.addShape(a[d], b);
						this.setIndex(b.arrays.index), this.addAttribute("position", new sa(b.arrays.position, 3)), this.addAttribute("uv", new sa(b.arrays.uv, 2))
					}, Yb.prototype.addShape = function(a, b) {
						function d(a, b, c) {
							return b || console.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(c).add(a)
						}

						function e(a, b, d) {
							var e, f, g;
							f = a.x - b.x, g = a.y - b.y, e = d.x - a.x;
							var h = d.y - a.y,
								i = f * f + g * g;
							if (Math.abs(f * h - g * e) > Number.EPSILON) {
								var j = Math.sqrt(i),
									k = Math.sqrt(e * e + h * h),
									i = b.x - g / j;
								if (b = b.y + f / j, h = ((d.x - h / k - i) * h - (d.y + e / k - b) * e) / (f * h - g * e), e = i + f * h - a.x, f = b + g * h - a.y, g = e * e + f * f, 2 >= g) return new c(e, f);
								g = Math.sqrt(g / 2)
							} else a = false, f > Number.EPSILON ? e > Number.EPSILON && (a = true) : f < -Number.EPSILON ? e < -Number.EPSILON && (a = true) : Math.sign(g) === Math.sign(h) && (a = true), a ? (e = -g, g = Math.sqrt(i)) : (e = f, f = g, g = Math.sqrt(i / 2));
							return new c(e / g, f / g)
						}

						function f(a, b) {
							var c, d;
							for (T = a.length; 0 <= --T;) {
								c = T, d = T - 1, 0 > d && (d = a.length - 1);
								var e, f = A + 2 * x;
								for (e = 0; e < f; e++) {
									var g = R * e,
										h = R * (e + 1),
										i = b + d + g,
										l = b + d + h,
										h = b + c + h;
									j(b + c + g), j(i), j(h), j(i), j(l), j(h), g = r.length / 3, g = D.generateSideWallUV(H, r, g - 6, g - 3, g - 2, g - 1), k(g[0]), k(g[1]), k(g[3]), k(g[1]), k(g[2]), k(g[3])
								}
							}
						}

						function g(a, b, c) {
							u.push(a), u.push(b), u.push(c)
						}

						function h(a, b, c) {
							j(a), j(b), j(c), a = r.length / 3, a = D.generateTopUV(H, r, a - 3, a - 2, a - 1), k(a[0]), k(a[1]), k(a[2])
						}

						function j(a) {
							s.push(r.length / 3), r.push(u[3 * a + 0]), r.push(u[3 * a + 1]), r.push(u[3 * a + 2])
						}

						function k(a) {
							t.push(a.x), t.push(a.y)
						}
						var l, m, n, o, p, q = b.arrays ? b.arrays : this.getArrays(),
							r = q.position,
							s = q.index,
							t = q.uv,
							u = [],
							q = void 0 !== b.amount ? b.amount : 100,
							v = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
							w = void 0 !== b.bevelSize ? b.bevelSize : v - 2,
							x = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
							y = void 0 === b.bevelEnabled || b.bevelEnabled,
							z = void 0 !== b.curveSegments ? b.curveSegments : 12,
							A = void 0 !== b.steps ? b.steps : 1,
							B = b.extrudePath,
							C = false,
							D = void 0 !== b.UVGenerator ? b.UVGenerator : Xb.WorldUVGenerator;
						B && (l = B.getSpacedPoints(A), C = true, y = false, m = void 0 !== b.frames ? b.frames : B.computeFrenetFrames(A, false), n = new i, o = new i, p = new i), y || (w = v = x = 0);
						var E, F, G, H = this,
							B = a.extractPoints(z),
							z = B.shape,
							I = B.holes;
						if (B = !Je.isClockWise(z)) {
							for (z = z.reverse(), F = 0, G = I.length; F < G; F++) E = I[F], Je.isClockWise(E) && (I[F] = E.reverse());
							B = false
						}
						var J = Je.triangulateShape(z, I),
							K = z;
						for (F = 0, G = I.length; F < G; F++) E = I[F], z = z.concat(E);
						var L, M, N, O, P, Q, R = z.length,
							S = J.length,
							B = [],
							T = 0;
						for (N = K.length, L = N - 1, M = T + 1; T < N; T++, L++, M++) L === N && (L = 0), M === N && (M = 0), B[T] = e(K[T], K[L], K[M]);
						var U, V = [],
							W = B.concat();
						for (F = 0, G = I.length; F < G; F++) {
							for (E = I[F], U = [], T = 0, N = E.length, L = N - 1, M = T + 1; T < N; T++, L++, M++) L === N && (L = 0), M === N && (M = 0), U[T] = e(E[T], E[L], E[M]);
							V.push(U), W = W.concat(U)
						}
						for (L = 0; L < x; L++) {
							for (N = L / x, O = v * Math.cos(N * Math.PI / 2), M = w * Math.sin(N * Math.PI / 2), T = 0, N = K.length; T < N; T++) P = d(K[T], B[T], M), g(P.x, P.y, -O);
							for (F = 0, G = I.length; F < G; F++)
								for (E = I[F], U = V[F], T = 0, N = E.length; T < N; T++) P = d(E[T], U[T], M), g(P.x, P.y, -O)
						}
						for (M = w, T = 0; T < R; T++) P = y ? d(z[T], W[T], M) : z[T], C ? (o.copy(m.normals[0]).multiplyScalar(P.x), n.copy(m.binormals[0]).multiplyScalar(P.y), p.copy(l[0]).add(o).add(n), g(p.x, p.y, p.z)) : g(P.x, P.y, 0);
						for (N = 1; N <= A; N++)
							for (T = 0; T < R; T++) P = y ? d(z[T], W[T], M) : z[T], C ? (o.copy(m.normals[N]).multiplyScalar(P.x), n.copy(m.binormals[N]).multiplyScalar(P.y), p.copy(l[N]).add(o).add(n), g(p.x, p.y, p.z)) : g(P.x, P.y, q / A * N);
						for (L = x - 1; 0 <= L; L--) {
							for (N = L / x, O = v * Math.cos(N * Math.PI / 2), M = w * Math.sin(N * Math.PI / 2), T = 0, N = K.length; T < N; T++) P = d(K[T], B[T], M), g(P.x, P.y, q + O);
							for (F = 0, G = I.length; F < G; F++)
								for (E = I[F], U = V[F], T = 0, N = E.length; T < N; T++) P = d(E[T], U[T], M), C ? g(P.x, P.y + l[A - 1].y, l[A - 1].x + O) : g(P.x, P.y, q + O)
						}! function() {
							var a = r.length / 3;
							if (y) {
								var c = 0 * R;
								for (T = 0; T < S; T++) Q = J[T], h(Q[2] + c, Q[1] + c, Q[0] + c);
								for (c = R * (A + 2 * x), T = 0; T < S; T++) Q = J[T], h(Q[0] + c, Q[1] + c, Q[2] + c)
							} else {
								for (T = 0; T < S; T++) Q = J[T], h(Q[2], Q[1], Q[0]);
								for (T = 0; T < S; T++) Q = J[T], h(Q[0] + R * A, Q[1] + R * A, Q[2] + R * A)
							}
							H.addGroup(a, r.length / 3 - a, void 0 !== b.material ? b.material : 0)
						}(),
						function() {
							var a = r.length / 3,
								c = 0;
							for (f(K, c), c += K.length, F = 0, G = I.length; F < G; F++) E = I[F], f(E, c), c += E.length;
							H.addGroup(a, r.length / 3 - a, void 0 !== b.extrudeMaterial ? b.extrudeMaterial : 1)
						}(), b.arrays || (this.setIndex(s), this.addAttribute("position", new sa(r, 3)), this.addAttribute("uv", new sa(b.arrays.uv, 2)))
					}, Xb.WorldUVGenerator = {
						generateTopUV: function(a, b, d, e, f) {
							a = b[3 * e], e = b[3 * e + 1];
							var g = b[3 * f];
							return f = b[3 * f + 1], [new c(b[3 * d], b[3 * d + 1]), new c(a, e), new c(g, f)]
						},
						generateSideWallUV: function(a, b, d, e, f, g) {
							a = b[3 * d];
							var h = b[3 * d + 1];
							d = b[3 * d + 2];
							var i = b[3 * e],
								j = b[3 * e + 1];
							e = b[3 * e + 2];
							var k = b[3 * f],
								l = b[3 * f + 1];
							f = b[3 * f + 2];
							var m = b[3 * g],
								n = b[3 * g + 1];
							return b = b[3 * g + 2], .01 > Math.abs(h - j) ? [new c(a, 1 - d), new c(i, 1 - e), new c(k, 1 - f), new c(m, 1 - b)] : [new c(h, 1 - d), new c(j, 1 - e), new c(l, 1 - f), new c(n, 1 - b)]
						}
					}, Zb.prototype = Object.create(wa.prototype), Zb.prototype.constructor = Zb, $b.prototype = Object.create(Yb.prototype), $b.prototype.constructor = $b, _b.prototype = Object.create(wa.prototype), _b.prototype.constructor = _b, ac.prototype = Object.create(xa.prototype), ac.prototype.constructor = ac, bc.prototype = Object.create(wa.prototype), bc.prototype.constructor = bc, cc.prototype = Object.create(xa.prototype), cc.prototype.constructor = cc, dc.prototype = Object.create(wa.prototype), dc.prototype.constructor = dc, ec.prototype = Object.create(xa.prototype), ec.prototype.constructor = ec, fc.prototype = Object.create(wa.prototype), fc.prototype.constructor = fc, gc.prototype = Object.create(xa.prototype), gc.prototype.constructor = gc, hc.prototype = Object.create(xa.prototype), hc.prototype.constructor = hc, ic.prototype = Object.create(wa.prototype), ic.prototype.constructor = ic, jc.prototype = Object.create(xa.prototype), jc.prototype.constructor = jc, kc.prototype = Object.create(ic.prototype), kc.prototype.constructor = kc, lc.prototype = Object.create(jc.prototype), lc.prototype.constructor = lc, mc.prototype = Object.create(wa.prototype), mc.prototype.constructor = mc, nc.prototype = Object.create(xa.prototype), nc.prototype.constructor = nc;
					var Ke = Object.freeze({
						WireframeGeometry: Eb,
						ParametricGeometry: Fb,
						ParametricBufferGeometry: Gb,
						TetrahedronGeometry: Jb,
						TetrahedronBufferGeometry: Kb,
						OctahedronGeometry: Lb,
						OctahedronBufferGeometry: Mb,
						IcosahedronGeometry: Nb,
						IcosahedronBufferGeometry: Ob,
						DodecahedronGeometry: Pb,
						DodecahedronBufferGeometry: Qb,
						PolyhedronGeometry: Hb,
						PolyhedronBufferGeometry: Ib,
						TubeGeometry: Rb,
						TubeBufferGeometry: Sb,
						TorusKnotGeometry: Tb,
						TorusKnotBufferGeometry: Ub,
						TorusGeometry: Vb,
						TorusBufferGeometry: Wb,
						TextGeometry: Zb,
						TextBufferGeometry: $b,
						SphereGeometry: _b,
						SphereBufferGeometry: ac,
						RingGeometry: bc,
						RingBufferGeometry: cc,
						PlaneGeometry: Ba,
						PlaneBufferGeometry: Ca,
						LatheGeometry: dc,
						LatheBufferGeometry: ec,
						ShapeGeometry: fc,
						ShapeBufferGeometry: gc,
						ExtrudeGeometry: Xb,
						ExtrudeBufferGeometry: Yb,
						EdgesGeometry: hc,
						ConeGeometry: kc,
						ConeBufferGeometry: lc,
						CylinderGeometry: ic,
						CylinderBufferGeometry: jc,
						CircleGeometry: mc,
						CircleBufferGeometry: nc,
						BoxGeometry: za,
						BoxBufferGeometry: Aa
					});
					oc.prototype = Object.create(W.prototype), oc.prototype.constructor = oc, oc.prototype.isShadowMaterial = true, pc.prototype = Object.create(W.prototype), pc.prototype.constructor = pc, pc.prototype.isRawShaderMaterial = true, qc.prototype = Object.create(V.prototype), qc.prototype.constructor = qc, qc.prototype.isMeshStandardMaterial = true, qc.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.defines = {
							STANDARD: ""
						}, this.color.copy(a.color), this.roughness = a.roughness, this.metalness = a.metalness, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.roughnessMap = a.roughnessMap, this.metalnessMap = a.metalnessMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.envMapIntensity = a.envMapIntensity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
					}, rc.prototype = Object.create(qc.prototype), rc.prototype.constructor = rc, rc.prototype.isMeshPhysicalMaterial = true, rc.prototype.copy = function(a) {
						return qc.prototype.copy.call(this, a), this.defines = {
							PHYSICAL: ""
						}, this.reflectivity = a.reflectivity, this.clearCoat = a.clearCoat, this.clearCoatRoughness = a.clearCoatRoughness, this
					}, sc.prototype = Object.create(V.prototype), sc.prototype.constructor = sc, sc.prototype.isMeshPhongMaterial = true, sc.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), this.shininess = a.shininess, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
					}, tc.prototype = Object.create(sc.prototype), tc.prototype.constructor = tc, tc.prototype.isMeshToonMaterial = true, tc.prototype.copy = function(a) {
						return sc.prototype.copy.call(this, a), this.gradientMap = a.gradientMap, this
					}, uc.prototype = Object.create(V.prototype), uc.prototype.constructor = uc, uc.prototype.isMeshNormalMaterial = true, uc.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
					}, vc.prototype = Object.create(V.prototype), vc.prototype.constructor = vc, vc.prototype.isMeshLambertMaterial = true, vc.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
					}, wc.prototype = Object.create(V.prototype), wc.prototype.constructor = wc, wc.prototype.isLineDashedMaterial = true, wc.prototype.copy = function(a) {
						return V.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.scale = a.scale, this.dashSize = a.dashSize, this.gapSize = a.gapSize, this
					};
					var Le = Object.freeze({
							ShadowMaterial: oc,
							SpriteMaterial: nb,
							RawShaderMaterial: pc,
							ShaderMaterial: W,
							PointsMaterial: xb,
							MeshPhysicalMaterial: rc,
							MeshStandardMaterial: qc,
							MeshPhongMaterial: sc,
							MeshToonMaterial: tc,
							MeshNormalMaterial: uc,
							MeshLambertMaterial: vc,
							MeshDepthMaterial: X,
							MeshBasicMaterial: ja,
							LineDashedMaterial: wc,
							LineBasicMaterial: tb,
							Material: V
						}),
						Me = {
							enabled: false,
							files: {},
							add: function(a, b) {
								false !== this.enabled && (this.files[a] = b)
							},
							get: function(a) {
								if (false !== this.enabled) return this.files[a]
							},
							remove: function(a) {
								delete this.files[a]
							},
							clear: function() {
								this.files = {}
							}
						},
						Ne = new xc;
					Object.assign(yc.prototype, {
						load: function(a, b, c, d) {
							void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a);
							var e = this,
								f = Me.get(a);
							if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
								b && b(f), e.manager.itemEnd(a)
							}, 0), f;
							var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
							if (g) {
								var h = g[1],
									i = !!g[2],
									g = g[3],
									g = window.decodeURIComponent(g);
								i && (g = window.atob(g));
								try {
									var j, k = (this.responseType || "").toLowerCase();
									switch (k) {
										case "arraybuffer":
										case "blob":
											j = new ArrayBuffer(g.length);
											for (var l = new Uint8Array(j), i = 0; i < g.length; i++) l[i] = g.charCodeAt(i);
											"blob" === k && (j = new Blob([j], {
												type: h
											}));
											break;
										case "document":
											j = (new DOMParser).parseFromString(g, h);
											break;
										case "json":
											j = JSON.parse(g);
											break;
										default:
											j = g
									}
									window.setTimeout(function() {
										b && b(j), e.manager.itemEnd(a)
									}, 0)
								} catch (b) {
									window.setTimeout(function() {
										d && d(b), e.manager.itemEnd(a), e.manager.itemError(a)
									}, 0)
								}
							} else {
								var m = new XMLHttpRequest;
								m.open("GET", a, true), m.addEventListener("load", function(c) {
									var f = c.target.response;
									Me.add(a, f), 200 === this.status ? (b && b(f), e.manager.itemEnd(a)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), b && b(f), e.manager.itemEnd(a)) : (d && d(c), e.manager.itemEnd(a), e.manager.itemError(a))
								}, false), void 0 !== c && m.addEventListener("progress", function(a) {
									c(a)
								}, false), m.addEventListener("error", function(b) {
									d && d(b), e.manager.itemEnd(a), e.manager.itemError(a)
								}, false), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
								for (h in this.requestHeader) m.setRequestHeader(h, this.requestHeader[h]);
								m.send(null)
							}
							return e.manager.itemStart(a), m
						},
						setPath: function(a) {
							return this.path = a, this
						},
						setResponseType: function(a) {
							return this.responseType = a, this
						},
						setWithCredentials: function(a) {
							return this.withCredentials = a, this
						},
						setMimeType: function(a) {
							return this.mimeType = a, this
						},
						setRequestHeader: function(a) {
							return this.requestHeader = a, this
						}
					}), Object.assign(zc.prototype, {
						load: function(a, b, c, d) {
							function e(e) {
								i.load(a[e], function(a) {
									a = f._parser(a, true), g[e] = {
										width: a.width,
										height: a.height,
										format: a.format,
										mipmaps: a.mipmaps
									}, j += 1, 6 === j && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = true, b && b(h))
								}, c, d)
							}
							var f = this,
								g = [],
								h = new Bb;
							h.image = g;
							var i = new yc(this.manager);
							if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(a))
								for (var j = 0, k = 0, l = a.length; k < l; ++k) e(k);
							else i.load(a, function(a) {
								if (a = f._parser(a, true), a.isCubemap)
									for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
										g[d] = {
											mipmaps: []
										};
										for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
									} else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
								1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = true, b && b(h)
							}, c, d);
							return h
						},
						setPath: function(a) {
							return this.path = a, this
						}
					}), Object.assign(Ac.prototype, {
						load: function(a, b, c, d) {
							var e = this,
								f = new k,
								g = new yc(this.manager);
							return g.setResponseType("arraybuffer"), g.load(a, function(a) {
								(a = e._parser(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = true, b && b(f, a))
							}, c, d), f
						}
					}), Object.assign(Bc.prototype, {
						load: function(a, b, c, d) {
							void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a);
							var e = this,
								f = Me.get(a);
							return void 0 !== f ? (e.manager.itemStart(a), setTimeout(function() {
								b && b(f), e.manager.itemEnd(a)
							}, 0), f) : (c = document.createElementNS("http://www.w3.org/1999/xhtml", "img"), c.addEventListener("load", function() {
								Me.add(a, this), b && b(this), e.manager.itemEnd(a)
							}, false), c.addEventListener("error", function(b) {
								d && d(b), e.manager.itemEnd(a), e.manager.itemError(a)
							}, false), "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin), e.manager.itemStart(a), c.src = a, c)
						},
						setCrossOrigin: function(a) {
							return this.crossOrigin = a, this
						},
						setPath: function(a) {
							return this.path = a, this
						}
					}), Object.assign(Cc.prototype, {
						load: function(a, b, c, d) {
							function e(c) {
								g.load(a[c], function(a) {
									f.images[c] = a, h++, 6 === h && (f.needsUpdate = true, b && b(f))
								}, void 0, d)
							}
							var f = new l,
								g = new Bc(this.manager);
							g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
							var h = 0;
							for (c = 0; c < a.length; ++c) e(c);
							return f
						},
						setCrossOrigin: function(a) {
							return this.crossOrigin = a, this
						},
						setPath: function(a) {
							return this.path = a, this
						}
					}), Object.assign(Dc.prototype, {
						load: function(a, b, c, e) {
							var f = new Bc(this.manager);
							f.setCrossOrigin(this.crossOrigin), f.setPath(this.path);
							var g = new d;
							return g.image = f.load(a, function() {
								var c = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data\:image\/jpeg/);
								g.format = c ? 1022 : 1023, g.needsUpdate = true, void 0 !== b && b(g)
							}, c, e), g
						},
						setCrossOrigin: function(a) {
							return this.crossOrigin = a, this
						},
						setPath: function(a) {
							return this.path = a, this
						}
					}), Ec.prototype = Object.assign(Object.create(fa.prototype), {
						constructor: Ec,
						isLight: true,
						copy: function(a) {
							return fa.prototype.copy.call(this, a), this.color.copy(a.color), this.intensity = a.intensity, this
						},
						toJSON: function(a) {
							return a = fa.prototype.toJSON.call(this, a), a.object.color = this.color.getHex(), a.object.intensity = this.intensity, void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (a.object.distance = this.distance), void 0 !== this.angle && (a.object.angle = this.angle), void 0 !== this.decay && (a.object.decay = this.decay), void 0 !== this.penumbra && (a.object.penumbra = this.penumbra), void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()), a
						}
					}), Fc.prototype = Object.assign(Object.create(Ec.prototype), {
						constructor: Fc,
						isHemisphereLight: true,
						copy: function(a) {
							return Ec.prototype.copy.call(this, a), this.groundColor.copy(a.groundColor), this
						}
					}), Object.assign(Gc.prototype, {
						copy: function(a) {
							return this.camera = a.camera.clone(), this.bias = a.bias, this.radius = a.radius, this.mapSize.copy(a.mapSize), this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						toJSON: function() {
							var a = {};
							return 0 !== this.bias && (a.bias = this.bias), 1 !== this.radius && (a.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (a.mapSize = this.mapSize.toArray()), a.camera = this.camera.toJSON(false).object, delete a.camera.matrix, a
						}
					}), Hc.prototype = Object.assign(Object.create(Gc.prototype), {
						constructor: Hc,
						isSpotLightShadow: true,
						update: function(a) {
							var b = this.camera,
								c = 2 * re.RAD2DEG * a.angle,
								d = this.mapSize.width / this.mapSize.height;
							a = a.distance || b.far, c === b.fov && d === b.aspect && a === b.far || (b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix())
						}
					}), Ic.prototype = Object.assign(Object.create(Ec.prototype), {
						constructor: Ic,
						isSpotLight: true,
						copy: function(a) {
							return Ec.prototype.copy.call(this, a), this.distance = a.distance, this.angle = a.angle, this.penumbra = a.penumbra, this.decay = a.decay, this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
						}
					}), Jc.prototype = Object.assign(Object.create(Ec.prototype), {
						constructor: Jc,
						isPointLight: true,
						copy: function(a) {
							return Ec.prototype.copy.call(this, a), this.distance = a.distance, this.decay = a.decay, this.shadow = a.shadow.clone(), this
						}
					}), Kc.prototype = Object.assign(Object.create(Gc.prototype), {
						constructor: Kc
					}), Lc.prototype = Object.assign(Object.create(Ec.prototype), {
						constructor: Lc,
						isDirectionalLight: true,
						copy: function(a) {
							return Ec.prototype.copy.call(this, a), this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
						}
					}), Mc.prototype = Object.assign(Object.create(Ec.prototype), {
						constructor: Mc,
						isAmbientLight: true
					}), Nc.prototype = Object.assign(Object.create(Ec.prototype), {
						constructor: Nc,
						isRectAreaLight: true,
						copy: function(a) {
							return Ec.prototype.copy.call(this, a), this.width = a.width, this.height = a.height, this
						},
						toJSON: function(a) {
							return a = Ec.prototype.toJSON.call(this, a), a.object.width = this.width, a.object.height = this.height, a
						}
					});
					var Oe = {
						arraySlice: function(a, b, c) {
							return Oe.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
						},
						convertArray: function(a, b, c) {
							return !a || !c && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
						},
						isTypedArray: function(a) {
							return ArrayBuffer.isView(a) && !(a instanceof DataView)
						},
						getKeyframeOrder: function(a) {
							for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
							return c.sort(function(b, c) {
								return a[b] - a[c]
							}), c
						},
						sortedArray: function(a, b, c) {
							for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)
								for (var h = c[f] * b, i = 0; i !== b; ++i) e[g++] = a[h + i];
							return e
						},
						flattenJSON: function(a, b, c, d) {
							for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
							if (void 0 !== f) {
								var g = f[d];
								if (void 0 !== g)
									if (Array.isArray(g)) {
										do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
									} else if (void 0 !== g.toArray) {
									do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
								} else
									do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f)
							}
						}
					};
					Object.assign(Oc.prototype, {
						evaluate: function(a) {
							var b = this.parameterPositions,
								c = this._cachedIndex,
								d = b[c],
								e = b[c - 1];
							a: {
								b: {
									c: {
										d: if (!(a < d)) {
											for (var f = c + 2;;) {
												if (void 0 === d) {
													if (a < e) break d;
													return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, a, e)
												}
												if (c === f) break;
												if (e = d, d = b[++c], a < d) break b
											}
											d = b.length;
											break c
										}if (a >= e) break a;
										for (f = b[1], a < f && (c = 2, e = f), f = c - 2;;) {
											if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
											if (c === f) break;
											if (d = e, e = b[--c - 1], a >= e) break b
										}
										d = c,
										c = 0
									}
									for (; c < d;) e = c + d >>> 1,
									a < b[e] ? d = e : c = e + 1;
									if (d = b[c], e = b[c - 1], void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
									if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
								}
								this._cachedIndex = c,
								this.intervalChanged_(c, e, d)
							}
							return this.interpolate_(c, e, a, d)
						},
						settings: null,
						DefaultSettings_: {},
						getSettings_: function() {
							return this.settings || this.DefaultSettings_
						},
						copySampleValue_: function(a) {
							var b = this.resultBuffer,
								c = this.sampleValues,
								d = this.valueSize;
							a *= d;
							for (var e = 0; e !== d; ++e) b[e] = c[a + e];
							return b
						},
						interpolate_: function(a, b, c, d) {
							throw Error("call to abstract method")
						},
						intervalChanged_: function(a, b, c) {}
					}), Object.assign(Oc.prototype, {
						beforeStart_: Oc.prototype.copySampleValue_,
						afterEnd_: Oc.prototype.copySampleValue_
					}), Pc.prototype = Object.assign(Object.create(Oc.prototype), {
						constructor: Pc,
						DefaultSettings_: {
							endingStart: 2400,
							endingEnd: 2400
						},
						intervalChanged_: function(a, b, c) {
							var d = this.parameterPositions,
								e = a - 2,
								f = a + 1,
								g = d[e],
								h = d[f];
							if (void 0 === g) switch (this.getSettings_().endingStart) {
								case 2401:
									e = a, g = 2 * b - c;
									break;
								case 2402:
									e = d.length - 2, g = b + d[e] - d[e + 1];
									break;
								default:
									e = a, g = c
							}
							if (void 0 === h) switch (this.getSettings_().endingEnd) {
								case 2401:
									f = a, h = 2 * c - b;
									break;
								case 2402:
									f = 1, h = c + d[1] - d[0];
									break;
								default:
									f = a - 1, h = b
							}
							a = .5 * (c - b), d = this.valueSize, this._weightPrev = a / (b - g), this._weightNext = a / (h - c), this._offsetPrev = e * d, this._offsetNext = f * d
						},
						interpolate_: function(a, b, c, d) {
							var e = this.resultBuffer,
								f = this.sampleValues,
								g = this.valueSize;
							a *= g;
							var h = a - g,
								i = this._offsetPrev,
								j = this._offsetNext,
								k = this._weightPrev,
								l = this._weightNext,
								m = (c - b) / (d - b);
							for (c = m * m, d = c * m, b = -k * d + 2 * k * c - k * m, k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * m + 1, m = (-1 - l) * d + (1.5 + l) * c + .5 * m, l = l * d - l * c, c = 0; c !== g; ++c) e[c] = b * f[i + c] + k * f[h + c] + m * f[a + c] + l * f[j + c];
							return e
						}
					}), Qc.prototype = Object.assign(Object.create(Oc.prototype), {
						constructor: Qc,
						interpolate_: function(a, b, c, d) {
							var e = this.resultBuffer,
								f = this.sampleValues,
								g = this.valueSize;
							a *= g;
							var h = a - g;
							for (b = (c - b) / (d - b), c = 1 - b, d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
							return e
						}
					}), Rc.prototype = Object.assign(Object.create(Oc.prototype), {
						constructor: Rc,
						interpolate_: function(a, b, c, d) {
							return this.copySampleValue_(a - 1)
						}
					});
					var Pe;
					Pe = {
						TimeBufferType: Float32Array,
						ValueBufferType: Float32Array,
						DefaultInterpolation: 2301,
						InterpolantFactoryMethodDiscrete: function(a) {
							return new Rc(this.times, this.values, this.getValueSize(), a)
						},
						InterpolantFactoryMethodLinear: function(a) {
							return new Qc(this.times, this.values, this.getValueSize(), a)
						},
						InterpolantFactoryMethodSmooth: function(a) {
							return new Pc(this.times, this.values, this.getValueSize(), a)
						},
						setInterpolation: function(a) {
							var b;
							switch (a) {
								case 2300:
									b = this.InterpolantFactoryMethodDiscrete;
									break;
								case 2301:
									b = this.InterpolantFactoryMethodLinear;
									break;
								case 2302:
									b = this.InterpolantFactoryMethodSmooth
							}
							if (void 0 === b) {
								if (b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
									if (a === this.DefaultInterpolation) throw Error(b);
									this.setInterpolation(this.DefaultInterpolation)
								}
								console.warn(b)
							} else this.createInterpolant = b
						},
						getInterpolation: function() {
							switch (this.createInterpolant) {
								case this.InterpolantFactoryMethodDiscrete:
									return 2300;
								case this.InterpolantFactoryMethodLinear:
									return 2301;
								case this.InterpolantFactoryMethodSmooth:
									return 2302
							}
						},
						getValueSize: function() {
							return this.values.length / this.times.length
						},
						shift: function(a) {
							if (0 !== a)
								for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
							return this
						},
						scale: function(a) {
							if (1 !== a)
								for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
							return this
						},
						trim: function(a, b) {
							for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;) ++e;
							for (; - 1 !== f && c[f] > b;) --f;
							return ++f, 0 === e && f === d || (e >= f && (f = Math.max(f, 1), e = f - 1), d = this.getValueSize(), this.times = Oe.arraySlice(c, e, f), this.values = Oe.arraySlice(this.values, e * d, f * d)), this
						},
						validate: function() {
							var a = true,
								b = this.getValueSize();
							0 !== b - Math.floor(b) && (console.error("invalid value size in track", this), a = false);
							var c = this.times,
								b = this.values,
								d = c.length;
							0 === d && (console.error("track is empty", this), a = false);
							for (var e = null, f = 0; f !== d; f++) {
								var g = c[f];
								if ("number" == typeof g && isNaN(g)) {
									console.error("time is not a valid number", this, f, g), a = false;
									break
								}
								if (null !== e && e > g) {
									console.error("out of order keys", this, f, g, e), a = false;
									break
								}
								e = g
							}
							if (void 0 !== b && Oe.isTypedArray(b))
								for (f = 0, c = b.length; f !== c; ++f)
									if (d = b[f], isNaN(d)) {
										console.error("value is not a valid number", this, f, d), a = false;
										break
									}
							return a
						},
						optimize: function() {
							for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) {
								var h = false,
									i = a[g];
								if (i !== a[g + 1] && (1 !== g || i !== i[0]))
									if (d) h = true;
									else
										for (var j = g * c, k = j - c, l = j + c, i = 0; i !== c; ++i) {
											var m = b[j + i];
											if (m !== b[k + i] || m !== b[l + i]) {
												h = true;
												break
											}
										}
								if (h) {
									if (g !== e)
										for (a[e] = a[g], h = g * c, j = e * c, i = 0; i !== c; ++i) b[j + i] = b[h + i];
									++e
								}
							}
							if (0 < f) {
								for (a[e] = a[f], h = f * c, j = e * c, i = 0; i !== c; ++i) b[j + i] = b[h + i];
								++e
							}
							return e !== a.length && (this.times = Oe.arraySlice(a, 0, e), this.values = Oe.arraySlice(b, 0, e * c)), this
						}
					}, Tc.prototype = Object.assign(Object.create(Pe), {
						constructor: Tc,
						ValueTypeName: "vector"
					}), Uc.prototype = Object.assign(Object.create(Oc.prototype), {
						constructor: Uc,
						interpolate_: function(a, b, c, d) {
							var e = this.resultBuffer,
								f = this.sampleValues,
								g = this.valueSize;
							for (a *= g, b = (c - b) / (d - b), c = a + g; a !== c; a += 4) h.slerpFlat(e, 0, f, a - g, f, a, b);
							return e
						}
					}), Vc.prototype = Object.assign(Object.create(Pe), {
						constructor: Vc,
						ValueTypeName: "quaternion",
						DefaultInterpolation: 2301,
						InterpolantFactoryMethodLinear: function(a) {
							return new Uc(this.times, this.values, this.getValueSize(), a)
						},
						InterpolantFactoryMethodSmooth: void 0
					}), Wc.prototype = Object.assign(Object.create(Pe), {
						constructor: Wc,
						ValueTypeName: "number"
					}), Xc.prototype = Object.assign(Object.create(Pe), {
						constructor: Xc,
						ValueTypeName: "string",
						ValueBufferType: Array,
						DefaultInterpolation: 2300,
						InterpolantFactoryMethodLinear: void 0,
						InterpolantFactoryMethodSmooth: void 0
					}), Yc.prototype = Object.assign(Object.create(Pe), {
						constructor: Yc,
						ValueTypeName: "bool",
						ValueBufferType: Array,
						DefaultInterpolation: 2300,
						InterpolantFactoryMethodLinear: void 0,
						InterpolantFactoryMethodSmooth: void 0
					}), Zc.prototype = Object.assign(Object.create(Pe), {
						constructor: Zc,
						ValueTypeName: "color"
					}), $c.prototype = Pe, Pe.constructor = $c, Object.assign($c, {
						parse: function(a) {
							if (void 0 === a.type) throw Error("track type undefined, can not parse");
							var b = $c._getTrackTypeForValueTypeName(a.type);
							if (void 0 === a.times) {
								var c = [],
									d = [];
								Oe.flattenJSON(a.keys, c, d, "value"), a.times = c, a.values = d
							}
							return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
						},
						toJSON: function(a) {
							var b = a.constructor;
							if (void 0 !== b.toJSON) b = b.toJSON(a);
							else {
								var b = {
										name: a.name,
										times: Oe.convertArray(a.times, Array),
										values: Oe.convertArray(a.values, Array)
									},
									c = a.getInterpolation();
								c !== a.DefaultInterpolation && (b.interpolation = c)
							}
							return b.type = a.ValueTypeName, b
						},
						_getTrackTypeForValueTypeName: function(a) {
							switch (a.toLowerCase()) {
								case "scalar":
								case "double":
								case "float":
								case "number":
								case "integer":
									return Wc;
								case "vector":
								case "vector2":
								case "vector3":
								case "vector4":
									return Tc;
								case "color":
									return Zc;
								case "quaternion":
									return Vc;
								case "bool":
								case "boolean":
									return Yc;
								case "string":
									return Xc
							}
							throw Error("Unsupported typeName: " + a)
						}
					}), Object.assign(_c, {
						parse: function(a) {
							for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push($c.parse(c[e]).scale(d));
							return new _c(a.name, a.duration, b)
						},
						toJSON: function(a) {
							var b = [],
								c = a.tracks;
							a = {
								name: a.name,
								duration: a.duration,
								tracks: b
							};
							for (var d = 0, e = c.length; d !== e; ++d) b.push($c.toJSON(c[d]));
							return a
						},
						CreateFromMorphTargetSequence: function(a, b, c, d) {
							for (var e = b.length, f = [], g = 0; g < e; g++) {
								var h = [],
									i = [];
								h.push((g + e - 1) % e, g, (g + 1) % e), i.push(0, 1, 0);
								var j = Oe.getKeyframeOrder(h),
									h = Oe.sortedArray(h, 1, j),
									i = Oe.sortedArray(i, 1, j);
								d || 0 !== h[0] || (h.push(e), i.push(i[0])), f.push(new Wc(".morphTargetInfluences[" + b[g].name + "]", h, i).scale(1 / c))
							}
							return new _c(a, -1, f)
						},
						findByName: function(a, b) {
							var c = a;
							Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
							for (var d = 0; d < c.length; d++)
								if (c[d].name === b) return c[d];
							return null
						},
						CreateClipsFromMorphTargetSequences: function(a, b, c) {
							for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
								var h = a[f],
									i = h.name.match(e);
								if (i && 1 < i.length) {
									var j = i[1];
									(i = d[j]) || (d[j] = i = []), i.push(h)
								}
							}
							a = [];
							for (j in d) a.push(_c.CreateFromMorphTargetSequence(j, d[j], b, c));
							return a
						},
						parseAnimation: function(a, b) {
							if (!a) return console.error("  no animation in JSONLoader data"), null;
							for (var c = function(a, b, c, d, e) {
									if (0 !== c.length) {
										var f = [],
											g = [];
										Oe.flattenJSON(c, f, g, d), 0 !== f.length && e.push(new a(b, f, g))
									}
								}, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30, h = a.hierarchy || [], i = 0; i < h.length; i++) {
								var j = h[i].keys;
								if (j && 0 !== j.length)
									if (j[0].morphTargets) {
										for (var f = {}, k = 0; k < j.length; k++)
											if (j[k].morphTargets)
												for (var l = 0; l < j[k].morphTargets.length; l++) f[j[k].morphTargets[l]] = -1;
										for (var m in f) {
											for (var n = [], o = [], l = 0; l !== j[k].morphTargets.length; ++l) {
												var p = j[k];
												n.push(p.time), o.push(p.morphTarget === m ? 1 : 0)
											}
											d.push(new Wc(".morphTargetInfluence[" + m + "]", n, o))
										}
										f = f.length * (g || 1)
									} else k = ".bones[" + b[i].name + "]", c(Tc, k + ".position", j, "pos", d), c(Vc, k + ".quaternion", j, "rot", d), c(Tc, k + ".scale", j, "scl", d)
							}
							return 0 === d.length ? null : new _c(e, f, d)
						}
					}), Object.assign(_c.prototype, {
						resetDuration: function() {
							for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) var d = this.tracks[b],
								a = Math.max(a, d.times[d.times.length - 1]);
							this.duration = a
						},
						trim: function() {
							for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
							return this
						},
						optimize: function() {
							for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
							return this
						}
					}), Object.assign(ad.prototype, {
						load: function(a, b, c, d) {
							var e = this,
								f = new yc(e.manager);
							f.setResponseType("json"), f.load(a, function(a) {
								b(e.parse(a))
							}, c, d)
						},
						setTextures: function(a) {
							this.textures = a
						},
						parse: function(a) {
							function b(a) {
								return void 0 === d[a] && console.warn("THREE.MaterialLoader: Undefined texture", a), d[a]
							}
							var d = this.textures,
								e = new Le[a.type];
							if (void 0 !== a.uuid && (e.uuid = a.uuid), void 0 !== a.name && (e.name = a.name), void 0 !== a.color && e.color.setHex(a.color), void 0 !== a.roughness && (e.roughness = a.roughness), void 0 !== a.metalness && (e.metalness = a.metalness), void 0 !== a.emissive && e.emissive.setHex(a.emissive), void 0 !== a.specular && e.specular.setHex(a.specular), void 0 !== a.shininess && (e.shininess = a.shininess), void 0 !== a.clearCoat && (e.clearCoat = a.clearCoat), void 0 !== a.clearCoatRoughness && (e.clearCoatRoughness = a.clearCoatRoughness), void 0 !== a.uniforms && (e.uniforms = a.uniforms), void 0 !== a.vertexShader && (e.vertexShader = a.vertexShader), void 0 !== a.fragmentShader && (e.fragmentShader = a.fragmentShader), void 0 !== a.vertexColors && (e.vertexColors = a.vertexColors), void 0 !== a.fog && (e.fog = a.fog), void 0 !== a.shading && (e.shading = a.shading), void 0 !== a.blending && (e.blending = a.blending), void 0 !== a.side && (e.side = a.side), void 0 !== a.opacity && (e.opacity = a.opacity), void 0 !== a.transparent && (e.transparent = a.transparent), void 0 !== a.alphaTest && (e.alphaTest = a.alphaTest), void 0 !== a.depthTest && (e.depthTest = a.depthTest), void 0 !== a.depthWrite && (e.depthWrite = a.depthWrite), void 0 !== a.colorWrite && (e.colorWrite = a.colorWrite), void 0 !== a.wireframe && (e.wireframe = a.wireframe), void 0 !== a.wireframeLinewidth && (e.wireframeLinewidth = a.wireframeLinewidth), void 0 !== a.wireframeLinecap && (e.wireframeLinecap = a.wireframeLinecap), void 0 !== a.wireframeLinejoin && (e.wireframeLinejoin = a.wireframeLinejoin), void 0 !== a.skinning && (e.skinning = a.skinning), void 0 !== a.morphTargets && (e.morphTargets = a.morphTargets), void 0 !== a.size && (e.size = a.size), void 0 !== a.sizeAttenuation && (e.sizeAttenuation = a.sizeAttenuation), void 0 !== a.map && (e.map = b(a.map)), void 0 !== a.alphaMap && (e.alphaMap = b(a.alphaMap), e.transparent = true), void 0 !== a.bumpMap && (e.bumpMap = b(a.bumpMap)), void 0 !== a.bumpScale && (e.bumpScale = a.bumpScale), void 0 !== a.normalMap && (e.normalMap = b(a.normalMap)), void 0 !== a.normalScale) {
								var f = a.normalScale;
								false === Array.isArray(f) && (f = [f, f]), e.normalScale = (new c).fromArray(f)
							}
							return void 0 !== a.displacementMap && (e.displacementMap = b(a.displacementMap)), void 0 !== a.displacementScale && (e.displacementScale = a.displacementScale), void 0 !== a.displacementBias && (e.displacementBias = a.displacementBias), void 0 !== a.roughnessMap && (e.roughnessMap = b(a.roughnessMap)), void 0 !== a.metalnessMap && (e.metalnessMap = b(a.metalnessMap)), void 0 !== a.emissiveMap && (e.emissiveMap = b(a.emissiveMap)), void 0 !== a.emissiveIntensity && (e.emissiveIntensity = a.emissiveIntensity), void 0 !== a.specularMap && (e.specularMap = b(a.specularMap)), void 0 !== a.envMap && (e.envMap = b(a.envMap)), void 0 !== a.reflectivity && (e.reflectivity = a.reflectivity), void 0 !== a.lightMap && (e.lightMap = b(a.lightMap)), void 0 !== a.lightMapIntensity && (e.lightMapIntensity = a.lightMapIntensity), void 0 !== a.aoMap && (e.aoMap = b(a.aoMap)), void 0 !== a.aoMapIntensity && (e.aoMapIntensity = a.aoMapIntensity), void 0 !== a.gradientMap && (e.gradientMap = b(a.gradientMap)), e
						}
					}), Object.assign(bd.prototype, {
						load: function(a, b, c, d) {
							var e = this,
								f = new yc(e.manager);
							f.setResponseType("json"), f.load(a, function(a) {
								b(e.parse(a))
							}, c, d)
						},
						parse: function(a) {
							var b = new xa,
								c = a.data.index;
							void 0 !== c && (c = new Qe[c.type](c.array), b.setIndex(new ka(c, 1)));
							var d, e = a.data.attributes;
							for (d in e) {
								var f = e[d],
									c = new Qe[f.type](f.array);
								b.addAttribute(d, new ka(c, f.itemSize, f.normalized))
							}
							if (d = a.data.groups || a.data.drawcalls || a.data.offsets, void 0 !== d)
								for (c = 0, e = d.length; c !== e; ++c) f = d[c], b.addGroup(f.start, f.count, f.materialIndex);
							return a = a.data.boundingSphere, void 0 !== a && (d = new i, void 0 !== a.center && d.fromArray(a.center), b.boundingSphere = new Z(d, a.radius)), b
						}
					});
					var Qe = {
						Int8Array: Int8Array,
						Uint8Array: Uint8Array,
						Uint8ClampedArray: Uint8ClampedArray,
						Int16Array: Int16Array,
						Uint16Array: Uint16Array,
						Int32Array: Int32Array,
						Uint32Array: Uint32Array,
						Float32Array: Float32Array,
						Float64Array: Float64Array
					};
					cd.Handlers = {
						handlers: [],
						add: function(a, b) {
							this.handlers.push(a, b)
						},
						get: function(a) {
							for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
								var e = b[c + 1];
								if (b[c].test(a)) return e
							}
							return null
						}
					}, Object.assign(cd.prototype, {
						crossOrigin: void 0,
						extractUrlBase: function(a) {
							return a = a.split("/"), 1 === a.length ? "./" : (a.pop(), a.join("/") + "/")
						},
						initMaterials: function(a, b, c) {
							for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
							return d
						},
						createMaterial: function() {
							var a = {
									NoBlending: 0,
									NormalBlending: 1,
									AdditiveBlending: 2,
									SubtractiveBlending: 3,
									MultiplyBlending: 4,
									CustomBlending: 5
								},
								b = new R,
								c = new Dc,
								d = new ad;
							return function(e, f, g) {
								function h(a, b, d, e, h) {
									a = f + a;
									var i = cd.Handlers.get(a);
									return null !== i ? a = i.load(a) : (c.setCrossOrigin(g), a = c.load(a)), void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1e3), 1 !== b[1] && (a.wrapT = 1e3)), void 0 !== d && a.offset.fromArray(d), void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1e3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1e3), "mirror" === e[1] && (a.wrapT = 1002)), void 0 !== h && (a.anisotropy = h), b = re.generateUUID(), j[b] = a, b
								}
								var i, j = {},
									k = {
										uuid: re.generateUUID(),
										type: "MeshLambertMaterial"
									};
								for (i in e) {
									var l = e[i];
									switch (i) {
										case "DbgColor":
										case "DbgIndex":
										case "opticalDensity":
										case "illumination":
											break;
										case "DbgName":
											k.name = l;
											break;
										case "blending":
											k.blending = a[l];
											break;
										case "colorAmbient":
										case "mapAmbient":
											console.warn("THREE.Loader.createMaterial:", i, "is no longer supported.");
											break;
										case "colorDiffuse":
											k.color = b.fromArray(l).getHex();
											break;
										case "colorSpecular":
											k.specular = b.fromArray(l).getHex();
											break;
										case "colorEmissive":
											k.emissive = b.fromArray(l).getHex();
											break;
										case "specularCoef":
											k.shininess = l;
											break;
										case "shading":
											"basic" === l.toLowerCase() && (k.type = "MeshBasicMaterial"), "phong" === l.toLowerCase() && (k.type = "MeshPhongMaterial"), "standard" === l.toLowerCase() && (k.type = "MeshStandardMaterial");
											break;
										case "mapDiffuse":
											k.map = h(l, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
											break;
										case "mapDiffuseRepeat":
										case "mapDiffuseOffset":
										case "mapDiffuseWrap":
										case "mapDiffuseAnisotropy":
											break;
										case "mapEmissive":
											k.emissiveMap = h(l, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
											break;
										case "mapEmissiveRepeat":
										case "mapEmissiveOffset":
										case "mapEmissiveWrap":
										case "mapEmissiveAnisotropy":
											break;
										case "mapLight":
											k.lightMap = h(l, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
											break;
										case "mapLightRepeat":
										case "mapLightOffset":
										case "mapLightWrap":
										case "mapLightAnisotropy":
											break;
										case "mapAO":
											k.aoMap = h(l, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
											break;
										case "mapAORepeat":
										case "mapAOOffset":
										case "mapAOWrap":
										case "mapAOAnisotropy":
											break;
										case "mapBump":
											k.bumpMap = h(l, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
											break;
										case "mapBumpScale":
											k.bumpScale = l;
											break;
										case "mapBumpRepeat":
										case "mapBumpOffset":
										case "mapBumpWrap":
										case "mapBumpAnisotropy":
											break;
										case "mapNormal":
											k.normalMap = h(l, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
											break;
										case "mapNormalFactor":
											k.normalScale = [l, l];
											break;
										case "mapNormalRepeat":
										case "mapNormalOffset":
										case "mapNormalWrap":
										case "mapNormalAnisotropy":
											break;
										case "mapSpecular":
											k.specularMap = h(l, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
											break;
										case "mapSpecularRepeat":
										case "mapSpecularOffset":
										case "mapSpecularWrap":
										case "mapSpecularAnisotropy":
											break;
										case "mapMetalness":
											k.metalnessMap = h(l, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
											break;
										case "mapMetalnessRepeat":
										case "mapMetalnessOffset":
										case "mapMetalnessWrap":
										case "mapMetalnessAnisotropy":
											break;
										case "mapRoughness":
											k.roughnessMap = h(l, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
											break;
										case "mapRoughnessRepeat":
										case "mapRoughnessOffset":
										case "mapRoughnessWrap":
										case "mapRoughnessAnisotropy":
											break;
										case "mapAlpha":
											k.alphaMap = h(l, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
											break;
										case "mapAlphaRepeat":
										case "mapAlphaOffset":
										case "mapAlphaWrap":
										case "mapAlphaAnisotropy":
											break;
										case "flipSided":
											k.side = 1;
											break;
										case "doubleSided":
											k.side = 2;
											break;
										case "transparency":
											console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), k.opacity = l;
											break;
										case "depthTest":
										case "depthWrite":
										case "colorWrite":
										case "opacity":
										case "reflectivity":
										case "transparent":
										case "visible":
										case "wireframe":
											k[i] = l;
											break;
										case "vertexColors":
											true === l && (k.vertexColors = 2), "face" === l && (k.vertexColors = 1);
											break;
										default:
											console.error("THREE.Loader.createMaterial: Unsupported", i, l)
									}
								}
								return "MeshBasicMaterial" === k.type && delete k.emissive, "MeshPhongMaterial" !== k.type && delete k.specular, 1 > k.opacity && (k.transparent = true), d.setTextures(j), d.parse(k)
							}
						}()
					}), Object.assign(dd.prototype, {
						load: function(a, b, c, d) {
							var e = this,
								f = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : cd.prototype.extractUrlBase(a),
								g = new yc(this.manager);
							g.setResponseType("json"), g.setWithCredentials(this.withCredentials), g.load(a, function(c) {
								var d = c.metadata;
								if (void 0 !== d && (d = d.type, void 0 !== d)) {
									if ("object" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
									if ("scene" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.")
								}
								c = e.parse(c, f), b(c.geometry, c.materials)
							}, c, d)
						},
						setTexturePath: function(a) {
							this.texturePath = a
						},
						parse: function() {
							return function(a, b) {
								void 0 !== a.data && (a = a.data), a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
								var d, f, g, h, j, k, l, m, n, o, p, q, r, s, t = new wa,
									u = a,
									v = u.faces;
								n = u.vertices;
								var w = u.normals,
									x = u.colors;
								k = u.scale;
								var y = 0;
								if (void 0 !== u.uvs) {
									for (d = 0; d < u.uvs.length; d++) u.uvs[d].length && y++;
									for (d = 0; d < y; d++) t.faceVertexUvs[d] = []
								}
								for (h = 0, j = n.length; h < j;) d = new i, d.x = n[h++] * k, d.y = n[h++] * k, d.z = n[h++] * k, t.vertices.push(d);
								for (h = 0, j = v.length; h < j;)
									if (n = v[h++], o = 1 & n, g = 2 & n, d = 8 & n, l = 16 & n, p = 32 & n, k = 64 & n, n &= 128, o) {
										if (o = new ia, o.a = v[h], o.b = v[h + 1], o.c = v[h + 3], q = new ia, q.a = v[h + 1], q.b = v[h + 2], q.c = v[h + 3], h += 4, g && (g = v[h++], o.materialIndex = g, q.materialIndex = g), g = t.faces.length, d)
											for (d = 0; d < y; d++)
												for (r = u.uvs[d], t.faceVertexUvs[d][g] = [], t.faceVertexUvs[d][g + 1] = [], f = 0; 4 > f; f++) m = v[h++], s = r[2 * m], m = r[2 * m + 1], s = new c(s, m), 2 !== f && t.faceVertexUvs[d][g].push(s), 0 !== f && t.faceVertexUvs[d][g + 1].push(s);
										if (l && (l = 3 * v[h++], o.normal.set(w[l++], w[l++], w[l]), q.normal.copy(o.normal)), p)
											for (d = 0; 4 > d; d++) l = 3 * v[h++], p = new i(w[l++], w[l++], w[l]), 2 !== d && o.vertexNormals.push(p), 0 !== d && q.vertexNormals.push(p);
										if (k && (k = v[h++], k = x[k], o.color.setHex(k), q.color.setHex(k)), n)
											for (d = 0; 4 > d; d++) k = v[h++], k = x[k], 2 !== d && o.vertexColors.push(new R(k)), 0 !== d && q.vertexColors.push(new R(k));
										t.faces.push(o), t.faces.push(q)
									} else {
										if (o = new ia, o.a = v[h++], o.b = v[h++], o.c = v[h++], g && (g = v[h++], o.materialIndex = g), g = t.faces.length, d)
											for (d = 0; d < y; d++)
												for (r = u.uvs[d], t.faceVertexUvs[d][g] = [], f = 0; 3 > f; f++) m = v[h++], s = r[2 * m], m = r[2 * m + 1], s = new c(s, m), t.faceVertexUvs[d][g].push(s);
										if (l && (l = 3 * v[h++], o.normal.set(w[l++], w[l++], w[l])), p)
											for (d = 0; 3 > d; d++) l = 3 * v[h++], p = new i(w[l++], w[l++], w[l]), o.vertexNormals.push(p);
										if (k && (k = v[h++], o.color.setHex(x[k])), n)
											for (d = 0; 3 > d; d++) k = v[h++], o.vertexColors.push(new R(x[k]));
										t.faces.push(o)
									}
								if (u = a, h = void 0 !== u.influencesPerVertex ? u.influencesPerVertex : 2, u.skinWeights)
									for (j = 0, v = u.skinWeights.length; j < v; j += h) t.skinWeights.push(new e(u.skinWeights[j], 1 < h ? u.skinWeights[j + 1] : 0, 2 < h ? u.skinWeights[j + 2] : 0, 3 < h ? u.skinWeights[j + 3] : 0));
								if (u.skinIndices)
									for (j = 0, v = u.skinIndices.length; j < v; j += h) t.skinIndices.push(new e(u.skinIndices[j], 1 < h ? u.skinIndices[j + 1] : 0, 2 < h ? u.skinIndices[j + 2] : 0, 3 < h ? u.skinIndices[j + 3] : 0));
								if (t.bones = u.bones, t.bones && 0 < t.bones.length && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match."), j = a, v = j.scale, void 0 !== j.morphTargets)
									for (u = 0, h = j.morphTargets.length; u < h; u++)
										for (t.morphTargets[u] = {}, t.morphTargets[u].name = j.morphTargets[u].name, t.morphTargets[u].vertices = [], w = t.morphTargets[u].vertices, x = j.morphTargets[u].vertices, y = 0, n = x.length; y < n; y += 3) k = new i, k.x = x[y] * v, k.y = x[y + 1] * v, k.z = x[y + 2] * v, w.push(k);
								if (void 0 !== j.morphColors && 0 < j.morphColors.length)
									for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), v = t.faces, j = j.morphColors[0].colors, u = 0, h = v.length; u < h; u++) v[u].color.fromArray(j, 3 * u);
								for (j = a, u = [], h = [], void 0 !== j.animation && h.push(j.animation), void 0 !== j.animations && (j.animations.length ? h = h.concat(j.animations) : h.push(j.animations)), j = 0; j < h.length; j++)(v = _c.parseAnimation(h[j], t.bones)) && u.push(v);
								return t.morphTargets && (h = _c.CreateClipsFromMorphTargetSequences(t.morphTargets, 10), u = u.concat(h)), 0 < u.length && (t.animations = u), t.computeFaceNormals(), t.computeBoundingSphere(), void 0 === a.materials || 0 === a.materials.length ? {
									geometry: t
								} : (u = cd.prototype.initMaterials(a.materials, b, this.crossOrigin), {
									geometry: t,
									materials: u
								})
							}
						}()
					}), Object.assign(ed.prototype, {
						load: function(a, b, c, d) {
							"" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
							var e = this;
							new yc(e.manager).load(a, function(c) {
								var f = null;
								try {
									f = JSON.parse(c)
								} catch (b) {
									return void 0 !== d && d(b), void console.error("THREE:ObjectLoader: Can't parse " + a + ".", b.message)
								}
								c = f.metadata, void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(f, b)
							}, c, d)
						},
						setTexturePath: function(a) {
							this.texturePath = a
						},
						setCrossOrigin: function(a) {
							this.crossOrigin = a
						},
						parse: function(a, b) {
							var c = this.parseGeometries(a.geometries),
								d = this.parseImages(a.images, function() {
									void 0 !== b && b(e)
								}),
								d = this.parseTextures(a.textures, d),
								d = this.parseMaterials(a.materials, d),
								e = this.parseObject(a.object, c, d);
							return a.animations && (e.animations = this.parseAnimations(a.animations)), void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e), e
						},
						parseGeometries: function(a) {
							var b = {};
							if (void 0 !== a)
								for (var c = new dd, d = new bd, e = 0, f = a.length; e < f; e++) {
									var g, h = a[e];
									switch (h.type) {
										case "PlaneGeometry":
										case "PlaneBufferGeometry":
											g = new Ke[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
											break;
										case "BoxGeometry":
										case "BoxBufferGeometry":
										case "CubeGeometry":
											g = new Ke[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
											break;
										case "CircleGeometry":
										case "CircleBufferGeometry":
											g = new Ke[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
											break;
										case "CylinderGeometry":
										case "CylinderBufferGeometry":
											g = new Ke[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
											break;
										case "ConeGeometry":
										case "ConeBufferGeometry":
											g = new Ke[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
											break;
										case "SphereGeometry":
										case "SphereBufferGeometry":
											g = new Ke[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
											break;
										case "DodecahedronGeometry":
										case "IcosahedronGeometry":
										case "OctahedronGeometry":
										case "TetrahedronGeometry":
											g = new Ke[h.type](h.radius, h.detail);
											break;
										case "RingGeometry":
										case "RingBufferGeometry":
											g = new Ke[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
											break;
										case "TorusGeometry":
										case "TorusBufferGeometry":
											g = new Ke[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
											break;
										case "TorusKnotGeometry":
										case "TorusKnotBufferGeometry":
											g = new Ke[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
											break;
										case "LatheGeometry":
										case "LatheBufferGeometry":
											g = new Ke[h.type](h.points, h.segments, h.phiStart, h.phiLength);
											break;
										case "BufferGeometry":
											g = d.parse(h);
											break;
										case "Geometry":
											g = c.parse(h, this.texturePath).geometry;
											break;
										default:
											console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
											continue
									}
									g.uuid = h.uuid, void 0 !== h.name && (g.name = h.name), b[h.uuid] = g
								}
							return b
						},
						parseMaterials: function(a, b) {
							var c = {};
							if (void 0 !== a) {
								var d = new ad;
								d.setTextures(b);
								for (var e = 0, f = a.length; e < f; e++) {
									var g = a[e];
									if ("MultiMaterial" === g.type) {
										for (var h = [], i = 0; i < g.materials.length; i++) h.push(d.parse(g.materials[i]));
										c[g.uuid] = h
									} else c[g.uuid] = d.parse(g)
								}
							}
							return c
						},
						parseAnimations: function(a) {
							for (var b = [], c = 0; c < a.length; c++) {
								var d = _c.parse(a[c]);
								b.push(d)
							}
							return b
						},
						parseImages: function(a, b) {
							function c(a) {
								return d.manager.itemStart(a), g.load(a, function() {
									d.manager.itemEnd(a)
								}, void 0, function() {
									d.manager.itemEnd(a), d.manager.itemError(a)
								})
							}
							var d = this,
								e = {};
							if (void 0 !== a && 0 < a.length) {
								var f = new xc(b),
									g = new Bc(f);
								g.setCrossOrigin(this.crossOrigin);
								for (var f = 0, h = a.length; f < h; f++) {
									var i = a[f],
										j = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i.url) ? i.url : d.texturePath + i.url;
									e[i.uuid] = c(j)
								}
							}
							return e
						},
						parseTextures: function(a, b) {
							function c(a, b) {
								return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), b[a])
							}
							var e = {};
							if (void 0 !== a)
								for (var f = 0, g = a.length; f < g; f++) {
									var h = a[f];
									void 0 === h.image && console.warn('THREE.ObjectLoader: No "image" specified for', h.uuid), void 0 === b[h.image] && console.warn("THREE.ObjectLoader: Undefined image", h.image);
									var i = new d(b[h.image]);
									i.needsUpdate = true, i.uuid = h.uuid, void 0 !== h.name && (i.name = h.name), void 0 !== h.mapping && (i.mapping = c(h.mapping, Re)), void 0 !== h.offset && i.offset.fromArray(h.offset), void 0 !== h.repeat && i.repeat.fromArray(h.repeat), void 0 !== h.wrap && (i.wrapS = c(h.wrap[0], Se), i.wrapT = c(h.wrap[1], Se)), void 0 !== h.minFilter && (i.minFilter = c(h.minFilter, Te)), void 0 !== h.magFilter && (i.magFilter = c(h.magFilter, Te)), void 0 !== h.anisotropy && (i.anisotropy = h.anisotropy), void 0 !== h.flipY && (i.flipY = h.flipY), e[h.uuid] = i
								}
							return e
						},
						parseObject: function() {
							var a = new j;
							return function(b, c, d) {
								function e(a) {
									return void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a), c[a]
								}

								function f(a) {
									if (void 0 !== a) {
										if (Array.isArray(a)) {
											for (var b = [], c = 0, e = a.length; c < e; c++) {
												var f = a[c];
												void 0 === d[f] && console.warn("THREE.ObjectLoader: Undefined material", f), b.push(d[f])
											}
											return b
										}
										return void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a), d[a]
									}
								}
								var g;
								switch (b.type) {
									case "Scene":
										g = new lb, void 0 !== b.background && Number.isInteger(b.background) && (g.background = new R(b.background)), void 0 !== b.fog && ("Fog" === b.fog.type ? g.fog = new kb(b.fog.color, b.fog.near, b.fog.far) : "FogExp2" === b.fog.type && (g.fog = new jb(b.fog.color, b.fog.density)));
										break;
									case "PerspectiveCamera":
										g = new Ea(b.fov, b.aspect, b.near, b.far), void 0 !== b.focus && (g.focus = b.focus), void 0 !== b.zoom && (g.zoom = b.zoom), void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge), void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset), void 0 !== b.view && (g.view = Object.assign({}, b.view));
										break;
									case "OrthographicCamera":
										g = new Fa(b.left, b.right, b.top, b.bottom, b.near, b.far);
										break;
									case "AmbientLight":
										g = new Mc(b.color, b.intensity);
										break;
									case "DirectionalLight":
										g = new Lc(b.color, b.intensity);
										break;
									case "PointLight":
										g = new Jc(b.color, b.intensity, b.distance, b.decay);
										break;
									case "RectAreaLight":
										g = new Nc(b.color, b.intensity, b.width, b.height);
										break;
									case "SpotLight":
										g = new Ic(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay);
										break;
									case "HemisphereLight":
										g = new Fc(b.color, b.groundColor, b.intensity);
										break;
									case "SkinnedMesh":
										console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
									case "Mesh":
										g = e(b.geometry);
										var h = f(b.material);
										g = g.bones && 0 < g.bones.length ? new sb(g, h) : new ya(g, h);
										break;
									case "LOD":
										g = new pb;
										break;
									case "Line":
										g = new ub(e(b.geometry), f(b.material), b.mode);
										break;
									case "LineLoop":
										g = new wb(e(b.geometry), f(b.material));
										break;
									case "LineSegments":
										g = new vb(e(b.geometry), f(b.material));
										break;
									case "PointCloud":
									case "Points":
										g = new yb(e(b.geometry), f(b.material));
										break;
									case "Sprite":
										g = new ob(f(b.material));
										break;
									case "Group":
										g = new zb;
										break;
									default:
										g = new fa
								}
								if (g.uuid = b.uuid, void 0 !== b.name && (g.name = b.name), void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position), void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.quaternion && g.quaternion.fromArray(b.quaternion), void 0 !== b.scale && g.scale.fromArray(b.scale)), void 0 !== b.castShadow && (g.castShadow = b.castShadow), void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow), b.shadow && (void 0 !== b.shadow.bias && (g.shadow.bias = b.shadow.bias), void 0 !== b.shadow.radius && (g.shadow.radius = b.shadow.radius), void 0 !== b.shadow.mapSize && g.shadow.mapSize.fromArray(b.shadow.mapSize), void 0 !== b.shadow.camera && (g.shadow.camera = this.parseObject(b.shadow.camera))), void 0 !== b.visible && (g.visible = b.visible), void 0 !== b.userData && (g.userData = b.userData), void 0 !== b.children)
									for (var i in b.children) g.add(this.parseObject(b.children[i], c, d));
								if ("LOD" === b.type)
									for (b = b.levels, h = 0; h < b.length; h++) {
										var j = b[h];
										i = g.getObjectByProperty("uuid", j.object), void 0 !== i && g.addLevel(i, j.distance)
									}
								return g
							}
						}()
					});
					var Re = {
							UVMapping: 300,
							CubeReflectionMapping: 301,
							CubeRefractionMapping: 302,
							EquirectangularReflectionMapping: 303,
							EquirectangularRefractionMapping: 304,
							SphericalReflectionMapping: 305,
							CubeUVReflectionMapping: 306,
							CubeUVRefractionMapping: 307
						},
						Se = {
							RepeatWrapping: 1e3,
							ClampToEdgeWrapping: 1001,
							MirroredRepeatWrapping: 1002
						},
						Te = {
							NearestFilter: 1003,
							NearestMipMapNearestFilter: 1004,
							NearestMipMapLinearFilter: 1005,
							LinearFilter: 1006,
							LinearMipMapNearestFilter: 1007,
							LinearMipMapLinearFilter: 1008
						};
					Object.assign(id.prototype, {
						getPoint: function() {
							return console.warn("THREE.Curve: .getPoint() not implemented."), null
						},
						getPointAt: function(a) {
							return a = this.getUtoTmapping(a), this.getPoint(a)
						},
						getPoints: function(a) {
							void 0 === a && (a = 5);
							for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
							return b
						},
						getSpacedPoints: function(a) {
							void 0 === a && (a = 5);
							for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
							return b
						},
						getLength: function() {
							var a = this.getLengths();
							return a[a.length - 1]
						},
						getLengths: function(a) {
							if (void 0 === a && (a = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
							this.needsUpdate = false;
							var b, c, d = [],
								e = this.getPoint(0),
								f = 0;
							for (d.push(0), c = 1; c <= a; c++) b = this.getPoint(c / a), f += b.distanceTo(e), d.push(f), e = b;
							return this.cacheArcLengths = d
						},
						updateArcLengths: function() {
							this.needsUpdate = true, this.getLengths()
						},
						getUtoTmapping: function(a, b) {
							var c, d, e = this.getLengths(),
								f = e.length;
							d = b ? b : a * e[f - 1];
							for (var g, h = 0, i = f - 1; h <= i;)
								if (c = Math.floor(h + (i - h) / 2), g = e[c] - d, 0 > g) h = c + 1;
								else {
									if (!(0 < g)) {
										i = c;
										break
									}
									i = c - 1
								}
							return c = i, e[c] === d ? c / (f - 1) : (h = e[c], (c + (d - h) / (e[c + 1] - h)) / (f - 1))
						},
						getTangent: function(a) {
							var b = a - 1e-4;
							return a += 1e-4, 0 > b && (b = 0), 1 < a && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize()
						},
						getTangentAt: function(a) {
							return a = this.getUtoTmapping(a), this.getTangent(a)
						},
						computeFrenetFrames: function(a, b) {
							var c, d, e = new i,
								f = [],
								g = [],
								h = [],
								k = new i,
								l = new j;
							for (c = 0; c <= a; c++) d = c / a, f[c] = this.getTangentAt(d), f[c].normalize();
							g[0] = new i, h[0] = new i, c = Number.MAX_VALUE, d = Math.abs(f[0].x);
							var m = Math.abs(f[0].y),
								n = Math.abs(f[0].z);
							for (d <= c && (c = d, e.set(1, 0, 0)), m <= c && (c = m, e.set(0, 1, 0)), n <= c && e.set(0, 0, 1), k.crossVectors(f[0], e).normalize(), g[0].crossVectors(f[0], k), h[0].crossVectors(f[0], g[0]), c = 1; c <= a; c++) g[c] = g[c - 1].clone(), h[c] = h[c - 1].clone(), k.crossVectors(f[c - 1], f[c]), k.length() > Number.EPSILON && (k.normalize(), e = Math.acos(re.clamp(f[c - 1].dot(f[c]), -1, 1)), g[c].applyMatrix4(l.makeRotationAxis(k, e))), h[c].crossVectors(f[c], g[c]);
							if (true === b)
								for (e = Math.acos(re.clamp(g[0].dot(g[a]), -1, 1)), e /= a, 0 < f[0].dot(k.crossVectors(g[0], g[a])) && (e = -e), c = 1; c <= a; c++) g[c].applyMatrix4(l.makeRotationAxis(f[c], e * c)), h[c].crossVectors(f[c], g[c]);
							return {
								tangents: f,
								normals: g,
								binormals: h
							}
						}
					}), jd.prototype = Object.create(id.prototype), jd.prototype.constructor = jd, jd.prototype.isLineCurve = true, jd.prototype.getPoint = function(a) {
						if (1 === a) return this.v2.clone();
						var b = this.v2.clone().sub(this.v1);
						return b.multiplyScalar(a).add(this.v1), b
					}, jd.prototype.getPointAt = function(a) {
						return this.getPoint(a)
					}, jd.prototype.getTangent = function(a) {
						return this.v2.clone().sub(this.v1).normalize()
					}, kd.prototype = Object.assign(Object.create(id.prototype), {
						constructor: kd,
						add: function(a) {
							this.curves.push(a)
						},
						closePath: function() {
							var a = this.curves[0].getPoint(0),
								b = this.curves[this.curves.length - 1].getPoint(1);
							a.equals(b) || this.curves.push(new jd(b, a))
						},
						getPoint: function(a) {
							var b = a * this.getLength(),
								c = this.getCurveLengths();
							for (a = 0; a < c.length;) {
								if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
								a++
							}
							return null
						},
						getLength: function() {
							var a = this.getCurveLengths();
							return a[a.length - 1]
						},
						updateArcLengths: function() {
							this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths()
						},
						getCurveLengths: function() {
							if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
							for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
							return this.cacheLengths = a
						},
						getSpacedPoints: function(a) {
							void 0 === a && (a = 40);
							for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
							return this.autoClose && b.push(b[0]), b
						},
						getPoints: function(a) {
							a = a || 12;
							for (var b, c = [], d = 0, e = this.curves; d < e.length; d++)
								for (var f = e[d], f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && f.isLineCurve ? 1 : f && f.isSplineCurve ? a * f.points.length : a), g = 0; g < f.length; g++) {
									var h = f[g];
									b && b.equals(h) || (c.push(h), b = h)
								}
							return this.autoClose && 1 < c.length && !c[c.length - 1].equals(c[0]) && c.push(c[0]), c
						},
						createPointsGeometry: function(a) {
							return a = this.getPoints(a), this.createGeometry(a)
						},
						createSpacedPointsGeometry: function(a) {
							return a = this.getSpacedPoints(a), this.createGeometry(a)
						},
						createGeometry: function(a) {
							for (var b = new wa, c = 0, d = a.length; c < d; c++) {
								var e = a[c];
								b.vertices.push(new i(e.x, e.y, e.z || 0))
							}
							return b
						}
					}), ld.prototype = Object.create(id.prototype), ld.prototype.constructor = ld, ld.prototype.isEllipseCurve = true, ld.prototype.getPoint = function(a) {
						for (var b = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;) d += b;
						for (; d > b;) d -= b;
						d < Number.EPSILON && (d = e ? 0 : b), true !== this.aClockwise || e || (d = d === b ? -b : d - b), b = this.aStartAngle + a * d, a = this.aX + this.xRadius * Math.cos(b);
						var f = this.aY + this.yRadius * Math.sin(b);
						return 0 !== this.aRotation && (b = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * b - f * d + this.aX, f = e * d + f * b + this.aY), new c(a, f)
					}, md.prototype = Object.create(id.prototype), md.prototype.constructor = md, md.prototype.isSplineCurve = true, md.prototype.getPoint = function(a) {
						var b = this.points,
							d = (b.length - 1) * a;
						a = Math.floor(d);
						var d = d - a,
							e = b[0 === a ? a : a - 1],
							f = b[a],
							g = b[a > b.length - 2 ? b.length - 1 : a + 1],
							b = b[a > b.length - 3 ? b.length - 1 : a + 2];
						return new c(fd(d, e.x, f.x, g.x, b.x), fd(d, e.y, f.y, g.y, b.y))
					}, nd.prototype = Object.create(id.prototype), nd.prototype.constructor = nd, nd.prototype.getPoint = function(a) {
						var b = this.v0,
							d = this.v1,
							e = this.v2,
							f = this.v3;
						return new c(hd(a, b.x, d.x, e.x, f.x), hd(a, b.y, d.y, e.y, f.y))
					}, od.prototype = Object.create(id.prototype), od.prototype.constructor = od, od.prototype.getPoint = function(a) {
						var b = this.v0,
							d = this.v1,
							e = this.v2;
						return new c(gd(a, b.x, d.x, e.x), gd(a, b.y, d.y, e.y))
					};
					var Ue = Object.assign(Object.create(kd.prototype), {
						fromPoints: function(a) {
							this.moveTo(a[0].x, a[0].y);
							for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
						},
						moveTo: function(a, b) {
							this.currentPoint.set(a, b)
						},
						lineTo: function(a, b) {
							var d = new jd(this.currentPoint.clone(), new c(a, b));
							this.curves.push(d), this.currentPoint.set(a, b)
						},
						quadraticCurveTo: function(a, b, d, e) {
							a = new od(this.currentPoint.clone(), new c(a, b), new c(d, e)), this.curves.push(a), this.currentPoint.set(d, e)
						},
						bezierCurveTo: function(a, b, d, e, f, g) {
							a = new nd(this.currentPoint.clone(), new c(a, b), new c(d, e), new c(f, g)), this.curves.push(a), this.currentPoint.set(f, g)
						},
						splineThru: function(a) {
							var b = [this.currentPoint.clone()].concat(a),
								b = new md(b);
							this.curves.push(b), this.currentPoint.copy(a[a.length - 1])
						},
						arc: function(a, b, c, d, e, f) {
							this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
						},
						absarc: function(a, b, c, d, e, f) {
							this.absellipse(a, b, c, c, d, e, f)
						},
						ellipse: function(a, b, c, d, e, f, g, h) {
							this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h)
						},
						absellipse: function(a, b, c, d, e, f, g, h) {
							a = new ld(a, b, c, d, e, f, g, h), 0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y)), this.curves.push(a), a = a.getPoint(1), this.currentPoint.copy(a)
						}
					});
					pd.prototype = Ue, Ue.constructor = pd, qd.prototype = Object.assign(Object.create(Ue), {
						constructor: qd,
						getPointsHoles: function(a) {
							for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
							return b
						},
						extractAllPoints: function(a) {
							return {
								shape: this.getPoints(a),
								holes: this.getPointsHoles(a)
							}
						},
						extractPoints: function(a) {
							return this.extractAllPoints(a)
						}
					}), Object.assign(rd.prototype, {
						moveTo: function(a, b) {
							this.currentPath = new pd, this.subPaths.push(this.currentPath), this.currentPath.moveTo(a, b)
						},
						lineTo: function(a, b) {
							this.currentPath.lineTo(a, b)
						},
						quadraticCurveTo: function(a, b, c, d) {
							this.currentPath.quadraticCurveTo(a, b, c, d)
						},
						bezierCurveTo: function(a, b, c, d, e, f) {
							this.currentPath.bezierCurveTo(a, b, c, d, e, f)
						},
						splineThru: function(a) {
							this.currentPath.splineThru(a)
						},
						toShapes: function(a, b) {
							function c(a) {
								for (var b = [], c = 0, d = a.length; c < d; c++) {
									var e = a[c],
										f = new qd;
									f.curves = e.curves, b.push(f)
								}
								return b
							}

							function d(a, b) {
								for (var c = b.length, d = false, e = c - 1, f = 0; f < c; e = f++) {
									var g = b[e],
										h = b[f],
										i = h.x - g.x,
										j = h.y - g.y;
									if (Math.abs(j) > Number.EPSILON) {
										if (0 > j && (g = b[f], i = -i, h = b[e], j = -j), !(a.y < g.y || a.y > h.y))
											if (a.y === g.y) {
												if (a.x === g.x) return true
											} else {
												if (e = j * (a.x - g.x) - i * (a.y - g.y), 0 === e) return true;
												0 > e || (d = !d)
											}
									} else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return true
								}
								return d
							}
							var e = Je.isClockWise,
								f = this.subPaths;
							if (0 === f.length) return [];
							if (true === b) return c(f);
							var g, h, i, j = [];
							if (1 === f.length) return h = f[0], i = new qd, i.curves = h.curves, j.push(i), j;
							var k = !e(f[0].getPoints()),
								k = a ? !k : k;
							i = [];
							var l, m = [],
								n = [],
								o = 0;
							m[o] = void 0, n[o] = [];
							for (var p = 0, q = f.length; p < q; p++) h = f[p], l = h.getPoints(), g = e(l), (g = a ? !g : g) ? (!k && m[o] && o++, m[o] = {
								s: new qd,
								p: l
							}, m[o].s.curves = h.curves, k && o++, n[o] = []) : n[o].push({
								h: h,
								p: l[0]
							});
							if (!m[0]) return c(f);
							if (1 < m.length) {
								for (p = false, h = [], e = 0, f = m.length; e < f; e++) i[e] = [];
								for (e = 0, f = m.length; e < f; e++)
									for (g = n[e], k = 0; k < g.length; k++) {
										for (o = g[k], l = true, q = 0; q < m.length; q++) d(o.p, m[q].p) && (e !== q && h.push({
											froms: e,
											tos: q,
											hole: k
										}), l ? (l = false, i[q].push(o)) : p = true);
										l && i[e].push(o)
									}
								0 < h.length && (p || (n = i))
							}
							for (p = 0, e = m.length; p < e; p++)
								for (i = m[p].s, j.push(i), h = n[p], f = 0, g = h.length; f < g; f++) i.holes.push(h[f].h);
							return j
						}
					}), Object.assign(sd.prototype, {
						isFont: true,
						generateShapes: function(a, b, c) {
							void 0 === b && (b = 100), void 0 === c && (c = 4);
							var d = this.data;
							a = String(a).split("");
							var e = b / d.resolution,
								f = (d.boundingBox.yMax - d.boundingBox.yMin + d.underlineThickness) * e,
								g = 0,
								h = 0;
							b = [];
							for (var i = 0; i < a.length; i++) {
								var j = a[i];
								if ("\n" === j) g = 0, h -= f;
								else {
									var k;
									k = e;
									var l = g,
										m = h;
									if (j = d.glyphs[j] || d.glyphs["?"]) {
										var n, o, p, q, r, s, t, u, v = new rd,
											w = [];
										if (j.o)
											for (var x = j._cachedOutline || (j._cachedOutline = j.o.split(" ")), y = 0, z = x.length; y < z;) switch (x[y++]) {
												case "m":
													n = x[y++] * k + l, o = x[y++] * k + m, v.moveTo(n, o);
													break;
												case "l":
													n = x[y++] * k + l, o = x[y++] * k + m, v.lineTo(n, o);
													break;
												case "q":
													if (n = x[y++] * k + l, o = x[y++] * k + m, r = x[y++] * k + l, s = x[y++] * k + m, v.quadraticCurveTo(r, s, n, o), q = w[w.length - 1]) {
														p = q.x, q = q.y;
														for (var A = 1; A <= c; A++) {
															var B = A / c;
															gd(B, p, r, n), gd(B, q, s, o)
														}
													}
													break;
												case "b":
													if (n = x[y++] * k + l, o = x[y++] * k + m, r = x[y++] * k + l, s = x[y++] * k + m, t = x[y++] * k + l, u = x[y++] * k + m, v.bezierCurveTo(r, s, t, u, n, o), q = w[w.length - 1])
														for (p = q.x, q = q.y, A = 1; A <= c; A++) B = A / c, hd(B, p, r, t, n), hd(B, q, s, u, o)
											}
										k = {
											offsetX: j.ha * k,
											path: v
										}
									} else k = void 0;
									g += k.offsetX, b.push(k.path)
								}
							}
							for (c = [], d = 0, a = b.length; d < a; d++) Array.prototype.push.apply(c, b[d].toShapes());
							return c
						}
					}), Object.assign(td.prototype, {
						load: function(a, b, c, d) {
							var e = this;
							new yc(this.manager).load(a, function(a) {
								var c;
								try {
									c = JSON.parse(a)
								} catch (b) {
									console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2))
								}
								a = e.parse(c), b && b(a)
							}, c, d)
						},
						parse: function(a) {
							return new sd(a)
						}
					});
					var Ve, We = {
						getContext: function() {
							return void 0 === Ve && (Ve = new(window.AudioContext || window.webkitAudioContext)), Ve
						},
						setContext: function(a) {
							Ve = a
						}
					};
					Object.assign(ud.prototype, {
						load: function(a, b, c, d) {
							var e = new yc(this.manager);
							e.setResponseType("arraybuffer"), e.load(a, function(a) {
								We.getContext().decodeAudioData(a, function(a) {
									b(a)
								})
							}, c, d)
						}
					}), Object.assign(vd.prototype, {
						update: function() {
							var a, b, c, d, e, f, g, h, i = new j,
								k = new j;
							return function(j) {
								if (a !== this || b !== j.focus || c !== j.fov || d !== j.aspect * this.aspect || e !== j.near || f !== j.far || g !== j.zoom || h !== this.eyeSep) {
									a = this, b = j.focus, c = j.fov, d = j.aspect * this.aspect, e = j.near, f = j.far, g = j.zoom;
									var l = j.projectionMatrix.clone();
									h = this.eyeSep / 2;
									var m, n, o = h * e / b,
										p = e * Math.tan(re.DEG2RAD * c * .5) / g;
									k.elements[12] = -h, i.elements[12] = h, m = -p * d + o, n = p * d + o, l.elements[0] = 2 * e / (n - m), l.elements[8] = (n + m) / (n - m), this.cameraL.projectionMatrix.copy(l), m = -p * d - o, n = p * d - o, l.elements[0] = 2 * e / (n - m), l.elements[8] = (n + m) / (n - m), this.cameraR.projectionMatrix.copy(l)
								}
								this.cameraL.matrixWorld.copy(j.matrixWorld).multiply(k), this.cameraR.matrixWorld.copy(j.matrixWorld).multiply(i)
							}
						}()
					}), wd.prototype = Object.create(fa.prototype), wd.prototype.constructor = wd, xd.prototype = Object.assign(Object.create(Ea.prototype), {
						constructor: xd,
						isArrayCamera: true
					}), yd.prototype = Object.assign(Object.create(fa.prototype), {
						constructor: yd,
						getInput: function() {
							return this.gain
						},
						removeFilter: function() {
							null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
						},
						getFilter: function() {
							return this.filter
						},
						setFilter: function(a) {
							null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = a, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
						},
						getMasterVolume: function() {
							return this.gain.gain.value
						},
						setMasterVolume: function(a) {
							this.gain.gain.value = a
						},
						updateMatrixWorld: function() {
							var a = new i,
								b = new h,
								c = new i,
								d = new i;
							return function(e) {
								fa.prototype.updateMatrixWorld.call(this, e), e = this.context.listener;
								var f = this.up;
								this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z))
							}
						}()
					}), zd.prototype = Object.assign(Object.create(fa.prototype), {
						constructor: zd,
						getOutput: function() {
							return this.gain
						},
						setNodeSource: function(a) {
							return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = a, this.connect(), this
						},
						setBuffer: function(a) {
							return this.buffer = a, this.sourceType = "buffer", this.autoplay && this.play(), this
						},
						play: function() {
							if (true === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
							else {
								if (false !== this.hasPlaybackControl) {
									var a = this.context.createBufferSource();
									return a.buffer = this.buffer, a.loop = this.loop, a.onended = this.onEnded.bind(this), a.playbackRate.setValueAtTime(this.playbackRate, this.startTime), a.start(0, this.startTime), this.isPlaying = true, this.source = a, this.connect()
								}
								console.warn("THREE.Audio: this Audio has no playback control.")
							}
						},
						pause: function() {
							return false !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = false, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
						},
						stop: function() {
							return false !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = 0, this.isPlaying = false, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
						},
						connect: function() {
							if (0 < this.filters.length) {
								this.source.connect(this.filters[0]);
								for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
								this.filters[this.filters.length - 1].connect(this.getOutput())
							} else this.source.connect(this.getOutput());
							return this
						},
						disconnect: function() {
							if (0 < this.filters.length) {
								this.source.disconnect(this.filters[0]);
								for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
								this.filters[this.filters.length - 1].disconnect(this.getOutput())
							} else this.source.disconnect(this.getOutput());
							return this
						},
						getFilters: function() {
							return this.filters
						},
						setFilters: function(a) {
							return a || (a = []), true === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a, this
						},
						getFilter: function() {
							return this.getFilters()[0]
						},
						setFilter: function(a) {
							return this.setFilters(a ? [a] : [])
						},
						setPlaybackRate: function(a) {
							return false !== this.hasPlaybackControl ? (this.playbackRate = a, true === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this) : void console.warn("THREE.Audio: this Audio has no playback control.")
						},
						getPlaybackRate: function() {
							return this.playbackRate
						},
						onEnded: function() {
							this.isPlaying = false
						},
						getLoop: function() {
							return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop
						},
						setLoop: function(a) {
							return false !== this.hasPlaybackControl ? (this.loop = a, true === this.isPlaying && (this.source.loop = this.loop), this) : void console.warn("THREE.Audio: this Audio has no playback control.")
						},
						getVolume: function() {
							return this.gain.gain.value
						},
						setVolume: function(a) {
							return this.gain.gain.value = a, this
						}
					}), Ad.prototype = Object.assign(Object.create(zd.prototype), {
						constructor: Ad,
						getOutput: function() {
							return this.panner
						},
						getRefDistance: function() {
							return this.panner.refDistance
						},
						setRefDistance: function(a) {
							this.panner.refDistance = a
						},
						getRolloffFactor: function() {
							return this.panner.rolloffFactor
						},
						setRolloffFactor: function(a) {
							this.panner.rolloffFactor = a
						},
						getDistanceModel: function() {
							return this.panner.distanceModel
						},
						setDistanceModel: function(a) {
							this.panner.distanceModel = a
						},
						getMaxDistance: function() {
							return this.panner.maxDistance
						},
						setMaxDistance: function(a) {
							this.panner.maxDistance = a
						},
						updateMatrixWorld: function() {
							var a = new i;
							return function(b) {
								fa.prototype.updateMatrixWorld.call(this, b), a.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(a.x, a.y, a.z)
							}
						}()
					}), Object.assign(Bd.prototype, {
						getFrequencyData: function() {
							return this.analyser.getByteFrequencyData(this.data), this.data
						},
						getAverageFrequency: function() {
							for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
							return a / b.length
						}
					}), Object.assign(Cd.prototype, {
						accumulate: function(a, b) {
							var c = this.buffer,
								d = this.valueSize,
								e = a * d + d,
								f = this.cumulativeWeight;
							if (0 === f) {
								for (f = 0; f !== d; ++f) c[e + f] = c[f];
								f = b
							} else f += b, this._mixBufferRegion(c, e, 0, b / f, d);
							this.cumulativeWeight = f
						},
						apply: function(a) {
							var b = this.valueSize,
								c = this.buffer;
							a = a * b + b;
							var d = this.cumulativeWeight,
								e = this.binding;
							this.cumulativeWeight = 0, 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
							for (var d = b, f = b + b; d !== f; ++d)
								if (c[d] !== c[d + b]) {
									e.setValue(c, a);
									break
								}
						},
						saveOriginalState: function() {
							var a = this.buffer,
								b = this.valueSize,
								c = 3 * b;
							this.binding.getValue(a, c);
							for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
							this.cumulativeWeight = 0
						},
						restoreOriginalState: function() {
							this.binding.setValue(this.buffer, 3 * this.valueSize)
						},
						_select: function(a, b, c, d, e) {
							if (.5 <= d)
								for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
						},
						_slerp: function(a, b, c, d) {
							h.slerpFlat(a, b, a, b, a, c, d)
						},
						_lerp: function(a, b, c, d, e) {
							for (var f = 1 - d, g = 0; g !== e; ++g) {
								var h = b + g;
								a[h] = a[h] * f + a[c + g] * d
							}
						}
					}), Object.assign(Dd.prototype, {
						getValue: function(a, b) {
							this.bind();
							var c = this._bindings[this._targetGroup.nCachedObjects_];
							void 0 !== c && c.getValue(a, b)
						},
						setValue: function(a, b) {
							for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
						},
						bind: function() {
							for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
						},
						unbind: function() {
							for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
						}
					}), Object.assign(Ed, {
						Composite: Dd,
						create: function(a, b, c) {
							return a && a.isAnimationObjectGroup ? new Ed.Composite(a, b, c) : new Ed(a, b, c)
						},
						parseTrackName: function() {
							var a = new RegExp("^" + /((?:[\w-]+[\/:])*)/.source + /([\w-\.]+)?/.source + /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source + /\.([\w-]+)(?:\[(.+)\])?/.source + "$"),
								b = ["material", "materials", "bones"];
							return function(c) {
								var d = a.exec(c);
								if (!d) throw Error("PropertyBinding: Cannot parse trackName: " + c);
								var d = {
										nodeName: d[2],
										objectName: d[3],
										objectIndex: d[4],
										propertyName: d[5],
										propertyIndex: d[6]
									},
									e = d.nodeName && d.nodeName.lastIndexOf(".");
								if (void 0 !== e && -1 !== e) {
									var f = d.nodeName.substring(e + 1); - 1 !== b.indexOf(f) && (d.nodeName = d.nodeName.substring(0, e), d.objectName = f)
								}
								if (null === d.propertyName || 0 === d.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + c);
								return d
							}
						}(),
						findNode: function(a, b) {
							if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
							if (a.skeleton) {
								var c = function(a) {
									for (var c = 0; c < a.bones.length; c++) {
										var d = a.bones[c];
										if (d.name === b) return d
									}
									return null
								}(a.skeleton);
								if (c) return c
							}
							if (a.children) {
								var d = function(a) {
									for (var c = 0; c < a.length; c++) {
										var e = a[c];
										if (e.name === b || e.uuid === b || (e = d(e.children))) return e
									}
									return null
								};
								if (c = d(a.children)) return c
							}
							return null
						}
					}), Object.assign(Ed.prototype, {
						_getValue_unavailable: function() {},
						_setValue_unavailable: function() {},
						BindingType: {
							Direct: 0,
							EntireArray: 1,
							ArrayElement: 2,
							HasFromToArray: 3
						},
						Versioning: {
							None: 0,
							NeedsUpdate: 1,
							MatrixWorldNeedsUpdate: 2
						},
						GetterByBindingType: [function(a, b) {
							a[b] = this.node[this.propertyName]
						}, function(a, b) {
							for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
						}, function(a, b) {
							a[b] = this.resolvedProperty[this.propertyIndex]
						}, function(a, b) {
							this.resolvedProperty.toArray(a, b)
						}],
						SetterByBindingTypeAndVersioning: [
							[function(a, b) {
								this.node[this.propertyName] = a[b]
							}, function(a, b) {
								this.node[this.propertyName] = a[b], this.targetObject.needsUpdate = true
							}, function(a, b) {
								this.node[this.propertyName] = a[b], this.targetObject.matrixWorldNeedsUpdate = true
							}],
							[function(a, b) {
								for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
							}, function(a, b) {
								for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
								this.targetObject.needsUpdate = true
							}, function(a, b) {
								for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
								this.targetObject.matrixWorldNeedsUpdate = true
							}],
							[function(a, b) {
								this.resolvedProperty[this.propertyIndex] = a[b]
							}, function(a, b) {
								this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.needsUpdate = true
							}, function(a, b) {
								this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.matrixWorldNeedsUpdate = true
							}],
							[function(a, b) {
								this.resolvedProperty.fromArray(a, b)
							}, function(a, b) {
								this.resolvedProperty.fromArray(a, b), this.targetObject.needsUpdate = true
							}, function(a, b) {
								this.resolvedProperty.fromArray(a, b), this.targetObject.matrixWorldNeedsUpdate = true
							}]
						],
						getValue: function(a, b) {
							this.bind(), this.getValue(a, b)
						},
						setValue: function(a, b) {
							this.bind(), this.setValue(a, b)
						},
						bind: function() {
							var a = this.node,
								b = this.parsedPath,
								c = b.objectName,
								d = b.propertyName,
								e = b.propertyIndex;
							if (a || (this.node = a = Ed.findNode(this.rootNode, b.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, a) {
								if (c) {
									var f = b.objectIndex;
									switch (c) {
										case "materials":
											if (!a.material) return void console.error("  can not bind to material as node does not have a material", this);
											if (!a.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
											a = a.material.materials;
											break;
										case "bones":
											if (!a.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
											for (a = a.skeleton.bones, c = 0; c < a.length; c++)
												if (a[c].name === f) {
													f = c;
													break
												}
											break;
										default:
											if (void 0 === a[c]) return void console.error("  can not bind to objectName of node, undefined", this);
											a = a[c]
									}
									if (void 0 !== f) {
										if (void 0 === a[f]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
										a = a[f]
									}
								}
								if (f = a[d], void 0 === f) console.error("  trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
								else {
									if (b = this.Versioning.None, void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a), c = this.BindingType.Direct, void 0 !== e) {
										if ("morphTargetInfluences" === d) {
											if (!a.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
											if (!a.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
											for (c = 0; c < this.node.geometry.morphTargets.length; c++)
												if (a.geometry.morphTargets[c].name === e) {
													e = c;
													break
												}
										}
										c = this.BindingType.ArrayElement, this.resolvedProperty = f, this.propertyIndex = e
									} else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
									this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
								}
							} else console.error("  trying to update node for track: " + this.path + " but it wasn't found.")
						},
						unbind: function() {
							this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
						}
					}), Object.assign(Ed.prototype, {
						_getValue_unbound: Ed.prototype.getValue,
						_setValue_unbound: Ed.prototype.setValue
					}), Object.assign(Fd.prototype, {
						isAnimationObjectGroup: true,
						add: function(a) {
							for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._paths, g = this._parsedPaths, h = this._bindings, i = h.length, j = 0, k = arguments.length; j !== k; ++j) {
								var l = arguments[j],
									m = l.uuid,
									n = e[m];
								if (void 0 === n) {
									n = c++, e[m] = n, b.push(l);
									for (var m = 0, o = i; m !== o; ++m) h[m].push(new Ed(l, f[m], g[m]))
								} else if (n < d) {
									var p = --d,
										o = b[p];
									for (e[o.uuid] = n, b[n] = o, e[m] = p, b[p] = l, m = 0, o = i; m !== o; ++m) {
										var q = h[m],
											r = q[n];
										q[n] = q[p], void 0 === r && (r = new Ed(l, f[m], g[m])), q[p] = r
									}
								} else void 0 !== b[n] && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
							}
							this.nCachedObjects_ = d
						},
						remove: function(a) {
							for (var b = this._objects, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
								var i = arguments[g],
									j = i.uuid,
									k = d[j];
								if (void 0 !== k && k >= c) {
									var l = c++,
										m = b[l];
									for (d[m.uuid] = k, b[k] = m, d[j] = l, b[l] = i, i = 0, j = f; i !== j; ++i) {
										var m = e[i],
											n = m[k];
										m[k] = m[l], m[l] = n
									}
								}
							}
							this.nCachedObjects_ = c
						},
						uncache: function(a) {
							for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._bindings, g = f.length, h = 0, i = arguments.length; h !== i; ++h) {
								var j = arguments[h].uuid,
									k = e[j];
								if (void 0 !== k)
									if (delete e[j], k < d) {
										var j = --d,
											l = b[j],
											m = --c,
											n = b[m];
										for (e[l.uuid] = k, b[k] = l, e[n.uuid] = j, b[j] = n, b.pop(), l = 0, n = g; l !== n; ++l) {
											var o = f[l],
												p = o[m];
											o[k] = o[j], o[j] = p, o.pop()
										}
									} else
										for (m = --c, n = b[m], e[n.uuid] = k, b[k] = n, b.pop(), l = 0, n = g; l !== n; ++l) o = f[l], o[k] = o[m], o.pop()
							}
							this.nCachedObjects_ = d
						},
						subscribe_: function(a, b) {
							var c = this._bindingsIndicesByPath,
								d = c[a],
								e = this._bindings;
							if (void 0 !== d) return e[d];
							var f = this._paths,
								g = this._parsedPaths,
								h = this._objects,
								i = this.nCachedObjects_,
								j = Array(h.length),
								d = e.length;
							for (c[a] = d, f.push(a), g.push(b), e.push(j), c = i, d = h.length; c !== d; ++c) j[c] = new Ed(h[c], a, b);
							return j
						},
						unsubscribe_: function(a) {
							var b = this._bindingsIndicesByPath,
								c = b[a];
							if (void 0 !== c) {
								var d = this._paths,
									e = this._parsedPaths,
									f = this._bindings,
									g = f.length - 1,
									h = f[g];
								b[a[g]] = c, f[c] = h, f.pop(), e[c] = e[g], e.pop(), d[c] = d[g], d.pop()
							}
						}
					}), Object.assign(Gd.prototype, {
						play: function() {
							return this._mixer._activateAction(this), this
						},
						stop: function() {
							return this._mixer._deactivateAction(this), this.reset()
						},
						reset: function() {
							return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
						},
						isRunning: function() {
							return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
						},
						isScheduled: function() {
							return this._mixer._isActiveAction(this)
						},
						startAt: function(a) {
							return this._startTime = a, this
						},
						setLoop: function(a, b) {
							return this.loop = a, this.repetitions = b, this
						},
						setEffectiveWeight: function(a) {
							return this.weight = a, this._effectiveWeight = this.enabled ? a : 0, this.stopFading()
						},
						getEffectiveWeight: function() {
							return this._effectiveWeight
						},
						fadeIn: function(a) {
							return this._scheduleFading(a, 0, 1)
						},
						fadeOut: function(a) {
							return this._scheduleFading(a, 1, 0)
						},
						crossFadeFrom: function(a, b, c) {
							if (a.fadeOut(b), this.fadeIn(b), c) {
								c = this._clip.duration;
								var d = a._clip.duration,
									e = c / d;
								a.warp(1, d / c, b), this.warp(e, 1, b)
							}
							return this
						},
						crossFadeTo: function(a, b, c) {
							return a.crossFadeFrom(this, b, c)
						},
						stopFading: function() {
							var a = this._weightInterpolant;
							return null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
						},
						setEffectiveTimeScale: function(a) {
							return this.timeScale = a, this._effectiveTimeScale = this.paused ? 0 : a, this.stopWarping()
						},
						getEffectiveTimeScale: function() {
							return this._effectiveTimeScale
						},
						setDuration: function(a) {
							return this.timeScale = this._clip.duration / a, this.stopWarping()
						},
						syncWith: function(a) {
							return this.time = a.time, this.timeScale = a.timeScale, this.stopWarping()
						},
						halt: function(a) {
							return this.warp(this._effectiveTimeScale, 0, a)
						},
						warp: function(a, b, c) {
							var d = this._mixer,
								e = d.time,
								f = this._timeScaleInterpolant,
								g = this.timeScale;
							return null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()), d = f.parameterPositions, f = f.sampleValues, d[0] = e, d[1] = e + c, f[0] = a / g, f[1] = b / g, this
						},
						stopWarping: function() {
							var a = this._timeScaleInterpolant;
							return null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
						},
						getMixer: function() {
							return this._mixer
						},
						getClip: function() {
							return this._clip
						},
						getRoot: function() {
							return this._localRoot || this._mixer._root
						},
						_update: function(a, b, c, d) {
							if (this.enabled) {
								var e = this._startTime;
								if (null !== e) {
									if (b = (a - e) * c, 0 > b || 0 === c) return;
									this._startTime = null, b *= c
								}
								if (b *= this._updateTimeScale(a), c = this._updateTime(b), a = this._updateWeight(a), 0 < a) {
									b = this._interpolants;
									for (var e = this._propertyBindings, f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
								}
							} else this._updateWeight(a)
						},
						_updateWeight: function(a) {
							var b = 0;
							if (this.enabled) {
								var b = this.weight,
									c = this._weightInterpolant;
								if (null !== c) {
									var d = c.evaluate(a)[0],
										b = b * d;
									a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = false))
								}
							}
							return this._effectiveWeight = b
						},
						_updateTimeScale: function(a) {
							var b = 0;
							if (!this.paused) {
								var b = this.timeScale,
									c = this._timeScaleInterpolant;
								if (null !== c) {
									var d = c.evaluate(a)[0],
										b = b * d;
									a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = true : this.timeScale = b)
								}
							}
							return this._effectiveTimeScale = b
						},
						_updateTime: function(a) {
							var b = this.time + a;
							if (0 === a) return b;
							var c = this._clip.duration,
								d = this.loop,
								e = this._loopCount;
							if (2200 === d) a: {
								if (-1 === e && (this._loopCount = 0, this._setEndings(true, true, false)), b >= c) b = c;
								else {
									if (!(0 > b)) break a;
									b = 0
								}
								this.clampWhenFinished ? this.paused = true : this.enabled = false,
								this._mixer.dispatchEvent({
									type: "finished",
									action: this,
									direction: 0 > a ? -1 : 1
								})
							}
							else {
								if (d = 2202 === d, -1 === e && (0 <= a ? (e = 0, this._setEndings(true, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, true, d)), b >= c || 0 > b) {
									var f = Math.floor(b / c),
										b = b - c * f,
										e = e + Math.abs(f),
										g = this.repetitions - e;
									0 > g ? (this.clampWhenFinished ? this.paused = true : this.enabled = false, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: 0 < a ? 1 : -1
									})) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(false, false, d), this._loopCount = e, this._mixer.dispatchEvent({
										type: "loop",
										action: this,
										loopDelta: f
									}))
								}
								if (d && 1 === (1 & e)) return this.time = b, c - b
							}
							return this.time = b
						},
						_setEndings: function(a, b, c) {
							var d = this._interpolantSettings;
							c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
						},
						_scheduleFading: function(a, b, c) {
							var d = this._mixer,
								e = d.time,
								f = this._weightInterpolant;
							return null === f && (this._weightInterpolant = f = d._lendControlInterpolant()), d = f.parameterPositions, f = f.sampleValues, d[0] = e, f[0] = b, d[1] = e + a, f[1] = c, this
						}
					}), Object.assign(Hd.prototype, b.prototype, {
						_bindAction: function(a, b) {
							var c = a._localRoot || this._root,
								d = a._clip.tracks,
								e = d.length,
								f = a._propertyBindings,
								g = a._interpolants,
								h = c.uuid,
								i = this._bindingsByRootAndName,
								j = i[h];
							for (void 0 === j && (j = {}, i[h] = j), i = 0; i !== e; ++i) {
								var k = d[i],
									l = k.name,
									m = j[l];
								if (void 0 === m) {
									if (m = f[i], void 0 !== m) {
										null === m._cacheIndex && (++m.referenceCount, this._addInactiveBinding(m, h, l));
										continue
									}
									m = new Cd(Ed.create(c, l, b && b._propertyBindings[i].binding.parsedPath), k.ValueTypeName, k.getValueSize()), ++m.referenceCount, this._addInactiveBinding(m, h, l)
								}
								f[i] = m, g[i].resultBuffer = m.buffer
							}
						},
						_activateAction: function(a) {
							if (!this._isActiveAction(a)) {
								if (null === a._cacheIndex) {
									var b = (a._localRoot || this._root).uuid,
										c = a._clip.uuid,
										d = this._actionsByClip[c];
									this._bindAction(a, d && d.knownActions[0]), this._addInactiveAction(a, c, b)
								}
								for (b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
									var e = b[c];
									0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
								}
								this._lendAction(a)
							}
						},
						_deactivateAction: function(a) {
							if (this._isActiveAction(a)) {
								for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
									var e = b[c];
									0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
								}
								this._takeBackAction(a)
							}
						},
						_initMemoryManager: function() {
							this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
							var a = this;
							this.stats = {
								actions: {
									get total() {
										return a._actions.length
									},
									get inUse() {
										return a._nActiveActions
									}
								},
								bindings: {
									get total() {
										return a._bindings.length
									},
									get inUse() {
										return a._nActiveBindings
									}
								},
								controlInterpolants: {
									get total() {
										return a._controlInterpolants.length
									},
									get inUse() {
										return a._nActiveControlInterpolants
									}
								}
							}
						},
						_isActiveAction: function(a) {
							return a = a._cacheIndex, null !== a && a < this._nActiveActions
						},
						_addInactiveAction: function(a, b, c) {
							var d = this._actions,
								e = this._actionsByClip,
								f = e[b];
							void 0 === f ? (f = {
								knownActions: [a],
								actionByRoot: {}
							}, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a)), a._cacheIndex = d.length, d.push(a), f.actionByRoot[c] = a
						},
						_removeInactiveAction: function(a) {
							var b = this._actions,
								c = b[b.length - 1],
								d = a._cacheIndex;
							c._cacheIndex = d, b[d] = c, b.pop(), a._cacheIndex = null;
							var b = a._clip.uuid,
								c = this._actionsByClip,
								d = c[b],
								e = d.knownActions,
								f = e[e.length - 1],
								g = a._byClipCacheIndex;
							f._byClipCacheIndex = g, e[g] = f, e.pop(), a._byClipCacheIndex = null, delete d.actionByRoot[(a._localRoot || this._root).uuid], 0 === e.length && delete c[b], this._removeInactiveBindingsForAction(a)
						},
						_removeInactiveBindingsForAction: function(a) {
							a = a._propertyBindings;
							for (var b = 0, c = a.length; b !== c; ++b) {
								var d = a[b];
								0 === --d.referenceCount && this._removeInactiveBinding(d)
							}
						},
						_lendAction: function(a) {
							var b = this._actions,
								c = a._cacheIndex,
								d = this._nActiveActions++,
								e = b[d];
							a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
						},
						_takeBackAction: function(a) {
							var b = this._actions,
								c = a._cacheIndex,
								d = --this._nActiveActions,
								e = b[d];
							a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
						},
						_addInactiveBinding: function(a, b, c) {
							var d = this._bindingsByRootAndName,
								e = d[b],
								f = this._bindings;
							void 0 === e && (e = {}, d[b] = e), e[c] = a, a._cacheIndex = f.length, f.push(a)
						},
						_removeInactiveBinding: function(a) {
							var b = this._bindings,
								c = a.binding,
								d = c.rootNode.uuid,
								c = c.path,
								e = this._bindingsByRootAndName,
								f = e[d],
								g = b[b.length - 1];
							a = a._cacheIndex, g._cacheIndex = a, b[a] = g, b.pop(), delete f[c];
							a: {
								for (var h in f) break a;delete e[d]
							}
						},
						_lendBinding: function(a) {
							var b = this._bindings,
								c = a._cacheIndex,
								d = this._nActiveBindings++,
								e = b[d];
							a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
						},
						_takeBackBinding: function(a) {
							var b = this._bindings,
								c = a._cacheIndex,
								d = --this._nActiveBindings,
								e = b[d];
							a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
						},
						_lendControlInterpolant: function() {
							var a = this._controlInterpolants,
								b = this._nActiveControlInterpolants++,
								c = a[b];
							return void 0 === c && (c = new Qc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c), c
						},
						_takeBackControlInterpolant: function(a) {
							var b = this._controlInterpolants,
								c = a.__cacheIndex,
								d = --this._nActiveControlInterpolants,
								e = b[d];
							a.__cacheIndex = d, b[d] = a, e.__cacheIndex = c, b[c] = e
						},
						_controlInterpolantsResultBuffer: new Float32Array(1),
						clipAction: function(a, b) {
							var c = b || this._root,
								d = c.uuid,
								e = "string" == typeof a ? _c.findByName(c, a) : a,
								c = null !== e ? e.uuid : a,
								f = this._actionsByClip[c],
								g = null;
							if (void 0 !== f) {
								if (g = f.actionByRoot[d], void 0 !== g) return g;
								g = f.knownActions[0], null === e && (e = g._clip)
							}
							return null === e ? null : (e = new Gd(this, e, b), this._bindAction(e, g), this._addInactiveAction(e, c, d), e)
						},
						existingAction: function(a, b) {
							var c = b || this._root,
								d = c.uuid,
								c = "string" == typeof a ? _c.findByName(c, a) : a,
								c = this._actionsByClip[c ? c.uuid : a];
							return void 0 !== c ? c.actionByRoot[d] || null : null
						},
						stopAllAction: function() {
							for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
							for (e = 0; e !== d; ++e) c[e].useCount = 0;
							return this
						},
						update: function(a) {
							a *= this.timeScale;
							for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) b[g]._update(d, a, e, f);
							for (a = this._bindings, b = this._nActiveBindings, g = 0; g !== b; ++g) a[g].apply(f);
							return this
						},
						getRoot: function() {
							return this._root
						},
						uncacheClip: function(a) {
							var b = this._actions;
							a = a.uuid;
							var c = this._actionsByClip,
								d = c[a];
							if (void 0 !== d) {
								for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
									var g = d[e];
									this._deactivateAction(g);
									var h = g._cacheIndex,
										i = b[b.length - 1];
									g._cacheIndex = null, g._byClipCacheIndex = null, i._cacheIndex = h, b[h] = i, b.pop(), this._removeInactiveBindingsForAction(g)
								}
								delete c[a]
							}
						},
						uncacheRoot: function(a) {
							a = a.uuid;
							var b, c = this._actionsByClip;
							for (b in c) {
								var d = c[b].actionByRoot[a];
								void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d))
							}
							if (b = this._bindingsByRootAndName[a], void 0 !== b)
								for (var e in b) a = b[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
						},
						uncacheAction: function(a, b) {
							var c = this.existingAction(a, b);
							null !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
						}
					}), Id.prototype.clone = function() {
						return new Id(void 0 === this.value.clone ? this.value : this.value.clone())
					}, Jd.prototype = Object.assign(Object.create(xa.prototype), {
						constructor: Jd,
						isInstancedBufferGeometry: true,
						addGroup: function(a, b, c) {
							this.groups.push({
								start: a,
								count: b,
								materialIndex: c
							})
						},
						copy: function(a) {
							var b = a.index;
							null !== b && this.setIndex(b.clone());
							var c, b = a.attributes;
							for (c in b) this.addAttribute(c, b[c].clone());
							for (a = a.groups, c = 0, b = a.length; c < b; c++) {
								var d = a[c];
								this.addGroup(d.start, d.count, d.materialIndex)
							}
							return this
						}
					}), Object.defineProperties(Kd.prototype, {
						count: {
							get: function() {
								return this.data.count
							}
						},
						array: {
							get: function() {
								return this.data.array
							}
						}
					}), Object.assign(Kd.prototype, {
						isInterleavedBufferAttribute: true,
						setX: function(a, b) {
							return this.data.array[a * this.data.stride + this.offset] = b, this
						},
						setY: function(a, b) {
							return this.data.array[a * this.data.stride + this.offset + 1] = b, this
						},
						setZ: function(a, b) {
							return this.data.array[a * this.data.stride + this.offset + 2] = b, this
						},
						setW: function(a, b) {
							return this.data.array[a * this.data.stride + this.offset + 3] = b, this
						},
						getX: function(a) {
							return this.data.array[a * this.data.stride + this.offset]
						},
						getY: function(a) {
							return this.data.array[a * this.data.stride + this.offset + 1]
						},
						getZ: function(a) {
							return this.data.array[a * this.data.stride + this.offset + 2]
						},
						getW: function(a) {
							return this.data.array[a * this.data.stride + this.offset + 3]
						},
						setXY: function(a, b, c) {
							return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this
						},
						setXYZ: function(a, b, c, d) {
							return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this
						},
						setXYZW: function(a, b, c, d, e) {
							return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this.data.array[a + 3] = e, this
						}
					}), Object.defineProperty(Ld.prototype, "needsUpdate", {
						set: function(a) {
							true === a && this.version++
						}
					}), Object.assign(Ld.prototype, {
						isInterleavedBuffer: true,
						setArray: function(a) {
							if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
							this.count = void 0 !== a ? a.length / this.stride : 0, this.array = a
						},
						setDynamic: function(a) {
							return this.dynamic = a, this
						},
						copy: function(a) {
							return this.array = new a.array.constructor(a.array), this.count = a.count, this.stride = a.stride, this.dynamic = a.dynamic, this
						},
						copyAt: function(a, b, c) {
							a *= this.stride, c *= b.stride;
							for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
							return this
						},
						set: function(a, b) {
							return void 0 === b && (b = 0), this.array.set(a, b), this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						onUpload: function(a) {
							return this.onUploadCallback = a, this
						}
					}), Md.prototype = Object.assign(Object.create(Ld.prototype), {
						constructor: Md,
						isInstancedInterleavedBuffer: true,
						copy: function(a) {
							return Ld.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
						}
					}), Nd.prototype = Object.assign(Object.create(ka.prototype), {
						constructor: Nd,
						isInstancedBufferAttribute: true,
						copy: function(a) {
							return ka.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
						}
					}), Object.assign(Od.prototype, {
						linePrecision: 1,
						set: function(a, b) {
							this.ray.set(a, b)
						},
						setFromCamera: function(a, b) {
							b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
						},
						intersectObject: function(a, b) {
							var c = [];
							return Qd(a, this, c, b), c.sort(Pd), c
						},
						intersectObjects: function(a, b) {
							var c = [];
							if (false === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
							for (var d = 0, e = a.length; d < e; d++) Qd(a[d], this, c, b);
							return c.sort(Pd), c
						}
					}), Object.assign(Rd.prototype, {
						start: function() {
							this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = true
						},
						stop: function() {
							this.getElapsedTime(), this.running = false
						},
						getElapsedTime: function() {
							return this.getDelta(), this.elapsedTime
						},
						getDelta: function() {
							var a = 0;
							if (this.autoStart && !this.running) return this.start(), 0;
							if (this.running) {
								var b = ("undefined" == typeof performance ? Date : performance).now(),
									a = (b - this.oldTime) / 1e3;
								this.oldTime = b, this.elapsedTime += a
							}
							return a
						}
					}), Object.assign(Sd.prototype, {
						set: function(a, b, c) {
							return this.radius = a, this.phi = b, this.theta = c, this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.radius = a.radius, this.phi = a.phi, this.theta = a.theta, this
						},
						makeSafe: function() {
							return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
						},
						setFromVector3: function(a) {
							return this.radius = a.length(), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(re.clamp(a.y / this.radius, -1, 1))), this
						}
					}), Object.assign(Td.prototype, {
						set: function(a, b, c) {
							return this.radius = a, this.theta = b, this.y = c, this
						},
						clone: function() {
							return (new this.constructor).copy(this)
						},
						copy: function(a) {
							return this.radius = a.radius, this.theta = a.theta, this.y = a.y, this
						},
						setFromVector3: function(a) {
							return this.radius = Math.sqrt(a.x * a.x + a.z * a.z), this.theta = Math.atan2(a.x, a.z), this.y = a.y, this
						}
					}), Ud.prototype = Object.create(ya.prototype), Ud.prototype.constructor = Ud, Ud.prototype.createAnimation = function(a, b, c, d) {
						b = {
							start: b,
							end: c,
							length: c - b + 1,
							fps: d,
							duration: (c - b) / d,
							lastFrame: 0,
							currentFrame: 0,
							active: false,
							time: 0,
							direction: 1,
							weight: 1,
							directionBackwards: false,
							mirroredLoop: false
						}, this.animationsMap[a] = b, this.animationsList.push(b)
					}, Ud.prototype.autoCreateAnimations = function(a) {
						for (var b, c = /([a-z]+)_?(\d+)/i, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
							var h = e.morphTargets[f].name.match(c);
							if (h && 1 < h.length) {
								var i = h[1];
								d[i] || (d[i] = {
									start: 1 / 0,
									end: -(1 / 0)
								}), h = d[i], f < h.start && (h.start = f), f > h.end && (h.end = f), b || (b = i)
							}
						}
						for (i in d) h = d[i], this.createAnimation(i, h.start, h.end, a);
						this.firstAnimation = b
					}, Ud.prototype.setAnimationDirectionForward = function(a) {
						(a = this.animationsMap[a]) && (a.direction = 1, a.directionBackwards = false)
					}, Ud.prototype.setAnimationDirectionBackward = function(a) {
						(a = this.animationsMap[a]) && (a.direction = -1, a.directionBackwards = true)
					}, Ud.prototype.setAnimationFPS = function(a, b) {
						var c = this.animationsMap[a];
						c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
					}, Ud.prototype.setAnimationDuration = function(a, b) {
						var c = this.animationsMap[a];
						c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
					}, Ud.prototype.setAnimationWeight = function(a, b) {
						var c = this.animationsMap[a];
						c && (c.weight = b)
					}, Ud.prototype.setAnimationTime = function(a, b) {
						var c = this.animationsMap[a];
						c && (c.time = b)
					}, Ud.prototype.getAnimationTime = function(a) {
						var b = 0;
						return (a = this.animationsMap[a]) && (b = a.time), b
					}, Ud.prototype.getAnimationDuration = function(a) {
						var b = -1;
						return (a = this.animationsMap[a]) && (b = a.duration), b
					}, Ud.prototype.playAnimation = function(a) {
						var b = this.animationsMap[a];
						b ? (b.time = 0, b.active = true) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
					}, Ud.prototype.stopAnimation = function(a) {
						(a = this.animationsMap[a]) && (a.active = false)
					}, Ud.prototype.update = function(a) {
						for (var b = 0, c = this.animationsList.length; b < c; b++) {
							var d = this.animationsList[b];
							if (d.active) {
								var e = d.duration / d.length;
								d.time += d.direction * a, d.mirroredLoop ? (d.time > d.duration || 0 > d.time) && (d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = true), 0 > d.time && (d.time = 0, d.directionBackwards = false)) : (d.time %= d.duration, 0 > d.time && (d.time += d.duration));
								var f = d.start + re.clamp(Math.floor(d.time / e), 0, d.length - 1),
									g = d.weight;
								f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f), e = d.time % e / e, d.directionBackwards && (e = 1 - e), d.currentFrame !== d.lastFrame ? (this.morphTargetInfluences[d.currentFrame] = e * g, this.morphTargetInfluences[d.lastFrame] = (1 - e) * g) : this.morphTargetInfluences[d.currentFrame] = g
							}
						}
					}, Vd.prototype = Object.create(fa.prototype), Vd.prototype.constructor = Vd, Vd.prototype.isImmediateRenderObject = true, Wd.prototype = Object.create(vb.prototype), Wd.prototype.constructor = Wd, Wd.prototype.update = function() {
						var a = new i,
							b = new i,
							c = new $;
						return function() {
							var d = ["a", "b", "c"];
							this.object.updateMatrixWorld(true), c.getNormalMatrix(this.object.matrixWorld);
							var e = this.object.matrixWorld,
								f = this.geometry.attributes.position,
								g = this.object.geometry;
							if (g && g.isGeometry)
								for (var h = g.vertices, i = g.faces, j = g = 0, k = i.length; j < k; j++)
									for (var l = i[j], m = 0, n = l.vertexNormals.length; m < n; m++) {
										var o = l.vertexNormals[m];
										a.copy(h[l[d[m]]]).applyMatrix4(e), b.copy(o).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1
									} else if (g && g.isBufferGeometry)
										for (d = g.attributes.position, h = g.attributes.normal, m = g = 0, n = d.count; m < n; m++) a.set(d.getX(m), d.getY(m), d.getZ(m)).applyMatrix4(e), b.set(h.getX(m), h.getY(m), h.getZ(m)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
							f.needsUpdate = true
						}
					}(), Xd.prototype = Object.create(fa.prototype), Xd.prototype.constructor = Xd, Xd.prototype.dispose = function() {
						this.cone.geometry.dispose(), this.cone.material.dispose()
					}, Xd.prototype.update = function() {
						var a = new i,
							b = new i;
						return function() {
							var c = this.light.distance ? this.light.distance : 1e3,
								d = c * Math.tan(this.light.angle);
							this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(b.sub(a)), this.cone.material.color.copy(this.light.color)
						}
					}(), Yd.prototype = Object.create(vb.prototype), Yd.prototype.constructor = Yd, Yd.prototype.getBoneList = function(a) {
						var b = [];
						a && a.isBone && b.push(a);
						for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
						return b
					}, Yd.prototype.update = function() {
						var a = new i,
							b = new j,
							c = new j;
						return function() {
							var d = this.geometry,
								e = d.getAttribute("position");
							c.getInverse(this.root.matrixWorld);
							for (var f = 0, g = 0; f < this.bones.length; f++) {
								var h = this.bones[f];
								h.parent && h.parent.isBone && (b.multiplyMatrices(c, h.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g, a.x, a.y, a.z), b.multiplyMatrices(c, h.parent.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g + 1, a.x, a.y, a.z), g += 2)
							}
							d.getAttribute("position").needsUpdate = true
						}
					}(), Zd.prototype = Object.create(ya.prototype), Zd.prototype.constructor = Zd, Zd.prototype.dispose = function() {
						this.geometry.dispose(), this.material.dispose()
					}, Zd.prototype.update = function() {
						this.material.color.copy(this.light.color)
					}, $d.prototype = Object.create(fa.prototype), $d.prototype.constructor = $d, $d.prototype.dispose = function() {
						this.children[0].geometry.dispose(), this.children[0].material.dispose()
					}, $d.prototype.update = function() {
						var a = this.children[0];
						a.material.color.copy(this.light.color);
						var b = .5 * this.light.width,
							c = .5 * this.light.height,
							a = a.geometry.attributes.position,
							d = a.array;
						d[0] = b, d[1] = -c, d[2] = 0, d[3] = b, d[4] = c, d[5] = 0, d[6] = -b, d[7] = c, d[8] = 0, d[9] = -b, d[10] = -c, d[11] = 0, d[12] = b, d[13] = -c, d[14] = 0, a.needsUpdate = true
					}, _d.prototype = Object.create(fa.prototype), _d.prototype.constructor = _d, _d.prototype.dispose = function() {
						this.children[0].geometry.dispose(), this.children[0].material.dispose()
					}, _d.prototype.update = function() {
						var a = new i,
							b = new R,
							c = new R;
						return function() {
							var d = this.children[0],
								e = d.geometry.getAttribute("color");
							b.copy(this.light.color), c.copy(this.light.groundColor);
							for (var f = 0, g = e.count; f < g; f++) {
								var h = f < g / 2 ? b : c;
								e.setXYZ(f, h.r, h.g, h.b)
							}
							d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()), e.needsUpdate = true
						}
					}(), ae.prototype = Object.create(vb.prototype), ae.prototype.constructor = ae, be.prototype = Object.create(vb.prototype), be.prototype.constructor = be, ce.prototype = Object.create(vb.prototype), ce.prototype.constructor = ce, ce.prototype.update = function() {
						var a = new i,
							b = new i,
							c = new $;
						return function() {
							this.object.updateMatrixWorld(true), c.getNormalMatrix(this.object.matrixWorld);
							for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices, f = f.faces, h = 0, i = 0, j = f.length; i < j; i++) {
								var k = f[i],
									l = k.normal;
								a.copy(g[k.a]).add(g[k.b]).add(g[k.c]).divideScalar(3).applyMatrix4(d), b.copy(l).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), e.setXYZ(h, a.x, a.y, a.z), h += 1, e.setXYZ(h, b.x, b.y, b.z), h += 1
							}
							e.needsUpdate = true
						}
					}(), de.prototype = Object.create(fa.prototype), de.prototype.constructor = de, de.prototype.dispose = function() {
						var a = this.children[0],
							b = this.children[1];
						a.geometry.dispose(), a.material.dispose(), b.geometry.dispose(), b.material.dispose()
					}, de.prototype.update = function() {
						var a = new i,
							b = new i,
							c = new i;
						return function() {
							a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), c.subVectors(b, a);
							var d = this.children[0],
								e = this.children[1];
							d.lookAt(c), d.material.color.copy(this.light.color), e.lookAt(c), e.scale.z = c.length()
						}
					}(), ee.prototype = Object.create(vb.prototype), ee.prototype.constructor = ee, ee.prototype.update = function() {
						function a(a, f, g, h) {
							if (d.set(f, g, h).unproject(e), a = c[a], void 0 !== a)
								for (f = b.getAttribute("position"), g = 0, h = a.length; g < h; g++) f.setXYZ(a[g], d.x, d.y, d.z)
						}
						var b, c, d = new i,
							e = new Da;
						return function() {
							b = this.geometry, c = this.pointMap, e.projectionMatrix.copy(this.camera.projectionMatrix), a("c", 0, 0, -1), a("t", 0, 0, 1), a("n1", -1, -1, -1), a("n2", 1, -1, -1), a("n3", -1, 1, -1), a("n4", 1, 1, -1), a("f1", -1, -1, 1), a("f2", 1, -1, 1), a("f3", -1, 1, 1), a("f4", 1, 1, 1), a("u1", .7, 1.1, -1), a("u2", -.7, 1.1, -1), a("u3", 0, 2, -1), a("cf1", -1, 0, 1), a("cf2", 1, 0, 1), a("cf3", 0, -1, 1), a("cf4", 0, 1, 1), a("cn1", -1, 0, -1), a("cn2", 1, 0, -1), a("cn3", 0, -1, -1), a("cn4", 0, 1, -1), b.getAttribute("position").needsUpdate = true
						}
					}(), fe.prototype = Object.create(vb.prototype), fe.prototype.constructor = fe, fe.prototype.update = function() {
						var a = new Y;
						return function(b) {
							if (void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && a.setFromObject(this.object), !a.isEmpty()) {
								b = a.min;
								var c = a.max,
									d = this.geometry.attributes.position,
									e = d.array;
								e[0] = c.x, e[1] = c.y, e[2] = c.z, e[3] = b.x, e[4] = c.y, e[5] = c.z, e[6] = b.x, e[7] = b.y, e[8] = c.z, e[9] = c.x, e[10] = b.y, e[11] = c.z, e[12] = c.x, e[13] = c.y, e[14] = b.z, e[15] = b.x, e[16] = c.y, e[17] = b.z, e[18] = b.x, e[19] = b.y, e[20] = b.z, e[21] = c.x, e[22] = b.y, e[23] = b.z, d.needsUpdate = true, this.geometry.computeBoundingSphere()
							}
						}
					}(), fe.prototype.setFromObject = function(a) {
						return this.object = a, this.update(), this
					};
					var Xe, Ye;
					ge.prototype = Object.create(fa.prototype), ge.prototype.constructor = ge, ge.prototype.setDirection = function() {
						var a, b = new i;
						return function(c) {
							.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a))
						}
					}(), ge.prototype.setLength = function(a, b, c) {
						void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, Math.max(0, a - b), 1), this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, this.cone.updateMatrix()
					}, ge.prototype.setColor = function(a) {
						this.line.material.color.copy(a), this.cone.material.color.copy(a)
					}, he.prototype = Object.create(vb.prototype), he.prototype.constructor = he;
					var Ze = new i,
						$e = new ie,
						_e = new ie,
						af = new ie;
					je.prototype = Object.create(id.prototype), je.prototype.constructor = je, je.prototype.getPoint = function(a) {
						var b = this.points,
							c = b.length;
						2 > c && console.log("duh, you need at least 2 points"), a *= c - (this.closed ? 0 : 1);
						var d = Math.floor(a);
						a -= d, this.closed ? d += 0 < d ? 0 : (Math.floor(Math.abs(d) / b.length) + 1) * b.length : 0 === a && d === c - 1 && (d = c - 2, a = 1);
						var e, f, g;
						if (this.closed || 0 < d ? e = b[(d - 1) % c] : (Ze.subVectors(b[0], b[1]).add(b[0]), e = Ze), f = b[d % c], g = b[(d + 1) % c], this.closed || d + 2 < c ? b = b[(d + 2) % c] : (Ze.subVectors(b[c - 1], b[c - 2]).add(b[c - 1]), b = Ze), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
							var h = "chordal" === this.type ? .5 : .25,
								c = Math.pow(e.distanceToSquared(f), h),
								d = Math.pow(f.distanceToSquared(g), h),
								h = Math.pow(g.distanceToSquared(b), h);
							1e-4 > d && (d = 1), 1e-4 > c && (c = d), 1e-4 > h && (h = d), $e.initNonuniformCatmullRom(e.x, f.x, g.x, b.x, c, d, h), _e.initNonuniformCatmullRom(e.y, f.y, g.y, b.y, c, d, h), af.initNonuniformCatmullRom(e.z, f.z, g.z, b.z, c, d, h)
						} else "catmullrom" === this.type && (c = void 0 !== this.tension ? this.tension : .5, $e.initCatmullRom(e.x, f.x, g.x, b.x, c), _e.initCatmullRom(e.y, f.y, g.y, b.y, c), af.initCatmullRom(e.z, f.z, g.z, b.z, c));
						return new i($e.calc(a), _e.calc(a), af.calc(a))
					}, ke.prototype = Object.create(id.prototype), ke.prototype.constructor = ke, ke.prototype.getPoint = function(a) {
						var b = this.v0,
							c = this.v1,
							d = this.v2,
							e = this.v3;
						return new i(hd(a, b.x, c.x, d.x, e.x), hd(a, b.y, c.y, d.y, e.y), hd(a, b.z, c.z, d.z, e.z))
					}, le.prototype = Object.create(id.prototype), le.prototype.constructor = le, le.prototype.getPoint = function(a) {
						var b = this.v0,
							c = this.v1,
							d = this.v2;
						return new i(gd(a, b.x, c.x, d.x), gd(a, b.y, c.y, d.y), gd(a, b.z, c.z, d.z))
					}, me.prototype = Object.create(id.prototype), me.prototype.constructor = me, me.prototype.getPoint = function(a) {
						if (1 === a) return this.v2.clone();
						var b = new i;
						return b.subVectors(this.v2, this.v1), b.multiplyScalar(a), b.add(this.v1), b
					}, ne.prototype = Object.create(ld.prototype), ne.prototype.constructor = ne, id.create = function(a, b) {
						return console.log("THREE.Curve.create() has been deprecated"), a.prototype = Object.create(id.prototype), a.prototype.constructor = a, a.prototype.getPoint = b, a
					}, oe.prototype = Object.create(je.prototype), pe.prototype = Object.create(je.prototype), qe.prototype = Object.create(je.prototype), Object.assign(qe.prototype, {
						initFromArray: function(a) {
							console.error("THREE.Spline: .initFromArray() has been removed.")
						},
						getControlPointsArray: function(a) {
							console.error("THREE.Spline: .getControlPointsArray() has been removed.")
						},
						reparametrizeByArcLength: function(a) {
							console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
						}
					}), ae.prototype.setColors = function() {
						console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
					}, Object.assign(S.prototype, {
						center: function(a) {
							return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(a)
						},
						empty: function() {
							return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
						},
						isIntersectionBox: function(a) {
							return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
						},
						size: function(a) {
							return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(a)
						}
					}), Object.assign(Y.prototype, {
						center: function(a) {
							return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(a)
						},
						empty: function() {
							return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
						},
						isIntersectionBox: function(a) {
							return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
						},
						isIntersectionSphere: function(a) {
							return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
						},
						size: function(a) {
							return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(a)
						}
					}), ga.prototype.center = function(a) {
						return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(a)
					}, re.random16 = function() {
						return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
					}, Object.assign($.prototype, {
						flattenToArrayOffset: function(a, b) {
							return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, b)
						},
						multiplyVector3: function(a) {
							return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), a.applyMatrix3(this)
						},
						multiplyVector3Array: function(a) {
							return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
						},
						applyToBuffer: function(a, b, c) {
							return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(a)
						},
						applyToVector3Array: function(a, b, c) {
							console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
						}
					}), Object.assign(j.prototype, {
						extractPosition: function(a) {
							return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(a)
						},
						flattenToArrayOffset: function(a, b) {
							return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, b)
						},
						getPosition: function() {
							var a;
							return function() {
								return void 0 === a && (a = new i), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), a.setFromMatrixColumn(this, 3)
							}
						}(),
						setRotationFromQuaternion: function(a) {
							return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(a)
						},
						multiplyToArray: function() {
							console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
						},
						multiplyVector3: function(a) {
							return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
						},
						multiplyVector4: function(a) {
							return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
						},
						multiplyVector3Array: function(a) {
							return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
						},
						rotateAxis: function(a) {
							console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), a.transformDirection(this)
						},
						crossVector: function(a) {
							return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
						},
						translate: function() {
							console.error("THREE.Matrix4: .translate() has been removed.")
						},
						rotateX: function() {
							console.error("THREE.Matrix4: .rotateX() has been removed.")
						},
						rotateY: function() {
							console.error("THREE.Matrix4: .rotateY() has been removed.")
						},
						rotateZ: function() {
							console.error("THREE.Matrix4: .rotateZ() has been removed.")
						},
						rotateByAxis: function() {
							console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
						},
						applyToBuffer: function(a, b, c) {
							return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(a)
						},
						applyToVector3Array: function(a, b, c) {
							console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
						},
						makeFrustum: function(a, b, c, d, e, f) {
							return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(a, b, d, c, e, f)
						}
					}), _.prototype.isIntersectionLine = function(a) {
						return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(a)
					}, h.prototype.multiplyVector3 = function(a) {
						return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), a.applyQuaternion(this)
					}, Object.assign(ca.prototype, {
						isIntersectionBox: function(a) {
							return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
						},
						isIntersectionPlane: function(a) {
							return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(a)
						},
						isIntersectionSphere: function(a) {
							return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
						}
					}), Object.assign(qd.prototype, {
						extrude: function(a) {
							return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Xb(this, a)
						},
						makeGeometry: function(a) {
							return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new fc(this, a)
						}
					}), Object.assign(c.prototype, {
						fromAttribute: function(a, b, c) {
							return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, c)
						}
					}), Object.assign(i.prototype, {
						setEulerFromRotationMatrix: function() {
							console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
						},
						setEulerFromQuaternion: function() {
							console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
						},
						getPositionFromMatrix: function(a) {
							return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(a)
						},
						getScaleFromMatrix: function(a) {
							return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(a)
						},
						getColumnFromMatrix: function(a, b) {
							return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(b, a)
						},
						applyProjection: function(a) {
							return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(a)
						},
						fromAttribute: function(a, b, c) {
							return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, c)
						}
					}), Object.assign(e.prototype, {
						fromAttribute: function(a, b, c) {
							return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, c)
						}
					}), wa.prototype.computeTangents = function() {
						console.warn("THREE.Geometry: .computeTangents() has been removed.")
					}, Object.assign(fa.prototype, {
						getChildByName: function(a) {
							return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(a)
						},
						renderDepth: function() {
							console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
						},
						translate: function(a, b) {
							return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(b, a)
						}
					}), Object.defineProperties(fa.prototype, {
						eulerOrder: {
							get: function() {
								return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
							},
							set: function(a) {
								console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a
							}
						},
						useQuaternion: {
							get: function() {
								console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
							},
							set: function() {
								console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
							}
						}
					}), Object.defineProperties(pb.prototype, {
						objects: {
							get: function() {
								return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
							}
						}
					}), Object.defineProperty(qb.prototype, "useVertexTexture", {
						get: function() {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						},
						set: function() {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						}
					}), Object.defineProperty(id.prototype, "__arcLengthDivisions", {
						get: function() {
							return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
						},
						set: function(a) {
							console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = a
						}
					}), Ea.prototype.setLens = function(a, b) {
						console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== b && (this.filmGauge = b), this.setFocalLength(a)
					}, Object.defineProperties(Ec.prototype, {
						onlyShadow: {
							set: function() {
								console.warn("THREE.Light: .onlyShadow has been removed.")
							}
						},
						shadowCameraFov: {
							set: function(a) {
								console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a
							}
						},
						shadowCameraLeft: {
							set: function(a) {
								console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a
							}
						},
						shadowCameraRight: {
							set: function(a) {
								console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a
							}
						},
						shadowCameraTop: {
							set: function(a) {
								console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a
							}
						},
						shadowCameraBottom: {
							set: function(a) {
								console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = a
							}
						},
						shadowCameraNear: {
							set: function(a) {
								console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a
							}
						},
						shadowCameraFar: {
							set: function(a) {
								console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a
							}
						},
						shadowCameraVisible: {
							set: function() {
								console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
							}
						},
						shadowBias: {
							set: function(a) {
								console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a
							}
						},
						shadowDarkness: {
							set: function() {
								console.warn("THREE.Light: .shadowDarkness has been removed.")
							}
						},
						shadowMapWidth: {
							set: function(a) {
								console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a
							}
						},
						shadowMapHeight: {
							set: function(a) {
								console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a
							}
						}
					}), Object.defineProperties(ka.prototype, {
						length: {
							get: function() {
								return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
							}
						}
					}), Object.assign(xa.prototype, {
						addIndex: function(a) {
							console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(a)
						},
						addDrawCall: function(a, b, c) {
							void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, b)
						},
						clearDrawCalls: function() {
							console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
						},
						computeTangents: function() {
							console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
						},
						computeOffsets: function() {
							console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
						}
					}), Object.defineProperties(xa.prototype, {
						drawcalls: {
							get: function() {
								return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
							}
						},
						offsets: {
							get: function() {
								return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
							}
						}
					}), Object.defineProperties(Id.prototype, {
						dynamic: {
							set: function() {
								console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
							}
						},
						onUpdate: {
							value: function() {
								return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
							}
						}
					}), Object.defineProperties(V.prototype, {
						wrapAround: {
							get: function() {
								console.warn("THREE.Material: .wrapAround has been removed.")
							},
							set: function() {
								console.warn("THREE.Material: .wrapAround has been removed.")
							}
						},
						wrapRGB: {
							get: function() {
								return console.warn("THREE.Material: .wrapRGB has been removed."), new R
							}
						}
					}), Object.defineProperties(sc.prototype, {
						metal: {
							get: function() {
								return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), false
							},
							set: function() {
								console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
							}
						}
					}), Object.defineProperties(W.prototype, {
						derivatives: {
							get: function() {
								return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
							},
							set: function(a) {
								console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = a
							}
						}
					}), Object.assign(ib.prototype, {
						getCurrentRenderTarget: function() {
							return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
						},
						supportsFloatTextures: function() {
							return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
						},
						supportsHalfFloatTextures: function() {
							return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
						},
						supportsStandardDerivatives: function() {
							return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
						},
						supportsCompressedTextureS3TC: function() {
							return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
						},
						supportsCompressedTexturePVRTC: function() {
							return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
						},
						supportsBlendMinMax: function() {
							return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
						},
						supportsVertexTextures: function() {
							return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
						},
						supportsInstancedArrays: function() {
							return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
						},
						enableScissorTest: function(a) {
							console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(a)
						},
						initMaterial: function() {
							console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
						},
						addPrePlugin: function() {
							console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
						},
						addPostPlugin: function() {
							console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
						},
						updateShadowMap: function() {
							console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
						}
					}), Object.defineProperties(ib.prototype, {
						shadowMapEnabled: {
							get: function() {
								return this.shadowMap.enabled
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = a;
							}
						},
						shadowMapType: {
							get: function() {
								return this.shadowMap.type
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a
							}
						},
						shadowMapCullFace: {
							get: function() {
								return this.shadowMap.cullFace
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = a
							}
						}
					}), Object.defineProperties(ba.prototype, {
						cullFace: {
							get: function() {
								return this.renderReverseSided ? 2 : 1
							},
							set: function(a) {
								a = 1 !== a, console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + "."), this.renderReverseSided = a
							}
						}
					}), Object.defineProperties(f.prototype, {
						wrapS: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a
							}
						},
						wrapT: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a
							}
						},
						magFilter: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = a
							}
						},
						minFilter: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = a
							}
						},
						anisotropy: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = a
							}
						},
						offset: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a
							}
						},
						repeat: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a
							}
						},
						format: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a
							}
						},
						type: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a
							}
						},
						generateMipmaps: {
							get: function() {
								return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
							},
							set: function(a) {
								console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = a
							}
						}
					}), zd.prototype.load = function(a) {
						console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
						var b = this;
						return (new ud).load(a, function(a) {
							b.setBuffer(a)
						}), this
					}, Bd.prototype.getData = function() {
						return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
					}, a.WebGLRenderTargetCube = g, a.WebGLRenderTarget = f, a.WebGLRenderer = ib, a.ShaderLib = Ee, a.UniformsLib = Be, a.UniformsUtils = Ce, a.ShaderChunk = De, a.FogExp2 = jb, a.Fog = kb, a.Scene = lb, a.LensFlare = mb, a.Sprite = ob, a.LOD = pb, a.SkinnedMesh = sb, a.Skeleton = qb, a.Bone = rb, a.Mesh = ya, a.LineSegments = vb, a.LineLoop = wb, a.Line = ub, a.Points = yb, a.Group = zb, a.VideoTexture = Ab, a.DataTexture = k, a.CompressedTexture = Bb, a.CubeTexture = l, a.CanvasTexture = Cb, a.DepthTexture = Db, a.Texture = d, a.CompressedTextureLoader = zc, a.DataTextureLoader = Ac, a.CubeTextureLoader = Cc, a.TextureLoader = Dc, a.ObjectLoader = ed, a.MaterialLoader = ad, a.BufferGeometryLoader = bd, a.DefaultLoadingManager = Ne, a.LoadingManager = xc, a.JSONLoader = dd, a.ImageLoader = Bc, a.FontLoader = td, a.FileLoader = yc, a.Loader = cd, a.Cache = Me, a.AudioLoader = ud, a.SpotLightShadow = Hc, a.SpotLight = Ic, a.PointLight = Jc, a.RectAreaLight = Nc, a.HemisphereLight = Fc, a.DirectionalLightShadow = Kc, a.DirectionalLight = Lc, a.AmbientLight = Mc, a.LightShadow = Gc, a.Light = Ec, a.StereoCamera = vd, a.PerspectiveCamera = Ea, a.OrthographicCamera = Fa, a.CubeCamera = wd, a.ArrayCamera = xd, a.Camera = Da, a.AudioListener = yd, a.PositionalAudio = Ad, a.AudioContext = We, a.AudioAnalyser = Bd, a.Audio = zd, a.VectorKeyframeTrack = Tc, a.StringKeyframeTrack = Xc, a.QuaternionKeyframeTrack = Vc, a.NumberKeyframeTrack = Wc, a.ColorKeyframeTrack = Zc, a.BooleanKeyframeTrack = Yc, a.PropertyMixer = Cd, a.PropertyBinding = Ed, a.KeyframeTrack = $c, a.AnimationUtils = Oe, a.AnimationObjectGroup = Fd, a.AnimationMixer = Hd, a.AnimationClip = _c, a.Uniform = Id, a.InstancedBufferGeometry = Jd, a.BufferGeometry = xa, a.GeometryIdCount = function() {
						return He++
					}, a.Geometry = wa, a.InterleavedBufferAttribute = Kd, a.InstancedInterleavedBuffer = Md, a.InterleavedBuffer = Ld, a.InstancedBufferAttribute = Nd, a.Face3 = ia, a.Object3D = fa, a.Raycaster = Od, a.Layers = ea, a.EventDispatcher = b, a.Clock = Rd, a.QuaternionLinearInterpolant = Uc, a.LinearInterpolant = Qc, a.DiscreteInterpolant = Rc, a.CubicInterpolant = Pc, a.Interpolant = Oc, a.Triangle = ha, a.Math = re, a.Spherical = Sd, a.Cylindrical = Td, a.Plane = _, a.Frustum = aa, a.Sphere = Z, a.Ray = ca, a.Matrix4 = j, a.Matrix3 = $, a.Box3 = Y, a.Box2 = S, a.Line3 = ga, a.Euler = da, a.Vector4 = e, a.Vector3 = i, a.Vector2 = c, a.Quaternion = h, a.Color = R, a.MorphBlendMesh = Ud, a.ImmediateRenderObject = Vd, a.VertexNormalsHelper = Wd, a.SpotLightHelper = Xd, a.SkeletonHelper = Yd, a.PointLightHelper = Zd, a.RectAreaLightHelper = $d, a.HemisphereLightHelper = _d, a.GridHelper = ae, a.PolarGridHelper = be, a.FaceNormalsHelper = ce, a.DirectionalLightHelper = de, a.CameraHelper = ee, a.BoxHelper = fe, a.ArrowHelper = ge, a.AxisHelper = he, a.CatmullRomCurve3 = je, a.CubicBezierCurve3 = ke, a.QuadraticBezierCurve3 = le, a.LineCurve3 = me, a.ArcCurve = ne, a.EllipseCurve = ld, a.SplineCurve = md, a.CubicBezierCurve = nd, a.QuadraticBezierCurve = od, a.LineCurve = jd, a.Shape = qd, a.Path = pd;
					a.ShapePath = rd;
					a.Font = sd, a.CurvePath = kd, a.Curve = id, a.ShapeUtils = Je, a.SceneUtils = {
						createMultiMaterialObject: function(a, b) {
							for (var c = new zb, d = 0, e = b.length; d < e; d++) c.add(new ya(a, b[d]));
							return c
						},
						detach: function(a, b, c) {
							a.applyMatrix(b.matrixWorld), b.remove(a), c.add(a)
						},
						attach: function(a, b, c) {
							var d = new j;
							d.getInverse(c.matrixWorld), a.applyMatrix(d), b.remove(a), c.add(a)
						}
					}, a.WireframeGeometry = Eb, a.ParametricGeometry = Fb, a.ParametricBufferGeometry = Gb, a.TetrahedronGeometry = Jb, a.TetrahedronBufferGeometry = Kb, a.OctahedronGeometry = Lb, a.OctahedronBufferGeometry = Mb, a.IcosahedronGeometry = Nb, a.IcosahedronBufferGeometry = Ob, a.DodecahedronGeometry = Pb, a.DodecahedronBufferGeometry = Qb, a.PolyhedronGeometry = Hb, a.PolyhedronBufferGeometry = Ib, a.TubeGeometry = Rb, a.TubeBufferGeometry = Sb, a.TorusKnotGeometry = Tb, a.TorusKnotBufferGeometry = Ub, a.TorusGeometry = Vb, a.TorusBufferGeometry = Wb, a.TextGeometry = Zb, a.TextBufferGeometry = $b, a.SphereGeometry = _b, a.SphereBufferGeometry = ac, a.RingGeometry = bc, a.RingBufferGeometry = cc, a.PlaneGeometry = Ba, a.PlaneBufferGeometry = Ca, a.LatheGeometry = dc, a.LatheBufferGeometry = ec, a.ShapeGeometry = fc, a.ShapeBufferGeometry = gc, a.ExtrudeGeometry = Xb, a.ExtrudeBufferGeometry = Yb, a.EdgesGeometry = hc, a.ConeGeometry = kc, a.ConeBufferGeometry = lc, a.CylinderGeometry = ic, a.CylinderBufferGeometry = jc, a.CircleGeometry = mc, a.CircleBufferGeometry = nc, a.BoxGeometry = za, a.BoxBufferGeometry = Aa, a.ShadowMaterial = oc, a.SpriteMaterial = nb, a.RawShaderMaterial = pc, a.ShaderMaterial = W, a.PointsMaterial = xb, a.MeshPhysicalMaterial = rc, a.MeshStandardMaterial = qc, a.MeshPhongMaterial = sc, a.MeshToonMaterial = tc, a.MeshNormalMaterial = uc, a.MeshLambertMaterial = vc, a.MeshDepthMaterial = X, a.MeshBasicMaterial = ja, a.LineDashedMaterial = wc, a.LineBasicMaterial = tb, a.Material = V, a.Float64BufferAttribute = ta, a.Float32BufferAttribute = sa, a.Uint32BufferAttribute = ra, a.Int32BufferAttribute = qa, a.Uint16BufferAttribute = pa, a.Int16BufferAttribute = oa, a.Uint8ClampedBufferAttribute = na, a.Uint8BufferAttribute = ma, a.Int8BufferAttribute = la, a.BufferAttribute = ka, a.REVISION = "85", a.MOUSE = {
						LEFT: 0,
						MIDDLE: 1,
						RIGHT: 2
					}, a.CullFaceNone = 0, a.CullFaceBack = 1, a.CullFaceFront = 2, a.CullFaceFrontBack = 3, a.FrontFaceDirectionCW = 0, a.FrontFaceDirectionCCW = 1, a.BasicShadowMap = 0, a.PCFShadowMap = 1, a.PCFSoftShadowMap = 2, a.FrontSide = 0, a.BackSide = 1, a.DoubleSide = 2, a.FlatShading = 1, a.SmoothShading = 2, a.NoColors = 0, a.FaceColors = 1, a.VertexColors = 2, a.NoBlending = 0, a.NormalBlending = 1, a.AdditiveBlending = 2, a.SubtractiveBlending = 3, a.MultiplyBlending = 4, a.CustomBlending = 5, a.AddEquation = 100, a.SubtractEquation = 101, a.ReverseSubtractEquation = 102, a.MinEquation = 103, a.MaxEquation = 104, a.ZeroFactor = 200, a.OneFactor = 201, a.SrcColorFactor = 202, a.OneMinusSrcColorFactor = 203, a.SrcAlphaFactor = 204, a.OneMinusSrcAlphaFactor = 205, a.DstAlphaFactor = 206, a.OneMinusDstAlphaFactor = 207, a.DstColorFactor = 208, a.OneMinusDstColorFactor = 209, a.SrcAlphaSaturateFactor = 210, a.NeverDepth = 0, a.AlwaysDepth = 1, a.LessDepth = 2, a.LessEqualDepth = 3, a.EqualDepth = 4, a.GreaterEqualDepth = 5, a.GreaterDepth = 6, a.NotEqualDepth = 7, a.MultiplyOperation = 0, a.MixOperation = 1, a.AddOperation = 2, a.NoToneMapping = 0, a.LinearToneMapping = 1, a.ReinhardToneMapping = 2, a.Uncharted2ToneMapping = 3, a.CineonToneMapping = 4, a.UVMapping = 300, a.CubeReflectionMapping = 301, a.CubeRefractionMapping = 302, a.EquirectangularReflectionMapping = 303, a.EquirectangularRefractionMapping = 304, a.SphericalReflectionMapping = 305, a.CubeUVReflectionMapping = 306, a.CubeUVRefractionMapping = 307, a.RepeatWrapping = 1e3, a.ClampToEdgeWrapping = 1001, a.MirroredRepeatWrapping = 1002, a.NearestFilter = 1003, a.NearestMipMapNearestFilter = 1004, a.NearestMipMapLinearFilter = 1005, a.LinearFilter = 1006, a.LinearMipMapNearestFilter = 1007, a.LinearMipMapLinearFilter = 1008, a.UnsignedByteType = 1009, a.ByteType = 1010, a.ShortType = 1011, a.UnsignedShortType = 1012, a.IntType = 1013, a.UnsignedIntType = 1014, a.FloatType = 1015, a.HalfFloatType = 1016, a.UnsignedShort4444Type = 1017, a.UnsignedShort5551Type = 1018, a.UnsignedShort565Type = 1019, a.UnsignedInt248Type = 1020, a.AlphaFormat = 1021, a.RGBFormat = 1022, a.RGBAFormat = 1023, a.LuminanceFormat = 1024, a.LuminanceAlphaFormat = 1025, a.RGBEFormat = 1023, a.DepthFormat = 1026, a.DepthStencilFormat = 1027, a.RGB_S3TC_DXT1_Format = 2001, a.RGBA_S3TC_DXT1_Format = 2002, a.RGBA_S3TC_DXT3_Format = 2003, a.RGBA_S3TC_DXT5_Format = 2004, a.RGB_PVRTC_4BPPV1_Format = 2100, a.RGB_PVRTC_2BPPV1_Format = 2101, a.RGBA_PVRTC_4BPPV1_Format = 2102, a.RGBA_PVRTC_2BPPV1_Format = 2103, a.RGB_ETC1_Format = 2151, a.LoopOnce = 2200, a.LoopRepeat = 2201, a.LoopPingPong = 2202, a.InterpolateDiscrete = 2300, a.InterpolateLinear = 2301, a.InterpolateSmooth = 2302, a.ZeroCurvatureEnding = 2400, a.ZeroSlopeEnding = 2401, a.WrapAroundEnding = 2402, a.TrianglesDrawMode = 0, a.TriangleStripDrawMode = 1, a.TriangleFanDrawMode = 2, a.LinearEncoding = 3e3, a.sRGBEncoding = 3001, a.GammaEncoding = 3007, a.RGBEEncoding = 3002, a.LogLuvEncoding = 3003, a.RGBM7Encoding = 3004, a.RGBM16Encoding = 3005, a.RGBDEncoding = 3006, a.BasicDepthPacking = 3200, a.RGBADepthPacking = 3201, a.CubeGeometry = za, a.Face4 = function(a, b, c, d, e, f, g) {
						return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ia(a, b, c, e, f, g)
					};
					a.LineStrip = 0;
					a.LinePieces = 1, a.MeshFaceMaterial = function(a) {
						return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), a
					}, a.MultiMaterial = function(a) {
						return void 0 === a && (a = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), a.isMultiMaterial = true, a.materials = a, a.clone = function() {
							return a.slice()
						}, a
					}, a.PointCloud = function(a, b) {
						return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new yb(a, b)
					}, a.Particle = function(a) {
						return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new ob(a)
					}, a.ParticleSystem = function(a, b) {
						return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new yb(a, b)
					}, a.PointCloudMaterial = function(a) {
						return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new xb(a)
					}, a.ParticleBasicMaterial = function(a) {
						return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new xb(a)
					}, a.ParticleSystemMaterial = function(a) {
						return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new xb(a)
					}, a.Vertex = function(a, b, c) {
						return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new i(a, b, c)
					}, a.DynamicBufferAttribute = function(a, b) {
						return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ka(a, b).setDynamic(true)
					}, a.Int8Attribute = function(a, b) {
						return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new la(a, b)
					}, a.Uint8Attribute = function(a, b) {
						return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ma(a, b)
					}, a.Uint8ClampedAttribute = function(a, b) {
						return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new na(a, b)
					}, a.Int16Attribute = function(a, b) {
						return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new oa(a, b)
					}, a.Uint16Attribute = function(a, b) {
						return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new pa(a, b)
					}, a.Int32Attribute = function(a, b) {
						return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new qa(a, b)
					}, a.Uint32Attribute = function(a, b) {
						return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new ra(a, b)
					}, a.Float32Attribute = function(a, b) {
						return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new sa(a, b)
					}, a.Float64Attribute = function(a, b) {
						return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ta(a, b)
					}, a.ClosedSplineCurve3 = oe, a.SplineCurve3 = pe, a.Spline = qe, a.BoundingBoxHelper = function(a, b) {
						return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new fe(a, b)
					}, a.EdgesHelper = function(a, b) {
						return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new vb(new hc(a.geometry), new tb({
							color: void 0 !== b ? b : 16777215
						}))
					}, a.WireframeHelper = function(a, b) {
						return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new vb(new Eb(a.geometry), new tb({
							color: void 0 !== b ? b : 16777215
						}))
					}, a.XHRLoader = function(a) {
						return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new yc(a)
					}, a.BinaryTextureLoader = function(a) {
						return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ac(a)
					}, a.GeometryUtils = {
						merge: function(a, b, c) {
							console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
							var d;
							b.isMesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry), a.merge(b, d, c)
						},
						center: function(a) {
							return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), a.center()
						}
					}, a.ImageUtils = {
						crossOrigin: void 0,
						loadTexture: function(a, b, c, d) {
							console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
							var e = new Dc;
							return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), a
						},
						loadTextureCube: function(a, b, c, d) {
							console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
							var e = new Cc;
							return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), a
						},
						loadCompressedTexture: function() {
							console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
						},
						loadCompressedTextureCube: function() {
							console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
						}
					}, a.Projector = function() {
						console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(a, b) {
							console.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b)
						}, this.unprojectVector = function(a, b) {
							console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), a.unproject(b)
						}, this.pickingRay = function() {
							console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
						}
					}, a.CanvasRenderer = function() {
						console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
					}, Object.defineProperty(a, "__esModule", {
						value: true
					})
				}), ! function(a, b) {
					"object" == typeof exports && "object" == typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define([], b) : "object" == typeof exports ? exports.io = b() : a.io = b()
				}(this, function() {
					return function(a) {
						function b(d) {
							if (c[d]) return c[d].exports;
							var e = c[d] = {
								exports: {},
								id: d,
								loaded: false
							};
							return a[d].call(e.exports, e, e.exports, b), e.loaded = true, e.exports
						}
						var c = {};
						return b.m = a, b.c = c, b.p = "", b(0)
					}([function(a, b, c) {
						"use strict";

						function d(a, b) {
							"object" === ("undefined" == typeof a ? "undefined" : e(a)) && (b = a, a = void 0), b = b || {};
							var c, d = f(a),
								g = d.source,
								j = d.id,
								k = d.path,
								l = i[j] && k in i[j].nsps,
								m = b.forceNew || b["force new connection"] || false === b.multiplex || l;
							return m ? c = h(g, b) : (i[j] || (i[j] = h(g, b)), c = i[j]), d.query && !b.query && (b.query = d.query), c.socket(d.path, b)
						}
						var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
								return typeof a
							} : function(a) {
								return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
							},
							f = c(1),
							g = c(4),
							h = c(10);
						c(3)("socket.io-client"), a.exports = b = d;
						var i = b.managers = {};
						b.protocol = g.protocol, b.connect = d, b.Manager = c(10), b.Socket = c(36)
					}, function(a, b, c) {
						(function(b) {
							"use strict";

							function d(a, c) {
								var d = a;
								c = c || b.location, null == a && (a = c.protocol + "//" + c.host), "string" == typeof a && ("/" === a.charAt(0) && (a = "/" === a.charAt(1) ? c.protocol + a : c.host + a), /^(https?|wss?):\/\//.test(a) || (a = "undefined" != typeof c ? c.protocol + "//" + a : "https://" + a), d = e(a)), d.port || (/^(http|ws)$/.test(d.protocol) ? d.port = "80" : /^(http|ws)s$/.test(d.protocol) && (d.port = "443")), d.path = d.path || "/";
								var f = d.host.indexOf(":") !== -1,
									g = f ? "[" + d.host + "]" : d.host;
								return d.id = d.protocol + "://" + g + ":" + d.port, d.href = d.protocol + "://" + g + (c && c.port === d.port ? "" : ":" + d.port), d
							}
							var e = c(2);
							c(3)("socket.io-client:url"), a.exports = d
						}).call(b, function() {
							return this
						}())
					}, function(a, b) {
						var c = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
							d = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
						a.exports = function(a) {
							var b = a,
								e = a.indexOf("["),
								f = a.indexOf("]");
							e != -1 && f != -1 && (a = a.substring(0, e) + a.substring(e, f).replace(/:/g, ";") + a.substring(f, a.length));
							for (var g = c.exec(a || ""), h = {}, i = 14; i--;) h[d[i]] = g[i] || "";
							return e != -1 && f != -1 && (h.source = b, h.host = h.host.substring(1, h.host.length - 1).replace(/;/g, ":"), h.authority = h.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), h.ipv6uri = true), h
						}
					}, function(a, b) {
						"use strict";
						a.exports = function() {
							return function() {}
						}
					}, function(a, b, c) {
						function d() {}

						function e(a) {
							var c = "" + a.type;
							return b.BINARY_EVENT !== a.type && b.BINARY_ACK !== a.type || (c += a.attachments + "-"), a.nsp && "/" !== a.nsp && (c += a.nsp + ","), null != a.id && (c += a.id), null != a.data && (c += JSON.stringify(a.data)), c
						}

						function f(a, b) {
							function c(a) {
								var c = n.deconstructPacket(a),
									d = e(c.packet),
									f = c.buffers;
								f.unshift(d), b(f)
							}
							n.removeBlobs(a, c)
						}

						function g() {
							this.reconstructor = null
						}

						function h(a) {
							var c = 0,
								d = {
									type: Number(a.charAt(0))
								};
							if (null == b.types[d.type]) return k();
							if (b.BINARY_EVENT === d.type || b.BINARY_ACK === d.type) {
								for (var e = "";
									"-" !== a.charAt(++c) && (e += a.charAt(c), c != a.length););
								if (e != Number(e) || "-" !== a.charAt(c)) throw new Error("Illegal attachments");
								d.attachments = Number(e)
							}
							if ("/" === a.charAt(c + 1))
								for (d.nsp = ""; ++c;) {
									var f = a.charAt(c);
									if ("," === f) break;
									if (d.nsp += f, c === a.length) break
								} else d.nsp = "/";
							var g = a.charAt(c + 1);
							if ("" !== g && Number(g) == g) {
								for (d.id = ""; ++c;) {
									var f = a.charAt(c);
									if (null == f || Number(f) != f) {
										--c;
										break
									}
									if (d.id += a.charAt(c), c === a.length) break
								}
								d.id = Number(d.id)
							}
							return a.charAt(++c) && (d = i(d, a.substr(c))), d
						}

						function i(a, b) {
							try {
								a.data = JSON.parse(b)
							} catch (a) {
								return k()
							}
							return a
						}

						function j(a) {
							this.reconPack = a, this.buffers = []
						}

						function k() {
							return {
								type: b.ERROR,
								data: "parser error"
							}
						}
						var l = (c(3)("socket.io-parser"), c(5)),
							m = c(6),
							n = c(8),
							o = c(9);
						b.protocol = 4, b.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], b.CONNECT = 0, b.DISCONNECT = 1, b.EVENT = 2, b.ACK = 3, b.ERROR = 4, b.BINARY_EVENT = 5, b.BINARY_ACK = 6, b.Encoder = d, b.Decoder = g, d.prototype.encode = function(a, c) {
							if (a.type !== b.EVENT && a.type !== b.ACK || !m(a.data) || (a.type = a.type === b.EVENT ? b.BINARY_EVENT : b.BINARY_ACK), b.BINARY_EVENT === a.type || b.BINARY_ACK === a.type) f(a, c);
							else {
								var d = e(a);
								c([d])
							}
						}, l(g.prototype), g.prototype.add = function(a) {
							var c;
							if ("string" == typeof a) c = h(a), b.BINARY_EVENT === c.type || b.BINARY_ACK === c.type ? (this.reconstructor = new j(c), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", c)) : this.emit("decoded", c);
							else {
								if (!o(a) && !a.base64) throw new Error("Unknown type: " + a);
								if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
								c = this.reconstructor.takeBinaryData(a), c && (this.reconstructor = null, this.emit("decoded", c))
							}
						}, g.prototype.destroy = function() {
							this.reconstructor && this.reconstructor.finishedReconstruction()
						}, j.prototype.takeBinaryData = function(a) {
							if (this.buffers.push(a), this.buffers.length === this.reconPack.attachments) {
								var b = n.reconstructPacket(this.reconPack, this.buffers);
								return this.finishedReconstruction(), b
							}
							return null
						}, j.prototype.finishedReconstruction = function() {
							this.reconPack = null, this.buffers = []
						}
					}, function(a, b, c) {
						function d(a) {
							if (a) return e(a)
						}

						function e(a) {
							for (var b in d.prototype) a[b] = d.prototype[b];
							return a
						}
						a.exports = d, d.prototype.on = d.prototype.addEventListener = function(a, b) {
							return this._callbacks = this._callbacks || {}, (this._callbacks["$" + a] = this._callbacks["$" + a] || []).push(b), this
						}, d.prototype.once = function(a, b) {
							function c() {
								this.off(a, c), b.apply(this, arguments)
							}
							return c.fn = b, this.on(a, c), this
						}, d.prototype.off = d.prototype.removeListener = d.prototype.removeAllListeners = d.prototype.removeEventListener = function(a, b) {
							if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
							var c = this._callbacks["$" + a];
							if (!c) return this;
							if (1 == arguments.length) return delete this._callbacks["$" + a], this;
							for (var d, e = 0; e < c.length; e++)
								if (d = c[e], d === b || d.fn === b) {
									c.splice(e, 1);
									break
								}
							return this
						}, d.prototype.emit = function(a) {
							this._callbacks = this._callbacks || {};
							var b = [].slice.call(arguments, 1),
								c = this._callbacks["$" + a];
							if (c) {
								c = c.slice(0);
								for (var d = 0, e = c.length; d < e; ++d) c[d].apply(this, b)
							}
							return this
						}, d.prototype.listeners = function(a) {
							return this._callbacks = this._callbacks || {}, this._callbacks["$" + a] || []
						}, d.prototype.hasListeners = function(a) {
							return !!this.listeners(a).length
						}
					}, function(a, b, c) {
						(function(b) {
							function d(a) {
								if (!a || "object" != typeof a) return false;
								if (e(a)) {
									for (var c = 0, f = a.length; c < f; c++)
										if (d(a[c])) return true;
									return false
								}
								if ("function" == typeof b.Buffer && b.Buffer.isBuffer && b.Buffer.isBuffer(a) || "function" == typeof b.ArrayBuffer && a instanceof ArrayBuffer || g && a instanceof Blob || h && a instanceof File) return true;
								if (a.toJSON && "function" == typeof a.toJSON && 1 === arguments.length) return d(a.toJSON(), true);
								for (var i in a)
									if (Object.prototype.hasOwnProperty.call(a, i) && d(a[i])) return true;
								return false
							}
							var e = c(7),
								f = Object.prototype.toString,
								g = "function" == typeof b.Blob || "[object BlobConstructor]" === f.call(b.Blob),
								h = "function" == typeof b.File || "[object FileConstructor]" === f.call(b.File);
							a.exports = d
						}).call(b, function() {
							return this
						}())
					}, function(a, b) {
						var c = {}.toString;
						a.exports = Array.isArray || function(a) {
							return "[object Array]" == c.call(a)
						}
					}, function(a, b, c) {
						(function(a) {
							function d(a, b) {
								if (!a) return a;
								if (g(a)) {
									var c = {
										_placeholder: true,
										num: b.length
									};
									return b.push(a), c
								}
								if (f(a)) {
									for (var e = new Array(a.length), h = 0; h < a.length; h++) e[h] = d(a[h], b);
									return e
								}
								if ("object" == typeof a && !(a instanceof Date)) {
									var e = {};
									for (var i in a) e[i] = d(a[i], b);
									return e
								}
								return a
							}

							function e(a, b) {
								if (!a) return a;
								if (a && a._placeholder) return b[a.num];
								if (f(a))
									for (var c = 0; c < a.length; c++) a[c] = e(a[c], b);
								else if ("object" == typeof a)
									for (var d in a) a[d] = e(a[d], b);
								return a
							}
							var f = c(7),
								g = c(9),
								h = Object.prototype.toString,
								i = "function" == typeof a.Blob || "[object BlobConstructor]" === h.call(a.Blob),
								j = "function" == typeof a.File || "[object FileConstructor]" === h.call(a.File);
							b.deconstructPacket = function(a) {
								var b = [],
									c = a.data,
									e = a;
								return e.data = d(c, b), e.attachments = b.length, {
									packet: e,
									buffers: b
								}
							}, b.reconstructPacket = function(a, b) {
								return a.data = e(a.data, b), a.attachments = void 0, a
							}, b.removeBlobs = function(a, b) {
								function c(a, h, k) {
									if (!a) return a;
									if (i && a instanceof Blob || j && a instanceof File) {
										d++;
										var l = new FileReader;
										l.onload = function() {
											k ? k[h] = this.result : e = this.result, --d || b(e)
										}, l.readAsArrayBuffer(a)
									} else if (f(a))
										for (var m = 0; m < a.length; m++) c(a[m], m, a);
									else if ("object" == typeof a && !g(a))
										for (var n in a) c(a[n], n, a)
								}
								var d = 0,
									e = a;
								c(e), d || b(e)
							}
						}).call(b, function() {
							return this
						}())
					}, function(a, b) {
						(function(b) {
							function c(a) {
								return b.Buffer && b.Buffer.isBuffer(a) || b.ArrayBuffer && a instanceof ArrayBuffer
							}
							a.exports = c
						}).call(b, function() {
							return this
						}())
					}, function(a, b, c) {
						"use strict";

						function d(a, b) {
							if (!(this instanceof d)) return new d(a, b);
							a && "object" === ("undefined" == typeof a ? "undefined" : e(a)) && (b = a, a = void 0), b = b || {}, b.path = b.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = b, this.reconnection(b.reconnection !== false), this.reconnectionAttempts(b.reconnectionAttempts || 1 / 0), this.reconnectionDelay(b.reconnectionDelay || 1e3), this.reconnectionDelayMax(b.reconnectionDelayMax || 5e3), this.randomizationFactor(b.randomizationFactor || .5), this.backoff = new m({
								min: this.reconnectionDelay(),
								max: this.reconnectionDelayMax(),
								jitter: this.randomizationFactor()
							}), this.timeout(null == b.timeout ? 2e4 : b.timeout), this.readyState = "closed", this.uri = a, this.connecting = [], this.lastPing = null, this.encoding = false, this.packetBuffer = [];
							var c = b.parser || i;
							this.encoder = new c.Encoder, this.decoder = new c.Decoder, this.autoConnect = b.autoConnect !== false, this.autoConnect && this.open()
						}
						var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
								return typeof a
							} : function(a) {
								return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
							},
							f = c(11),
							g = c(36),
							h = c(5),
							i = c(4),
							j = c(38),
							k = c(39),
							l = (c(3)("socket.io-client:manager"), c(34)),
							m = c(40),
							n = Object.prototype.hasOwnProperty;
						a.exports = d, d.prototype.emitAll = function() {
							this.emit.apply(this, arguments);
							for (var a in this.nsps) n.call(this.nsps, a) && this.nsps[a].emit.apply(this.nsps[a], arguments)
						}, d.prototype.updateSocketIds = function() {
							for (var a in this.nsps) n.call(this.nsps, a) && (this.nsps[a].id = this.generateId(a))
						}, d.prototype.generateId = function(a) {
							return ("/" === a ? "" : a + "#") + this.engine.id
						}, h(d.prototype), d.prototype.reconnection = function(a) {
							return arguments.length ? (this._reconnection = !!a, this) : this._reconnection
						}, d.prototype.reconnectionAttempts = function(a) {
							return arguments.length ? (this._reconnectionAttempts = a, this) : this._reconnectionAttempts
						}, d.prototype.reconnectionDelay = function(a) {
							return arguments.length ? (this._reconnectionDelay = a, this.backoff && this.backoff.setMin(a), this) : this._reconnectionDelay
						}, d.prototype.randomizationFactor = function(a) {
							return arguments.length ? (this._randomizationFactor = a, this.backoff && this.backoff.setJitter(a), this) : this._randomizationFactor
						}, d.prototype.reconnectionDelayMax = function(a) {
							return arguments.length ? (this._reconnectionDelayMax = a, this.backoff && this.backoff.setMax(a), this) : this._reconnectionDelayMax
						}, d.prototype.timeout = function(a) {
							return arguments.length ? (this._timeout = a, this) : this._timeout
						}, d.prototype.maybeReconnectOnOpen = function() {
							!this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
						}, d.prototype.open = d.prototype.connect = function(a, b) {
							if (~this.readyState.indexOf("open")) return this;
							this.engine = f(this.uri, this.opts);
							var c = this.engine,
								d = this;
							this.readyState = "opening", this.skipReconnect = false;
							var e = j(c, "open", function() {
									d.onopen(), a && a()
								}),
								g = j(c, "error", function(b) {
									if (d.cleanup(), d.readyState = "closed", d.emitAll("connect_error", b), a) {
										var c = new Error("Connection error");
										c.data = b, a(c)
									} else d.maybeReconnectOnOpen()
								});
							if (false !== this._timeout) {
								var h = this._timeout,
									i = setTimeout(function() {
										e.destroy(), c.close(), c.emit("error", "timeout"), d.emitAll("connect_timeout", h)
									}, h);
								this.subs.push({
									destroy: function() {
										clearTimeout(i)
									}
								})
							}
							return this.subs.push(e), this.subs.push(g), this
						}, d.prototype.onopen = function() {
							this.cleanup(), this.readyState = "open", this.emit("open");
							var a = this.engine;
							this.subs.push(j(a, "data", k(this, "ondata"))), this.subs.push(j(a, "ping", k(this, "onping"))), this.subs.push(j(a, "pong", k(this, "onpong"))), this.subs.push(j(a, "error", k(this, "onerror"))), this.subs.push(j(a, "close", k(this, "onclose"))), this.subs.push(j(this.decoder, "decoded", k(this, "ondecoded")))
						}, d.prototype.onping = function() {
							this.lastPing = new Date, this.emitAll("ping")
						}, d.prototype.onpong = function() {
							this.emitAll("pong", new Date - this.lastPing)
						}, d.prototype.ondata = function(a) {
							this.decoder.add(a)
						}, d.prototype.ondecoded = function(a) {
							this.emit("packet", a)
						}, d.prototype.onerror = function(a) {
							this.emitAll("error", a)
						}, d.prototype.socket = function(a, b) {
							function c() {
								~l(e.connecting, d) || e.connecting.push(d)
							}
							var d = this.nsps[a];
							if (!d) {
								d = new g(this, a, b), this.nsps[a] = d;
								var e = this;
								d.on("connecting", c), d.on("connect", function() {
									d.id = e.generateId(a)
								}), this.autoConnect && c()
							}
							return d
						}, d.prototype.destroy = function(a) {
							var b = l(this.connecting, a);
							~b && this.connecting.splice(b, 1), this.connecting.length || this.close()
						}, d.prototype.packet = function(a) {
							var b = this;
							a.query && 0 === a.type && (a.nsp += "?" + a.query), b.encoding ? b.packetBuffer.push(a) : (b.encoding = true, this.encoder.encode(a, function(c) {
								for (var d = 0; d < c.length; d++) b.engine.write(c[d], a.options);
								b.encoding = false, b.processPacketQueue()
							}))
						}, d.prototype.processPacketQueue = function() {
							if (this.packetBuffer.length > 0 && !this.encoding) {
								var a = this.packetBuffer.shift();
								this.packet(a)
							}
						}, d.prototype.cleanup = function() {
							for (var a = this.subs.length, b = 0; b < a; b++) {
								var c = this.subs.shift();
								c.destroy()
							}
							this.packetBuffer = [], this.encoding = false, this.lastPing = null, this.decoder.destroy()
						}, d.prototype.close = d.prototype.disconnect = function() {
							this.skipReconnect = true, this.reconnecting = false, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close()
						}, d.prototype.onclose = function(a) {
							this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", a), this._reconnection && !this.skipReconnect && this.reconnect()
						}, d.prototype.reconnect = function() {
							if (this.reconnecting || this.skipReconnect) return this;
							var a = this;
							if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = false;
							else {
								var b = this.backoff.duration();
								this.reconnecting = true;
								var c = setTimeout(function() {
									a.skipReconnect || (a.emitAll("reconnect_attempt", a.backoff.attempts), a.emitAll("reconnecting", a.backoff.attempts), a.skipReconnect || a.open(function(b) {
										b ? (a.reconnecting = false, a.reconnect(), a.emitAll("reconnect_error", b.data)) : a.onreconnect()
									}))
								}, b);
								this.subs.push({
									destroy: function() {
										clearTimeout(c)
									}
								})
							}
						}, d.prototype.onreconnect = function() {
							var a = this.backoff.attempts;
							this.reconnecting = false, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", a)
						}
					}, function(a, b, c) {
						a.exports = c(12)
					}, function(a, b, c) {
						a.exports = c(13), a.exports.parser = c(20)
					}, function(a, b, c) {
						(function(b) {
							function d(a, c) {
								if (!(this instanceof d)) return new d(a, c);
								c = c || {}, a && "object" == typeof a && (c = a, a = null), a ? (a = j(a), c.hostname = a.host, c.secure = "https" === a.protocol || "wss" === a.protocol, c.port = a.port, a.query && (c.query = a.query)) : c.host && (c.hostname = j(c.host).host),
									this.secure = null != c.secure ? c.secure : b.location && "https:" === location.protocol, c.hostname && !c.port && (c.port = this.secure ? "443" : "80"), this.agent = c.agent || false, this.hostname = c.hostname || (b.location ? location.hostname : "localhost"), this.port = c.port || (b.location && location.port ? location.port : this.secure ? 443 : 80), this.query = c.query || {}, "string" == typeof this.query && (this.query = l.decode(this.query)), this.upgrade = false !== c.upgrade, this.path = (c.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!c.forceJSONP, this.jsonp = false !== c.jsonp, this.forceBase64 = !!c.forceBase64, this.enablesXDR = !!c.enablesXDR, this.timestampParam = c.timestampParam || "t", this.timestampRequests = c.timestampRequests, this.transports = c.transports || ["polling", "websocket"], this.transportOptions = c.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = c.policyPort || 843, this.rememberUpgrade = c.rememberUpgrade || false, this.binaryType = null, this.onlyBinaryUpgrades = c.onlyBinaryUpgrades, this.perMessageDeflate = false !== c.perMessageDeflate && (c.perMessageDeflate || {}), true === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = c.pfx || null, this.key = c.key || null, this.passphrase = c.passphrase || null, this.cert = c.cert || null, this.ca = c.ca || null, this.ciphers = c.ciphers || null, this.rejectUnauthorized = void 0 === c.rejectUnauthorized || c.rejectUnauthorized, this.forceNode = !!c.forceNode;
								var e = "object" == typeof b && b;
								e.global === e && (c.extraHeaders && Object.keys(c.extraHeaders).length > 0 && (this.extraHeaders = c.extraHeaders), c.localAddress && (this.localAddress = c.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open()
							}

							function e(a) {
								var b = {};
								for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
								return b
							}
							var f = c(14),
								g = c(5),
								h = (c(3)("engine.io-client:socket"), c(34)),
								i = c(20),
								j = c(2),
								k = c(35),
								l = c(28);
							a.exports = d, d.priorWebsocketSuccess = false, g(d.prototype), d.protocol = i.protocol, d.Socket = d, d.Transport = c(19), d.transports = c(14), d.parser = c(20), d.prototype.createTransport = function(a) {
								var b = e(this.query);
								b.EIO = i.protocol, b.transport = a;
								var c = this.transportOptions[a] || {};
								this.id && (b.sid = this.id);
								var d = new f[a]({
									query: b,
									socket: this,
									agent: c.agent || this.agent,
									hostname: c.hostname || this.hostname,
									port: c.port || this.port,
									secure: c.secure || this.secure,
									path: c.path || this.path,
									forceJSONP: c.forceJSONP || this.forceJSONP,
									jsonp: c.jsonp || this.jsonp,
									forceBase64: c.forceBase64 || this.forceBase64,
									enablesXDR: c.enablesXDR || this.enablesXDR,
									timestampRequests: c.timestampRequests || this.timestampRequests,
									timestampParam: c.timestampParam || this.timestampParam,
									policyPort: c.policyPort || this.policyPort,
									pfx: c.pfx || this.pfx,
									key: c.key || this.key,
									passphrase: c.passphrase || this.passphrase,
									cert: c.cert || this.cert,
									ca: c.ca || this.ca,
									ciphers: c.ciphers || this.ciphers,
									rejectUnauthorized: c.rejectUnauthorized || this.rejectUnauthorized,
									perMessageDeflate: c.perMessageDeflate || this.perMessageDeflate,
									extraHeaders: c.extraHeaders || this.extraHeaders,
									forceNode: c.forceNode || this.forceNode,
									localAddress: c.localAddress || this.localAddress,
									requestTimeout: c.requestTimeout || this.requestTimeout,
									protocols: c.protocols || void 0
								});
								return d
							}, d.prototype.open = function() {
								var a;
								if (this.rememberUpgrade && d.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) a = "websocket";
								else {
									if (0 === this.transports.length) {
										var b = this;
										return void setTimeout(function() {
											b.emit("error", "No transports available")
										}, 0)
									}
									a = this.transports[0]
								}
								this.readyState = "opening";
								try {
									a = this.createTransport(a)
								} catch (a) {
									return this.transports.shift(), void this.open()
								}
								a.open(), this.setTransport(a)
							}, d.prototype.setTransport = function(a) {
								var b = this;
								this.transport && this.transport.removeAllListeners(), this.transport = a, a.on("drain", function() {
									b.onDrain()
								}).on("packet", function(a) {
									b.onPacket(a)
								}).on("error", function(a) {
									b.onError(a)
								}).on("close", function() {
									b.onClose("transport close")
								})
							}, d.prototype.probe = function(a) {
								function b() {
									if (l.onlyBinaryUpgrades) {
										var a = !this.supportsBinary && l.transport.supportsBinary;
										k = k || a
									}
									k || (j.send([{
										type: "ping",
										data: "probe"
									}]), j.once("packet", function(a) {
										if (!k)
											if ("pong" === a.type && "probe" === a.data) {
												if (l.upgrading = true, l.emit("upgrading", j), !j) return;
												d.priorWebsocketSuccess = "websocket" === j.name, l.transport.pause(function() {
													k || "closed" !== l.readyState && (i(), l.setTransport(j), j.send([{
														type: "upgrade"
													}]), l.emit("upgrade", j), j = null, l.upgrading = false, l.flush())
												})
											} else {
												var b = new Error("probe error");
												b.transport = j.name, l.emit("upgradeError", b)
											}
									}))
								}

								function c() {
									k || (k = true, i(), j.close(), j = null)
								}

								function e(a) {
									var b = new Error("probe error: " + a);
									b.transport = j.name, c(), l.emit("upgradeError", b)
								}

								function f() {
									e("transport closed")
								}

								function g() {
									e("socket closed")
								}

								function h(a) {
									j && a.name !== j.name && c()
								}

								function i() {
									j.removeListener("open", b), j.removeListener("error", e), j.removeListener("close", f), l.removeListener("close", g), l.removeListener("upgrading", h)
								}
								var j = this.createTransport(a, {
										probe: 1
									}),
									k = false,
									l = this;
								d.priorWebsocketSuccess = false, j.once("open", b), j.once("error", e), j.once("close", f), this.once("close", g), this.once("upgrading", h), j.open()
							}, d.prototype.onOpen = function() {
								if (this.readyState = "open", d.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause)
									for (var a = 0, b = this.upgrades.length; a < b; a++) this.probe(this.upgrades[a])
							}, d.prototype.onPacket = function(a) {
								if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (this.emit("packet", a), this.emit("heartbeat"), a.type) {
									case "open":
										this.onHandshake(k(a.data));
										break;
									case "pong":
										this.setPing(), this.emit("pong");
										break;
									case "error":
										var b = new Error("server error");
										b.code = a.data, this.onError(b);
										break;
									case "message":
										this.emit("data", a.data), this.emit("message", a.data)
								}
							}, d.prototype.onHandshake = function(a) {
								this.emit("handshake", a), this.id = a.sid, this.transport.query.sid = a.sid, this.upgrades = this.filterUpgrades(a.upgrades), this.pingInterval = a.pingInterval, this.pingTimeout = a.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat))
							}, d.prototype.onHeartbeat = function(a) {
								clearTimeout(this.pingTimeoutTimer);
								var b = this;
								b.pingTimeoutTimer = setTimeout(function() {
									"closed" !== b.readyState && b.onClose("ping timeout")
								}, a || b.pingInterval + b.pingTimeout)
							}, d.prototype.setPing = function() {
								var a = this;
								clearTimeout(a.pingIntervalTimer), a.pingIntervalTimer = setTimeout(function() {
									a.ping(), a.onHeartbeat(a.pingTimeout)
								}, a.pingInterval)
							}, d.prototype.ping = function() {
								var a = this;
								this.sendPacket("ping", function() {
									a.emit("ping")
								})
							}, d.prototype.onDrain = function() {
								this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush()
							}, d.prototype.flush = function() {
								"closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"))
							}, d.prototype.write = d.prototype.send = function(a, b, c) {
								return this.sendPacket("message", a, b, c), this
							}, d.prototype.sendPacket = function(a, b, c, d) {
								if ("function" == typeof b && (d = b, b = void 0), "function" == typeof c && (d = c, c = null), "closing" !== this.readyState && "closed" !== this.readyState) {
									c = c || {}, c.compress = false !== c.compress;
									var e = {
										type: a,
										data: b,
										options: c
									};
									this.emit("packetCreate", e), this.writeBuffer.push(e), d && this.once("flush", d), this.flush()
								}
							}, d.prototype.close = function() {
								function a() {
									d.onClose("forced close"), d.transport.close()
								}

								function b() {
									d.removeListener("upgrade", b), d.removeListener("upgradeError", b), a()
								}

								function c() {
									d.once("upgrade", b), d.once("upgradeError", b)
								}
								if ("opening" === this.readyState || "open" === this.readyState) {
									this.readyState = "closing";
									var d = this;
									this.writeBuffer.length ? this.once("drain", function() {
										this.upgrading ? c() : a()
									}) : this.upgrading ? c() : a()
								}
								return this
							}, d.prototype.onError = function(a) {
								d.priorWebsocketSuccess = false, this.emit("error", a), this.onClose("transport error", a)
							}, d.prototype.onClose = function(a, b) {
								if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
									var c = this;
									clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", a, b), c.writeBuffer = [], c.prevBufferLen = 0
								}
							}, d.prototype.filterUpgrades = function(a) {
								for (var b = [], c = 0, d = a.length; c < d; c++) ~h(this.transports, a[c]) && b.push(a[c]);
								return b
							}
						}).call(b, function() {
							return this
						}())
					}, function(a, b, c) {
						(function(a) {
							function d(b) {
								var c, d = false,
									h = false,
									i = false !== b.jsonp;
								if (a.location) {
									var j = "https:" === location.protocol,
										k = location.port;
									k || (k = j ? 443 : 80), d = b.hostname !== location.hostname || k !== b.port, h = b.secure !== j
								}
								if (b.xdomain = d, b.xscheme = h, c = new e(b), "open" in c && !b.forceJSONP) return new f(b);
								if (!i) throw new Error("JSONP disabled");
								return new g(b)
							}
							var e = c(15),
								f = c(17),
								g = c(31),
								h = c(32);
							b.polling = d, b.websocket = h
						}).call(b, function() {
							return this
						}())
					}, function(a, b, c) {
						(function(b) {
							var d = c(16);
							a.exports = function(a) {
								var c = a.xdomain,
									e = a.xscheme,
									f = a.enablesXDR;
								try {
									if ("undefined" != typeof XMLHttpRequest && (!c || d)) return new XMLHttpRequest
								} catch (a) {}
								try {
									if ("undefined" != typeof XDomainRequest && !e && f) return new XDomainRequest
								} catch (a) {}
								if (!c) try {
									return new(b[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
								} catch (a) {}
							}
						}).call(b, function() {
							return this
						}())
					}, function(a, b) {
						try {
							a.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest
						} catch (b) {
							a.exports = false
						}
					}, function(a, b, c) {
						(function(b) {
							function d() {}

							function e(a) {
								if (i.call(this, a), this.requestTimeout = a.requestTimeout, this.extraHeaders = a.extraHeaders, b.location) {
									var c = "https:" === location.protocol,
										d = location.port;
									d || (d = c ? 443 : 80), this.xd = a.hostname !== b.location.hostname || d !== a.port, this.xs = a.secure !== c
								}
							}

							function f(a) {
								this.method = a.method || "GET", this.uri = a.uri, this.xd = !!a.xd, this.xs = !!a.xs, this.async = false !== a.async, this.data = void 0 !== a.data ? a.data : null, this.agent = a.agent, this.isBinary = a.isBinary, this.supportsBinary = a.supportsBinary, this.enablesXDR = a.enablesXDR, this.requestTimeout = a.requestTimeout, this.pfx = a.pfx, this.key = a.key, this.passphrase = a.passphrase, this.cert = a.cert, this.ca = a.ca, this.ciphers = a.ciphers, this.rejectUnauthorized = a.rejectUnauthorized, this.extraHeaders = a.extraHeaders, this.create()
							}

							function g() {
								for (var a in f.requests) f.requests.hasOwnProperty(a) && f.requests[a].abort()
							}
							var h = c(15),
								i = c(18),
								j = c(5),
								k = c(29);
							c(3)("engine.io-client:polling-xhr"), a.exports = e, a.exports.Request = f, k(e, i), e.prototype.supportsBinary = true, e.prototype.request = function(a) {
								return a = a || {}, a.uri = this.uri(), a.xd = this.xd, a.xs = this.xs, a.agent = this.agent || false, a.supportsBinary = this.supportsBinary, a.enablesXDR = this.enablesXDR, a.pfx = this.pfx, a.key = this.key, a.passphrase = this.passphrase, a.cert = this.cert, a.ca = this.ca, a.ciphers = this.ciphers, a.rejectUnauthorized = this.rejectUnauthorized, a.requestTimeout = this.requestTimeout, a.extraHeaders = this.extraHeaders, new f(a)
							}, e.prototype.doWrite = function(a, b) {
								var c = "string" != typeof a && void 0 !== a,
									d = this.request({
										method: "POST",
										data: a,
										isBinary: c
									}),
									e = this;
								d.on("success", b), d.on("error", function(a) {
									e.onError("xhr post error", a)
								}), this.sendXhr = d
							}, e.prototype.doPoll = function() {
								var a = this.request(),
									b = this;
								a.on("data", function(a) {
									b.onData(a)
								}), a.on("error", function(a) {
									b.onError("xhr poll error", a)
								}), this.pollXhr = a
							}, j(f.prototype), f.prototype.create = function() {
								var a = {
									agent: this.agent,
									xdomain: this.xd,
									xscheme: this.xs,
									enablesXDR: this.enablesXDR
								};
								a.pfx = this.pfx, a.key = this.key, a.passphrase = this.passphrase, a.cert = this.cert, a.ca = this.ca, a.ciphers = this.ciphers, a.rejectUnauthorized = this.rejectUnauthorized;
								var c = this.xhr = new h(a),
									d = this;
								try {
									c.open(this.method, this.uri, this.async);
									try {
										if (this.extraHeaders) {
											c.setDisableHeaderCheck && c.setDisableHeaderCheck(true);
											for (var e in this.extraHeaders) this.extraHeaders.hasOwnProperty(e) && c.setRequestHeader(e, this.extraHeaders[e])
										}
									} catch (a) {}
									if ("POST" === this.method) try {
										this.isBinary ? c.setRequestHeader("Content-type", "application/octet-stream") : c.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
									} catch (a) {}
									try {
										c.setRequestHeader("Accept", "*/*")
									} catch (a) {}
									"withCredentials" in c && (c.withCredentials = true), this.requestTimeout && (c.timeout = this.requestTimeout), this.hasXDR() ? (c.onload = function() {
										d.onLoad()
									}, c.onerror = function() {
										d.onError(c.responseText)
									}) : c.onreadystatechange = function() {
										if (2 === c.readyState) {
											var a;
											try {
												a = c.getResponseHeader("Content-Type")
											} catch (a) {}
											"application/octet-stream" === a && (c.responseType = "arraybuffer")
										}
										4 === c.readyState && (200 === c.status || 1223 === c.status ? d.onLoad() : setTimeout(function() {
											d.onError(c.status)
										}, 0))
									}, c.send(this.data)
								} catch (a) {
									return void setTimeout(function() {
										d.onError(a)
									}, 0)
								}
								b.document && (this.index = f.requestsCount++, f.requests[this.index] = this)
							}, f.prototype.onSuccess = function() {
								this.emit("success"), this.cleanup()
							}, f.prototype.onData = function(a) {
								this.emit("data", a), this.onSuccess()
							}, f.prototype.onError = function(a) {
								this.emit("error", a), this.cleanup(true)
							}, f.prototype.cleanup = function(a) {
								if ("undefined" != typeof this.xhr && null !== this.xhr) {
									if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = d : this.xhr.onreadystatechange = d, a) try {
										this.xhr.abort()
									} catch (a) {}
									b.document && delete f.requests[this.index], this.xhr = null
								}
							}, f.prototype.onLoad = function() {
								var a;
								try {
									var b;
									try {
										b = this.xhr.getResponseHeader("Content-Type")
									} catch (a) {}
									a = "application/octet-stream" === b ? this.xhr.response || this.xhr.responseText : this.xhr.responseText
								} catch (a) {
									this.onError(a)
								}
								null != a && this.onData(a)
							}, f.prototype.hasXDR = function() {
								return "undefined" != typeof b.XDomainRequest && !this.xs && this.enablesXDR
							}, f.prototype.abort = function() {
								this.cleanup()
							}, f.requestsCount = 0, f.requests = {}, b.document && (b.attachEvent ? b.attachEvent("onunload", g) : b.addEventListener && b.addEventListener("beforeunload", g, false))
						}).call(b, function() {
							return this
						}())
					}, function(a, b, c) {
						function d(a) {
							var b = a && a.forceBase64;
							j && !b || (this.supportsBinary = false), e.call(this, a)
						}
						var e = c(19),
							f = c(28),
							g = c(20),
							h = c(29),
							i = c(30);
						c(3)("engine.io-client:polling"), a.exports = d;
						var j = function() {
							var a = c(15),
								b = new a({
									xdomain: false
								});
							return null != b.responseType
						}();
						h(d, e), d.prototype.name = "polling", d.prototype.doOpen = function() {
							this.poll()
						}, d.prototype.pause = function(a) {
							function b() {
								c.readyState = "paused", a()
							}
							var c = this;
							if (this.readyState = "pausing", this.polling || !this.writable) {
								var d = 0;
								this.polling && (d++, this.once("pollComplete", function() {
									--d || b()
								})), this.writable || (d++, this.once("drain", function() {
									--d || b()
								}))
							} else b()
						}, d.prototype.poll = function() {
							this.polling = true, this.doPoll(), this.emit("poll")
						}, d.prototype.onData = function(a) {
							var b = this,
								c = function(a, c, d) {
									return "opening" === b.readyState && b.onOpen(), "close" === a.type ? (b.onClose(), false) : void b.onPacket(a)
								};
							g.decodePayload(a, this.socket.binaryType, c), "closed" !== this.readyState && (this.polling = false, this.emit("pollComplete"), "open" === this.readyState && this.poll())
						}, d.prototype.doClose = function() {
							function a() {
								b.write([{
									type: "close"
								}])
							}
							var b = this;
							"open" === this.readyState ? a() : this.once("open", a)
						}, d.prototype.write = function(a) {
							var b = this;
							this.writable = false;
							var c = function() {
								b.writable = true, b.emit("drain")
							};
							g.encodePayload(a, this.supportsBinary, function(a) {
								b.doWrite(a, c)
							})
						}, d.prototype.uri = function() {
							var a = this.query || {},
								b = this.secure ? "https" : "http",
								c = "";
							false !== this.timestampRequests && (a[this.timestampParam] = i()), this.supportsBinary || a.sid || (a.b64 = 1), a = f.encode(a), this.port && ("https" === b && 443 !== Number(this.port) || "http" === b && 80 !== Number(this.port)) && (c = ":" + this.port), a.length && (a = "?" + a);
							var d = this.hostname.indexOf(":") !== -1;
							return b + "://" + (d ? "[" + this.hostname + "]" : this.hostname) + c + this.path + a
						}
					}, function(a, b, c) {
						function d(a) {
							this.path = a.path, this.hostname = a.hostname, this.port = a.port, this.secure = a.secure, this.query = a.query, this.timestampParam = a.timestampParam, this.timestampRequests = a.timestampRequests, this.readyState = "", this.agent = a.agent || false, this.socket = a.socket, this.enablesXDR = a.enablesXDR, this.pfx = a.pfx, this.key = a.key, this.passphrase = a.passphrase, this.cert = a.cert, this.ca = a.ca, this.ciphers = a.ciphers, this.rejectUnauthorized = a.rejectUnauthorized, this.forceNode = a.forceNode, this.extraHeaders = a.extraHeaders, this.localAddress = a.localAddress
						}
						var e = c(20),
							f = c(5);
						a.exports = d, f(d.prototype), d.prototype.onError = function(a, b) {
							var c = new Error(a);
							return c.type = "TransportError", c.description = b, this.emit("error", c), this
						}, d.prototype.open = function() {
							return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this
						}, d.prototype.close = function() {
							return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this
						}, d.prototype.send = function(a) {
							if ("open" !== this.readyState) throw new Error("Transport not open");
							this.write(a)
						}, d.prototype.onOpen = function() {
							this.readyState = "open", this.writable = true, this.emit("open")
						}, d.prototype.onData = function(a) {
							var b = e.decodePacket(a, this.socket.binaryType);
							this.onPacket(b)
						}, d.prototype.onPacket = function(a) {
							this.emit("packet", a)
						}, d.prototype.onClose = function() {
							this.readyState = "closed", this.emit("close")
						}
					}, function(a, b, c) {
						(function(a) {
							function d(a, c) {
								var d = "b" + b.packets[a.type] + a.data.data;
								return c(d)
							}

							function e(a, c, d) {
								if (!c) return b.encodeBase64Packet(a, d);
								var e = a.data,
									f = new Uint8Array(e),
									g = new Uint8Array(1 + e.byteLength);
								g[0] = s[a.type];
								for (var h = 0; h < f.length; h++) g[h + 1] = f[h];
								return d(g.buffer)
							}

							function f(a, c, d) {
								if (!c) return b.encodeBase64Packet(a, d);
								var e = new FileReader;
								return e.onload = function() {
									a.data = e.result, b.encodePacket(a, c, true, d)
								}, e.readAsArrayBuffer(a.data)
							}

							function g(a, c, d) {
								if (!c) return b.encodeBase64Packet(a, d);
								if (r) return f(a, c, d);
								var e = new Uint8Array(1);
								e[0] = s[a.type];
								var g = new v([e.buffer, a.data]);
								return d(g)
							}

							function h(a) {
								try {
									a = o.decode(a, {
										strict: false
									})
								} catch (a) {
									return false
								}
								return a
							}

							function i(a, b, c) {
								for (var d = new Array(a.length), e = n(a.length, c), f = function(a, c, e) {
										b(c, function(b, c) {
											d[a] = c, e(b, d)
										})
									}, g = 0; g < a.length; g++) f(g, a[g], e)
							}
							var j, k = c(21),
								l = c(6),
								m = c(22),
								n = c(23),
								o = c(24);
							a && a.ArrayBuffer && (j = c(26));
							var p = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
								q = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent),
								r = p || q;
							b.protocol = 3;
							var s = b.packets = {
									open: 0,
									close: 1,
									ping: 2,
									pong: 3,
									message: 4,
									upgrade: 5,
									noop: 6
								},
								t = k(s),
								u = {
									type: "error",
									data: "parser error"
								},
								v = c(27);
							b.encodePacket = function(b, c, f, h) {
								"function" == typeof c && (h = c, c = false), "function" == typeof f && (h = f, f = null);
								var i = void 0 === b.data ? void 0 : b.data.buffer || b.data;
								if (a.ArrayBuffer && i instanceof ArrayBuffer) return e(b, c, h);
								if (v && i instanceof a.Blob) return g(b, c, h);
								if (i && i.base64) return d(b, h);
								var j = s[b.type];
								return void 0 !== b.data && (j += f ? o.encode(String(b.data), {
									strict: false
								}) : String(b.data)), h("" + j)
							}, b.encodeBase64Packet = function(c, d) {
								var e = "b" + b.packets[c.type];
								if (v && c.data instanceof a.Blob) {
									var f = new FileReader;
									return f.onload = function() {
										var a = f.result.split(",")[1];
										d(e + a)
									}, f.readAsDataURL(c.data)
								}
								var g;
								try {
									g = String.fromCharCode.apply(null, new Uint8Array(c.data))
								} catch (a) {
									for (var h = new Uint8Array(c.data), i = new Array(h.length), j = 0; j < h.length; j++) i[j] = h[j];
									g = String.fromCharCode.apply(null, i)
								}
								return e += a.btoa(g), d(e)
							}, b.decodePacket = function(a, c, d) {
								if (void 0 === a) return u;
								if ("string" == typeof a) {
									if ("b" === a.charAt(0)) return b.decodeBase64Packet(a.substr(1), c);
									if (d && (a = h(a), a === false)) return u;
									var e = a.charAt(0);
									return Number(e) == e && t[e] ? a.length > 1 ? {
										type: t[e],
										data: a.substring(1)
									} : {
										type: t[e]
									} : u
								}
								var f = new Uint8Array(a),
									e = f[0],
									g = m(a, 1);
								return v && "blob" === c && (g = new v([g])), {
									type: t[e],
									data: g
								}
							}, b.decodeBase64Packet = function(a, b) {
								var c = t[a.charAt(0)];
								if (!j) return {
									type: c,
									data: {
										base64: true,
										data: a.substr(1)
									}
								};
								var d = j.decode(a.substr(1));
								return "blob" === b && v && (d = new v([d])), {
									type: c,
									data: d
								}
							}, b.encodePayload = function(a, c, d) {
								function e(a) {
									return a.length + ":" + a
								}

								function f(a, d) {
									b.encodePacket(a, !!g && c, false, function(a) {
										d(null, e(a))
									})
								}
								"function" == typeof c && (d = c, c = null);
								var g = l(a);
								return c && g ? v && !r ? b.encodePayloadAsBlob(a, d) : b.encodePayloadAsArrayBuffer(a, d) : a.length ? void i(a, f, function(a, b) {
									return d(b.join(""))
								}) : d("0:")
							}, b.decodePayload = function(a, c, d) {
								if ("string" != typeof a) return b.decodePayloadAsBinary(a, c, d);
								"function" == typeof c && (d = c, c = null);
								var e;
								if ("" === a) return d(u, 0, 1);
								for (var f, g, h = "", i = 0, j = a.length; i < j; i++) {
									var k = a.charAt(i);
									if (":" === k) {
										if ("" === h || h != (f = Number(h))) return d(u, 0, 1);
										if (g = a.substr(i + 1, f), h != g.length) return d(u, 0, 1);
										if (g.length) {
											if (e = b.decodePacket(g, c, false), u.type === e.type && u.data === e.data) return d(u, 0, 1);
											var l = d(e, i + f, j);
											if (false === l) return
										}
										i += f, h = ""
									} else h += k
								}
								return "" !== h ? d(u, 0, 1) : void 0
							}, b.encodePayloadAsArrayBuffer = function(a, c) {
								function d(a, c) {
									b.encodePacket(a, true, true, function(a) {
										return c(null, a)
									})
								}
								return a.length ? void i(a, d, function(a, b) {
									var d = b.reduce(function(a, b) {
											var c;
											return c = "string" == typeof b ? b.length : b.byteLength, a + c.toString().length + c + 2
										}, 0),
										e = new Uint8Array(d),
										f = 0;
									return b.forEach(function(a) {
										var b = "string" == typeof a,
											c = a;
										if (b) {
											for (var d = new Uint8Array(a.length), g = 0; g < a.length; g++) d[g] = a.charCodeAt(g);
											c = d.buffer
										}
										b ? e[f++] = 0 : e[f++] = 1;
										for (var h = c.byteLength.toString(), g = 0; g < h.length; g++) e[f++] = parseInt(h[g]);
										e[f++] = 255;
										for (var d = new Uint8Array(c), g = 0; g < d.length; g++) e[f++] = d[g]
									}), c(e.buffer)
								}) : c(new ArrayBuffer(0))
							}, b.encodePayloadAsBlob = function(a, c) {
								function d(a, c) {
									b.encodePacket(a, true, true, function(a) {
										var b = new Uint8Array(1);
										if (b[0] = 1, "string" == typeof a) {
											for (var d = new Uint8Array(a.length), e = 0; e < a.length; e++) d[e] = a.charCodeAt(e);
											a = d.buffer, b[0] = 0
										}
										for (var f = a instanceof ArrayBuffer ? a.byteLength : a.size, g = f.toString(), h = new Uint8Array(g.length + 1), e = 0; e < g.length; e++) h[e] = parseInt(g[e]);
										if (h[g.length] = 255, v) {
											var i = new v([b.buffer, h.buffer, a]);
											c(null, i)
										}
									})
								}
								i(a, d, function(a, b) {
									return c(new v(b))
								})
							}, b.decodePayloadAsBinary = function(a, c, d) {
								"function" == typeof c && (d = c, c = null);
								for (var e = a, f = []; e.byteLength > 0;) {
									for (var g = new Uint8Array(e), h = 0 === g[0], i = "", j = 1; 255 !== g[j]; j++) {
										if (i.length > 310) return d(u, 0, 1);
										i += g[j]
									}
									e = m(e, 2 + i.length), i = parseInt(i);
									var k = m(e, 0, i);
									if (h) try {
										k = String.fromCharCode.apply(null, new Uint8Array(k))
									} catch (a) {
										var l = new Uint8Array(k);
										k = "";
										for (var j = 0; j < l.length; j++) k += String.fromCharCode(l[j])
									}
									f.push(k), e = m(e, i)
								}
								var n = f.length;
								f.forEach(function(a, e) {
									d(b.decodePacket(a, c, true), e, n)
								})
							}
						}).call(b, function() {
							return this
						}())
					}, function(a, b) {
						a.exports = Object.keys || function(a) {
							var b = [],
								c = Object.prototype.hasOwnProperty;
							for (var d in a) c.call(a, d) && b.push(d);
							return b
						}
					}, function(a, b) {
						a.exports = function(a, b, c) {
							var d = a.byteLength;
							if (b = b || 0, c = c || d, a.slice) return a.slice(b, c);
							if (b < 0 && (b += d), c < 0 && (c += d), c > d && (c = d), b >= d || b >= c || 0 === d) return new ArrayBuffer(0);
							for (var e = new Uint8Array(a), f = new Uint8Array(c - b), g = b, h = 0; g < c; g++, h++) f[h] = e[g];
							return f.buffer
						}
					}, function(a, b) {
						function c(a, b, c) {
							function e(a, d) {
								if (e.count <= 0) throw new Error("after called too many times");
								--e.count, a ? (f = true, b(a), b = c) : 0 !== e.count || f || b(null, d)
							}
							var f = false;
							return c = c || d, e.count = a, 0 === a ? b() : e
						}

						function d() {}
						a.exports = c
					}, function(a, b, c) {
						var d;
						(function(a, e) {
							! function(f) {
								function g(a) {
									for (var b, c, d = [], e = 0, f = a.length; e < f;) b = a.charCodeAt(e++), b >= 55296 && b <= 56319 && e < f ? (c = a.charCodeAt(e++), 56320 == (64512 & c) ? d.push(((1023 & b) << 10) + (1023 & c) + 65536) : (d.push(b), e--)) : d.push(b);
									return d
								}

								function h(a) {
									for (var b, c = a.length, d = -1, e = ""; ++d < c;) b = a[d], b > 65535 && (b -= 65536, e += u(b >>> 10 & 1023 | 55296), b = 56320 | 1023 & b), e += u(b);
									return e
								}

								function i(a, b) {
									if (a >= 55296 && a <= 57343) {
										if (b) throw Error("Lone surrogate U+" + a.toString(16).toUpperCase() + " is not a scalar value");
										return false
									}
									return true
								}

								function j(a, b) {
									return u(a >> b & 63 | 128)
								}

								function k(a, b) {
									if (0 == (4294967168 & a)) return u(a);
									var c = "";
									return 0 == (4294965248 & a) ? c = u(a >> 6 & 31 | 192) : 0 == (4294901760 & a) ? (i(a, b) || (a = 65533), c = u(a >> 12 & 15 | 224), c += j(a, 6)) : 0 == (4292870144 & a) && (c = u(a >> 18 & 7 | 240), c += j(a, 12), c += j(a, 6)), c += u(63 & a | 128)
								}

								function l(a, b) {
									b = b || {};
									for (var c, d = false !== b.strict, e = g(a), f = e.length, h = -1, i = ""; ++h < f;) c = e[h], i += k(c, d);
									return i
								}

								function m() {
									if (t >= s) throw Error("Invalid byte index");
									var a = 255 & r[t];
									if (t++, 128 == (192 & a)) return 63 & a;
									throw Error("Invalid continuation byte")
								}

								function n(a) {
									var b, c, d, e, f;
									if (t > s) throw Error("Invalid byte index");
									if (t == s) return false;
									if (b = 255 & r[t], t++, 0 == (128 & b)) return b;
									if (192 == (224 & b)) {
										if (c = m(), f = (31 & b) << 6 | c, f >= 128) return f;
										throw Error("Invalid continuation byte")
									}
									if (224 == (240 & b)) {
										if (c = m(), d = m(), f = (15 & b) << 12 | c << 6 | d, f >= 2048) return i(f, a) ? f : 65533;
										throw Error("Invalid continuation byte")
									}
									if (240 == (248 & b) && (c = m(), d = m(), e = m(), f = (7 & b) << 18 | c << 12 | d << 6 | e, f >= 65536 && f <= 1114111)) return f;
									throw Error("Invalid UTF-8 detected")
								}

								function o(a, b) {
									b = b || {};
									var c = false !== b.strict;
									r = g(a), s = r.length, t = 0;
									for (var d, e = [];
										(d = n(c)) !== false;) e.push(d);
									return h(e)
								}
								var p = "object" == typeof b && b,
									q = ("object" == typeof a && a && a.exports == p && a, "object" == typeof e && e);
								q.global !== q && q.window !== q || (f = q);
								var r, s, t, u = String.fromCharCode,
									v = {
										version: "2.1.2",
										encode: l,
										decode: o
									};
								d = function() {
									return v
								}.call(b, c, b, a), !(void 0 !== d && (a.exports = d))
							}(this)
						}).call(b, c(25)(a), function() {
							return this
						}())
					}, function(a, b) {
						a.exports = function(a) {
							return a.webpackPolyfill || (a.deprecate = function() {}, a.paths = [], a.children = [], a.webpackPolyfill = 1), a
						}
					}, function(a, b) {
						! function() {
							"use strict";
							for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = new Uint8Array(256), d = 0; d < a.length; d++) c[a.charCodeAt(d)] = d;
							b.encode = function(b) {
								var c, d = new Uint8Array(b),
									e = d.length,
									f = "";
								for (c = 0; c < e; c += 3) f += a[d[c] >> 2], f += a[(3 & d[c]) << 4 | d[c + 1] >> 4], f += a[(15 & d[c + 1]) << 2 | d[c + 2] >> 6], f += a[63 & d[c + 2]];
								return e % 3 === 2 ? f = f.substring(0, f.length - 1) + "=" : e % 3 === 1 && (f = f.substring(0, f.length - 2) + "=="), f
							}, b.decode = function(a) {
								var b, d, e, f, g, h = .75 * a.length,
									i = a.length,
									j = 0;
								"=" === a[a.length - 1] && (h--, "=" === a[a.length - 2] && h--);
								var k = new ArrayBuffer(h),
									l = new Uint8Array(k);
								for (b = 0; b < i; b += 4) d = c[a.charCodeAt(b)], e = c[a.charCodeAt(b + 1)], f = c[a.charCodeAt(b + 2)], g = c[a.charCodeAt(b + 3)], l[j++] = d << 2 | e >> 4, l[j++] = (15 & e) << 4 | f >> 2, l[j++] = (3 & f) << 6 | 63 & g;
								return k
							}
						}()
					}, function(a, b) {
						(function(b) {
							function c(a) {
								for (var b = 0; b < a.length; b++) {
									var c = a[b];
									if (c.buffer instanceof ArrayBuffer) {
										var d = c.buffer;
										if (c.byteLength !== d.byteLength) {
											var e = new Uint8Array(c.byteLength);
											e.set(new Uint8Array(d, c.byteOffset, c.byteLength)), d = e.buffer
										}
										a[b] = d
									}
								}
							}

							function d(a, b) {
								b = b || {};
								var d = new f;
								c(a);
								for (var e = 0; e < a.length; e++) d.append(a[e]);
								return b.type ? d.getBlob(b.type) : d.getBlob()
							}

							function e(a, b) {
								return c(a), new Blob(a, b || {})
							}
							var f = b.BlobBuilder || b.WebKitBlobBuilder || b.MSBlobBuilder || b.MozBlobBuilder,
								g = function() {
									try {
										var a = new Blob(["hi"]);
										return 2 === a.size
									} catch (a) {
										return false
									}
								}(),
								h = g && function() {
									try {
										var a = new Blob([new Uint8Array([1, 2])]);
										return 2 === a.size
									} catch (a) {
										return false
									}
								}(),
								i = f && f.prototype.append && f.prototype.getBlob;
							a.exports = function() {
								return g ? h ? b.Blob : e : i ? d : void 0
							}()
						}).call(b, function() {
							return this
						}())
					}, function(a, b) {
						b.encode = function(a) {
							var b = "";
							for (var c in a) a.hasOwnProperty(c) && (b.length && (b += "&"), b += encodeURIComponent(c) + "=" + encodeURIComponent(a[c]));
							return b
						}, b.decode = function(a) {
							for (var b = {}, c = a.split("&"), d = 0, e = c.length; d < e; d++) {
								var f = c[d].split("=");
								b[decodeURIComponent(f[0])] = decodeURIComponent(f[1])
							}
							return b
						}
					}, function(a, b) {
						a.exports = function(a, b) {
							var c = function() {};
							c.prototype = b.prototype, a.prototype = new c, a.prototype.constructor = a
						}
					}, function(a, b) {
						"use strict";

						function c(a) {
							var b = "";
							do b = g[a % h] + b, a = Math.floor(a / h); while (a > 0);
							return b
						}

						function d(a) {
							var b = 0;
							for (k = 0; k < a.length; k++) b = b * h + i[a.charAt(k)];
							return b
						}

						function e() {
							var a = c(+new Date);
							return a !== f ? (j = 0, f = a) : a + "." + c(j++)
						}
						for (var f, g = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), h = 64, i = {}, j = 0, k = 0; k < h; k++) i[g[k]] = k;
						e.encode = c, e.decode = d, a.exports = e
					}, function(a, b, c) {
						(function(b) {
							function d() {}

							function e(a) {
								f.call(this, a), this.query = this.query || {}, h || (b.___eio || (b.___eio = []), h = b.___eio), this.index = h.length;
								var c = this;
								h.push(function(a) {
									c.onData(a)
								}), this.query.j = this.index, b.document && b.addEventListener && b.addEventListener("beforeunload", function() {
									c.script && (c.script.onerror = d)
								}, false)
							}
							var f = c(18),
								g = c(29);
							a.exports = e;
							var h, i = /\n/g,
								j = /\\n/g;
							g(e, f), e.prototype.supportsBinary = false, e.prototype.doClose = function() {
								this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), f.prototype.doClose.call(this)
							}, e.prototype.doPoll = function() {
								var a = this,
									b = document.createElement("script");
								this.script && (this.script.parentNode.removeChild(this.script), this.script = null), b.async = true, b.src = this.uri(), b.onerror = function(b) {
									a.onError("jsonp poll error", b)
								};
								var c = document.getElementsByTagName("script")[0];
								c ? c.parentNode.insertBefore(b, c) : (document.head || document.body).appendChild(b), this.script = b;
								var d = "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent);
								d && setTimeout(function() {
									var a = document.createElement("iframe");
									document.body.appendChild(a), document.body.removeChild(a)
								}, 100)
							}, e.prototype.doWrite = function(a, b) {
								function c() {
									d(), b()
								}

								function d() {
									if (e.iframe) try {
										e.form.removeChild(e.iframe)
									} catch (a) {
										e.onError("jsonp polling iframe removal error", a)
									}
									try {
										var a = '<iframe src="javascript:0" name="' + e.iframeId + '">';
										f = document.createElement(a)
									} catch (a) {
										f = document.createElement("iframe"), f.name = e.iframeId, f.src = "javascript:0"
									}
									f.id = e.iframeId, e.form.appendChild(f), e.iframe = f
								}
								var e = this;
								if (!this.form) {
									var f, g = document.createElement("form"),
										h = document.createElement("textarea"),
										k = this.iframeId = "eio_iframe_" + this.index;
									g.className = "socketio", g.style.position = "absolute", g.style.top = "-1000px", g.style.left = "-1000px", g.target = k, g.method = "POST", g.setAttribute("accept-charset", "utf-8"), h.name = "d", g.appendChild(h), document.body.appendChild(g), this.form = g, this.area = h
								}
								this.form.action = this.uri(), d(), a = a.replace(j, "\\\n"), this.area.value = a.replace(i, "\\n");
								try {
									this.form.submit()
								} catch (a) {}
								this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
									"complete" === e.iframe.readyState && c()
								} : this.iframe.onload = c
							}
						}).call(b, function() {
							return this
						}())
					}, function(a, b, c) {
						(function(b) {
							function d(a) {
								var b = a && a.forceBase64;
								b && (this.supportsBinary = false), this.perMessageDeflate = a.perMessageDeflate, this.usingBrowserWebSocket = k && !a.forceNode, this.protocols = a.protocols, this.usingBrowserWebSocket || (l = e), f.call(this, a)
							}
							var e, f = c(19),
								g = c(20),
								h = c(28),
								i = c(29),
								j = c(30),
								k = (c(3)("engine.io-client:websocket"), b.WebSocket || b.MozWebSocket);
							if ("undefined" == typeof window) try {
								e = c(33)
							} catch (a) {}
							var l = k;
							l || "undefined" != typeof window || (l = e), a.exports = d, i(d, f), d.prototype.name = "websocket", d.prototype.supportsBinary = true, d.prototype.doOpen = function() {
								if (this.check()) {
									var a = this.uri(),
										b = this.protocols,
										c = {
											agent: this.agent,
											perMessageDeflate: this.perMessageDeflate
										};
									c.pfx = this.pfx, c.key = this.key, c.passphrase = this.passphrase, c.cert = this.cert, c.ca = this.ca, c.ciphers = this.ciphers, c.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (c.headers = this.extraHeaders), this.localAddress && (c.localAddress = this.localAddress);
									try {
										this.ws = this.usingBrowserWebSocket ? b ? new l(a, b) : new l(a) : new l(a, b, c)
									} catch (a) {
										return this.emit("error", a)
									}
									void 0 === this.ws.binaryType && (this.supportsBinary = false), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = true, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners()
								}
							}, d.prototype.addEventListeners = function() {
								var a = this;
								this.ws.onopen = function() {
									a.onOpen()
								}, this.ws.onclose = function() {
									a.onClose()
								}, this.ws.onmessage = function(b) {
									a.onData(b.data)
								}, this.ws.onerror = function(b) {
									a.onError("websocket error", b)
								}
							}, d.prototype.write = function(a) {
								function c() {
									d.emit("flush"), setTimeout(function() {
										d.writable = true, d.emit("drain")
									}, 0)
								}
								var d = this;
								this.writable = false;
								for (var e = a.length, f = 0, h = e; f < h; f++) ! function(a) {
									g.encodePacket(a, d.supportsBinary, function(f) {
										if (!d.usingBrowserWebSocket) {
											var g = {};
											if (a.options && (g.compress = a.options.compress), d.perMessageDeflate) {
												var h = "string" == typeof f ? b.Buffer.byteLength(f) : f.length;
												h < d.perMessageDeflate.threshold && (g.compress = false)
											}
										}
										try {
											d.usingBrowserWebSocket ? d.ws.send(f) : d.ws.send(f, g)
										} catch (a) {}--e || c()
									})
								}(a[f])
							}, d.prototype.onClose = function() {
								f.prototype.onClose.call(this)
							}, d.prototype.doClose = function() {
								"undefined" != typeof this.ws && this.ws.close()
							}, d.prototype.uri = function() {
								var a = this.query || {},
									b = this.secure ? "wss" : "ws",
									c = "";
								this.port && ("wss" === b && 443 !== Number(this.port) || "ws" === b && 80 !== Number(this.port)) && (c = ":" + this.port),
									this.timestampRequests && (a[this.timestampParam] = j()), this.supportsBinary || (a.b64 = 1), a = h.encode(a), a.length && (a = "?" + a);
								var d = this.hostname.indexOf(":") !== -1;
								return b + "://" + (d ? "[" + this.hostname + "]" : this.hostname) + c + this.path + a
							}, d.prototype.check = function() {
								return !(!l || "__initialize" in l && this.name === d.prototype.name)
							}
						}).call(b, function() {
							return this
						}())
					}, function(a, b) {}, function(a, b) {
						var c = [].indexOf;
						a.exports = function(a, b) {
							if (c) return a.indexOf(b);
							for (var d = 0; d < a.length; ++d)
								if (a[d] === b) return d;
							return -1
						}
					}, function(a, b) {
						(function(b) {
							var c = /^[\],:{}\s]*$/,
								d = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
								e = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
								f = /(?:^|:|,)(?:\s*\[)+/g,
								g = /^\s+/,
								h = /\s+$/;
							a.exports = function(a) {
								return "string" == typeof a && a ? (a = a.replace(g, "").replace(h, ""), b.JSON && JSON.parse ? JSON.parse(a) : c.test(a.replace(d, "@").replace(e, "]").replace(f, "")) ? new Function("return " + a)() : void 0) : null
							}
						}).call(b, function() {
							return this
						}())
					}, function(a, b, c) {
						"use strict";

						function d(a, b, c) {
							this.io = a, this.nsp = b, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = false, this.disconnected = true, c && c.query && (this.query = c.query), this.io.autoConnect && this.open()
						}
						var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
								return typeof a
							} : function(a) {
								return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
							},
							f = c(4),
							g = c(5),
							h = c(37),
							i = c(38),
							j = c(39),
							k = (c(3)("socket.io-client:socket"), c(28));
						a.exports = b = d;
						var l = {
								connect: 1,
								connect_error: 1,
								connect_timeout: 1,
								connecting: 1,
								disconnect: 1,
								error: 1,
								reconnect: 1,
								reconnect_attempt: 1,
								reconnect_failed: 1,
								reconnect_error: 1,
								reconnecting: 1,
								ping: 1,
								pong: 1
							},
							m = g.prototype.emit;
						g(d.prototype), d.prototype.subEvents = function() {
							if (!this.subs) {
								var a = this.io;
								this.subs = [i(a, "open", j(this, "onopen")), i(a, "packet", j(this, "onpacket")), i(a, "close", j(this, "onclose"))]
							}
						}, d.prototype.open = d.prototype.connect = function() {
							return this.connected ? this : (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting"), this)
						}, d.prototype.send = function() {
							var a = h(arguments);
							return a.unshift("message"), this.emit.apply(this, a), this
						}, d.prototype.emit = function(a) {
							if (l.hasOwnProperty(a)) return m.apply(this, arguments), this;
							var b = h(arguments),
								c = {
									type: f.EVENT,
									data: b
								};
							return c.options = {}, c.options.compress = !this.flags || false !== this.flags.compress, "function" == typeof b[b.length - 1] && (this.acks[this.ids] = b.pop(), c.id = this.ids++), this.connected ? this.packet(c) : this.sendBuffer.push(c), delete this.flags, this
						}, d.prototype.packet = function(a) {
							a.nsp = this.nsp, this.io.packet(a)
						}, d.prototype.onopen = function() {
							if ("/" !== this.nsp)
								if (this.query) {
									var a = "object" === e(this.query) ? k.encode(this.query) : this.query;
									this.packet({
										type: f.CONNECT,
										query: a
									})
								} else this.packet({
									type: f.CONNECT
								})
						}, d.prototype.onclose = function(a) {
							this.connected = false, this.disconnected = true, delete this.id, this.emit("disconnect", a)
						}, d.prototype.onpacket = function(a) {
							if (a.nsp === this.nsp) switch (a.type) {
								case f.CONNECT:
									this.onconnect();
									break;
								case f.EVENT:
									this.onevent(a);
									break;
								case f.BINARY_EVENT:
									this.onevent(a);
									break;
								case f.ACK:
									this.onack(a);
									break;
								case f.BINARY_ACK:
									this.onack(a);
									break;
								case f.DISCONNECT:
									this.ondisconnect();
									break;
								case f.ERROR:
									this.emit("error", a.data)
							}
						}, d.prototype.onevent = function(a) {
							var b = a.data || [];
							null != a.id && b.push(this.ack(a.id)), this.connected ? m.apply(this, b) : this.receiveBuffer.push(b)
						}, d.prototype.ack = function(a) {
							var b = this,
								c = false;
							return function() {
								if (!c) {
									c = true;
									var d = h(arguments);
									b.packet({
										type: f.ACK,
										id: a,
										data: d
									})
								}
							}
						}, d.prototype.onack = function(a) {
							var b = this.acks[a.id];
							"function" == typeof b && (b.apply(this, a.data), delete this.acks[a.id])
						}, d.prototype.onconnect = function() {
							this.connected = true, this.disconnected = false, this.emit("connect"), this.emitBuffered()
						}, d.prototype.emitBuffered = function() {
							var a;
							for (a = 0; a < this.receiveBuffer.length; a++) m.apply(this, this.receiveBuffer[a]);
							for (this.receiveBuffer = [], a = 0; a < this.sendBuffer.length; a++) this.packet(this.sendBuffer[a]);
							this.sendBuffer = []
						}, d.prototype.ondisconnect = function() {
							this.destroy(), this.onclose("io server disconnect")
						}, d.prototype.destroy = function() {
							if (this.subs) {
								for (var a = 0; a < this.subs.length; a++) this.subs[a].destroy();
								this.subs = null
							}
							this.io.destroy(this)
						}, d.prototype.close = d.prototype.disconnect = function() {
							return this.connected && this.packet({
								type: f.DISCONNECT
							}), this.destroy(), this.connected && this.onclose("io client disconnect"), this
						}, d.prototype.compress = function(a) {
							return this.flags = this.flags || {}, this.flags.compress = a, this
						}
					}, function(a, b) {
						function c(a, b) {
							var c = [];
							b = b || 0;
							for (var d = b || 0; d < a.length; d++) c[d - b] = a[d];
							return c
						}
						a.exports = c
					}, function(a, b) {
						"use strict";

						function c(a, b, c) {
							return a.on(b, c), {
								destroy: function() {
									a.removeListener(b, c)
								}
							}
						}
						a.exports = c
					}, function(a, b) {
						var c = [].slice;
						a.exports = function(a, b) {
							if ("string" == typeof b && (b = a[b]), "function" != typeof b) throw new Error("bind() requires a function");
							var d = c.call(arguments, 2);
							return function() {
								return b.apply(a, d.concat(c.call(arguments)))
							}
						}
					}, function(a, b) {
						function c(a) {
							a = a || {}, this.ms = a.min || 100, this.max = a.max || 1e4, this.factor = a.factor || 2, this.jitter = a.jitter > 0 && a.jitter <= 1 ? a.jitter : 0, this.attempts = 0
						}
						a.exports = c, c.prototype.duration = function() {
							var a = this.ms * Math.pow(this.factor, this.attempts++);
							if (this.jitter) {
								var b = Math.random(),
									c = Math.floor(b * this.jitter * a);
								a = 0 == (1 & Math.floor(10 * b)) ? a - c : a + c
							}
							return 0 | Math.min(a, this.max)
						}, c.prototype.reset = function() {
							this.attempts = 0
						}, c.prototype.setMin = function(a) {
							this.ms = a
						}, c.prototype.setMax = function(a) {
							this.max = a
						}, c.prototype.setJitter = function(a) {
							this.jitter = a
						}
					}])
				}),
				function() {
					var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = {}.hasOwnProperty,
						u = [].indexOf || function(a) {
							for (var b = 0, c = this.length; b < c; b++)
								if (b in this && this[b] === a) return b;
							return -1
						};
					f = {
						is_unordered: false,
						is_counting: false,
						is_exclusive: false,
						is_solitary: false,
						prevent_default: false,
						prevent_repeat: false
					}, r = "meta alt option ctrl shift cmd".split(" "), p = "ctrl", a = {
						debug: false
					};
					var v = function(a) {
						var b, c;
						for (b in a) t.call(a, b) && (c = a[b], false !== c && (this[b] = c));
						this.keys = this.keys || [], this.count = this.count || 0
					};
					v.prototype.allows_key_repeat = function() {
						return !this.prevent_repeat && "function" == typeof this.on_keydown
					}, v.prototype.reset = function() {
						return this.count = 0, this.keyup_fired = null
					};
					var w = function(a, b) {
						var c, d;
						"undefined" != typeof jQuery && null !== jQuery && a instanceof jQuery && (1 !== a.length && o("Warning: your jQuery selector should have exactly one object."), a = a[0]), this.should_force_event_defaults = this.should_suppress_event_defaults = false, this.sequence_delay = 800, this._registered_combos = [], this._keys_down = [], this._active_combos = [], this._sequence = [], this._sequence_timer = null, this._prevent_capture = false, this._defaults = b || {};
						for (c in f) t.call(f, c) && (d = f[c], this._defaults[c] = this._defaults[c] || d);
						this.element = a || document.body, c = function(a, b, c) {
							return a.addEventListener ? a.addEventListener(b, c) : a.attachEvent && a.attachEvent("on" + b, c), c
						};
						var e = this;
						this.keydown_event = c(this.element, "keydown", function(a) {
							return a = a || window.event, e._receive_input(a, true), e._bug_catcher(a)
						});
						var g = this;
						this.keyup_event = c(this.element, "keyup", function(a) {
							return a = a || window.event, g._receive_input(a, false)
						});
						var h = this;
						this.blur_event = c(window, "blur", function() {
							var a, b, c, d;
							for (d = h._keys_down, b = 0, c = d.length; b < c; b++) a = d[b], h._key_up(a, {});
							return h._keys_down = []
						})
					};
					w.prototype.destroy = function() {
						var a;
						return a = function(a, b, c) {
							return null != a.removeEventListener ? a.removeEventListener(b, c) : null != a.removeEvent ? a.removeEvent("on" + b, c) : void 0
						}, a(this.element, "keydown", this.keydown_event), a(this.element, "keyup", this.keyup_event), a(window, "blur", this.blur_event)
					}, w.prototype._bug_catcher = function(a) {
						var b, c;
						if ("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && "cmd" !== (b = d(null != (c = a.keyCode) ? c : a.key)) && "shift" !== b && "alt" !== b && "caps" !== b && "tab" !== b) return this._receive_input(a, false)
					}, w.prototype._cmd_bug_check = function(a) {
						return !("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && 0 > u.call(a, "cmd"))
					}, w.prototype._prevent_default = function(a, b) {
						if ((b || this.should_suppress_event_defaults) && !this.should_force_event_defaults && (a.preventDefault ? a.preventDefault() : a.returnValue = false, a.stopPropagation)) return a.stopPropagation()
					}, w.prototype._get_active_combos = function(a) {
						var b, c;
						return b = [], c = g(this._keys_down, function(b) {
							return b !== a
						}), c.push(a), this._match_combo_arrays(c, function(a) {
							return function(c) {
								if (a._cmd_bug_check(c.keys)) return b.push(c)
							}
						}(this)), this._fuzzy_match_combo_arrays(c, function(a) {
							return function(c) {
								if (!(0 <= u.call(b, c)) && !c.is_solitary && a._cmd_bug_check(c.keys)) return b.push(c)
							}
						}(this)), b
					}, w.prototype._get_potential_combos = function(a) {
						var b, c, d, e, f;
						for (c = [], f = this._registered_combos, d = 0, e = f.length; d < e; d++) b = f[d], b.is_sequence || 0 <= u.call(b.keys, a) && this._cmd_bug_check(b.keys) && c.push(b);
						return c
					}, w.prototype._add_to_active_combos = function(a) {
						var b, c, d, e, f, g, h, i, j, k, l;
						if (g = false, f = true, d = false, 0 <= u.call(this._active_combos, a)) return true;
						if (this._active_combos.length)
							for (e = h = 0, k = this._active_combos.length; 0 <= k ? h < k : h > k; e = 0 <= k ? ++h : --h)
								if ((b = this._active_combos[e]) && b.is_exclusive && a.is_exclusive) {
									if (b = b.keys, !g)
										for (i = 0, j = b.length; i < j; i++)
											if (c = b[i], g = true, 0 > u.call(a.keys, c)) {
												g = false;
												break
											}
									if (f && !g)
										for (l = a.keys, i = 0, j = l.length; i < j; i++)
											if (c = l[i], f = false, 0 > u.call(b, c)) {
												f = true;
												break
											}
									g && (d ? (b = this._active_combos.splice(e, 1)[0], null != b && b.reset()) : (b = this._active_combos.splice(e, 1, a)[0], null != b && b.reset(), d = true), f = false)
								}
						return f && this._active_combos.unshift(a), g || f
					}, w.prototype._remove_from_active_combos = function(a) {
						var b, c, d, e;
						for (c = d = 0, e = this._active_combos.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d)
							if (b = this._active_combos[c], b === a) {
								a = this._active_combos.splice(c, 1)[0], a.reset();
								break
							}
					}, w.prototype._get_possible_sequences = function() {
						var a, b, c, d, e, f, h, i, j, k, l, m;
						for (d = [], k = this._registered_combos, f = 0, j = k.length; f < j; f++)
							for (a = k[f], b = h = 1, l = this._sequence.length; 1 <= l ? h <= l : h >= l; b = 1 <= l ? ++h : --h)
								if (e = this._sequence.slice(-b), a.is_sequence) {
									if (0 > u.call(a.keys, "shift") && (e = g(e, function(a) {
											return "shift" !== a
										}), !e.length)) continue;
									for (b = i = 0, m = e.length; 0 <= m ? i < m : i > m; b = 0 <= m ? ++i : --i) {
										if (a.keys[b] !== e[b]) {
											c = false;
											break
										}
										c = true
									}
									c && d.push(a)
								}
						return d
					}, w.prototype._add_key_to_sequence = function(a, b) {
						var c, d, e, f;
						if (this._sequence.push(a), d = this._get_possible_sequences(), d.length) {
							for (e = 0, f = d.length; e < f; e++) c = d[e], this._prevent_default(b, c.prevent_default);
							this._sequence_timer && clearTimeout(this._sequence_timer), -1 < this.sequence_delay && (this._sequence_timer = setTimeout(function() {
								return this._sequence = []
							}, this.sequence_delay))
						} else this._sequence = []
					}, w.prototype._get_sequence = function(a) {
						var b, c, d, e, f, h, i, j, k, l, m, n;
						for (l = this._registered_combos, h = 0, k = l.length; h < k; h++)
							if (b = l[h], b.is_sequence) {
								for (c = i = 1, m = this._sequence.length; 1 <= m ? i <= m : i >= m; c = 1 <= m ? ++i : --i)
									if (f = g(this._sequence, function(a) {
											return 0 <= u.call(b.keys, "shift") || "shift" !== a
										}).slice(-c), b.keys.length === f.length)
										for (c = j = 0, n = f.length; 0 <= n ? j < n : j > n; c = 0 <= n ? ++j : --j)
											if (e = f[c], !(0 > u.call(b.keys, "shift") && "shift" === e || "shift" === a && 0 > u.call(b.keys, "shift"))) {
												if (b.keys[c] !== e) {
													d = false;
													break
												}
												d = true
											}
								if (d) return b.is_exclusive && (this._sequence = []), b
							}
						return false
					}, w.prototype._receive_input = function(a, b) {
						var c, e;
						if (this._prevent_capture) this._keys_down.length && (this._keys_down = []);
						else if (c = d(null != (e = a.keyCode) ? e : a.key), (b || this._keys_down.length || !("alt" === c || c === p)) && c) return b ? this._key_down(c, a) : this._key_up(c, a)
					}, w.prototype._fire = function(a, b, c, d) {
						if ("function" == typeof b["on_" + a] && this._prevent_default(c, true !== b["on_" + a].call(b.this, c, b.count, d)), "release" === a && (b.count = 0), "keyup" === a) return b.keyup_fired = true
					}, w.prototype._match_combo_arrays = function(a, d) {
						var e, f, g, h;
						for (h = this._registered_combos, f = 0, g = h.length; f < g; f++) e = h[f], (!e.is_unordered && c(a, e.keys) || e.is_unordered && b(a, e.keys)) && d(e)
					}, w.prototype._fuzzy_match_combo_arrays = function(a, b) {
						var c, d, e, f;
						for (f = this._registered_combos, d = 0, e = f.length; d < e; d++) c = f[d], (!c.is_unordered && j(c.keys, a) || c.is_unordered && i(c.keys, a)) && b(c)
					}, w.prototype._keys_remain = function(a) {
						var b, c, d, e;
						for (e = a.keys, c = 0, d = e.length; c < d; c++)
							if (a = e[c], 0 <= u.call(this._keys_down, a)) {
								b = true;
								break
							}
						return b
					}, w.prototype._key_down = function(a, b) {
						var c, d, f, g, h;
						(c = e(a, b)) && (a = c), this._add_key_to_sequence(a, b), (c = this._get_sequence(a)) && this._fire("keydown", c, b);
						for (f in q) c = q[f], b[c] && (f === a || 0 <= u.call(this._keys_down, f) || this._keys_down.push(f));
						for (f in q)
							if (c = q[f], f !== a && 0 <= u.call(this._keys_down, f) && !b[c] && !("cmd" === f && "cmd" !== p))
								for (c = d = 0, g = this._keys_down.length; 0 <= g ? d < g : d > g; c = 0 <= g ? ++d : --d) this._keys_down[c] === f && this._keys_down.splice(c, 1);
						for (d = this._get_active_combos(a), f = this._get_potential_combos(a), g = 0, h = d.length; g < h; g++) c = d[g], this._handle_combo_down(c, f, a, b);
						if (f.length)
							for (d = 0, g = f.length; d < g; d++) c = f[d], this._prevent_default(b, c.prevent_default);
						0 > u.call(this._keys_down, a) && this._keys_down.push(a)
					}, w.prototype._handle_combo_down = function(a, b, c, d) {
						var e, f, g, h, i;
						if (0 > u.call(a.keys, c)) return false;
						if (this._prevent_default(d, a && a.prevent_default), e = false, 0 <= u.call(this._keys_down, c) && (e = true, !a.allows_key_repeat())) return false;
						if (g = this._add_to_active_combos(a, c), c = a.keyup_fired = false, a.is_exclusive)
							for (h = 0, i = b.length; h < i; h++)
								if (f = b[h], f.is_exclusive && f.keys.length > a.keys.length) {
									c = true;
									break
								}
						return !c && (a.is_counting && "function" == typeof a.on_keydown && (a.count += 1), g) ? this._fire("keydown", a, d, e) : void 0
					}, w.prototype._key_up = function(a, b) {
						var c, d, f, g, h, i;
						if (c = a, (f = e(a, b)) && (a = f), f = n[c], b.shiftKey ? f && 0 <= u.call(this._keys_down, f) || (a = c) : c && 0 <= u.call(this._keys_down, c) || (a = f), (g = this._get_sequence(a)) && this._fire("keyup", g, b), 0 > u.call(this._keys_down, a)) return false;
						for (g = h = 0, i = this._keys_down.length; 0 <= i ? h < i : h > i; g = 0 <= i ? ++h : --h)
							if ((d = this._keys_down[g]) === a || d === f || d === c) {
								this._keys_down.splice(g, 1);
								break
							}
						for (d = this._active_combos.length, f = [], i = this._active_combos, g = 0, h = i.length; g < h; g++) c = i[g], 0 <= u.call(c.keys, a) && f.push(c);
						for (g = 0, h = f.length; g < h; g++) c = f[g], this._handle_combo_up(c, b, a);
						if (1 < d)
							for (h = this._active_combos, d = 0, g = h.length; d < g; d++) c = h[d], void 0 === c || 0 <= u.call(f, c) || this._keys_remain(c) || this._remove_from_active_combos(c)
					}, w.prototype._handle_combo_up = function(a, c, d) {
						var e, f;
						this._prevent_default(c, a && a.prevent_default), f = this._keys_remain(a), a.keyup_fired || (e = this._keys_down.slice(), e.push(d), a.is_solitary && !b(e, a.keys)) || (this._fire("keyup", a, c), a.is_counting && "function" == typeof a.on_keyup && "function" != typeof a.on_keydown && (a.count += 1)), f || (this._fire("release", a, c), this._remove_from_active_combos(a))
					}, w.prototype.simple_combo = function(a, b) {
						return this.register_combo({
							keys: a,
							on_keydown: b
						})
					}, w.prototype.counting_combo = function(a, b) {
						return this.register_combo({
							keys: a,
							is_counting: true,
							is_unordered: false,
							on_keydown: b
						})
					}, w.prototype.sequence_combo = function(a, b) {
						return this.register_combo({
							keys: a,
							on_keydown: b,
							is_sequence: true,
							is_exclusive: true
						})
					}, w.prototype.register_combo = function(a) {
						var b, c, d;
						"string" == typeof a.keys && (a.keys = a.keys.split(" ")), d = this._defaults;
						for (b in d) t.call(d, b) && (c = d[b], void 0 === a[b] && (a[b] = c));
						if (a = new v(a), s(a)) return this._registered_combos.push(a), a
					}, w.prototype.register_many = function(a) {
						var b, c, d, e;
						for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.register_combo(b));
						return e
					}, w.prototype.unregister_combo = function(a) {
						var d, e, f, g, h, i;
						if (!a) return false;
						var j = this;
						if (e = function(a) {
								var b, c, d, e;
								for (e = [], b = c = 0, d = j._registered_combos.length; 0 <= d ? c < d : c > d; b = 0 <= d ? ++c : --c) {
									if (a === j._registered_combos[b]) {
										j._registered_combos.splice(b, 1);
										break
									}
									e.push(void 0)
								}
								return e
							}, a instanceof v) return e(a);
						for ("string" == typeof a && (a = a.split(" ")), h = this._registered_combos, i = [], f = 0, g = h.length; f < g; f++) d = h[f], null != d && (d.is_unordered && b(a, d.keys) || !d.is_unordered && c(a, d.keys) ? i.push(e(d)) : i.push(void 0));
						return i
					}, w.prototype.unregister_many = function(a) {
						var b, c, d, e;
						for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.unregister_combo(b));
						return e
					}, w.prototype.get_registered_combos = function() {
						return this._registered_combos
					}, w.prototype.reset = function() {
						return this._registered_combos = []
					}, w.prototype.listen = function() {
						return this._prevent_capture = false
					}, w.prototype.stop_listening = function() {
						return this._prevent_capture = true
					}, w.prototype.get_meta_key = function() {
						return p
					}, a.Listener = w, d = function(a) {
						return m[a]
					}, g = function(a, b) {
						var c;
						if (a.filter) return a.filter(b);
						var d, e, f;
						for (f = [], d = 0, e = a.length; d < e; d++) c = a[d], b(c) && f.push(c);
						return f
					}, b = function(a, b) {
						var c, d, e;
						if (a.length !== b.length) return false;
						for (d = 0, e = a.length; d < e; d++)
							if (c = a[d], !(0 <= u.call(b, c))) return false;
						return true
					}, c = function(a, b) {
						var c, d, e;
						if (a.length !== b.length) return false;
						for (c = d = 0, e = a.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d)
							if (a[c] !== b[c]) return false;
						return true
					}, i = function(a, b) {
						var c, d, e;
						for (d = 0, e = a.length; d < e; d++)
							if (c = a[d], 0 > u.call(b, c)) return false;
						return true
					}, h = Array.prototype.indexOf || function(a, b) {
						var c, d, e;
						for (c = d = 0, e = a.length; 0 <= e ? d <= e : d >= e; c = 0 <= e ? ++d : --d)
							if (a[c] === b) return c;
						return -1
					}, j = function(a, b) {
						var c, d, e, f;
						for (e = d = 0, f = a.length; e < f; e++) {
							if (c = a[e], c = h.call(b, c), !(c >= d)) return false;
							d = c
						}
						return true
					}, o = function() {
						if (a.debug) return console.log.apply(console, arguments)
					}, k = function(a) {
						var b, c, d;
						b = false;
						for (d in m)
							if (c = m[d], a === c) {
								b = true;
								break
							}
						if (!b)
							for (d in n)
								if (c = n[d], a === c) {
									b = true;
									break
								}
						return b
					}, s = function(a) {
						var b, c, d, e, g, i, j;
						for (g = true, a.keys.length || o("You're trying to bind a combo with no keys:", a), c = i = 0, j = a.keys.length; 0 <= j ? i < j : i > j; c = 0 <= j ? ++i : --i) d = a.keys[c], (b = l[d]) && (d = a.keys[c] = b), "meta" === d && a.keys.splice(c, 1, p), "cmd" === d && o('Warning: use the "meta" key rather than "cmd" for Windows compatibility');
						for (j = a.keys, b = 0, i = j.length; b < i; b++) d = j[b], k(d) || (o('Do not recognize the key "' + d + '"'), g = false);
						if (0 <= u.call(a.keys, "meta") || 0 <= u.call(a.keys, "cmd")) {
							for (b = a.keys.slice(), i = 0, j = r.length; i < j; i++) d = r[i], -1 < (c = h.call(b, d)) && b.splice(c, 1);
							1 < b.length && (o("META and CMD key combos cannot have more than 1 non-modifier keys", a, b), g = false)
						}
						for (e in a) "undefined" === f[e] && o("The property " + e + " is not a valid combo property. Your combo has still been registered.");
						return g
					}, e = function(a, b) {
						var c;
						return !!b.shiftKey && (c = n[a], null != c && c)
					}, q = {
						cmd: "metaKey",
						ctrl: "ctrlKey",
						shift: "shiftKey",
						alt: "altKey"
					}, l = {
						escape: "esc",
						control: "ctrl",
						command: "cmd",
						break: "pause",
						windows: "cmd",
						option: "alt",
						caps_lock: "caps",
						apostrophe: "'",
						semicolon: ";",
						tilde: "~",
						accent: "`",
						scroll_lock: "scroll",
						num_lock: "num"
					}, n = {
						"/": "?",
						".": ">",
						",": "<",
						"'": '"',
						";": ":",
						"[": "{",
						"]": "}",
						"\\": "|",
						"`": "~",
						"=": "+",
						"-": "_",
						1: "!",
						2: "@",
						3: "#",
						4: "$",
						5: "%",
						6: "^",
						7: "&",
						8: "*",
						9: "(",
						0: ")"
					}, m = {
						0: "\\",
						8: "backspace",
						9: "tab",
						12: "num",
						13: "enter",
						16: "shift",
						17: "ctrl",
						18: "alt",
						19: "pause",
						20: "caps",
						27: "esc",
						32: "space",
						33: "pageup",
						34: "pagedown",
						35: "end",
						36: "home",
						37: "left",
						38: "up",
						39: "right",
						40: "down",
						44: "print",
						45: "insert",
						46: "delete",
						48: "0",
						49: "1",
						50: "2",
						51: "3",
						52: "4",
						53: "5",
						54: "6",
						55: "7",
						56: "8",
						57: "9",
						65: "a",
						66: "b",
						67: "c",
						68: "d",
						69: "e",
						70: "f",
						71: "g",
						72: "h",
						73: "i",
						74: "j",
						75: "k",
						76: "l",
						77: "m",
						78: "n",
						79: "o",
						80: "p",
						81: "q",
						82: "r",
						83: "s",
						84: "t",
						85: "u",
						86: "v",
						87: "w",
						88: "x",
						89: "y",
						90: "z",
						91: "cmd",
						92: "cmd",
						93: "cmd",
						96: "num_0",
						97: "num_1",
						98: "num_2",
						99: "num_3",
						100: "num_4",
						101: "num_5",
						102: "num_6",
						103: "num_7",
						104: "num_8",
						105: "num_9",
						106: "num_multiply",
						107: "num_add",
						108: "num_enter",
						109: "num_subtract",
						110: "num_decimal",
						111: "num_divide",
						112: "f1",
						113: "f2",
						114: "f3",
						115: "f4",
						116: "f5",
						117: "f6",
						118: "f7",
						119: "f8",
						120: "f9",
						121: "f10",
						122: "f11",
						123: "f12",
						124: "print",
						144: "num",
						145: "scroll",
						186: ";",
						187: "=",
						188: ",",
						189: "-",
						190: ".",
						191: "/",
						192: "`",
						219: "[",
						220: "\\",
						221: "]",
						222: "'",
						223: "`",
						224: "cmd",
						225: "alt",
						57392: "ctrl",
						63289: "num",
						59: ";",
						61: "=",
						173: "-"
					}, a._keycode_dictionary = m, a._is_array_in_array_sorted = j, -1 !== navigator.userAgent.indexOf("Mac OS X") && (p = "cmd"), -1 !== navigator.userAgent.indexOf("Opera") && (m[17] = "cmd"), "function" == typeof define && define.amd ? define([], function() {
						return a
					}) : "undefined" != typeof exports && null !== exports ? exports.keypress = a : window.keypress = a
				}.call(this), THREE.OBJLoader = function(a) {
					this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.materials = null, this.regexp = {
						vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
						normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
						uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
						face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
						face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
						face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
						face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
						object_pattern: /^[og]\s*(.+)?/,
						smoothing_pattern: /^s\s+(\d+|on|off)/,
						material_library_pattern: /^mtllib /,
						material_use_pattern: /^usemtl /
					}
				}, THREE.OBJLoader.prototype = {
					constructor: THREE.OBJLoader,
					load: function(a, b, c, d) {
						var e = this,
							f = new THREE.FileLoader(e.manager);
						f.setPath(this.path), f.load(a, function(a) {
							b(e.parse(a))
						}, c, d)
					},
					setPath: function(a) {
						this.path = a
					},
					setMaterials: function(a) {
						this.materials = a
					},
					_createParserState: function() {
						var a = {
							objects: [],
							object: {},
							vertices: [],
							normals: [],
							uvs: [],
							materialLibraries: [],
							startObject: function(a, b) {
								if (this.object && this.object.fromDeclaration === false) return this.object.name = a, void(this.object.fromDeclaration = b !== false);
								this.object && "function" == typeof this.object._finalize && this.object._finalize();
								var c = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
								if (this.object = {
										name: a || "",
										fromDeclaration: b !== false,
										geometry: {
											vertices: [],
											normals: [],
											uvs: []
										},
										materials: [],
										smooth: true,
										startMaterial: function(a, b) {
											var c = this._finalize(false);
											c && (c.inherited || c.groupCount <= 0) && this.materials.splice(c.index, 1);
											var d = {
												index: this.materials.length,
												name: a || "",
												mtllib: Array.isArray(b) && b.length > 0 ? b[b.length - 1] : "",
												smooth: void 0 !== c ? c.smooth : this.smooth,
												groupStart: void 0 !== c ? c.groupEnd : 0,
												groupEnd: -1,
												groupCount: -1,
												inherited: false,
												clone: function(a) {
													return {
														index: "number" == typeof a ? a : this.index,
														name: this.name,
														mtllib: this.mtllib,
														smooth: this.smooth,
														groupStart: this.groupEnd,
														groupEnd: -1,
														groupCount: -1,
														inherited: false
													}
												}
											};
											return this.materials.push(d), d
										},
										currentMaterial: function() {
											if (this.materials.length > 0) return this.materials[this.materials.length - 1]
										},
										_finalize: function(a) {
											var b = this.currentMaterial();
											return b && b.groupEnd === -1 && (b.groupEnd = this.geometry.vertices.length / 3, b.groupCount = b.groupEnd - b.groupStart, b.inherited = false), a !== false && 0 === this.materials.length && this.materials.push({
												name: "",
												smooth: this.smooth
											}), b
										}
									}, c && c.name && "function" == typeof c.clone) {
									var d = c.clone(0);
									d.inherited = true, this.object.materials.push(d)
								}
								this.objects.push(this.object)
							},
							finalize: function() {
								this.object && "function" == typeof this.object._finalize && this.object._finalize()
							},
							parseVertexIndex: function(a, b) {
								var c = parseInt(a, 10);
								return 3 * (c >= 0 ? c - 1 : c + b / 3)
							},
							parseNormalIndex: function(a, b) {
								var c = parseInt(a, 10);
								return 3 * (c >= 0 ? c - 1 : c + b / 3)
							},
							parseUVIndex: function(a, b) {
								var c = parseInt(a, 10);
								return 2 * (c >= 0 ? c - 1 : c + b / 2)
							},
							addVertex: function(a, b, c) {
								var d = this.vertices,
									e = this.object.geometry.vertices;
								e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[a + 2]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[b + 2]), e.push(d[c + 0]), e.push(d[c + 1]), e.push(d[c + 2])
							},
							addVertexLine: function(a) {
								var b = this.vertices,
									c = this.object.geometry.vertices;
								c.push(b[a + 0]), c.push(b[a + 1]), c.push(b[a + 2])
							},
							addNormal: function(a, b, c) {
								var d = this.normals,
									e = this.object.geometry.normals;
								e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[a + 2]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[b + 2]), e.push(d[c + 0]), e.push(d[c + 1]), e.push(d[c + 2])
							},
							addUV: function(a, b, c) {
								var d = this.uvs,
									e = this.object.geometry.uvs;
								e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[c + 0]), e.push(d[c + 1])
							},
							addUVLine: function(a) {
								var b = this.uvs,
									c = this.object.geometry.uvs;
								c.push(b[a + 0]), c.push(b[a + 1])
							},
							addFace: function(a, b, c, d, e, f, g, h, i, j, k, l) {
								var m, n = this.vertices.length,
									o = this.parseVertexIndex(a, n),
									p = this.parseVertexIndex(b, n),
									q = this.parseVertexIndex(c, n);
								if (void 0 === d ? this.addVertex(o, p, q) : (m = this.parseVertexIndex(d, n), this.addVertex(o, p, m), this.addVertex(p, q, m)), void 0 !== e) {
									var r = this.uvs.length;
									o = this.parseUVIndex(e, r), p = this.parseUVIndex(f, r), q = this.parseUVIndex(g, r), void 0 === d ? this.addUV(o, p, q) : (m = this.parseUVIndex(h, r), this.addUV(o, p, m), this.addUV(p, q, m))
								}
								if (void 0 !== i) {
									var s = this.normals.length;
									o = this.parseNormalIndex(i, s), p = i === j ? o : this.parseNormalIndex(j, s), q = i === k ? o : this.parseNormalIndex(k, s), void 0 === d ? this.addNormal(o, p, q) : (m = this.parseNormalIndex(l, s), this.addNormal(o, p, m), this.addNormal(p, q, m))
								}
							},
							addLineGeometry: function(a, b) {
								this.object.geometry.type = "Line";
								for (var c = this.vertices.length, d = this.uvs.length, e = 0, f = a.length; e < f; e++) this.addVertexLine(this.parseVertexIndex(a[e], c));
								for (var g = 0, f = b.length; g < f; g++) this.addUVLine(this.parseUVIndex(b[g], d))
							}
						};
						return a.startObject("", false), a
					},
					parse: function(a) {
						console.time("OBJLoader");
						var b = this._createParserState();
						a.indexOf("\r\n") !== -1 && (a = a.replace("\r\n", "\n"));
						for (var c = a.split("\n"), d = "", e = "", f = "", g = 0, h = [], i = "function" == typeof "".trimLeft, j = 0, k = c.length; j < k; j++)
							if (d = c[j], d = i ? d.trimLeft() : d.trim(), g = d.length, 0 !== g && (e = d.charAt(0), "#" !== e))
								if ("v" === e)
									if (f = d.charAt(1), " " === f && null !== (h = this.regexp.vertex_pattern.exec(d))) b.vertices.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
									else if ("n" === f && null !== (h = this.regexp.normal_pattern.exec(d))) b.normals.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
						else {
							if ("t" !== f || null === (h = this.regexp.uv_pattern.exec(d))) throw new Error("Unexpected vertex/normal/uv line: '" + d + "'");
							b.uvs.push(parseFloat(h[1]), parseFloat(h[2]))
						} else if ("f" === e)
							if (null !== (h = this.regexp.face_vertex_uv_normal.exec(d))) b.addFace(h[1], h[4], h[7], h[10], h[2], h[5], h[8], h[11], h[3], h[6], h[9], h[12]);
							else if (null !== (h = this.regexp.face_vertex_uv.exec(d))) b.addFace(h[1], h[3], h[5], h[7], h[2], h[4], h[6], h[8]);
						else if (null !== (h = this.regexp.face_vertex_normal.exec(d))) b.addFace(h[1], h[3], h[5], h[7], void 0, void 0, void 0, void 0, h[2], h[4], h[6], h[8]);
						else {
							if (null === (h = this.regexp.face_vertex.exec(d))) throw new Error("Unexpected face line: '" + d + "'");
							b.addFace(h[1], h[2], h[3], h[4])
						} else if ("l" === e) {
							var l = d.substring(1).trim().split(" "),
								m = [],
								n = [];
							if (d.indexOf("/") === -1) m = l;
							else
								for (var o = 0, p = l.length; o < p; o++) {
									var q = l[o].split("/");
									"" !== q[0] && m.push(q[0]), "" !== q[1] && n.push(q[1])
								}
							b.addLineGeometry(m, n)
						} else if (null !== (h = this.regexp.object_pattern.exec(d))) {
							var r = h[0].substr(1).trim();
							b.startObject(r)
						} else if (this.regexp.material_use_pattern.test(d)) b.object.startMaterial(d.substring(7).trim(), b.materialLibraries);
						else if (this.regexp.material_library_pattern.test(d)) b.materialLibraries.push(d.substring(7).trim());
						else {
							if (null === (h = this.regexp.smoothing_pattern.exec(d))) {
								if ("\0" === d) continue;
								throw new Error("Unexpected line: '" + d + "'")
							}
							var s = h[1].trim().toLowerCase();
							b.object.smooth = "1" === s || "on" === s;
							var t = b.object.currentMaterial();
							t && (t.smooth = b.object.smooth)
						}
						b.finalize();
						var u = new THREE.Group;
						u.materialLibraries = [].concat(b.materialLibraries);
						for (var j = 0, k = b.objects.length; j < k; j++) {
							var v = b.objects[j],
								w = v.geometry,
								x = v.materials,
								y = "Line" === w.type;
							if (0 !== w.vertices.length) {
								var z = new THREE.BufferGeometry;
								z.addAttribute("position", new THREE.BufferAttribute(new Float32Array(w.vertices), 3)), w.normals.length > 0 ? z.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(w.normals), 3)) : z.computeVertexNormals(), w.uvs.length > 0 && z.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(w.uvs), 2));
								for (var A = [], B = 0, C = x.length; B < C; B++) {
									var D = x[B],
										t = void 0;
									if (null !== this.materials && (t = this.materials.create(D.name), y && t && !(t instanceof THREE.LineBasicMaterial))) {
										var E = new THREE.LineBasicMaterial;
										E.copy(t), t = E
									}
									t || (t = y ? new THREE.LineBasicMaterial : new THREE.MeshPhongMaterial, t.name = D.name), t.shading = D.smooth ? THREE.SmoothShading : THREE.FlatShading, A.push(t)
								}
								var F;
								if (A.length > 1) {
									for (var B = 0, C = x.length; B < C; B++) {
										var D = x[B];
										z.addGroup(D.groupStart, D.groupCount, B)
									}
									var G = new THREE.MultiMaterial(A);
									F = y ? new THREE.LineSegments(z, G) : new THREE.Mesh(z, G)
								} else F = y ? new THREE.LineSegments(z, A[0]) : new THREE.Mesh(z, A[0]);
								F.name = v.name, u.add(F)
							}
						}
						return console.timeEnd("OBJLoader"), u
					}
				};
			var ka = function() {
				var a = window.innerWidth,
					b = window.innerHeight;
				Cc && (Cc.setSize(a, b), hd()), za && (za.width = a, za.height = b), Fc && (Fc.fov = 75, Fc.aspect = a / b, Fc.updateProjectionMatrix()), Gc && (Gc.left = -a / 2, Gc.right = a / 2, Gc.top = b / 2, Gc.bottom = -b / 2, Gc.updateProjectionMatrix())
			};
			window.addEventListener("resize", ka, false);
			var la = new THREE.TextureLoader,
				ma = new THREE.FileLoader,
				na = new THREE.OBJLoader,
				oa = {},
				pa = {},
				qa = {},
				ra = {},
				sa = {};
			sa.promises = [], sa.compute = function(a) {
				return sa.promises.push(new Promise(function(b, c) {
					a(), b()
				})), sa.promises[sa.promises.length - 1]
			}, sa.loadTexture = function(a) {
				return sa.promises.push(new Promise(function(b, c) {
					la.load(a, function(c) {
						oa[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
					}, function(a) {}, function(a) {})
				})), sa.promises[sa.promises.length - 1]
			}, sa.loadModel = function(a) {
				return sa.promises.push(new Promise(function(b, c) {
					na.load(a, function(c) {
						qa[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
					})
				})), sa.promises[sa.promises.length - 1]
			}, sa.loadShader = function(a) {
				return sa.promises.push(new Promise(function(b, c) {
					ma.load(a, function(c) {
						pa[a.substring(a.lastIndexOf("/") + 1, a.length)] = c, b()
					})
				})), sa.promises[sa.promises.length - 1]
			}, sa.loadJSON = function(a) {
				return sa.promises.push(new Promise(function(b, c) {
					$.getJSON(a, function(c) {
						ra[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
					})
				})), sa.promises[sa.promises.length - 1]
			}, sa.onFinish = function(a) {
				Promise.all(sa.promises).then(function(b) {
					a && a()
				})
			};
			var ta = [{
					value: 1e18,
					symbol: "E"
				}, {
					value: 1e15,
					symbol: "P"
				}, {
					value: 1e12,
					symbol: "T"
				}, {
					value: 1e9,
					symbol: "G"
				}, {
					value: 1e6,
					symbol: "M"
				}, {
					value: 1e3,
					symbol: "k"
				}],
				ua = /\.0+$|(\.[0-9]*[1-9])0+$/,
				va = function(a) {
					return 1 == a || "true" == a
				};
			sa.loadTexture("../data/terrain/color.jpg"), sa.loadTexture("../data/terrain/heightmap.jpg"), sa.loadTexture("../data/terrain/grassmap.png"), sa.loadTexture("../data/terrain/grass.png"), sa.loadTexture("../data/terrain/detail.jpg"), sa.loadTexture("../data/terrain/detail2.jpg"), sa.loadTexture("../data/terrain/detail_h.jpg"), sa.loadShader("script/shader/grass.vert"), sa.loadShader("script/shader/grass.frag"), sa.loadShader("script/shader/terrain.vert"), sa.loadShader("script/shader/terrain.frag");
			var wa = function() {
					sa.loadTexture("../data/efx/gradient.jpg"), sa.loadTexture("../data/efx/heal_alpha.jpg"), sa.loadTexture("../data/efx/heal_color.jpg"), sa.loadTexture("../data/efx/ice_color.jpg"), sa.loadTexture("../data/efx/leech_color.jpg"), sa.loadTexture("../data/efx/decay_alpha.jpg"), sa.loadTexture("../data/efx/decay_color.jpg"), sa.loadTexture("../data/efx/swingtest.jpg"), sa.loadTexture("../data/efx/alpha.jpg"), sa.loadTexture("../data/factionA.png"), sa.loadTexture("../data/factionB.png"), sa.loadTexture("../data/items/items.png"), sa.loadModel("../data/model/crown.obj"), sa.loadModel("../data/model/helmet.obj"), sa.loadJSON("../data/items/items.json")
				},
				xa = ["armor", "weapon", "offhand", "glove", "armlet", "boot", "gem", "ring", "bag"],
				ya = {
					g: {
						type: "gold",
						name: "Gold",
						drop: 0
					},
					sw: {
						description: "Sword",
						slot: "weapon",
						type: "sword",
						rotatedSprite: true,
						name: ["Wooden Sword", "Rusty Ironsword", "Troll Blade", "Broadsword ", "Longsword", "Carved Bonesword", "Greatsword", "Ghastly Scimitar", "Nullfire Sword", "Knight's Greatsword", "King's Glaive", "Void Blade", "ZerstÃ¶rer", "Hearteater", "Demonedge", "Excalibur", "Harbinger"],
						drop: 1,
						class: ["warrior"],
						lvl: [1, 3, 9, 15, 21, 28, 34, 40, 46, 52, 58, 64, 70, 76, 82, 88, 94],
						stats: {
							mindmg: {
								base: 3,
								multi: .7,
								low: .6,
								high: .9
							},
							maxdmg: {
								base: 5,
								multi: .8,
								low: 1.1,
								high: 1.2
							},
							crit: {
								base: 2,
								multi: .12,
								low: .8,
								high: 1,
								float: true
							}
						}
					},
					st: {
						description: "Staff",
						slot: "weapon",
						type: "staff",
						rotatedSprite: true,
						name: ["Broken Twig", "Cracked Stick", "Gnarled Broomstick", "Oak Stave", "Mystic Wand", "Bone Stave", "Encrusted Rod", "Imbued Staff", "Emerald Staff", "Sapphire Staff", "Frozen Greatstaff", "Infernal Staff", "Hellfire Greatsaff", "Staff of Angelness ", "Crystal Core", "Witch's Heart", "Deathweaver"],
						drop: 1,
						class: ["mage"],
						lvl: [1, 4, 10, 16, 22, 29, 35, 41, 47, 53, 59, 65, 71, 77, 83, 89, 95],
						stats: {
							mindmg: {
								base: 2,
								multi: .9,
								low: .6,
								high: .9
							},
							maxdmg: {
								base: 3,
								multi: 1.1,
								low: 1.1,
								high: 1.2
							},
							crit: {
								base: 2,
								multi: .1,
								low: .8,
								high: 1,
								float: true
							},
							mp: {
								base: 5,
								multi: .8,
								low: .8,
								high: 1
							},
							mpreg: {
								base: .5,
								multi: .05,
								low: .8,
								high: 1,
								float: true
							}
						}
					},
					hm: {
						description: "Hammer",
						slot: "weapon",
						type: "hammer",
						rotatedSprite: true,
						name: ["Splintered Club", "Wooden Mallet", "Rusty Flail", "Orcish Bludgeon", "Heavy Mace", "Iron Basher", "Darkmetal Maul", "Divine Gavel", "Hallowed Hammer", "Dwarfen Maul", "Coldforged Gavel", "Amboss", "Skullshatterer", "Benevolence ", "Hammer of Gaia", "Worldender", "Nightmare"],
						drop: 1,
						class: ["shaman"],
						lvl: [1, 5, 11, 17, 23, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96],
						stats: {
							mindmg: {
								base: 1,
								multi: .6,
								low: .6,
								high: 1
							},
							maxdmg: {
								base: 4,
								multi: .8,
								low: .7,
								high: 1
							},
							mpreg: {
								base: 1,
								multi: .05,
								low: .8,
								high: 1,
								float: true
							}
						}
					},
					bw: {
						description: "Bow",
						slot: "weapon",
						type: "bow",
						rotatedSprite: true,
						name: ["Driftwood Shortbow", "Novice Shortbow", "Curved Shortbow", "Adventurer's Shortbow", "Long Bow", "Bone Bow", "Elven Bow", "Ancient Bow", "Iron Piercer", "Silver Recurve", "Assassin's Bow", "Skyfire Warbow", "Hellfire Warbow", "Widowmaker", "Stormsong", "Scarebow", "Fury"],
						drop: 1,
						class: ["archer"],
						lvl: [1, 6, 12, 18, 24, 31, 37, 43, 49, 55, 61, 67, 73, 79, 85, 91, 97],
						stats: {
							mindmg: {
								base: 1,
								multi: .7,
								low: .7,
								high: 1
							},
							maxdmg: {
								base: 3,
								multi: .9,
								low: 1,
								high: 1.1
							},
							crit: {
								base: 3,
								multi: .15,
								low: .6,
								high: 1,
								float: true
							}
						}
					},
					ar: {
						description: "Chest armor",
						slot: "armor",
						type: "armor",
						rotatedSprite: false,
						name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather", "Scaled Chestguard", "Sky Cloak", "Shadow Cloak", "Obsidian Cloak", "Hellfire Cloak", "Soulkeeper", "Deathless"],
						drop: 1,
						lvl: [1, 9, 18, 27, 36, 45, 56, 65, 74, 83],
						stats: {
							def: {
								base: 5,
								multi: .9,
								low: .6,
								high: 1
							},
							hp: {
								base: 10,
								multi: 1.2,
								low: .6,
								high: 1
							},
							hpreg: {
								base: .5,
								multi: .05,
								low: .3,
								high: 1,
								float: true
							}
						}
					},
					gl: {
						description: "Gloves",
						slot: "glove",
						type: "glove",
						rotatedSprite: false,
						name: ["Hand Wraps", "Cloth Mitts", "Leather Gloves", "Bone Grips", "Iron Gauntlets", "Imbued Gloves", "Wartorn Mitts", "Fiery Handguards", "Gloves of Empowerment ", "Coldforged Fists", "Eternal Gauntlets", "Gloves of Midas", "Titan's Mitts"],
						drop: 2,
						lvl: [1, 8, 17, 26, 35, 44, 55, 64, 73, 82],
						stats: {
							crit: {
								base: .2,
								multi: .05,
								low: .2,
								high: 1,
								float: true
							},
							def: {
								base: 2,
								multi: .3,
								low: .5,
								high: 1
							},
							hp: {
								base: 3,
								multi: .4,
								low: .5,
								high: 1
							}
						}
					},
					al: {
						description: "Armlet",
						slot: "armlet",
						type: "armlet",
						rotatedSprite: false,
						name: ["Simple Bracelet", "Makeshift Brace", "Leather Armlet", "Ivory Bracelet", "Iron Vambrace", "Imbued Bracers", "Ember Cuffs", "Mirrored Armlet", "Golem Fragment", "Coldforged Bracer", "Blackstar Gem", "Eternal Vambraces", "Lost Guardian"],
						drop: 2,
						lvl: [1, 7, 16, 25, 34, 43, 54, 63, 72, 81],
						stats: {
							def: {
								base: 2,
								multi: .4,
								low: .5,
								high: 1
							},
							hp: {
								base: 3,
								multi: .3,
								low: .5,
								high: 1
							},
							mp: {
								base: 5,
								multi: 1,
								low: .5,
								high: 1
							},
							mpreg: {
								base: .2,
								multi: .05,
								low: .5,
								high: 1,
								float: true
							}
						}
					},
					bt: {
						description: "Boots",
						slot: "boot",
						type: "boot",
						rotatedSprite: false,
						name: ["Sandals", "Cloth Footpads", "Leather Boots", "Bone Greaves", "Scaled Treads", "Patterned Greaves", "Wartorn Boots", "Imbued Treads", "Skyswift Boots", "Coldforged Greaves", "Cloudrunner Treads", "Boots of Hermes", "Starshard Greaves"],
						drop: 2,
						lvl: [1, 6, 15, 24, 33, 42, 53, 62, 71, 80],
						stats: {
							def: {
								base: 2,
								multi: .3,
								low: .5,
								high: 1
							},
							hp: {
								base: 3,
								multi: .3,
								low: .5,
								high: 1
							},
							move: {
								base: .1,
								multi: .02,
								low: .5,
								high: 1,
								float: true
							}
						}
					},
					gm: {
						description: "Gem",
						slot: "gem",
						type: "gem",
						rotatedSprite: false,
						name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather"],
						drop: 0,
						lvl: [1, 9, 18, 27, 36, 45, 56, 65, 74, 83],
						stats: {
							mindmg: {
								multi: 1,
								low: .8,
								high: 1
							},
							maxdmg: {
								multi: 1,
								low: 1.5,
								high: 1.9
							},
							crit: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							def: {
								multi: 1,
								low: .8,
								high: 1
							},
							hp: {
								multi: .5,
								low: .8,
								high: 1
							},
							hpreg: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							mp: {
								multi: .5,
								low: .8,
								high: 1
							},
							mpreg: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							move: {
								multi: 1,
								low: .8,
								high: 1,
								float: true
							}
						}
					},
					ri: {
						description: "Ring",
						slot: "ring",
						type: "ring",
						rotatedSprite: false,
						name: ["Woven Band", "Ironbark Circlet", "Brass Ringlet", "Hollowed Bone", "Elven Band", "Imbued Circlet", "Arcane Ring", "Emerald Band", "Infernal Ring", "Ancient Talisman", "Hallowed Relic", "Cantor's Trinket", "Peacekeeper"],
						drop: 1,
						lvl: [1, 5, 14, 23, 32, 41, 52, 61, 70, 79],
						stats: {
							hpreg: {
								base: .1,
								multi: .05,
								low: .2,
								high: 1,
								float: true
							},
							mpreg: {
								base: .1,
								multi: .05,
								low: .2,
								high: 1,
								float: true
							}
						}
					},
					bg: {
						description: "Bag",
						slot: "bag",
						type: "bag",
						rotatedSprite: false,
						name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather"],
						drop: 0,
						lvl: [1, 9, 18, 27, 36, 45, 56, 65, 74, 83],
						stats: {
							mindmg: {
								multi: 1,
								low: .8,
								high: 1
							},
							maxdmg: {
								multi: 1,
								low: 1.5,
								high: 1.9
							},
							crit: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							def: {
								multi: 1,
								low: .8,
								high: 1
							},
							hp: {
								multi: .5,
								low: .8,
								high: 1
							},
							hpreg: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							mp: {
								multi: .5,
								low: .8,
								high: 1
							},
							mpreg: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							move: {
								multi: 1,
								low: .8,
								high: 1,
								float: true
							}
						}
					},
					qv: {
						description: "Quiver",
						slot: "offhand",
						type: "quiver",
						rotatedSprite: true,
						name: ["Linen Quiver", "Reinforced Quiver", "Last Reserves", "Lotharien", "Snake Quiver"],
						drop: 1,
						class: ["archer"],
						lvl: [5, 25, 45, 65, 85],
						stats: {
							crit: {
								base: .5,
								multi: .08,
								low: .5,
								high: 1,
								float: true
							},
							move: {
								base: .1,
								multi: .03,
								low: .5,
								high: 1,
								float: true
							}
						}
					},
					sh: {
						description: "Shield",
						slot: "offhand",
						type: "shield",
						rotatedSprite: false,
						name: ["Wooden Shield", "Buckler", "Old Bulwark", "Metal Guard", "Protecteron"],
						drop: 2,
						class: ["shaman", "warrior"],
						lvl: [2, 13, 33, 63, 88],
						stats: {
							def: {
								base: 15,
								multi: 1.2,
								low: .5,
								high: 1
							},
							hp: {
								base: 8,
								multi: .4,
								low: .5,
								high: 1
							},
							hpreg: {
								base: .1,
								multi: .05,
								low: .5,
								high: 1,
								float: true
							}
						}
					},
					ta: {
						description: "Talisman",
						slot: "offhand",
						type: "talisman",
						rotatedSprite: false,
						name: ["Smelly Talisman", "Guided Talisman", "Ocean Talisman", "Qui'ton", "Dimension Talisman"],
						drop: 1,
						class: ["mage"],
						lvl: [7, 27, 47, 67, 87],
						stats: {
							mp: {
								base: 3,
								multi: 1.2,
								low: .5,
								high: 1
							},
							mpreg: {
								base: .1,
								multi: .1,
								low: .5,
								high: 1,
								float: true
							}
						}
					},
					to: {
						description: "Totem",
						slot: "offhand",
						type: "totem",
						rotatedSprite: true,
						name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather"],
						drop: 0,
						lvl: [10, 30, 50, 70, 90],
						stats: {
							mindmg: {
								multi: 1,
								low: .8,
								high: 1
							},
							maxdmg: {
								multi: 1,
								low: 1.5,
								high: 1.9
							},
							crit: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							def: {
								multi: 1,
								low: .8,
								high: 1
							},
							hp: {
								multi: .5,
								low: .8,
								high: 1
							},
							hpreg: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							mp: {
								multi: .5,
								low: .8,
								high: 1
							},
							mpreg: {
								multi: .5,
								low: .8,
								high: 1,
								float: true
							},
							move: {
								multi: 1,
								low: .8,
								high: 1,
								float: true
							}
						}
					}
				},
				za = {};
			Jc = new Object, za.entities = Jc;
			var Aa, Ba = function(a, b) {
					if (Jc.hasOwnProperty(a)) {
						if (void 0 === Jc[a]) return;
						Jc[a].timeSinceLastUpdate = 0, Jc[a].parseDeltaMsg(b)
					}
				},
				Ca = function(a) {
					Ic && Ic.id == a && (Ic = void 0), Jc.hasOwnProperty(a) && void 0 !== Jc[a] && (Ic && Ic.target == Jc[a] && (Ic.target = void 0), jb(Jc[a]), Jc[a].destroyBody(), Jc[a] = void 0)
				},
				Da = function() {
					for (e in Jc) Jc.hasOwnProperty(e) && Jc[e] && Jc[e].id && Ca(Jc[e].id);
					for (var a in nb) nb.hasOwnProperty(a) && nb[a].destroy();
					Hb(), Ic = void 0
				},
				Ea = false,
				Fa = false,
				Ga = false,
				Ha = false,
				Ia = false,
				Ja = false,
				Ka = function(a) {
					var b = {
						is_unordered: true,
						prevent_repeat: true,
						prevent_default: true
					};
					Aa = new window.keypress.Listener(document.getElementById("body"), b), $("input").bind("focus", function() {
						Aa.stop_listening()
					}).bind("blur", function() {
						Aa.listen()
					}), document.onkeyup = function(a) {
						a = a || window.event;
						var b = false;
						b = "key" in a ? "Escape" == a.key : 27 == a.keyCode, b && Ic && (Ic.target = void 0)
					}, La()
				},
				La = function() {
					$("#sys-help").after('<button class="btn btn-default systembarbutton" id="sys-discord" type="button"><div class="sys-icon icon-discord"></div></button>');
					$("#chatbox").before('<div class="playerProfile"> <h3 class = "profileName"> <div class = "profileClan" style = "color: purple;">[CLAN] </div> PLAYER</h3> <div class = "playerStats"> <button style = "height: auto; width: auto; background-color: red; text-align: center; margin-left: 20%" class = "profileClose">Close</button> <button style = "height: auto; width: auto; background-color: blue; text-align: center;" class = "profileView">View Profile</button></div> </div>');
					Aa.reset(), Aa.simple_combo(Pa.get("toggleHelp"), function() {
						$(".modal-help").replaceWith('<div class="modal fade in" id="modal-help" tabindex="-1" role="dialog" style="display: block;"><div class="modal-dialog modal-body-base modal-help" role="document"><div class="modal-content"><div class="modal-body"><button class="close" type="button" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button><h4><div class="sys-icon icon-help iconpanelmod"></div> Help</h4><div><h5>Controls <small>Can be changed with /rebind</small></h5><table class="table controltable"><tbody><tr><td><kbd>W A S D</kbd></td><td class="td-help"> Move around</td></tr><tr><td><kbd>1 2 3 4</kbd></td><td class="td-help"> Use skills on current target</td></tr><tr><td><kbd>B</kbd></td><td class="td-help"> Inventory</td></tr><tr><td><kbd>C</kbd></td><td class="td-help"> Character Panel</td></tr><tr><td><kbd>Left mouse</kbd></td><td class="td-help"> Select a target / Rotate camera</td></tr><tr><td><kbd>Right mouse</kbd></td><td class="td-help"> Look around</td></tr><tr><td><kbd>Tab</kbd></td><td class="td-help"> Next target</td></tr><tr><td><kbd>Shift</kbd></td><td class="td-help"> Next ally</td></tr><tr><td><kbd>F1</kbd></td><td class="td-help"> Toggle help</td></tr><tr><td style = "background-color: #FFCE44"><kbd>X</kbd></td><td class="td-help" style = "background-color: #FFCE44"> Show the XHORDES keys</td></tr></tbody></table><h5>Chat Commands <small>Type into chat to activate</small></h5><table class="table controltable"><tbody><tr><td><kbd>/bindings</kbd></td><td class="td-help"> Show list of current bindings</td></tr><tr><td><kbd>/rebind</kbd></td><td class="td-help"> Change the binding of a key</td></tr><tr><td><kbd>/resetbindings</kbd></td><td class="td-help"> Reset all bindings to default</td></tr><tr><td><kbd>/respawn</kbd></td><td class="td-help"> Suicide and go back to spawn</td></tr></tbody></table></div></div></div></div>')
						$("#modal-help").modal("toggle");
					}), Aa.simple_combo(Pa.get("toggleLegusHelp"), function() {
						$(".modal-help").replaceWith('<div class="modal fade in" id="modal-help" tabindex="-1" role="dialog" style="display: block;"><div class="modal-dialog modal-body-base modal-help" role="document"><div class="modal-content"><div class="modal-body"><button class="close" type="button" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button><h4><div class="sys-icon icon-help iconpanelmod"></div> XHORDES Help</h4><div><h5>Controls <small>Can be changed with /rebind</small></h5><table class="table controltable"><tbody><tr><td style = "background-color: #757575"><kbd>F1</kbd></td><td class="td-help" style = "background-color: #757575"> Toggle Regular Help</td></tr><tr><td><kbd>G</kbd></td><td class="td-help"> Open Global Chat</td></tr><tr><td><kbd>H</kbd></td><td class="td-help"> Open Clan Chat</td></tr><tr><td><kbd>F2</kbd></td><td class="td-help"> Hide/Show the Chat</td></tr><tr><td><kbd>F3</kbd></td><td class="td-help"> Hide/Show the Whole Leaderboard</td></tr><tr><td><kbd>O</kbd></td><td class="td-help"> Hide/Show the Fame Ladder</td></tr><tr><td><kbd>P</kbd></td><td class="td-help"> Hide/Show Player Count</td></tr></tbody></table><h5>Chat Commands <small>Type into chat to activate</small></h5><table class="table controltable"><tbody><tr><td><kbd>/mute [player]</kbd></td><td class="td-help"> Mutes a player (case-sensitive!)</td></tr><tr><td><kbd>/unmute [player]</kbd></td><td class="td-help"> Unmutes a player (case-sensitive!)</td></tr><tr><td><kbd>/mutelist</kbd></td><td class="td-help"> Lists all the people you have muted</td></tr></tbody></table></div></div></div></div>')
						$("#modal-help").modal("toggle");
					}),	Aa.simple_combo(Pa.get("toggleChat"), function() {
						$("#chatbox").toggle()
					}),	Aa.simple_combo(Pa.get("toggleLb"), function() {
						$("#ladder-body").toggle();
						$("#statistics").toggle();
					}), Aa.simple_combo(Pa.get("toggleLadder"), function() {
						$("#ladder-body").toggle();
					}), Aa.simple_combo(Pa.get("toggleStats"), function() {
						$("#statistics").toggle();
					}), Aa.simple_combo(Pa.get("globalChat"), function() {
						$("#chatChannelName").text("Global"), hc = "g";
						$("#chatInputForm").show(), $("#chatInput").focus(), a && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
					}), Aa.simple_combo(Pa.get("clanChat"), function() {
						$("#chatChannelName").text("Clan"), hc = "c";
						$("#chatInputForm").show(), $("#chatInput").focus(), a && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
					}), Aa.simple_combo(Pa.get("profile"), function() {
						var name = window.getSelection().toString();
						if(window.getSelection()) {
						$(".profileName").load('http://hordes.io/player/' + name + ' .col-md-12');
						$(".playerProfile").css("display", "inline-block");
						}
						else {
						$(".profileName").text("[CLAN]   PLAYER");
						$(".playerProfile").css("display", "none");
						}
						$(".profileClose").click(function() {
							$(".playerProfile").css("display", "none")
							name = "";
						});
						$(".profileView").click(function() {
							window.open("http://hordes.io/player/" + name, "_blank");
						});
					}),	 Aa.register_combo({
						keys: Pa.get("nextAlly"),
						on_keydown: function() {
							Ic && td && (Ic.target = td)
						}
					}), Aa.register_combo({
						keys: Pa.get("nextTarget"),
						on_keydown: function() {
							Ic && sd && (Ic.target = sd)
						}
					}), Aa.register_combo({
						keys: Pa.get("walkForward"),
						on_keydown: function() {
							Ga = true
						},
						on_release: function() {
							Ga = false
						}
					}), Aa.register_combo({
						keys: Pa.get("walkBackward"),
						on_keydown: function() {
							Ha = true
						},
						on_release: function() {
							Ha = false
						}
					}), Aa.register_combo({
						keys: Pa.get("walkRight"),
						on_keydown: function() {
							Fa = true
						},
						on_release: function() {
							Fa = false
						}
					}), Aa.register_combo({
						keys: Pa.get("walkLeft"),
						on_keydown: function() {
							Ea = true
						},
						on_release: function() {
							Ea = false
						}
					}), Aa.register_combo({
						keys: Pa.get("turnLeft"),
						on_keydown: function() {
							Ja = true
						},
						on_release: function() {
							Ja = false
						}
					}), Aa.register_combo({
						keys: Pa.get("turnRight"),
						on_keydown: function() {
							Ia = true
						},
						on_release: function() {
							Ia = false
						}
					}), Aa.register_combo({
						keys: Pa.get("walkForward2"),
						on_keydown: function() {
							Ga = true
						},
						on_release: function() {
							Ga = false
						}
					}), Aa.register_combo({
						keys: Pa.get("walkBackward2"),
						on_keydown: function() {
							Ha = true
						},
						on_release: function() {
							Ha = false
						}
					}), Aa.register_combo({
						keys: Pa.get("inventory"),
						prevent_default: false,
						on_release: function() {
							Ic && $("#inventory").toggle()
						}
					}), Aa.register_combo({
						keys: Pa.get("character"),
						prevent_default: false,
						on_release: function() {
							Ic && $("#characterpanel").toggle()
						}
					}),  Aa.simple_combo(Pa.get("skill1"), function() {
						Ic && Ic.useSkill(1)
					}), Aa.simple_combo(Pa.get("skill2"), function() {
						Ic && Ic.useSkill(2)
					}), Aa.simple_combo(Pa.get("skill3"), function() {
						Ic && Ic.useSkill(3)
					}),  Aa.simple_combo(Pa.get("skill4"), function() {
						Ic && Ic.useSkill(4)
					}), Aa.simple_combo("enter", function() {
						if (cc.chatboxWrapper) {
							Tb.unLock();
							var a = Math.round(cc.chatboxWrapper[0].scrollHeight - cc.chatboxWrapper[0].scrollTop) === Math.round(cc.chatboxWrapper[0].clientHeight);
							$("#chatInputForm").show(), $("#chatInput").focus(), a && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
						}
					}), $("#skillButtonKbd1").html(Pa.get("skill1")), $("#skillButtonKbd2").html(Pa.get("skill2")), $("#skillButtonKbd3").html(Pa.get("skill3")), $("#skillButtonKbd4").html(Pa.get("skill4"))
				},
				Ma = false;
			if ("undefined" != typeof Storage) try {
				x = "__storage_test__", localStorage.setItem(x, x), localStorage.removeItem(x), Ma = true, console.log("Webstorage found. loading settings..")
			} catch (a) {
				console.log("Error: Webstorage not working.")
			} else console.log("Error: Webstorage not working.");
			var Na = {
					skill1: "1",
					skill2: "2",
					skill3: "3",
					skill4: "4",
					nextTarget: "tab",
					nextAlly: "shift",
					walkForward: "w",
					walkLeft: "a",
					walkRight: "d",
					walkBackward: "s",
					turnLeft: "left",
					turnRight: "right",
					walkForward2: "up",
					walkBackward2: "down",
					toggleHelp: "f1",
					toggleChat: "f2",
					toggleUi: "u",
					globalChat: "g",
					clanChat: "h",
					toggleLb: "f3",
					toggleLadder: "o",
					toggleStats: "p",
					toggleLegusHelp: "x",
					profile: "t",
					inventory: "b",
					character: "c"
				},
				Oa = function() {
					this.get = function(a) {
						return this.hasOwnProperty(a) ? this[a] : void 0
					}, this.parse = function(a, b) {
						var c = b;
						return Ma && (c = localStorage.getItem(a), c || (c = b)), this[a] = c, c
					}, this.set = function(a, b) {
						return Ma && localStorage.setItem(a, b), this[a] = b, b
					}, this.parse("name", void 0), this.parse("faction", void 0), this.parse("class", void 0), this.parse("server", void 0), this.parse("camlock", "true"), this.parse("resolution", "10"), this.parse("skillefx", "true"), this.parse("lastAd", "0"), this.parse("dmgnumbers", "true"), this.parse("nameplates", "true"), this.parse("shadows", "0"), this.parse("grass", "3"), this.parse("chat-loot", "true"), this.parse("chat-chat", "true"), this.parse("chat-exp", "true"), this.parse("chat-pvp", "true");
					for (k in Na) this.parse(k, Na[k])
				},
				Pa = new Oa,
				Qa = function(a) {
					if ("string" != typeof a || a.length <= 0) return false;
					if ("/" == a[0]) {
						var b = a.split(" ");
						if (b.length <= 0) return false;
						var c = b.shift().substring(1),
							d = a.substring(1);
						if(typeof localStorage.muted==="string")window.muted=localStorage.muted.split("&");
						Ra.hasOwnProperty(c) ? Ra[c](b, d) : Y({
							msg: "Unknown command: " + c,
							src: "system"
						})
					} else f(a, hc)
				},
				Ra = {
					respawn: function(a) {
						Y({
							msg: "Respawning...",
							src: "system"
						}), wd.emit("respawn")
					},
					rebind: function(a) {
						return a.length < 2 ? void Y({
							msg: "Wrong usage. Example: '/rebind skill1 e'. For a list of keybindings, try /bindings",
							src: "system"
						}) : Na.hasOwnProperty(a[0]) ? (Y({
							msg: "Changed binding '" + a[0] + "' to: " + a[1],
							src: "system"
						}), Pa.set(a[0], a[1]), void La()) : void Y({
							msg: "No such keybinding: '" + a[0] + "'. For a list of keybindings, try /bindings",
							src: "system"
						})
					},
					resetbindings: function() {
						Y({
							msg: "Keybindings have been reset to default.",
							src: "system"
						});
						for (k in Na) Pa.set(k, Na[k]);
						La()
					},
					bindings: function() {
						Y({
							msg: "List of keybindings: ",
							src: "system"
						});
						for (k in Na) Y({
							msg: k + ": " + Pa.get(k),
							src: "system"
						});
						},
					mute: function(a) {
						Y({msg: "Muted "+a.join(' ')+" successfully!", src:"system"});
						typeof window.muted==="undefined"?window.muted=[a.join(' ')]:window.muted.push(a.join(' '));
						localStorage.muted = window.muted.join("&");
					},
					unmute: function(a) {
						var m='';
						window.muted.indexOf(a.join(' '))===-1?m='Could not find '+a.join(' '):m='Successfully unmuted '+a.join(' ');
						Y({msg: m, src: 'system'});
						window.muted=window.muted.filter(function(i){return i!==a.join(' ')});
						localStorage.muted = window.muted.join("&");
					},
					mutelist: function(a) {
						Y({msg: "Muted: " + window.muted||"Nobody is muted!", src: 'system'})
					},
					clear: function(a) {
						switch((a).toLowerCase()){
							case "loot":
								$(".chatmsg-loot").remove();
							break;
							case "exp":
							case "xp":
								$(".chatmsg-exp").remove();
							break;
							case "clan":
								$(".chatmsg-clan").remove();
							break;
							case "all":
								$(".chatmsg-loot").remove();
								$(".chatmsg-exp").remove();
								$(".chatmsg-clan").remove();
								$(".chatmsg-global").remove();
							break;
							case "unreg":
							case "unregistered":
								$(".unreg").remove();
							break;
							case "global":
							default:
								$(".chatmsg-global").remove();
							break;
						}							
					},
					hideui: function() {
						pc("hide")
					},
					hideplayer: function() {
						Ic.geometry.visible = false, Ic.namesprite.visible = false, Ic.clansprite.visible = false
					},
					test: function(a) {
						xd.emit(a);
						},
					msg: function(a) {
						if (!(a.length < 1)) {
							if (a.length > 1)
								for (var b = 2; b < a.length; ++b) a[1] = a[1] + " " + a[b];
							var c = {};
							c[a[0]] = a[1] || "", xd.emit("msg", c)
						}
					},
					global: function(a, b) {
						f(b.substring(6), "g")
					}
				},
				Sa = void 0,
				Ta = void 0,
				Ua = 2 * Math.PI,
				Va = false,
				Wa = false,
				Xa = "144.217.80.63",
				Ya = 150;
			j.prototype.tick = function(a) {
				if (!this.stats.isDead()) {
					var b = new THREE.Vector3(0, 0, 0);
					if (b.z = -this.walkForward, b.x = this.walkSideward, b.lengthSq() > 0 && b.normalize(), this.walkForward == -1 && (b.z *= .5, b.x *= .5), b.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation), this.velocity = b, !this.ignSteep && !this.isAi && (Va || this == Ic) && (0 != this.velocity.x || 0 != this.velocity.y)) {
						var c = b.clone();
						c.normalize();
						var d = .5,
							e = Qc(this.position.x, this.position.z),
							f = Qc(this.position.x + c.x, this.position.z),
							g = Qc(this.position.x, this.position.z + c.z),
							h = f - e > d ? 0 : 1,
							i = g - e > d ? 0 : 1;
						this.velocity.x *= h, this.velocity.z *= i
					}
					this.position.x += this.velocity.x * a * this.stats.movespeed, this.position.y += this.velocity.y * a * this.stats.movespeed, this.position.z += this.velocity.z * a * this.stats.movespeed, this.class && this.class.tick && this.class.tick(a), this.stats.tick(a)
				}
				for (; this.rotation < 0;) this.rotation += Ua;
				for (; this.rotation > Ua;) this.rotation -= Ua;
				this.state.tick(a, this)
			}, j.prototype.getDeltaMsg = function() {
				var a = {};
				if (Va || !Va && !this.stats.incapacitated) {
					var b = this.walkForward != this.last.walkForward || this.walkSideward != this.last.walkSideward ? 0 : Va ? this.isAi ? 8 : .5 : .3;
					Za(this.position, this.last.position, "x", b, a, "x", 1), Za(this.position, this.last.position, "z", b, a, "z", 1);
					this.isAi || ($a(this, this.last, "walkForward", a, "wf"), $a(this, this.last, "walkSideward", a, "ws"), Za(this, this.last, "rotation", .08, a, "r", 2))
				}
				Va && ($a(this.state, this.last.state, "id", a, "s"), $a(this, this.last, "faction", a, "f"), _a(this, this.last, "name", a, "n"), _a(this, this.last, "id", a, "id"), _a(this, this.last, "clan", a, "c"), _a(this, this.last, "isAi", a, "ai") && (a.ai = 1 == a.ai ? 1 : 0), this.stats.parseStatChanges(a), $a(this.class, this.last.class, "level", a, "lvl"), _a(this.class, this.last.class, "type", a, "class"), _a(this.stats, this.last.stats, "invincible", a, "ivc"), _a(this.stats, this.last.stats, "incapacitated", a, "inc"), _a(this.stats, this.last.stats, "stunned", a, "stn"), _a(this, this.last, "combat", a, "cbt"), this.isAi ? ($a(this.class.ai, this.last.class.ai, "isresetting", a, "rs"), Za(this.class.ai, this.last.class.ai, "goalx", .1, a, "gx", 1), Za(this.class.ai, this.last.class.ai, "goalz", .1, a, "gz", 1)) : this.stats.incapacitated && this.lastPositionUpdate.copy(this.position), _a(this.visuals, this.last.visuals, "h", a, "vh")), (Va || this == Ic) && (this.target && this.target.id != this.last.target.id ? _a(this.target, this.last.target, "id", a, "tr") : void 0 == this.target && void 0 != this.last.target.id && (a.tr = "", this.last.target.id = void 0));
				for (var c in this.serverMsgQueue) this.serverMsgQueue.hasOwnProperty(c) && (a[c] = this.serverMsgQueue[c]);
				this.serverMsgQueue = {};
				var d = l(a);
				if (Va) {
					var e = Date.now();
					if (d) {
						if (!(e - this.lastserverheartbeat > 2e3)) return false;
						this.lastserverheartbeat = e
					} else this.lastserverheartbeat = e
				} else {
					var e = Date.now();
					if (d) {
						if (!(e - this.last.updateTime > 2e3)) return false;
						this.last.updateTime = e
					} else this.last.updateTime = e
				}
				return a
			}, j.prototype.parseDeltaMsg = function(a) {
				if (Va || !this.isPlayer) {
					var b = new THREE.Vector3;
					if (Va) {
						if (!this.stats.incapacitated && this.ignoreMovement <= 0) {
							b.copy(this.position);
							var c = ab(a, "x", "x", b),
								d = ab(a, "z", "z", b);
							(c || d) && this.verifyPosition(b)
						}
						a.hasOwnProperty("lus") && "number" == typeof a.lus && this.class.skills.hasOwnProperty(a.lus) && this.class.skills[a.lus].tryLevelUp()
					} else if (ab(a, "x", "x", b) && (this.last.position.x = this.position.x, this.position.x = this.next.position.x, this.next.position.x = b.x), ab(a, "z", "z", b) && (this.last.position.z = this.position.z, this.position.z = this.next.position.z, this.next.position.z = b.z), this.isAi) {
						bb(a, "isresetting", "rs", this.class.ai);
						var e = ab(a, "x", "gx", this.class.ai.goal),
							f = ab(a, "z", "gz", this.class.ai.goal);
						(e || f) && (this.class.ai.hasReachedGoal = false)
					}(!Va || Va && !this.stats.incapacitated) && (bb(a, "walkForward", "wf", this), bb(a, "walkSideward", "ws", this), ab(a, "rotation", "r", this), cb(a, "queuedAction", "a", this))
				}
				if ((Va || this != Ic) && a.hasOwnProperty("tr") && ("" == a.tr ? (this.target = void 0, Va || (this.desiredTarget = "")) : za.entities.hasOwnProperty(a.tr) ? (this.target = za.entities[a.tr], Va || (this.desiredTarget = "")) : Va || (this.desiredTarget = a.tr)), a.hasOwnProperty("ab"))
					for (var g = 0; g < a.ab.length; ++g) !Va && this == Ic && this.class.skills[a.ab[g]].simulate || this.useSkill(a.ab[g], true);
				if (a.hasOwnProperty("abi"))
					for (var g = 0; g < a.abi.length; ++g) this.class.skills[a.abi[g]] && !this.class.skills[a.abi[g]].ignoreEc && (this.class.skills[a.abi[g]].interruptCast(), this.class.skills[a.abi[g]].interruptChannel());
				if (!Va) {
					if (cb(a, "invincible", "ivc", this.stats), cb(a, "incapacitated", "inc", this.stats), cb(a, "stunned", "stn", this.stats), a.hasOwnProperty("ec"))
						for (var g = 0; g < a.ec.length; ++g) this.class.skills.hasOwnProperty(a.ec[g]) && this.class.skills[a.ec[g]].endCast(true);
					if (cb(a, "isAi", "ai", this), cb(a, "id", "id", this), a.hasOwnProperty("s") && a.s != this.state.id && (this.state = this.parseState(parseInt(a.s))), a.hasOwnProperty("f") && this.updateFaction(a.f), a.hasOwnProperty("c") && void 0 !== a.c && (this.clan = a.c, this.clansprite && this.clansprite._text != this.clan && (this.clansprite._fillStyle = 0 == this.faction ? "#8CD8FF" : "#FF8481", this.clansprite._text = this.clan.substring(0, 4), this.clansprite.updateText(), this == Ic && (this.namesprite.position.set(Math.round(.5 * this.clansprite.canvas.textWidth), 30, 0), this.clansprite.position.set(-Math.round(.5 * this.namesprite.canvas.textWidth + 5), 30, 0)))), a.hasOwnProperty("n") && (a.n && (this.name = a.n, this.namesprite && this.namesprite._text != this.name && (this.namesprite._text = this.name, this.namesprite.updateText())), this == Ic && Fb.charName.text(this.name)), bb(a, "clanrole", "clr", this), a.hasOwnProperty("d") && "true" == Pa.get("dmgnumbers"))
						for (var g = 0; g < a.d.length; ++g) this.createCombatText(a.d[g], g);
					if (Ic && this.faction == Ic.faction && "true" == Pa.get("dmgnumbers") && a.hasOwnProperty("hl"))
						for (var g = 0; g < a.hl.length; ++g) this.createCombatText(a.hl[g], g, true);
					bb(a, "currentmp", "mp", this.stats), bb(a, "maxmp", "mmp", this.stats) && this.isPlayer && Fb.mp.text(this.stats.maxmp), bb(a, "currenthp", "h", this.stats), bb(a, "maxhp", "mh", this.stats) && this.isPlayer && Fb.hp.text(this.stats.maxhp), ab(a, "servermovespeed", "ms", this.stats) && this.isPlayer && Fb.ms.text(this.stats.servermovespeed);
					var h = this.class.level;
					if (bb(a, "level", "lvl", this.class) && (this == Ic && h < this.class.level && (Y({
							msg: "You have reached level " + this.class.level + "!",
							src: "system"
						}), Fb.lvl.text(this.class.level)), this.levelsprite._text = this.class.level, this.levelsprite.updateText(), Ic && (this != Ic ? this.canFightPlayer = ib(this, Ic).canFight() : od())), this.isPlayer) {
						bb(a, "gold", "g", this), a.g && cc.gold.text(a.g), a.gd && Y({
							msg: (a.gd > 0 ? "Gained " : "Lost ") + Math.abs(a.gd) + " $g",
							src: "loot"
						}), this.class && a.sl && this.class.skills.hasOwnProperty(a.sl.i) && (this.class.skills[a.sl.i].setLevel(a.sl.l), jc($("#skillLevelButton" + a.sl.i), a.sl.i), Y({
							msg: this.class.skills[a.sl.i].name + " raised to ability level " + a.sl.l + "!",
							src: "system"
						})), a.dexp && Y({
							msg: (a.dexp > 0 ? "Gained " : "Lost ") + Math.abs(a.dexp) + " experience.",
							src: "exp"
						});
						var i = bb(a, "exp", "exp", this.class),
							j = bb(a, "nextLevelExp", "nxp", this.class);
						(i || j) && W();
						var k = bb(a, "fame", "fm", this);
						k && Fb.fame.text(this.fame), a.dfm && Y({
							msg: (parseInt(a.dfm) > 0 ? "Earned " : "Lost ") + Math.abs(a.dfm) + " fame. ( You have " + this.fame + " fame)",
							src: "exp"
						}), ab(a, "x", "x", this.serverpos), ab(a, "z", "z", this.serverpos), this.stats.incapacitated && (this.position.copy(this.serverpos), this.visualPosition.copy(this.position), bb(a, "walkForward", "wf", this), bb(a, "walkSideward", "ws", this)), a.hasOwnProperty("r") && Math.abs(E(this.geometry.rotation.y, a.r)) > .9 * Math.PI && (this.rotation = a.r, this.geometry.rotation.y = this.rotation);
						var l = ab(a, "x", "hrx", this.position),
							m = ab(a, "z", "hrz", this.position);
						(l || m) && (this.serverpos.copy(this.position), this.visualPosition.copy(this.position)), void 0 !== a.hpr && Fb.hpr.text(a.hpr + "/s"), void 0 !== a.mpr && Fb.mpr.text(a.mpr + "/s"), void 0 === a.mid && void 0 === a.mad || (void 0 !== a.mid && (Fb.mid = a.mid), void 0 !== a.mad && (Fb.mad = a.mad), Fb.power.text(Fb.mid + " - " + Fb.mad)), void 0 !== a.cr && Fb.crit.text(a.cr + "%"), void 0 !== a.def && Fb.def.text(a.def)
					}
					if (a.hasOwnProperty("class") && a.class != this.class.type) {
						var n = this.class ? this.class.nextLevelExp : void 0;
						switch (a.class) {
							case "warrior":
								this.class = new R(this.class.level);
								break;
							case "shaman":
								this.class = new U(this.class.level);
								break;
							case "mage":
								this.class = new S(this.class.level);
								break;
							case "archer":
								this.class = new T(this.class.level);
								break;
							case "mob_sword":
								this.class = new O(this.class.level), this.isAi = true;
								break;
							case "mob_bow":
								this.class = new P(this.class.level), this.isAi = true;
								break;
							case "mob_slime":
								this.class = new Q(this.class.level), this.isAi = true;
								break;
							case "king":
								this.class = L(), this.isAi = true;
								break;
							case "warden":
								this.class = M(), this.isAi = true;
								break;
							case "vendor":
								this.class = N();
								break;
							default:
								console.log("warning: unknown class: " + a.class)
						}
						this.isAi && (this.class.ai.class = this.class, this.class.ai.parent = this), this.class.stats = this.stats, this.class.parent = this, this.class.initBaseBody.call(this), this.class.initBodyGeometry.call(this), this.class.update(), this.stats.spawn(), this.hasParsedClass = true, this.body.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), n && (this.class.nextLevelExp = n), Va || this != Ic || (this.class.skills[1].configureUiElements($("#skillIcon1"), $("#skillOverlay1"), $("#skillCooldown1")), this.class.skills[2].configureUiElements($("#skillIcon2"), $("#skillOverlay2"), $("#skillCooldown2")), this.class.skills[3].configureUiElements($("#skillIcon3"), $("#skillOverlay3"), $("#skillCooldown3")), this.class.skills[4].configureUiElements($("#skillIcon4"), $("#skillOverlay4"), $("#skillCooldown4")), this.class.skills[1].setInfoPanel("skill1"), this.class.skills[2].setInfoPanel("skill2"), this.class.skills[3].setInfoPanel("skill3"), this.class.skills[4].setInfoPanel("skill4"), Fb.charImg.attr("src", "data/class/class_" + this.class.type + ".png"))
					}
					bb(a, "h", "vh", this.visuals) && this.updateVisual("h")
				}
			}, j.prototype.parseState = function(a) {
				switch (a) {
					case 0:
						return this.chest.material = this.class.color, new A;
					case 2:
						return this.animationQueue[0] = new V({
							id: "dead",
							type: "static",
							duration: 5
						}), Va || this == Ic && (Y({
							msg: "You have died and lost exp.",
							src: "death"
						}), $("#deathScreen").fadeIn(400)), new C;
					default:
						return this.state
				}
			}, j.prototype.canSellToTrader = function() {
				if (void 0 !== this.target && void 0 !== this.target.class && "vendor" == this.target.class.type) {
					var a = ib(this, this.target);
					if (void 0 !== a) {
						var b = a.distance();
						if (void 0 !== b && b < 3) return true
					}
				}
				return false
			};
			var Za = function(a, b, c, d, e, f, g) {
					return (Math.abs(a[c] - b[c]) > d || void 0 === b[c]) && (e[f] = parseFloat(a[c]).toFixed(g), b[c] = a[c], true)
				},
				$a = function(a, b, c, d, e) {
					return a[c] !== b[c] && (d[e] = parseInt(a[c]), b[c] = a[c], true)
				},
				_a = function(a, b, c, d, e) {
					return a[c] !== b[c] && (d[e] = a[c], b[c] = a[c], true)
				},
				ab = function(a, b, c, d) {
					return !!a.hasOwnProperty(c) && (d[b] = parseFloat(a[c]), true)
				},
				bb = function(a, b, c, d) {
					return !!a.hasOwnProperty(c) && (d[b] = parseInt(a[c]), true)
				},
				cb = function(a, b, c, d) {
					return !!a.hasOwnProperty(c) && (d[b] = a[c], true)
				},
				db = {
					linear: function(a) {
						return a
					},
					easeInQuad: function(a) {
						return a * a
					},
					easeOutQuad: function(a) {
						return a * (2 - a)
					},
					easeInOutQuad: function(a) {
						return a < .5 ? 2 * a * a : -1 + (4 - 2 * a) * a
					},
					easeInCubic: function(a) {
						return a * a * a
					},
					easeOutCubic: function(a) {
						return --a * a * a + 1
					},
					easeInOutCubic: function(a) {
						return a < .5 ? 4 * a * a * a : (a - 1) * (2 * a - 2) * (2 * a - 2) + 1
					},
					easeInQuart: function(a) {
						return a * a * a * a
					},
					easeOutQuart: function(a) {
						return 1 - --a * a * a * a
					},
					easeInOutQuart: function(a) {
						return a < .5 ? 8 * a * a * a * a : 1 - 8 * --a * a * a * a
					},
					easeInQuint: function(a) {
						return a * a * a * a * a
					},
					easeOutQuint: function(a) {
						return 1 + --a * a * a * a * a
					},
					easeInOutQuint: function(a) {
						return a < .5 ? 16 * a * a * a * a * a : 1 + 16 * --a * a * a * a * a
					}
				},
				eb = function(a) {
					return a[Math.floor(Math.random() * a.length)]
				},
				fb = new Object,
				gb = function() {
					for (var a in fb) {
						var b = fb[a];
						void 0 !== b && (kb(b.a) && kb(b.b) && (!Va || lb(b.a, b.b)) ? b.clearIntervalData() : delete fb[a])
					}
				};
			o.prototype.distance = function() {
				return void 0 === this._distance ? (this._distance = Math.max(0, J(this.a, this.b) - (this.a.stats.scale + this.b.stats.scale)), this._distance) : this._distance
			}, o.prototype.aggro = function(a) {
				return this.a == a ? this.aggroA : this.aggroB
			}, o.prototype.modifyAggro = function(a, b) {
				a == this.a ? this.aggroA += b : this.aggroB += b
			}, o.prototype.resetAggro = function(a) {
				a == this.a ? this.aggroA = 0 : this.aggroB = 0
			}, o.prototype.canFight = function() {
				if (void 0 !== this._canFight) return this._canFight;
				if (this._canFight = true, Va && (this.a.isAi && 1 == this.a.class.ai.isresetting && (this._canFight = false), this.b.isAi && 1 == this.b.class.ai.isresetting && (this._canFight = false)), !this.a.isAi && !this.b.isAi) {
					var a = Math.min(this.a.class.level, this.b.class.level),
						b = Math.max(this.a.class.level, this.b.class.level);
					b > 1.8 * Math.max(3, a) + 2 && (this._canFight = false)
				}
				return this._canFight
			}, o.prototype.expShare = function(a) {
				return a == this.a ? this.expShareA : a == this.b ? this.expShareB : void 0
			}, o.prototype.modifyExpShare = function(a, b) {
				a == this.a && (this.expShareA += b), a == this.b && (this.expShareB += b)
			}, o.prototype.clearIntervalData = function() {
				this._distance = void 0, this._canFight = void 0
			};
			var hb = function(a, b) {
					return a.id < b.id ? a.id + "," + b.id : b.id + "," + a.id
				},
				ib = function(a, b) {
					if (void 0 === a || void 0 === b || a == b) return null;
					var c = hb(a, b);
					return void 0 === fb[c] && (fb[c] = new o(a, b)), fb[c]
				},
				jb = function(a) {},
				kb = function(a) {
					if (void 0 == a) return false;
					if (Va) {
						if (a.isAi || a.class.idleAi ? void 0 == za.npcs[a.id] : void 0 == za.players[a.id]) return false
					} else if (void 0 == za.entities[a.id]) return false;
					return true
				},
				lb = function(a, b) {
					if (void 0 != a && void 0 != b) {
						var c = getChunkCoord(a.position),
							d = getChunkCoord(b.position);
						return Math.abs(c.x - d.x) < 2 && Math.abs(c.z - d.z) < 2
					}
				},
				mb = {};
			mb.damage = function(a) {
				var b = a.scaledmg || 1,
					c = a.spread || .1,
					d = a.basedmg || 1,
					e = a.attacker || void 0,
					f = a.target || void 0,
					g = a.mode || "single",
					h = a.aoeCenter || void 0,
					i = a.aoeRange || 1,
					j = a.aoeArc || void 0,
					k = a.heal || false,
					l = a.buff || false,
					m = a.debuff || false,
					n = "aoe" == g ? Va ? getChunk(e ? e.position : h).entities : Kc : void 0,
					o = a.mod || void 0,
					p = a.aggro || 1,
					q = a.targetFun || void 0,
					r = a.aoeFun || void 0;
				if (e || "aoe" != g || h) {
					var s = [];
					if (!f || e && f.faction != e.faction && !ib(e, f).canFight() || s.push(f), "aoe" == g && n)
						for (var t = 0; t < n.length; ++t) {
							var u = n[t];
							if (!(void 0 === u || u.stats.isDead() || e && (k || l ? u.faction != e.faction : u.faction == e.faction || !ib(e, u).canFight()))) {
								if (j && e) {
									var v = E(e.rotation, G(e.position, u.position));
									if (Math.abs(v) > j) continue
								}
								var w = void 0;
								w = h ? I(u, h) : u == e ? 0 : ib(u, e).distance(), void 0 != w && w < i && s.push(u)
							}
						}
					for (var x = 0; x < s.length; ++x) {
						if (!l && !m) {
							var z = Math.max(0, (d + (e.stats.currentmindmg + (e.stats.currentmaxdmg - e.stats.currentmindmg) * Math.random()) * b) * (1 + (Math.random() - .5) * c));
							Math.random() < e.stats.crit / 100 && (z *= 2.5), k ? s[x].takeHealing(z, e) : s[x].takeDamage(z, e, p)
						}
						void 0 != o && s[x].stats.addMod(new y(s[x], e, o)), q && q(s[x], e)
					}
					r && r(s, e)
				}
			}, mb.interrupt = function(a, b) {
				if (ib(b, a).canFight())
					for (skill in a.class.skills) a.class.skills.hasOwnProperty(skill) && a.class.skills[skill].interruptCast()
			};
			var nb = {};
			p.prototype.clientInit = function(a) {
				void 0 !== a.x && void 0 !== a.z && void 0 !== a.t && void 0 !== a.i && (this.drop = true, this.position = {
					x: parseFloat(a.x),
					z: parseFloat(a.z)
				}, this.id = a.i, this.type = a.t, this.identifier = ya[this.type].type, this.name = ya[this.type].name[a.o], this.spritename = this.identifier + ("g" == this.type ? "" : a.o), this.timeout = Date.now() + 1e3 * parseInt(a.m), this.ownerid = a.k)
			}, p.prototype.destroy = function() {
				this.quad && Ac.remove(this.quad), this.shadow && Ac.remove(this.shadow), void 0 !== nb[this.id] && (nb[this.id] = void 0, delete nb[this.id])
			}, p.prototype.tick = function(a, b) {
				this.createModel(b), void 0 !== this.quad && Wc.push(this.quad), this.timeout < b && this.destroy()
			}, p.prototype.getInfoPanelString = function() {
				return "<div class='targetinfo targettext ally'><span class='targetname'>" + this.name + "</span></div> Item"
			}, p.prototype.createModel = function(a) {
				if (void 0 === this.quad && !(void 0 === Ic || void 0 !== this.ownerid && "" != this.ownerid && this.ownerid != Ic.id && this.timeout - a > 105e3)) {
					this.quad = new THREE.Mesh(kd.items[("g" == this.type ? "" : this.identifier + "/") + this.spritename], Vc.item), this.quad.position.set(this.position.x, Qc(this.position.x, this.position.z) + ("g" == this.type ? .15 : .2 + .1 * Math.random()), this.position.z);
					var b = Rc(this.position.x, this.position.z);
					b.y < 0 && (b.y *= -1, b.x *= -1, b.z *= -1), b.x += this.quad.position.x, b.y += this.quad.position.y, b.z += this.quad.position.z, this.quad.lookAt(b), this.quad.rotation.z = Math.random() * Ua, Ac.add(this.quad), this.quad.entity = this
				}
			};
			var ob = 0;
			p.prototype.requestPickUp = function() {
				var a = Date.now();
				!Ic || a - ob < 500 || n(this.position, Ic.position) < 4 && (ob = a, wd.emit("d", {
					i: this.id
				}))
			};
			var pb, qb = function(a) {
					var b = Date.now(),
						c = 1.2 + .13 * Math.sin(b / 90);
					Vc.item.color.r = c, Vc.item.color.g = c, Vc.item.color.b = c;
					for (var d in nb) nb.hasOwnProperty(d) && nb[d].tick(a, b)
				},
				rb = void 0,
				sb = function(a) {
					if (rb = a, void 0 === a || a.none) $("#claninfo").hide(), $("#clancreation").show();
					else if (void 0 !== Ic) {
						a.n && a.f && (a.fn = a.n + " <small> " + (0 == a.f ? "Vanguard Clan" : "Bloodlust Clan") + "</small>"), tb(a, "fn", "c-name"), tb(a, "m", "c-mcount"), tb(a, "t", "c-tag");
						var b = $("#clanmembers");
						b.html(""), a.b.forEach(function(a) {
							$("<tr><td><img class='classicon' src='data/" + vb[a.c] + ".png'> " + a.n + " </td><td class='detailText'>" + ub[a.r] + (a.r < 2 && Ic.clanrole >= 2 ? " <input data-kick='" + a.n + "' class='clanchange' type='checkbox'" + (a.r > 0 ? "checked" : "") + ">" : "") + "</td><td class='detailText'>" + a.f + " fame</td><td class='detailText'>Lv. " + a.l + "</td><td class='detailText'>" + (1 == a.o ? "Online" : "Offline") + "</td> <td class='detailText'>" + (a.r < Ic.clanrole ? "<button type='button' data-kick='" + a.n + "' class='close clankick' style='font-size:1.0em'><span>&times;</span>" : "") + "</button></td></tr>").appendTo(b)
						}), $(".clankick").on("click", function() {
							wd.emit("ca", {
								a: "kick",
								m: this.dataset.kick
							})
						}), $(".clanchange").on("click", function() {
							return wd.emit("ca", {
								a: "change",
								m: this.dataset.kick
							}), false
						}), 3 == Ic.clanrole ? $("#disbandClanButton").show() : $("#disbandClanButton").hide(), $("#claninfo").show(), $("#clancreation").hide()
						if ($("tr:contains('Officer')")) {
							$(this).css("background-color", "rgba(255, 255, 0, 0.5)");
						}
						if ($("tr:contains('Leader')")) {
							$(this).css("background-color", "rgba(255, 99, 71, 0.5)");
						}
					}
				},
				tb = function(a, b, c) {
					void 0 !== a[b] && (document.getElementById(c).innerHTML = a[b])
				},
				ub = ["Member", "Officer", "Leader", "Owner"],
				vb = ["warrior", "mage", "archer", "shaman"],
				wb = {},
				xb = {},
				yb = function(a) {
					for (i in a) {
						var b = a[i];
						if (b.del) wb[i] && (void 0 !== b.g && (bb(b, "gold", "g", Ic), void 0 !== b.g && cc.gold.text(b.g), void 0 !== b.gd && Y({
							msg: "Sold " + wb[i].name + " for " + b.gd + " $g",
							src: "loot"
						})), delete xb[wb[i].l], delete wb[i]);
						else if (b.mod) {
							if (void 0 !== wb[i]) {
								var c = wb[i].l,
									d = b.l;
								void 0 !== b.l && (xb[c] === wb[i] && (xb[c] = void 0), wb[i].l = d, xb[d] = wb[i])
							}
						} else {
							if (wb[i] = b, wb[i].worth = b.w, wb[i].name = ya[b.u].name[b.t], wb[i].img = ya[b.u].type + "" + b.t + ".png", wb[i].classReqString = "", ya[b.u].class)
								for (var e = 0; e < ya[b.u].class.length; ++e) wb[i].classReqString += t(ya[b.u].class[e] + (e < ya[b.u].class.length - 1 ? ", " : ""));
							if (b.s) {
		//THE GREAT WALL OF LEGUSX
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//b is the item variable
							var swords = ["Wooden Sword","Rusty Ironsword", "Troll Blade", "Broadsword ", "Longsword", "Carved Bonesword", "Greatsword", "Ghastly Scimitar", "Nullfire Sword", "Knight's Greatsword", "King's Glaive", "Void Blade", "Zerstörer","Hearteater", "Demonedge", "Excalibur", "Harbinger"]
							var swordmaxdmg = ["4-6","5-8","9-14","12-19","16-25","21-32","24-38","28-43","32-49","36-55","40-61","43-66","47-72","51-78","55-84","58-89","62-95"]
							var swordcrit = ["2.1","2.4","3.1","3.8","4.5","5.4","6.1","6.8","7.5","8.2","9","9.7","10.4","11.1","11.8","12.6","13.3"]
							var talismans = ["Smelly Talisman", "Guided Talisman", "Ocean Talisman", "Qui'ton", "Dimension Talisman"]
							var talimp = ["11", "35", "59", "83", "107"]
							var talimpregen = ["0.8", "2.8", "4.8", "6.8", "8.8"]
							var shields = ["Wooden Shield", "Buckler", "Old Bulwark", "Metal Guard", "Protecteron"]
							var shielddef = ["17", "31", "55", "91", "121"]
							var shieldhp = ["9", "13", "21", "33", "43"]
							var shieldhpregen = ["0.2", "0.8", "1.8", "3.3", "4.5"]
							var quivers = ["Linen Quiver", "Reinforced Quiver", "Last Reserves", "Lotharien", "Snake Quiver"]
							var quivercrit = ["0.9", "2.5", "4.1", "5.7", "7.3"]
							var quivermv = ["0.3", "0.9", "1.5", "2.1", "2.7"]
							var rings = ["Woven Band", "Ironbark Circlet", "Brass Ringlet", "Hollowed Bone", "Elven Band", "Imbued Circlet", "Arcane Ring", "Emerald Band", "Infernal Ring", "Ancient Talisman", "Hallowed Relic", "Cantor's Trinket", "Peacekeeper"]
							var ringhpregen = ["0.2", "0.4", "0.8", "1.3", "1.7", "2.2", "2.7", "3.2", "3.6", "4.1"]
							var ringmpregen = ["0.2", "0.4", "0.8", "1.3", "1.7", "2.2", "2.7", "3.2", "3.6", "4.1"]
							var boots = ["Sandals", "Cloth Footpads", "Leather Boots", "Bone Greaves", "Scaled Treads", "Patterned Greaves", "Wartorn Boots", "Imbued Treads", "Skyswift Boots", "Coldforged Greaves", "Cloudrunner Treads", "Boots of Hermes", "Starshard Greaves"]
							var bootdef = ["2", "4", "7", "9", "12", "15", "18", "21", "23", "26"]
							var boothp = ["3", "5", "8", "10", "13", "16", "19", "22", "24", "27"]
							var bootmv = ["0.1", "0.2", "0.4", "0.6", "0.8", "0.9", "1.2", "1.3", "1.5", "1.7"]
							var braclets = ["Simple Bracelet", "Makeshift Brace", "Leather Armlet", "Ivory Bracelet", "Iron Vambrace", "Imbued Bracers", "Ember Cuffs", "Mirrored Armlet", "Golem Fragment", "Coldforged Bracer", "Blackstar Gem", "Eternal Vambraces", "Lost Guardian"]
							var bracletdef = ["2", "5", "8", "12", "16", "19", "24", "27", "31", "34"]
							var braclethp = ["3", "5", "8", "11", "13", "16", "19", "22", "25", "27"]
							var bracletmp = ["6", "12", "21", "30", "39", "48", "59", "68", "77", "86"]
							var bracletmpregen = ["0.3", "0.6", "1", "1.5", "1.9", "2.4", "2.9", "3.4", "3.8", "4.3"]
							var gloves = ["Hand Wraps", "Cloth Mitts", "Leather Gloves", "Bone Grips", "Iron Gauntlets", "Imbued Gloves", "Wartorn Mitts", "Fiery Handguards", "Gloves of Empowerment ", "Coldforged Fists", "Eternal Gauntlets", "Gloves of Midas", "Titan's Mitts"]
							var glovedef = ["2", "4", "7", "10", "13", "15", "19", "21", "24", "27"]
							var glovecrit = ["0.3", "0.6", "1.1", "1.5", "2", "2.4", "3", "3.4", "3.9", "4.3"]
							var glovehp = ["3", "6", "10", "13", "17", "21", "25", "29", "32", "36"]
							var armor = ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather", "Scaled Chestguard", "Sky Cloak", "Shadow Cloak", "Obsidian Cloak", "Hellfire Cloak", "Soulkeeper", "Deathless"]
							var armordef = ["6", "13", "21", "29", "37", "46", "55", "64", "72", "80", "88"]
							var armorhp = ["11", "21", "32", "42", "53", "64", "77", "88", "99", "110", "120"]
							var armorhpregen = ["0.6", "1.4", "1.9", "2.3", "2.8", "3.3", "3.8", "4.2", "4.7", "5.1"]
							var bows = ["Driftwood Shortbow", "Novice Shortbow", "Curved Shortbow", "Adventurer's Shortbow", "Long Bow", "Bone Bow", "Elven Bow", "Ancient Bow", "Iron Piercer", "Silver Recurve", "Assassin's Bow", "Skyfire Warbow", "Hellfire Warbow", "Widowmaker", "Stormsong", "Scarebow", "Fury"]
							var bowmaxdmg = ["2-4","5-9","9-15","14-21","18-27","23-34","27-40","31-46","35-52","40-57","44-63","48-69","52-75","56-81","61-87","65-93","69-99"]
							var bowcrit = ["3.2", "3.9", "4.8", "5.7", "6.6", "7.7", "8.6", "9.5", "10.4", "11.3", "12.2", "13.1", "14", "14.9", "15.8", "16.7", "17.6"]
							var hammers = ["Splintered Club", "Wooden Mallet", "Rusty Flail", "Orcish Bludgeon", "Heavy Mace", "Iron Basher", "Darkmetal Maul", "Divine Gavel", "Hallowed Hammer", "Dwarfen Maul", "Coldforged Gavel", "Amboss", "Skullshatterer", "Benevolence ", "Hammer of Gaia", "Worldender", "Nightmare"]
							var hammermaxdmg = ["2-5","4-8","8-13","11-18","15-22","19-28","23-33","26-38","30-42","33-47","37-52","41-57","44-62","48-66","51-71","55-76","59-81"]
							var hammermpregen = ["1.1", "1.3", "1.6", "1.9", "2.2", "2.5", "2.8", "3.1", "3.4", "3.7", "4", "4.3", "4.6", "4.9", "5.2", "5.5", "5.8"]
							var staffs = ["Broken Twig", "Cracked Stick", "Gnarled Broomstick", "Oak Stave", "Mystic Wand", "Bone Stave", "Encrusted Rod", "Imbued Staff", "Emerald Staff", "Sapphire Staff", "Frozen Greatstaff", "Infernal Staff", "Hellfire Greatsaff", "Staff of Angelness ", "Crystal Core", "Witch's Heart", "Deathweaver"]
							var staffmaxdmg = ["3-4","5-8","10-16","15-24","20-32","25-41","30-49","35-57","40-65","45-73","50-81","55-89","60-97","64-105","69-113","74-120","79-128"]
							var staffcrit = ["2.1", "2.4", "3", "3.6", "4.2", "4.9", "5.5", "6.1", "6.7", "7.3", "7.9", "8.5", "9.1", "9.7", "10.3", "10.9", "11.5"]
							var staffmp = ["6", "8", "13", "18", "23", "28", "33", "38", "43", "47", "52", "57", "62", "67", "71", "76", "81"]
							var staffmpregen = ["0.6", "0.7", "1", "1.3", "1.6", "2", "2.3", "2.6", "2.9", "3.2", "3.5", "3.8", "4.1", "4.4", "4.7", "5", "5.3"]
								var xItem = {}
								if (swords.includes(b.name)) {
								  xItem.dmg = swordmaxdmg[swords.indexOf(b.name)]
								  xItem.crit = swordcrit[swords.indexOf(b.name)]
								} else if (talismans.includes(b.name)) {
								  xItem.mp = talimp[talismans.indexOf(b.name)]
								  xItem.mpregen = talimpregen[talismans.indexOf(b.name)]
								} else if (shields.includes(b.name)) {  
								  xItem.def = shielddef[shields.indexOf(b.name)]
								  xItem.hp = shieldhp[shields.indexOf(b.name)]
								  xItem.hpregen = shieldhpregen[shields.indexOf(b.name)]
								} else if (quivers.includes(b.name)) {  
								  xItem.crit = quivercrit[quivers.indexOf(b.name)]
								  xItem.mv = quivermv[quivers.indexOf(b.name)]
								} else if (rings.includes(b.name)) { 
								  xItem.hpregen = ringhpregen[rings.indexOf(b.name)]
								  xItem.mpregen = ringmpregen[rings.indexOf(b.name)]
								} else if (boots.includes(b.name)) { 
								  xItem.def = bootdef[boots.indexOf(b.name)]
								  xItem.hp = boothp[boots.indexOf(b.name)]
								  xItem.mv = bootmv[boots.indexOf(b.name)]
								} else if (braclets.includes(b.name)) {
								  xItem.def = bracletdef[braclets.indexOf(b.name)]
								  xItem.hp = braclethp[braclets.indexOf(b.name)]
								  xItem.mp = bracletmp[braclets.indexOf(b.name)]
								  xItem.mpregen = bracletmpregen[braclets.indexOf(b.name)]
								} else if (gloves.includes(b.name)) {
								  xItem.def = glovedef[gloves.indexOf(b.name)]
								  xItem.crit = glovecrit[gloves.indexOf(b.name)]
								  xItem.hp = glovehp[gloves.indexOf(b.name)]
								} else if (armor.includes(b.name)) {
								  xItem.hp = armorhp[armor.indexOf(b.name)]
								  xItem.def = armordef[armor.indexOf(b.name)]
								  xItem.hpregen = armorhpregen[armor.indexOf(b.name)]
								} else if (bows.includes(b.name)) {
								  xItem.dmg = bowmaxdmg[bows.indexOf(b.name)]
								  xItem.crit = bowcrit[bows.indexOf(b.name)]
								} else if (hammers.includes(b.name)) {
								  xItem.dmg = hammermaxdmg[hammers.indexOf(b.name)]
								  xItem.mpregen = hammermpregen[hammers.indexOf(b.name)]
								} else if (staffs.includes(b.name)) {
								  xItem.dmg = staffmaxdmg[staffs.indexOf(b.name)]
								  xItem.crit = staffcrit[staffs.indexOf(b.name)]
								  xItem.mp = staffmp[staffs.indexOf(b.name)]
								  xItem.mpregen = staffmpregen[staffs.indexOf(b.name)]
								} else {
								  xItem.dmg = "???"
								  xItem.def = "???"
								  xItem.hp = "???"
								  xItem.hpregen = "???"
								  xItem.mp = "???"
								  xItem.mpregen = "???"
								  xItem.crit = "???"
								}
								var f = "";
								window.b = b;
								window.xItem = xItem;
								b.s.dmgtext = b.s.mindmg + "-" +b.s.maxdmg;
								b.s.dmgtext = b.s.mindmg + "-" +b.s.maxdmg;
                        b.s.mindmg && b.s.maxdmg && (f += "<span "+((b.s.dmgtext == xItem.dmg) ? 'style="color: #ffbd24;">' : ">") +b.s.mindmg + " - " + b.s.maxdmg + " Damage</span> <span><em>Max: "+xItem.dmg+"</em></span><br>"), b.s.def && (f += "<span "+((b.s.def == xItem.def) ? 'style="color: #ffbd24;">' : ">")+b.s.def + " Defense</span> <span><em>Max: "+xItem.def+"</em></span><br>"), b.s.hp && (f += "<span "+((b.s.hp == xItem.hp) ? "style='color: #ffbd24;'>" : ">")+b.s.hp + " HP</span> <span><em>Max: "+xItem.hp+"</em></span><br>"), b.s.hpreg && (f += "<span "+((b.s.hpreg == xItem.hpregen) ? 'style="color: #ffbd24;">' : ">")+b.s.hpreg + "/s HP Reg.</span> <span><em>Max: "+xItem.hpregen+"</em></span><br>"), b.s.mp && (f += "<span "+((b.s.mp == xItem.mp) ? 'style="color: #ffbd24;">' : ">")+b.s.mp + " MP</span> <span><em>Max: "+xItem.mp+"</em></span><br>"), b.s.mpreg && (f += "<span "+((b.s.mpreg == xItem.mpregen) ? 'style="color: #ffbd24;">' : ">")+b.s.mpreg + "/s MP Reg.</span> <span><em>Max: "+xItem.mpregen+"</em></span><br>"), b.s.crit && (f += "<span "+((b.s.crit == xItem.crit) ? 'style="color: #ffbd24;">' : ">")+b.s.crit + "% Critical</span> <span><em>Max: "+xItem.crit+"%</em></span><br>"), b.s.move && (f += "<span "+((b.s.move == xItem.mv) ? 'style="color: #ffbd24;">' : ">")+b.s.move + " Move speed</span> <span><em>Max: "+xItem.mv+"</em></span>"), wb[i].statText = f
                    }
							wb[i].minlvl = ya[b.u].lvl[b.t], wb[i].l && (xb[wb[i].l] = wb[i])
						}
					}
					Ib()
				},
				zb = function(a, b) {
					void 0 !== xb[a] && void 0 === Db && (Db = xb[a], Eb.css("display", "block"), Eb.html($(b.firstChild).clone()))
				},
				Ab = function() {
					Eb.css("display", "none"), Db = void 0
				},
				Bb = 21,
				Cb = {},
				Db = void 0,
				Eb = void 0,
				Fb = {},
				Gb = function() {
					Eb = $("#mouseItemDiv"), $(".uiclosebutton").click(function(a) {
						$(this).parent().hide()
					}), Cb = {}, window.addEventListener("mouseup", q, false), Pb(document.getElementById("characterpanel")), Pb(document.getElementById("inventory"));
					var a = $("#character-items");
					a.html(""), xa.forEach(function(b) {
						var c = $("<div/>");
						Cb[b] = c, c.appendTo(a)
					});
					var b = $("#inventory-items");
					b.html("");
					for (var c = 0; c < Bb; ++c) {
						var d = $("<div/>");
						Cb[c] = d, d.appendTo(b)
					}
					for (c in Cb) Cb[c].mouseover({
						slot: c
					}, function(a) {
						var b = xb[a.data.slot];
						if (b) {
							var c = this.getBoundingClientRect();
							c.left < 200 ? (pb.css("left", c.left - 2), pb.css("right", "")) : (pb.css("right", za.width - c.left - 2), pb.css("left", "")), pb.css("bottom", za.height - c.top - 2), Jb.itemname.text(b.name), Jb.description.text(ya[b.u].description), b.statText ? (Jb.stats.html(b.statText), Jb.stats.css("display", "block")) : Jb.stats.css("display", "none"), Jb.requirements.html(""), Jb.requirements.append("<span class='" + (Ic.class.level >= b.minlvl ? "statReq" : "statReqMiss") + "'> Requires level " + b.minlvl + " </span>" + ("" != b.classReqString ? "<br><span class='" + (ya[b.u].class.indexOf(Ic.class.type) > -1 ? "statReq" : "statReqMiss") + "'> Class: " + b.classReqString + " </span>" : "") + "<h5 class='detailText'> Sells for " + b.worth + " <img src='data/coin.png' class='goldCoin'></h5>"), pb.css("display", "block")
						} else pb.css("display", "none");
						return false
					}), Cb[c].mouseout({
						slot: c
					}, function(a) {
						return pb.css("display", "none"), 1 == a.buttons && zb(a.data.slot, this), false
					}), Cb[c].mousedown({
						slot: c
					}, function(a) {
						return 0 == a.button, false
					}), Cb[c].mouseup({
						slot: c
					}, function(a) {
						0 === a.which || 0 === a.button ? void 0 === Db ? zb(a.data.slot, this) : (wd.emit("i", {
							i: Db.l,
							a: "m",
							t: a.data.slot
						}), Ab()) : 3 !== a.which && 2 !== a.button || wd.emit("i", {
							i: a.data.slot,
							a: Lb ? "s" : "u"
						})
					});
					var e = $("<div/>", {
						id: "character-icon"
					});
					e.appendTo(a), Fb.charName = $("<h4/>"), Fb.charName.appendTo(e),
						Fb.charImg = $("<img/>", {
							class: "charPanelIcon"
						}), Fb.charImg.appendTo(e), Fb.power = $("#stat_power"), Fb.crit = $("#stat_crit"), Fb.def = $("#stat_def"), Fb.hp = $("#stat_hp"), Fb.hpr = $("#stat_hpr"), Fb.mp = $("#stat_mp"), Fb.mpr = $("#stat_mpr"), Fb.ms = $("#stat_ms"), Fb.lvl = $("#stat_lvl"), Fb.fame = $("#stat_fame"), Kb(), Ib(), $("#invtrashcan, #trader").mouseup({
							slot: c
						}, function(a) {
							void 0 !== Db && (wd.emit("i", {
								i: Db.l,
								a: Lb ? "s" : "t"
							}), Ab())
						})
				},
				Hb = function() {
					for (i in wb) delete xb[wb[i].l], delete wb[i]
				},
				Ib = function() {
					for (s in Cb)
						if (void 0 !== xb[s]) {
							Cb[s].get(0).className = "item" + (isNaN(s) ? " equipslot slot_" + s + " clearslot" : "");
							var a = $("<img/>", {
								class: ya[xb[s].u].rotatedSprite ? "itemPic itemPicRotated" : "itemPic"
							});
							a.attr("src", "data/items/" + xb[s].img), Cb[s].html(a), Cb[s].item = xb[s]
						} else Cb[s].get(0).className = "itemEmpty" + (isNaN(s) ? " equipslot slot_" + s : ""), Cb[s].html(""), Cb[s].item = void 0
				},
				Jb = {},
				Kb = function() {
					pb = $("#itemview"), Jb.itemname = $("<p/>", {
						class: "itemName"
					}), pb.append(Jb.itemname), Jb.description = $("<p/>", {
						class: "itemDescription"
					}), pb.append(Jb.description), Jb.stats = $("<p/>", {
						class: "itemStat"
					}), pb.append(Jb.stats), Jb.requirements = $("<p/>", {
						class: "itemRequirements"
					}), pb.append(Jb.requirements)
				},
				Lb = false,
				Mb = void 0,
				Nb = 0,
				Ob = 0,
				Pb = function(a) {
					a.addEventListener("mousedown", function(b) {
						Mb = a, Nb = b.pageX - $(this).offset().left, Ob = b.pageY - $(this).offset().top, window.addEventListener("mousemove", r, true)
					}, false)
				},
				Qb = [],
				Rb = function(a) {
					for (var b = Qb.length; b--;) {
						var c = Qb[b];
						c.tick(a), c.deleteMe && (c.remove(), Qb.splice(b, 1))
					}
				};
			Va || (u.prototype.visualtick = function(a) {
				this.geometry.position.copy(this.position), this.target && this.target.geometry && this.geometry.lookAt(this.target.chest ? this.target.chest.getWorldPosition() : this.target.position)
			}), u.prototype.tick = function(a) {
				switch (this.mode) {
					case "attach":
						void 0 === this.target || this.target.stats.isDead() ? this.deleteMe = true : Va || !this.target.chest ? this.position.copy(this.target.position) : this.position.copy(this.target.chest.getWorldPosition());
					case "static":
						this.effectCallback && this.effectInterval > 0 && (this.effectTimer -= a, this.effectTimer < 0 && (this.effectTimer = this.effectInterval, this.effectCallback({
							spell: this,
							target: this.target,
							source: this.source
						}))), "static" == this.mode && this.movedir && (this.position.x += this.movedir.x * this.movespeed * a, this.position.y += this.movedir.y * this.movespeed * a, this.position.z += this.movedir.z * this.movespeed * a);
						break;
					case "follow":
						if (void 0 != this.target) {
							var b = new THREE.Vector3;
							Va || !this.target.chest ? b.subVectors(this.target.position, this.position) : b.subVectors(this.target.chest.getWorldPosition(), this.position);
							var c = b.lengthSq();
							c > Math.pow(this.movespeed * a, 2) ? (b.normalize(), b.multiplyScalar(this.movespeed * a), this.position.x += b.x, this.position.z += b.z, this.position.y += b.y) : (this.effectCallback && this.effectCallback({
								spell: this,
								target: this.target
							}), this.deleteMe = true)
						} else this.deleteMe = true
				}!Va && this.visualtick && this.visualtick(a), this.timeout > 0 && (this.timeout -= a, this.timeout <= 0 && (this.deleteMe = true))
			}, u.prototype.remove = function() {
				Va || (ca(this.geometry), Ac.remove(this.geometry), this.geometry = void 0, this.ribbonObject && this.ribbon.deleteWithSpell && (this.ribbonObject.deleteMe = true, this.ribbonObject = void 0))
			}, j.prototype.useSkill = function(a, b) {
				var c = false;
				if (0 == this.state.id || !Va && b) switch (a) {
					case "test":
					case "sit":
					case "logOut":
						break;
					default:
						if (this.class && this.class.skills.hasOwnProperty(a)) {
							var d = true;
							if (!Va && b && 1 == this.state.id)
								if (d = false, this.state.skill.slot != a) this.class.skills[a].interruptCast(), this.state = new A, d = true;
								else {
									var e = this.state.duration / this.state.maxduration;
									this.state.maxduration += this.state.skill.casttime - this.state.duration, this.state.duration = this.state.maxduration * e
								}
							d && this.class.skills[a].cast(Va ? void 0 : b) && (c = true)
						}
				} else 1 != this.state.id || !Va && b && !(this.state.duration < .5 * this.state.maxduration) || (this.queuedSkill = a);
				(c && Va && (1 == b || this.class.ai) || !Va && this == Ic && !b) && (this.serverMsgQueue.ab || (this.serverMsgQueue.ab = []), this.serverMsgQueue.ab.push(a))
			}, v.prototype.tick = function(a) {
				this.class.parent && (this.parent = this.class.parent), this.isOnCooldown() && (this.cooldowntimer -= a), this.isCasting() ? (this.casttimer -= a, this.casttimer <= 0 ? Va ? this.endCast(false) : this.casttimer = .01 : Va || this.addCastAnimation(), this.targetIsValid() || Va && this.interruptCast()) : Va || this.removeCastAnimation(), this.isChanneling() && (this.channelTimer -= a, this.channelInterval > 0 && (this.channelIntervalTimer -= a, this.channelIntervalTimer <= 0 && (this.hasChanneledSpell && this.channelspell ? this.channelspell.effectCallback({
					spell: this.channelspell,
					target: this.channelspell.target
				}) : this.confirmEffect(), this.channelIntervalTimer = this.channelInterval)), this.channelTimer <= 0 && (Va || this.removeChannelAnimation()), this.targetIsValid() || (Va || this.ignoreEc) && this.interruptChannel()), !Va && this.uielement && this.updateUiElement()
			}, v.prototype.addCastAnimation = function() {
				this.castAnimationActive || (this.castAnimation.deleteMe = false, this.castAnimation.timer = 0, this.parent.animationQueue.push(this.castAnimation), this.castAnimationActive = true)
			}, v.prototype.removeCastAnimation = function() {
				if (this.castAnimationActive) {
					var a = this.parent.animationQueue.indexOf(this.castAnimation);
					a > -1 && this.parent.animationQueue.splice(a, 1), this.castAnimationActive = false
				}
			}, v.prototype.addChannelAnimation = function() {
				this.channelAnimationActive || (this.channelAnimation.deleteMe = false, this.channelAnimation.timer = 0, this.parent.animationQueue.push(this.channelAnimation), this.channelAnimationActive = true)
			}, v.prototype.removeChannelAnimation = function() {
				if (this.channelAnimationActive) {
					var a = this.parent.animationQueue.indexOf(this.channelAnimation);
					a > -1 && this.parent.animationQueue.splice(a, 1), this.channelAnimationActive = false
				}
			}, v.prototype.cast = function(a) {
				if (this.parent && (a || this.level > 0 && !this.isOnCooldown() && !this.isCasting() && !this.isChanneling())) {
					var b = false;
					switch (this.casttarget = this.parent.target, this.targettype) {
						case "enemy":
							b = void 0 !== this.casttarget && this.casttarget.faction != this.parent.faction && !this.casttarget.stats.isDead(), Va || b || this.parent != Ic || !sd || (Ic.target = sd);
							break;
						case "friendly":
							void 0 != this.casttarget && this.casttarget.faction == this.parent.faction || (this.casttarget = this.parent, this.parent.target = this.parent), b = this.casttarget.faction == this.parent.faction;
							break;
						case "none":
							b = true;
							break;
						default:
							console.log("error (" + this.name + "): unknwon target type:" + this.targettype)
					}
					if (b && (!!Va || this.predict) || a) switch (this.casttype) {
						case "timed":
							return !(!a && !this.targetIsValid()) && (this.startCast(), this.causeGlobalCooldown && this.class.globalCooldown(), true);
						case "instant":
							if ("channel" == this.effecttype) {
								var c = !this.spell || this.confirmEffect(false);
								return this.startChannel(), c
							}
							return this.confirmEffect(false)
					}
				}
				return false
			}, v.prototype.targetIsValid = function(a) {
				if (void 0 === a && (a = this.casttarget), "none" != this.targettype && void 0 != a) {
					if (!this.allowDeadTarget && a.stats.isDead()) return false;
					if ("enemy" == this.targettype && this.parent != a && !ib(this.parent, a).canFight()) return false;
					var b = this.parent != a ? ib(this.parent, a).distance() : 0;
					return b <= (this.isCasting() ? 1.1 * this.maxrange : this.maxrange) + (Va ? 1.5 : 1.3)
				}
				return true
			}, v.prototype.confirmEffect = function(a) {
				if (Va || this.removeCastAnimation(), this.effect && this.targetIsValid()) {
					if (this.cooldowntimer <= 0 && !this.consumeMana()) return false;
					if (this.cooldowntimer = Math.max(this.cooldown, this.cooldowntimer), this.causeGlobalCooldown && this.class.globalCooldown(), this.spell) {
						var b = this.spell(this.casttarget, this.parent, this.effectWrapper);
						b && Qb.push(b), this.hasChanneledSpell && (this.channelspell = b), this.unique && (void 0 != this.oldspell && (this.oldspell.deleteMe = true), this.oldspell = b)
					} else this.effectWrapper({
						isParse: a
					});
					return this.simulate == !a && !Va && "channel" != this.effecttype && this.parent && this.parent.animationQueue.push(this.getCharacterAnim()), true
				}
				return false
			}, v.prototype.consumeMana = function() {
				return this.parent && this.parent.stats && this.parent.stats.useMana(this.manacost * this.parent.stats.basemana)
			}, v.prototype.hasEnoughMana = function() {
				return this.parent && this.parent.stats && this.parent.stats.currentmp > this.manacost * this.parent.stats.basemana
			}, v.prototype.endCast = function(a) {
				Va ? (this.parent.serverMsgQueue.ec || (this.parent.serverMsgQueue.ec = []), this.parent.serverMsgQueue.ec.push(this.slot), this.parent.addPersonalMessage("ec", this.slot)) : this.casttimer <= .1 * this.casttime && (this.casttimer = -1);
				var b = false;
				void 0 != this.casttarget && (this.parent.target != this.casttarget || Va && !this.targetIsValid()) ? this.interruptCast() : (b = true, this.confirmEffect(a)), "channel" == this.effecttype && b && this.startChannel()
			}, v.prototype.interruptCast = function() {
				Va || this.removeCastAnimation(), Va && this.parent && this.parent.addServerMessage("abi", this.slot), this.casttimer = -1
			}, v.prototype.interruptChannel = function() {
				Va || this.removeChannelAnimation(), Va && this.parent && this.parent.addServerMessage("abi", this.slot), this.channelspell && (this.channelspell.deleteMe = true, this.channelspell = void 0), this.channelTimer = -1
			}, v.prototype.isCasting = function() {
				return this.casttimer > 0
			}, v.prototype.isOnCooldown = function() {
				return this.cooldowntimer > 0
			}, v.prototype.isChanneling = function() {
				return this.channelTimer > 0
			}, v.prototype.configureUiElements = function(a, b, c) {
				this.uielement = a, this.uielement.attr("src", this.icon), this.uielementOverlay = b, this.uielementCooldown = c, this.uielementOverlay.addClass("skillOverlayDisable"), this.uielementCooldown.css("display", "none")
			}, v.prototype.updateUiElement = function() {
				if (this.uielement) {
					if (this.level > 0) {
						var a = !this.targetIsValid(Ic.target),
							b = !this.hasEnoughMana(),
							c = this.isOnCooldown();
						if (this.oldIsOnCooldown == c && this.oldIsOom == b && this.oldIsInvalid == a || (this.oldIsOnCooldown = c, this.oldIsOom = b, this.oldIsInvalid = a, this.uielementOverlay.css("display", a || c || b ? "block" : "none"), this.uielementCooldown.css("display", a || c || b ? "block" : "none")), c || b || a) {
							var d = "";
							b && (d = "MP"), c && (d = this.cooldowntimer < 10 ? ("" + this.cooldowntimer).substring(0, 3) : parseInt(this.cooldowntimer)), this.uielementCooldown.html(d)
						}
					}
					if (this.oldCanLevelUp != this.canLevelUp() && (this.oldCanLevelUp = this.canLevelUp(), 1 == this.oldCanLevelUp)) {
						var e = $("#skillLevelButton" + this.slot);
						jc(e, this.slot), e.fadeIn(1500), e.fadeOut(1500), e.fadeIn(1500), e.fadeOut(1500)
					}
				}
			}, v.prototype.globalCooldown = function(a) {
				this.cooldowntimer = Math.max(this.cooldowntimer, a)
			}, v.prototype.startCast = function() {
				this.casttimer = this.casttime, this.parent.state = new B({
					skill: this,
					casttime: this.casttime,
					activeCheck: this.isCasting,
					interrupt: this.interruptCast
				}), Va || (this.removeCastAnimation(), this.addCastAnimation())
			}, v.prototype.startChannel = function() {
				this.parent && (this.channelTimer = this.channelDuration, this.channelIntervalTimer = this.channelInterval, this.parent.state = new B({
					skill: this,
					casttime: this.channelTimer,
					activeCheck: this.isChanneling,
					interrupt: this.interruptChannel
				}), this.channelInstantFirstTick && (this.hasChanneledSpell ? this.channelspell && this.channelspell.effectCallback({
					spell: this.channelspell,
					target: this.channelspell.target
				}) : this.confirmEffect()), Va || (this.removeChannelAnimation(), this.addChannelAnimation(), this.onCastFun && this.onCastFun()))
			}, v.prototype.setInfoPanel = function(a) {
				var b = this;
				ec[a] = function() {
					var a = "<h5 class='skillName'>" + b.name + "<small> " + b.casttype + " cast </small></h5><p class='skillDescription'>" + b.description + "</p>" + (0 == b.level ? "Press the green button to level up this skill! <br>" : "<p class='skillLvlInfo'>" + parseInt(100 * b.abilitypower) + "% ability effect <br> Level: " + b.level + " <br>Mana cost: " + parseInt(b.manacost * b.parent.stats.basemana) + " <br>Cooldown: " + b.cooldown + " Seconds <br>") + "<span class=" + (b.parent.gold >= b.nextLevelCost ? "skillReq" : "skillReqMiss") + "> Upgrade cost: " + b.nextLevelCost + " " + dc.goldCoin + "</span><br><span class=" + (b.parent.class.level >= b.levelUpMinLevel ? "skillReq" : "skillReqMiss") + "> Minimum character level: " + b.levelUpMinLevel + "</span></p>";
					return a
				}
			}, v.prototype.setLevel = function(a) {
				var b = this.level;
				this.level = a, this.nextLevelCost = parseInt(Math.pow((a + 1) * (a + 3), 1.9)), this.levelUpMinLevel = Math.max(0, Math.round(4 * (this.level - 4))), this.abilitypower = this.getAbilityPowerAtLevel(a), Va && this.parent && this.parent.addPersonalMessage("sl", {
					i: this.slot,
					l: this.level
				}), !Va && 0 == b && this.level > 0 && Ic && this.parent == Ic && this.uielementOverlay.removeClass("skillOverlayDisable")
			}, v.prototype.canLevelUp = function() {
				return this.parent.gold >= this.nextLevelCost && this.parent.class.level >= this.levelUpMinLevel
			}, v.prototype.tryLevelUp = function() {
				return !!this.parent && void(Va ? this.canLevelUp() && this.parent.tryModifyGold(-this.nextLevelCost) && this.setLevel(this.level + 1) : this.parent.serverMsgQueue.lus = this.slot)
			}, v.prototype.getAbilityPowerAtLevel = function(a) {
				return .5 + .1 * a
			}, w.prototype.tick = function(a) {
				Va && (this._invincible = false, this._incapacitated = false, this._stunned = false, this._healmod = 1, this.currenthp < this.maxhp && (this.periodicTickTimerHP -= a), this.periodicTickTimerHP <= 0 && (this.hpregen < 1 ? (this.periodicTickTimerHP = 1 / this.hpregen, this.parent.takeHealing(1)) : (this.periodicTickTimerHP = 1, this.parent.takeHealing(this.hpregen))), this.currentmp < this.maxmp && (this.periodicTickTimerMP -= a), this.periodicTickTimerMP <= 0 && (this.mpregen < 1 ? (this.periodicTickTimerMP = 1 / this.mpregen, this.gainMana(1)) : (this.periodicTickTimerMP = 1, this.gainMana(this.mpregen))));
				for (var b = this.mods.length; b--;) this.mods[b].tick(a, this), this.mods[b].deleteMe && this.mods.splice(b, 1);
				Va && (this.invincible = this._invincible, this.incapacitated = this._incapacitated, this.stunned = this._stunned, this.healmod = this._healmod), Va || this.servermovespeed && (this.movespeed = this.servermovespeed)
			}, w.prototype.canBeAttacked = function(a) {
				return !(this.isDead() || a && a.faction == parent.faction)
			}, w.prototype.isDead = function() {
				return 2 == this.parent.state.id || this.currenthp <= 0
			}, w.prototype.spawn = function() {
				this.currenthp = this.maxhp, this.currentmp = this.maxmp
			}, w.prototype.clearBuffs = function() {
				for (var a = this.mods.length; a--;) this.mods[a].deleteMe = true
			}, w.prototype.reset = function() {
				this.currenthp = this.maxhp, this.currentmp = this.maxmp, this.clearBuffs()
			}, w.prototype.addMod = function(a) {
				if ((1 == a.overwrite || 1 == a.unique) && void 0 !== a.id)
					for (m in this.mods) this.mods.hasOwnProperty(m) && this.mods[m].id == a.id && (a.unique ? this.mods[m].deleteMe = true : a.overwrite && this.mods[m].source == a.source && (this.mods[m].deleteMe = true));
				this.mods.push(a)
			}, w.prototype.queryMod = function(a) {
				for (var b = [], c = this.mods.length; c--;) {
					var d = this.mods[c];
					a.source && d.source != a.source || a.id && d.id != a.id || b.push(d)
				}
				return b
			}, y.prototype.tick = function(a, b) {
				this.timer -= a, this.timer <= 0 && (this.deleteMe = true), this.effectinterval > 0 && void 0 != this.effectfunction && (this.effecttimer -= a, this.effecttimer <= 0 && (this.effectfunction(), this.effecttimer = this.effectinterval)), this.deleteMe || Va && (this.invincible && (b._invincible = true), this.incapacitate && (b._incapacitated = true), this.stun && (b._stunned = true), this.healmod && (b._healmod = this.healmod(b._healmod)), this.movespeed && (b.movespeed = this.movespeed(b.movespeed)))
			}, w.prototype.gainMana = function(a) {
				this.isDead() || (this.currentmp += parseInt(a), this.currentmp > this.maxmp && (this.currentmp = this.maxmp))
			}, w.prototype.useMana = function(a) {
				return !this.isDead() && (a = parseInt(a), !(this.currentmp < a) && (this.currentmp -= a, true))
			}, A.prototype = new z, A.prototype.constructor = A, B.prototype = new z, B.prototype.constructor = B, C.prototype = new z, C.prototype.constructor = C, K.prototype.skills = {}, K.prototype.getMaxHp = function() {
				return parseInt(70 + 3 * this.level)
			}, K.prototype.getMaxMp = function() {
				return parseInt(30 + 2 * this.level)
			}, K.prototype.getMinDmg = function() {
				return parseInt(2 + .2 * this.level)
			}, K.prototype.getMaxDmg = function() {
				return parseInt(3 + .3 * this.level)
			}, K.prototype.getMovespeed = function() {
				return 8
			}, K.prototype.getCrit = function() {
				return 2 + .005 * this.level
			}, K.prototype.getHpRegen = function() {
				return .3 + .1 * this.level
			}, K.prototype.getMpRegen = function() {
				return .5 + .2 * this.level
			}, K.prototype.getDefense = function() {
				return parseInt(80 + 2 * this.level)
			}, K.prototype.getScale = function() {
				return 1 + .005 * this.level
			}, K.prototype.globalCooldown = function() {
				for (skill in this.skills) this.skills.hasOwnProperty(skill) && this.skills[skill].globalCooldown(1.2)
			}, K.prototype.tick = function(a) {
				this.ai && this.ai.tick(a);
				for (skill in this.skills) this.skills.hasOwnProperty(skill) && this.skills[skill].tick(a);
				this.update()
			}, K.prototype.update = function() {
				Va && this.checkLevelUp(), this.scale = this.getScale(), this.stats.basemana = this.getMaxMp(), (Va || Wa) && (this.movespeed = this.getMovespeed(), this.ai && this.statCalcDone || (this.ai && (this.statCalcDone = true), this.mindmg = this.getMinDmg(), this.maxdmg = this.getMaxDmg(), this.maxhp = this.getMaxHp(), this.maxmp = this.stats.basemana, this.hpregen = this.getHpRegen(), this.mpregen = this.getMpRegen(), this.defense = this.getDefense(), this.crit = this.getCrit(), this.parent.inventory && (void 0 !== this.parent.inventory.sum.hp && (this.maxhp += this.parent.inventory.sum.hp), void 0 !== this.parent.inventory.sum.mp && (this.maxmp += this.parent.inventory.sum.mp), void 0 !== this.parent.inventory.sum.mindmg && (this.mindmg += this.parent.inventory.sum.mindmg), void 0 !== this.parent.inventory.sum.maxdmg && (this.maxdmg += this.parent.inventory.sum.maxdmg), void 0 !== this.parent.inventory.sum.def && (this.defense += this.parent.inventory.sum.def), void 0 !== this.parent.inventory.sum.hpreg && (this.hpregen += this.parent.inventory.sum.hpreg), void 0 !== this.parent.inventory.sum.mpreg && (this.mpregen += this.parent.inventory.sum.mpreg), void 0 !== this.parent.inventory.sum.crit && (this.crit += this.parent.inventory.sum.crit), void 0 !== this.parent.inventory.sum.move && (this.movespeed += this.parent.inventory.sum.move))), this.stats.movespeed = this.movespeed, this.stats.maxhp = this.maxhp, this.stats.maxmp = this.maxmp, this.stats.currentmindmg = this.mindmg, this.stats.currentmaxdmg = this.maxdmg, this.stats.hpregen = this.hpregen, this.stats.mpregen = this.mpregen, this.stats.defense = this.defense, this.stats.crit = this.crit), this.stats.scale = this.scale
			}, K.prototype.isCasting = function() {
				for (skill in this.skills)
					if (this.skills.hasOwnProperty(skill) && (this.skills[skill].isCasting() || this.skills[skill].isChanneling())) return true;
				return false
			}, Va || Wa || (K.prototype.headGearOffset = new THREE.Vector3(0, .5, 0), K.prototype.headGearOffsetScale = new THREE.Vector3(.5, .5, .5), K.prototype.initBaseBody = function() {
				this.chest = new THREE.Mesh(kd.chest.geo, this.class.color), this.chest.scale.set(kd.chest.scale[0], kd.chest.scale[1], kd.chest.scale[2]), this.chest.castShadow = true, this.chest.rotation.order = "YXZ", this.chest.cycle = 0, this.chest.material = this.class.color, this.body.add(this.chest);
				var a = new THREE.Mesh(kd.leg.geo, Vc.leg);
				a.scale.set(kd.leg.scale[0], kd.leg.scale[1], kd.leg.scale[2]), Ac.add(a);
				var b = new THREE.Mesh(kd.leg.geo, Vc.leg);
				b.scale.set(kd.leg.scale[0], kd.leg.scale[1], kd.leg.scale[2]), Ac.add(b), this.legs = new THREE.Group, Ac.add(b), this.body.add(this.legs), this.legs.add(b), this.legs.add(a), this.legs.l = a, this.legs.r = b, this.legs.cycle = 0, this.legs.lastVisualPos = new THREE.Vector3;
				var c = new THREE.Mesh(kd.hand.geo, Vc.leg);
				c.scale.set(kd.hand.scale[0], kd.hand.scale[1], kd.hand.scale[2]), Ac.add(c);
				var d = new THREE.Mesh(kd.hand.geo, Vc.leg);
				d.scale.set(kd.hand.scale[0], kd.hand.scale[1], kd.hand.scale[2]), Ac.add(d), this.hands = new THREE.Group, this.hands.cycle = 0, Ac.add(d), this.chest.add(this.hands), this.hands.add(d), this.hands.add(c), this.hands.l = c, this.hands.r = d
			}, K.prototype.initBodyGeometry = function() {
				this.weapon = new THREE.Mesh(kd.generic_sword.geo, Vc.generic_sword), this.weapon.scale.set(kd.generic_sword.scale[0], kd.generic_sword.scale[1], kd.generic_sword.scale[2]), this.weapon.rotation.y = .5, Ac.add(this.weapon), this.weapon.position.set(0, 0, .7), this.chest.add(this.weapon)
			}, K.prototype.tickBaseAnimation = function(a, b, c) {
				var d = new THREE.Vector3;
				d.subVectors(this.visualPosition, this.legs.lastVisualPos);
				var e = this.stats.movespeed * c;
				switch (this.walkForward == -1 && (e *= 1.3), a) {
					case "cast":
						this.hands.cycle = b.timer / b.duration * Ua;
						var f = Math.sin(this.hands.cycle),
							g = Math.cos(this.hands.cycle);
						this.chest.rotation.y = -1 + .05 * f, this.chest.rotation.x = -.2 + .03 * f, this.chest.rotation.z = .2 + .02 * g, this.chest.position.y = .2 * f + .3, this.chest.position.z = -.2, this.hands.r.rotation.set(.3 + .2 * f, .2 * f, 0), this.hands.l.rotation.set(.3 + .2 * g, .2 * -g, 0), this.hands.r.position.set(.3 + .1 * f, -.3 + .1 * f, -.75), this.hands.l.position.set(-.2 - .1 * f, -.1 + .1 * g, -.75);
						break;
					case "channel":
						this.hands.cycle = b.timer / b.duration * Ua;
						var f = Math.sin(this.hands.cycle),
							g = Math.cos(this.hands.cycle);
						this.chest.rotation.y = -.2 + .01 * f, this.chest.rotation.x = .3 + .01 * f, this.chest.rotation.z = -.5 + .01 * g, this.chest.position.y = .1 * f + .3, this.chest.position.z = -.2, this.hands.r.rotation.set(.3 + .05 * f, .2 * f, 0), this.hands.l.rotation.set(.3 + .05 * g, .2 * -g, 0), this.hands.r.position.set(.5 + .05 * f, .3 + .1 * g, -.6), this.hands.l.position.set(-.5 + .05 * f, 1 + .05 * f, -.6);
						break;
					case "release_spell":
						var h = db.easeOutQuint(1 - b.timer / b.duration);
						this.chest.rotation.y = -1 + h, this.chest.rotation.x = -.2 + .2 * h, this.chest.rotation.z = .2 - .2 * h, this.chest.position.y = .3 - .3 * h, this.chest.position.z = -.2 + .2 * h, this.hands.r.rotation.set(.3 - .3 * h, 0, 0), this.hands.l.rotation.set(.3 - .3 * h, 0, 0), this.hands.r.position.set(.35 + .2 * h, 0, -1), this.hands.l.position.set(-.35 - .2 * h, 0, -1);
						break;
					case "release_buff":
						var h = db.easeOutQuint(1 - b.timer / b.duration);
						this.chest.rotation.y = 0, this.chest.rotation.x = 0, this.chest.rotation.z = 0, this.hands.r.rotation.set(1.5 * h, 0, 0), this.hands.l.rotation.set(1.5 * h, 0, 0);
						var i = Math.sin(3 * h);
						this.hands.r.position.set(-.12 - .35 * i, -.1 + .8 * h, -.3 - i), this.hands.l.position.set(.12 + .35 * i, 0 + .8 * h, -.3 - i);
						break;
					case "boost":
						var h = db.easeInOutQuart(.5 + .5 * Math.sin(b.timer / b.duration * Math.PI * 2));
						this.chest.rotation.x = .4 * h, this.hands.r.rotation.set(0, 0, 0), this.hands.l.rotation.set(0, 0, 0), this.hands.r.position.set(.6 + .2 * h, .8 * h, -.3), this.hands.l.position.set(-.6 - .2 * h, .8 * h, -.3);
						break;
					case "swing_melee":
						this.hands.r.position.copy(this.weapon.position), this.hands.r.position.multiplyScalar(.5), this.chest.rotation.set(0, b.timer / b.duration * .5, 0);
						break;
					case "spin":
						this.body.rotation.y = b.timer / b.duration * Math.PI * 4, this.chest.position.z = .3, this.hands.l.position.set(-.2, 0, -1), this.hands.r.position.set(.2, 0, -1);
						break;
					case "dead":
						this.chest.material = Vc.dead, this.body.rotation.x = -(Math.min(this.state.timer, .8) / .8) * Math.PI * .5, this.state.timer > 2 && this.state.timer < 5 && (this.body.position.y -= .2 * c);
						break;
					default:
					case "idle":
						if (this.body.position.set(0, 0, 0), this.body.rotation.set(0, 0, 0), this.chest.position.set(0, 0, 0), this.chest.rotation.set(0, 0, 0), this.walkForward || this.walkSideward) {
							var j = .6;
							this.walkForward == -1 && (j = .3);
							var k = Math.sin(this.legs.cycle);
							this.hands.l.position.set(-.7 + .2 * Math.sin(2 * this.legs.cycle + 5), -.2 + .3 * Math.sin(this.legs.cycle), -.2 + k * j * 1.5), this.hands.r.position.set(.7 - .2 * Math.sin(2 * this.legs.cycle + 5), -.2 + .3 * -Math.sin(this.legs.cycle), -.2 - k * j * 1.5), this.hands.r.rotation.set(0, .5 + .8 * this.hands.l.position.z, 0), this.hands.l.rotation.set(0, -(.5 + .8 * this.hands.r.position.z), 0)
						} else {
							this.hands.rotation.y = 0;
							var f = Math.sin(this.chest.cycle + .5 * Math.PI);
							this.hands.r.rotation.set(0, .43 - .15 * f, -.3), this.hands.l.rotation.set(0, -.43 + .15 * f, .3), this.hands.l.position.set(-.7, -.3 + .08 * f, -.15 + .1 * f), this.hands.r.position.set(.7, -.3 + .08 * f, -.15 + .1 * f)
						}
				}
				switch (this.legs.cycle > Ua ? this.legs.cycle -= Ua : this.legs.cycle < 0 && (this.legs.cycle += Ua), a) {
					case "dead":
						break;
					case "spin":
						this.legs.cycle += 10 * c;
					default:
					case "idle":
						if (this.walkForward || this.walkSideward) {
							var l = .8;
							this.walkForward == -1 && (l = .3), this.legs.rotation.y = -this.rotation + D(new THREE.Vector2(d.x, d.z)), this.legs.cycle += 1.8 * e / this.stats.scale, this.legs.l.position.set(-.3, Math.max(0, .6 * Math.cos(this.legs.cycle)) + .1, Math.sin(-this.legs.cycle) * l), this.legs.r.position.set(.3, Math.max(0, .6 * Math.cos(this.legs.cycle + Math.PI)) + .1, Math.sin(-this.legs.cycle + Math.PI) * l), this.legs.r.rotation.x = .3 * this.legs.l.position.z, this.legs.l.rotation.x = .3 * this.legs.r.position.z, this.chest.position.y = .1 * Math.cos(2 * this.legs.cycle) + 1.1
						} else switch (this.legs.rotation.y = 0, this.legs.r.rotation.x = 0, this.legs.l.rotation.x = 0, this.chest.cycle += 3 * c, this.chest.cycle > Ua && (this.chest.cycle -= Ua), this.chest.position.y = .1 * Math.cos(this.chest.cycle) + 1.1, a) {
							case "cast":
								this.legs.l.position.set(-.4, .1, -.25), this.legs.r.position.set(.35, .1, .1), this.legs.l.rotation.y = 1, this.legs.r.rotation.y = .5;
							case "channel":
								this.legs.l.position.set(-.4, .1, -.6);
								break;
							case "release_buff":
								var h = db.easeOutQuint(1 - b.timer / b.duration);
								this.chest.position.y = 1.2 + .2 * Math.sin(3 + 5 * h);
								break;
							default:
								this.legs.l.position.set(-.45, .1, 0), this.legs.r.position.set(.45, .1, 0), this.legs.r.rotation.y = 0, this.legs.l.rotation.y = 0
						}
						this.legs.lastVisualPos.copy(this.visualPosition)
				}
			}, K.prototype.tickClassAnimation = function(a, b) {
				switch (a) {
					case "swing_melee":
						var c = db.easeInOutQuad(b.timer / b.duration),
							d = .5 * -Math.PI + Math.PI * c;
						this.weapon.rotation.set(.5 * Math.PI, 0, d), this.weapon.position.set(1.5 * Math.sin(d), 0, 1.5 * -Math.cos(d));
						break;
					case "spin":
						this.weapon.rotation.set(.5 * Math.PI, 0, 0), this.weapon.position.set(0, 0, -2);
						break;
					default:
					case "idle":
						this.weapon.rotation.set(0, 0, .5), this.weapon.position.set(0, 0, .7)
				}
			}), O.prototype = new K, O.prototype.constructor = O, O.prototype.getMaxHp = function() {
				return parseInt(.8 * Math.pow(12 + 1.5 * this.level, 1.6))
			}, O.prototype.getMovespeed = function() {
				return 1 == this.ai.isresetting ? 12 : 9
			}, O.prototype.getScale = function() {
				return .8 + .04 * this.level
			}, O.prototype.getMinDmg = function() {
				return 1 + .6 * this.level
			}, O.prototype.getMaxDmg = function() {
				return 2 + .9 * this.level
			}, O.prototype.getDefense = function() {
				return 0
			}, P.prototype = new K, P.prototype.constructor = P, P.prototype.getMaxHp = function() {
				return parseInt(.6 * Math.pow(12 + 1.5 * this.level, 1.6))
			}, P.prototype.getMovespeed = function() {
				return 1 == this.ai.isresetting ? 12 : 9
			}, P.prototype.getScale = function() {
				return .7 + .02 * this.level
			}, P.prototype.getMinDmg = function() {
				return 1 + .6 * this.level
			}, P.prototype.getMaxDmg = function() {
				return 2 + .9 * this.level
			}, P.prototype.getDefense = function() {
				return 0
			}, Q.prototype = new K, Q.prototype.constructor = Q, Va || (Q.prototype.headGearOffset = new THREE.Vector3(0, .6, 0), Q.prototype.headGearOffsetScale = new THREE.Vector3(.6, .6, .6), Q.prototype.initBaseBody = function() {
				this.chest = new THREE.Mesh(kd.slime.geo, this.class.color), this.chest.scale.set(kd.slime.scale[0], kd.slime.scale[1], kd.slime.scale[2]), this.chest.rotation.order = "YXZ", this.chest.cycle = 0, this.chest.castShadow = true, this.chest.position.y = .5, this.body.add(this.chest)
			}, Q.prototype.tickBaseAnimation = function(a, b, c) {
				switch (this.chest.cycle += c * (0 != this.walkForward ? 6 : 2), this.chest.cycle > Ua && (this.chest.cycle -= Ua), this.chest.position.y = .3 - .1 * Math.cos(this.chest.cycle), this.chest.position.z = 0, this.chest.scale.set(.1 * Math.cos(this.chest.cycle) + 1, 1 - .1 * Math.cos(this.chest.cycle), .1 * Math.cos(this.chest.cycle) + 1), a) {
					case "swing_melee":
						var d = Math.sin(3.1 * db.easeInOutQuad(b.timer / b.duration)) / this.stats.scale;
						this.chest.position.z -= 2 * d;
						break;
					case "dead":
						this.chest.position.y = 0, this.state.timer > 1 && this.state.timer < 5 && (this.body.position.y -= .15 * c), this.chest.scale.set(1 + .3 * this.state.timer, 1 / (1 + this.state.timer), 1 + .3 * this.state.timer)
				}
			}, Q.prototype.initBodyGeometry = function() {}, Q.prototype.tickClassAnimation = function(a, b) {}), Q.prototype.getMaxHp = function() {
				return parseInt(Math.pow(12 + 1.5 * this.level, 1.6))
			}, Q.prototype.getMovespeed = function() {
				return 1 == this.ai.isresetting ? 10 : 5
			}, Q.prototype.getScale = function() {
				return 1.05 + .07 * this.level
			}, Q.prototype.getMinDmg = function() {
				return 1 + .6 * this.level
			}, Q.prototype.getMaxDmg = function() {
				return 2 + .9 * this.level
			}, Q.prototype.getDefense = function() {
				return 0
			}, R.prototype = new K, R.prototype.constructor = R, R.prototype.initBodyGeometry = function() {
				this.weapon = new THREE.Mesh(kd.warrior_sword.geo, Vc.generic_metal), this.weapon.scale.set(kd.warrior_sword.scale[0], kd.warrior_sword.scale[1], kd.warrior_sword.scale[2]), this.weapon.position.y = .5, this.hands.r.add(this.weapon), this.shield = new THREE.Mesh(kd.warrior_shield.geo, Vc.generic_metal), this.shield.scale.set(kd.warrior_shield.scale[0], kd.warrior_shield.scale[1], kd.warrior_shield.scale[2]), this.shield.position.x = -.5, this.hands.l.add(this.shield)
			}, R.prototype.tickClassAnimation = function(a, b) {
				if (b) var c = db.easeInOutQuint(b.timer / b.duration);
				switch (a) {
					case "swing_melee":
						this.hands.r.position.set(-.5 + c, 2 * c - 1, -1), this.hands.r.lookAt(new THREE.Vector3(0, 0, 0)), this.hands.r.rotation.x -= 1.5, this.hands.r.rotation.z -= 3 * c - 1, this.chest.rotation.set(0, 1 - 3 * c, 0);
						break;
					case "spin":
						this.hands.r.rotation.set(-1.5, 0, 0), this.hands.r.position.z -= .3, this.hands.l.position.z += .2;
						break;
					default:
					case "idle":
						this.hands.l.rotation.z -= .1, this.hands.l.position.y += .1, this.hands.r.rotation.x -= .5, this.hands.r.position.y -= .2, this.hands.r.position.x += .1, this.weapon && this.oldanimId != a && (this.weapon.rotation.set(0, 0, 0), this.weapon.position.set(0, 1, 0))
				}
				this.oldanimId = a
			}, S.prototype = new K, S.prototype.constructor = S, S.prototype.initBodyGeometry = function() {
				this.weapon = new THREE.Mesh(kd.mage_staff.geo, Vc.generic_wood), this.weapon.scale.set(kd.mage_staff.scale[0], kd.mage_staff.scale[1], kd.mage_staff.scale[2]), this.weapon.rotation.z = .5, this.weapon.position.set(0, 0, .7), this.chest.add(this.weapon), this.shield = new THREE.Mesh(kd.mage_shield.geo, Vc.generic_white), this.shield.scale.set(kd.mage_shield.scale[0], kd.mage_shield.scale[1], kd.mage_shield.scale[2]), this.shield.position.x = -.4, this.shield.rotation.x = .25 * Math.PI, this.hands.l.add(this.shield)
			}, S.prototype.tickClassAnimation = function(a, b) {
				switch (a) {
					default:
						case "idle":
				}
			}, T.prototype = new K, T.prototype.constructor = T, T.prototype.initBodyGeometry = function() {
				this.bowcontainer = new THREE.Object3D, this.weapon = new THREE.Mesh(kd.archer_bow.geo, Vc.generic_wood), this.weapon.scale.set(2.5, 2.5, 1.9), this.weapon.rotation.z = .32, this.weapon.position.y = -2, this.bowcontainer.add(this.weapon), this.bowendU = new THREE.Mesh(kd.archer_bow_end.geo, Vc.generic_wood), this.bowendL = new THREE.Mesh(kd.archer_bow_end.geo, Vc.generic_wood), this.bowendU.position.x = 3.2, this.bowendL.position.x = -3.2, this.bowendU.position.y = -.7, this.bowendL.position.y = -.7, this.bowendL.scale.set(kd.archer_bow_end.scale[0], kd.archer_bow_end.scale[1], kd.archer_bow_end.scale[2]), this.bowendU.scale.set(kd.archer_bow_end.scale[0], kd.archer_bow_end.scale[1], kd.archer_bow_end.scale[2]), this.bowendL.rotation.z = 2.4, this.bowendU.rotation.z = .7, this.bowcontainer.add(this.bowendU), this.bowcontainer.add(this.bowendL), this.bowcontainer.rotation.z = 1.5, this.bowcontainer.rotation.x = 1.6, this.bowcontainer.position.x = 1.1, this.bowcontainer.position.z = -.1, this.hands.l.add(this.bowcontainer), this.ammo = new THREE.Mesh(kd.archer_ammo.geo, Vc.archer_ammo), this.ammo.position.z = .7, this.ammo.rotation.z = -.4, this.ammo.rotation.x = .16, this.ammo.position.y = -.15, this.ammo.scale.set(kd.archer_ammo.scale[0], kd.archer_ammo.scale[1], kd.archer_ammo.scale[2]), this.chest.add(this.ammo), this.ammo2 = new THREE.Mesh(kd.archer_ammo2.geo, Vc.archer_ammo2), this.ammo2.position.y = .8, this.ammo2.scale.set(kd.archer_ammo2.scale[0], kd.archer_ammo2.scale[1], kd.archer_ammo2.scale[2]), this.ammo.add(this.ammo2)
			}, T.prototype.tickClassAnimation = function(a, b) {
				if (b) {
					var c = db.easeInOutQuint(b.timer / b.duration);
					Math.sin(3.14 * c)
				}
				switch (a) {
					case "release_spell":
						var d = 1 - db.easeInQuint(b.timer / b.duration);
						this.hands.l.rotation.set(1.5, 2 + .4 * d, 1.5), this.hands.l.position.set(-.2, -.4 + .3 * d, -.8 - .8 * d), this.chest.rotation.y = 0, this.chest.rotation.x = -.2 + .2 * d, this.chest.rotation.z = 0, this.chest.position.z = 0, this.hands.r.position.set(.5 + .2 * d, -.2 + .4 * d, -.9 + (1 - b.timer / b.duration));
						break;
					default:
					case "idle":
						var e = Math.sin(this.chest.cycle + .5 * Math.PI),
							f = Math.sin(this.legs.cycle);
						this.hands.l.rotation.set(-.2 + .1 * e + .1 * f, -1.4 + .15 * e + .1 * f, .3), this.hands.l.position.set(-.15 - .2 * e - .2 * f, -.3 + .1 * e + .1 * f, -.9 + .1 * f), this.chest.rotation.y = .1, this.chest.rotation.x = -.1 + .1 * e, this.chest.position.z = -.1, this.legs.l.position.z -= .3, this.legs.r.position.z += .1
				}
			}, U.prototype = new K, U.prototype.constructor = U, U.prototype.initBodyGeometry = function() {
				this.weapon = new THREE.Mesh(kd.shaman_mace1.geo, Vc.generic_wood), this.weapontop = new THREE.Mesh(kd.shaman_mace2.geo, Vc.shaman_macetop), this.weapon.scale.set(kd.shaman_mace1.scale[0], kd.shaman_mace1.scale[1], kd.shaman_mace1.scale[2]), this.weapontop.scale.set(kd.shaman_mace2.scale[0], kd.shaman_mace2.scale[1], kd.shaman_mace2.scale[2]), this.weapon.position.y = -.5, this.weapontop.position.y = .8, this.hands.r.add(this.weapon), this.weapon.add(this.weapontop), this.shield = new THREE.Mesh(kd.shaman_shield.geo, Vc.generic_white), this.shield.scale.set(kd.shaman_shield.scale[0], kd.shaman_shield.scale[1], kd.shaman_shield.scale[2]), this.shield.position.z = .6, this.shield.position.y = .1,
					this.shield.rotation.z = .25 * Math.PI, this.chest.add(this.shield), this.robe = new THREE.Mesh(kd.shaman_robe.geo, Vc.generic_white), this.robe.scale.set(kd.shaman_robe.scale[0], kd.shaman_robe.scale[1], kd.shaman_robe.scale[2]), this.robe.position.z = -.5, this.robe.position.y = -.5, this.chest.add(this.robe)
			}, U.prototype.tickClassAnimation = function(a, b) {
				if (b) {
					db.easeInOutQuint(b.timer / b.duration)
				}
				switch (a) {
					default:
						case "idle":
						this.hands.l.rotation.z -= .1,
					this.hands.l.position.y += .1,
					this.hands.r.rotation.x -= 1.3,
					this.hands.r.position.y -= .1,
					this.hands.r.position.x += .1,
					this.weapon.rotation.set(0, 0, 0),
					this.weapon.position.set(0, .2, 0)
				}
			}, j.prototype.updateVisual = function(a) {
				switch (a) {
					case "h":
						switch (this.head && (ca(this.head), this.chest.remove(this.head), this.head = void 0), this.visuals.h) {
							default:
								case 0:
								break;
							case 1:
									this.head = new THREE.Mesh(qa.helmet.children[0].geometry, Vc.metal);
								break;
							case 2:
									this.head = new THREE.Mesh(qa.helmet.children[0].geometry, Vc.silver);
								break;
							case 3:
									this.head = new THREE.Mesh(qa.helmet.children[0].geometry, Vc.gold);
								break;
							case 4:
									this.head = new THREE.Mesh(qa.crown.children[0].geometry, Vc.metal);
								break;
							case 5:
									this.head = new THREE.Mesh(qa.crown.children[0].geometry, Vc.silver);
								break;
							case 6:
									this.head = new THREE.Mesh(qa.crown.children[0].geometry, Vc.gold)
						}
						this.head && (this.head.position.copy(this.class.headGearOffset), this.head.scale.copy(this.class.headGearOffsetScale), this.chest.add(this.head))
				}
			};
			var Sb = 0;
			j.prototype.tickDamageWobble = function(a) {
				if (this.dmgShake > 0 && this.chest)
					if (this.dmgShake -= a, this.dmgShake > .4 && (this.dmgShake = .4), this.dmgShake > 0) {
						var b = this.stats.scale + this.dmgShake * Math.sin(50 * this.dmgShake) * .5;
						this.body.scale.set(b, b, b), this.chest.material = Vc.damage
					} else this.body.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), this.chest.material = this.class.color
			}, j.prototype.tickAnimations = function(a) {
				if (this.animationQueue.length > 0) {
					var b = this.animationQueue[0];
					b.tick(a), (b.timer <= 0 || 1 == b.deleteMe) && this.animationQueue.shift()
				}
				this.worlddist < 60 ? (this.tickDamageWobble(a), this.tickBodyPartAnimations(a)) : this.isInHud && Sb % Math.round(.08 * (this.worlddist - 60) + 1 + this.globalAnimStepFuss) == 0 && (this.tickDamageWobble(($c - (this.lastBodyAnimTick || 0)) / 1e3), this.tickBodyPartAnimations(($c - (this.lastBodyAnimTick || 0)) / 1e3), this.lastBodyAnimTick = $c)
			}, V.prototype.tick = function(a) {
				"timed" != this.type && "loop" != this.type || (this.timer -= a, this.timer <= 0 && "loop" == this.type && (this.timer = this.duration))
			}, j.prototype.tickBodyPartAnimations = function(a) {
				if (this.hasParsedClass) {
					var b, c = void 0;
					this.animationQueue.length > 0 ? (b = this.animationQueue[0].id, c = this.animationQueue[0]) : b = "idle", this.class && this.class.type && (this.class.tickBaseAnimation.call(this, b, c, a), this.class.tickClassAnimation.call(this, b, c))
				}
			};
			var Tb, Ub = false,
				Vb = function() {
					var a = this,
						b = Math.PI / 2;
					this.locked = false, this.lmb = false, this.rmb = false, this.cameraX = 0, this.cameraY = 0, this.cameraZoom = 8, this.mouse = new THREE.Vector2, this.mouseOld = new THREE.Vector2, this.mouseElement = void 0, this.lmbLastDownTime = 0, this.lastX = 0, this.lastY = 0, this.mouseMove_unlocked = function(b) {
						a.mouseElement = b.target.getAttribute ? b.target.getAttribute("data-infopanel") : null, a.mouse.x = b.clientX / window.innerWidth * 2 - 1, a.mouse.y = 2 * -(b.clientY / window.innerHeight) + 1, Wb || (a.lastX = b.x, a.lastY = b.y), void 0 != Db && Eb.css({
							left: b.pageX,
							top: b.pageY
						})
					}, this.mouseMove_locked = function(c) {
						c.preventDefault();
						var d = c.movementX || c.mozMovementX || c.webkitMovementX || 0,
							e = c.movementY || c.mozMovementY || c.webkitMovementY || 0;
						Wb ? (d = c.movementX || c.mozMovementX || c.webkitMovementX || 0, e = c.movementY || c.mozMovementY || c.webkitMovementY || 0) : (d = c.x - a.lastX, e = c.y - a.lastY, a.lastX = c.x, a.lastY = c.y), a.cameraY -= .0035 * d, a.cameraX -= .0021 * e, a.cameraX = Math.max(-b, Math.min(b, a.cameraX))
					}, this.onMouseDown = function(b) {
						if (b.target.dataset.mouselock || a.lmb || a.rmb) {
							switch (b.button) {
								case 0:
									a.lmb = true, this.lmbLastDownTime = performance.now();
									break;
								case 3:
								case 2:
									a.rmb = true
							}
							return Ic && (a.lmb || a.rmb) && a.tryLock(), false
						}
					}, this.onMouseUp = function(b) {
						switch (b.button) {
							case 0:
								a.lmb = false, performance.now() - this.lmbLastDownTime < 300 && void 0 != Xc && void 0 != Ic && (Xc.drop ? Xc.requestPickUp() : (Ic.target = Xc, "vendor" == Ic.target.class.type && Ic && Ic.canSellToTrader() && ($("#trader").centerMe(0, -100), $("#trader").show(), $("#inventory").show(), Lb = true, Ub || (Ub = true, (adsbygoogle = window.adsbygoogle || []).push({})))));
								break;
							case 3:
							case 2:
								a.rmb = false
						}
						return a.lmb || a.rmb || a.unLock(), false
					}, this.mouseWheelEvent = function(b) {
						if (b.target == Cc.domElement || b.target == document.body) {
							b.preventDefault();
							var c = b.wheelDelta ? b.wheelDelta : -b.detail;
							a.cameraZoom -= c > 0 ? 1 : -1, a.cameraZoom = Math.min(30, Math.max(a.cameraZoom, 3))
						}
					}, document.addEventListener("mousemove", this.mouseMove_unlocked, false), document.addEventListener("mousedown", this.onMouseDown), document.addEventListener("mouseup", this.onMouseUp), document.addEventListener("mousewheel", this.mouseWheelEvent), document.addEventListener("DOMMouseScroll", this.mouseWheelEvent), this.tryLock = function() {
						if (Wb) {
							var a = document.body;
							a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock, a.requestPointerLock()
						} else this.locked = true, document.addEventListener("mousemove", Tb.mouseMove_locked, false), document.removeEventListener("mousemove", Tb.mouseMove_unlocked, false)
					}, this.unLock = function() {
						Wb ? (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock, document.exitPointerLock()) : (this.locked = false, document.addEventListener("mousemove", Tb.mouseMove_unlocked, false), document.removeEventListener("mousemove", Tb.mouseMove_locked, false))
					}
				};
			window.oncontextmenu = function() {
				return false
			};
			var Wb = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
			if (Wb) {
				var Xb = document.body,
					Yb = function(a) {
						document.pointerLockElement === Xb || document.mozPointerLockElement === Xb || document.webkitPointerLockElement === Xb ? (Tb.locked = true, document.addEventListener("mousemove", Tb.mouseMove_locked, false), document.removeEventListener("mousemove", Tb.mouseMove_unlocked, false)) : (Tb.locked = false, document.addEventListener("mousemove", Tb.mouseMove_unlocked, false), document.removeEventListener("mousemove", Tb.mouseMove_locked, false))
					};
				document.addEventListener("pointerlockchange", Yb, false), document.addEventListener("mozpointerlockchange", Yb, false), document.addEventListener("webkitpointerlockchange", Yb, false)
			} else console.log("ERROR: Your browser does seems to not support the pointer lock API.");
			var Zb = void 0,
				$b = true,
				_b = void 0,
				ac = function() {
					_b = $("#fpsdisplay"), Zb = setInterval(function() {
						$b || _b.text((1e3 / Zc).toFixed(1) + " fps")
					}, 200), $("#modal-settings").on("hidden.bs.modal", function(a) {
						pc("show"), $b = true
					}), $("#modal-settings").on("show.bs.modal", function(a) {
						pc("hide"), $b = false
					}), $("#sys-settings").on("click", function() {
						$("#setting-camlock").prop("checked", "true" == Pa.get("camlock")), $("#setting-resolution").val(parseInt(Pa.get("resolution"))), $("#setting-skillefx").prop("checked", "true" == Pa.get("skillefx")), $("#setting-shadows").val(parseInt(Pa.get("shadows"))), $("#setting-grass").val(parseInt(Pa.get("grass"))), $("#modal-settings").modal("show")
					}), $("#setting-camlock").on("change", function() {
						Pa.set("camlock", this.checked + "")
					}), $("#setting-resolution").on("input change", function() {
						Pa.set("resolution", this.value + ""), hd()
					}), $("#setting-skillefx").on("change", function() {
						Pa.set("skillefx", this.checked + "")
					}), $("#setting-shadows").on("input change", function() {
						Pa.set("shadows", this.value + ""), id()
					}), $("#setting-grass").on("change", function() {
						Pa.set("grass", this.value + ""), g(Z(oa.grassmap.image), uc.geometry)
					});
					var a = $(".chatsettingbutton");
					a.each(function() {
						var a = $(this).data("chat"),
							b = va(Pa.get(a));
						b || $(this).addClass("chatsettingdisable")
					})
				},
				bc = {},
				cc = {},
				dc = {
					goldCoin: "<img src='data/coin.png' class='goldCoin'></img>",
					faction1: "<img src='data/factionA.png' class='goldCoin'></img>",
					faction2: "<img src='data/factionB.png' class='goldCoin'></img>"
				},
				ec = {},
				fc = void 0,
				gc = {},
				hc = "g";
			createUi = function(a) {
				var b = document.body;
				bc.player = new TargetPanel($("#upperLeftContainer"), "You"), bc.target = new TargetPanel($("#upperLeftContainer"), "Target"), gc.claninvite = $("<button style='position:absolute; top: 0px; right: -32px;' class='btn btn-default btn-xs'><img style='width: 15px;margin: 3px;' src='data/icons/horde.png'></img></button>").appendTo(bc.target.panel), gc.claninvite.on("click", function(a) {
					Ic && void 0 !== Ic.target && Ic.target.faction == Ic.faction && wd.emit("ca", {
						a: "invite"
					})
				});
				gc.getinfo = $("<button style='position:absolute; top: 0px; right: -32px; margin-right: -61px;' class='btn btn-default btn-pf'><img style='width: 15px; height: 15px; margin: 3px;' src='http://www.skyovnis.com/wp-content/uploads/2014/12/Profile-sky-ovnis.jpg'></img></button>").appendTo(bc.target.panel), gc.getinfo.on("click", function(a) {
					Ic && window.open("http://www.hordes.io/player/" + Ic.target.name, "_blank")
				});
				gc.markplayer = $("<button style='position:absolute; top: 0px; right: -32px; margin-right: -11px; margin-top: 40px;' class='btn btn-default btn-mp'><img style='width: 15px; height: 15px; margin: 3px;' src='https://openclipart.org/download/255282/Racing_Flag_Red.svg'></img></button>").appendTo(bc.target.panel), gc.markplayer.on("click", function(a) {
					$(".btn-mp").after('<div class = "real"></div>');
					if(Ic.target.isAi == true){
						$(".real").text("MOB");
						$(".real").click(function(){
							$(".real").remove();
						});
					}
					else {
						//Thanks, StackOverflow
						$.ajax({
							type: 'HEAD',
							url: ("http://hordes.io/player/" + Ic.target.name),
							success: function() {
								if (Ic.target.name == "Traveler") {
									$(".real").addClass("unregistered");
									$(".real").text("UNREGISTERED PLAYER");
									$(".real").click(function(){
									$(".real").remove();
								});
								}
								else {
								$(".real").addClass("registered");
								$(".real").text("REGISTERED PLAYER");
								$(".real").click(function(){
									$(".real").remove();
								});
								}
							},
							error: function() {
								$(".real").addClass("unregistered");
								$(".real").text("UNREGISTERED PLAYER");
								$(".real").click(function(){
									$(".real").remove();
								});
							}
						});
					}
				});
				var c = $("<p/>", {
					class: "resourcesText",
					style: "float:left",
					id: "invtrashcan"
				}).appendTo($("#inventory"));
				c.html("<img src='/trash.png'>");
				var d = $("<p/>", {
					class: "resourcesText"
				}).appendTo($("#inventory"));
				d.html(dc.goldCoin + " <span>0</span>"), cc.gold = $(d).find("span"), Gb();
				var e = document.createElement("div");
				e.id = "expBarContainer", e.innerHTML = "<div class='progress' id='expbarprogress'><div class=\"progress-bar\" id='expbar' role=\"progressbar\"></div></div>", b.appendChild(e), cc.expbar = $("#expbar"), cc.expbarcontainer = $(e), cc.expbartext = $("<p/>", {
					class: "progressbartext",
					id: "expbartext"
				}), cc.expbartext.insertAfter(expbar);
				var f = document.createElement("div");
				f.innerHTML = "<div id='skillbar'></div>", b.appendChild(f), cc.skillbar = $("#skillbar"), ic(1, cc.skillbar), ic(2, cc.skillbar), ic(3, cc.skillbar), ic(4, cc.skillbar), castbarcontainer = document.createElement("div"), castbarcontainer.innerHTML = '<div class=\'progress\'><div class="progress-bar" id=\'castbar\' role="progressbar" style="width:0% padding:0px"> </div> </div>', castbarcontainer.id = "castBarContainer", b.appendChild(castbarcontainer), cc.castbar = $("#castbar"), cc.castbarcontainer = $("#castBarContainer"), cc.infoPanel = $("<div/>", {
					class: "panel panel-default",
					id: "infoPanel"
				}).appendTo($("#infoPanelContainer")), cc.infoPanel.hide(), cc.statistics = $("#statistics"), cc.chatboxBody = $("#chatboxBody"), cc.chatboxWrapper = $("#chatboxWrapper"), cc.chatInput = $("#chatInputForm"), cc.chatbox = $("#chatbox"), cc.ladder = $("#ladder"), cc.ladderBody = $("#ladder-body"), $("#chatInputForm").submit(function(a) {
					a.preventDefault(), cc.chatInput.hide();
					Qa($("#chatInput").val());
					$("#chatInput").val(""), $("#chatInput").blur()
				}), $("#cbt-g").on("click", function() {
					$("#chatChannelName").text("Global"), hc = "g"
				}), $("#cbt-c").on("click", function() {
					$("#chatChannelName").text("Clan"), hc = "c"
				}), $("#loginform").submit(function(a) {
					a.preventDefault(), sc()
				}), $("#loginformbutton").on("click", function(a) {
					load_c && load_g && sc(), a.preventDefault()
				}), $("#logintabs a").click(function(a) {
					a.preventDefault(), $(this).tab("show")
				}), $("#loginTabButton").on("click", function() {
					var a = $("#loginTabId").val();
					"" != a && (Ed = a, sc())
				});
				var g = $("#classSelection .classChoice");
				g.on("click", function() {
					g.removeClass("active"), $(this).addClass("active"), Pa.set("class", $(this).data("class"))
				}), cc.classSelection = g;
				var h = $("#factionSelectionPanel .factionSelect");
				h.on("click", function() {
					h.removeClass("active"), $(this).addClass("active"), Pa.set("faction", $(this).data("faction"))
				}), cc.factionSelection = h, cc.sysbar = $("#systembar"), $("#sys-user").on("click", function() {
					$("#serverLoginMessage").hide(), $("#modal-user").modal("show"), wd.emit("reqid")
				}), $("#modal-user").on("hidden.bs.modal", function(a) {
					pc("show")
				}), $("#modal-user").on("show.bs.modal", function(a) {
					pc("hide")
				}), $("#switchIdButton").on("click", function() {
					var a = $("#switchIdField").val();
					a != Ad && "" != a && ($("#serverLoginMessage").hide(), Md($("#switchIdField").val()))
				}), $("#setNickModalButton").on("click", function() {
					$("#modal-setnick").modal("show")
				}), $("#visitProfile").on("click", function() {
					Ic && window.open("http://www.hordes.io/player/" + Ic.name, "_blank")
				}), $("#setNickButton").on("click", function() {
					var a = $("#setNickField").val();
					"" != a && ($("#setNickMsg").hide(), wd.emit("cn", a))
				}), $("#sys-help").on("click", function() {
					$("#modal-help").modal("show")
				}), $("#sys-discord").on("click", function() {
					$("#modal-setnick").after('<div class="modal fade" id="modal-discord" tabindex="-1" role="dialog"> <div class="modal-dialog modal-body-base modal-user" role="document"> <div class="modal-content"> <div class="modal-body"><button class="close" type="button" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button> <h4> <img src = "https://discordapp.com/assets/94db9c3c1eba8a38a1fcf4f223294185.png" alt = "Discord" height = "75px" width = "250px"></img></h4> <h5 class="text-center detailText"> <a href="https://discord.gg/z78gnNe" line-height = "200px">Join the XHORDES Discord! <img src="http://i.imgur.com/Yn2YW2Q.png" alt="XHORDES" height="64px" width="64px"></img></a><br/> <br/><a href="https://discord.gg/bY2vFzg" line-height = "200px">Join the Hordes.io Discord! <img src="http://hordes.io/icon.png" alt="Hordes.io" height="48px" width="48px"></img></a></h5></div></div></div></div>');
					$("#modal-discord").modal("show")
				}), $("#sys-inventory").on("click", function() {
					$("#inventory").toggle()
				}), $("#sys-charpanel").on("click", function() {
					$("#characterpanel").toggle()
				}), $("#sys-clan").on("click", function() {
					sb(rb), $("#modal-clan").modal("show")
				}), $("#respawnButton").on("click", function() {
					$("#deathScreen").hide(), fc = function() {
						wd && wd.emit("confrespawn")
					}, tc()
				}), $("#sys-clan").on("click", function() {
					$("#modal-clan").modal("show")
				}), $("#createClanButton").on("click", function() {
					var a = $("#createClanName").val(),
						b = $("#createClanTag").val();
					"" != a && "" != b && ($("#createClanMsg").hide(), Nd({
						n: $("#createClanName").val(),
						t: $("#createClanTag").val()
					}))
				}), $("#leaveClanButton").on("click", function() {
					var sureAboutThat = confirm("Are you sure you want to leave your clan?");
					if (sureAboutThat == true){
					wd.emit("ca", {
						a: "leave"
					})
					}
					else {}
				}), $("#disbandClanButton").on("click", function() {
					var sureAboutThat = confirm("Are you sure you want to disband your clan?");
					if (sureAboutThat == true){
					wd.emit("ca", {
						a: "disband"
					})
					}
					else {}
				}), $("#interact-accept").on("click", function() {
					$("#userinteract").hide(), wd.emit("ca", {
						a: "accept"
					})
				}), $("#interact-decline").on("click", function() {
					$("#userinteract").hide()
				});
				var i = $(".chatsettingbutton");
				i.on("click", function() {
					var a = $(this).data("chat"),
						b = !va(Pa.get(a));
					Pa.set(a, b), b ? $(this).removeClass("chatsettingdisable") : $(this).addClass("chatsettingdisable")
				}), ac();
				var j = Pa.get("faction");
				switch (parseInt(j)) {
					case 0:
					case 1:
						cc.factionSelection.eq(j).click()
				}
				var k = Pa.get("class");
				switch (k) {
					case "warrior":
						cc.classSelection.eq(0).click();
						break;
					case "mage":
						cc.classSelection.eq(1).click();
						break;
					case "shaman":
						cc.classSelection.eq(2).click();
						break;
					case "archer":
						cc.classSelection.eq(3).click()
				}
				var l = Pa.get("name");
				$("#usernameInputField").val(l)
			};
			var ic = function(a, b) {
					var c = "<div data-infopanel='skill" + a + "' class='skill' id='skillButton" + a + "'><img data-infopanel='skill" + a + "' id='skillIcon" + a + "' src='' class='skillIcon'></img><div data-infopanel='skill" + a + "' id='skillOverlay" + a + "' class='skillOverlay'></div><kbd id='skillButtonKbd" + a + "'data-infopanel='skill" + a + "' class='skillHotkey'>" + Pa.get("skill" + a) + "</kbd><p data-infopanel='skill" + a + "' id='skillCooldown" + a + "' class='skillCooldown'></p></div>";
					b.append(c);
					var d = $("#skillButton" + a),
						e = $("<button id='skillLevelButton" + a + "' class='btn skillLvlUpButton'>+</button>");
					d.mouseover(function(b) {
						jc(e, a), e.stop(true, true), e.show()
					}), d.mouseout(function(a) {
						e.stop(true, true), e.fadeOut(400)
					}), e.hide(), e.click(function(b) {
						Ic && Ic.class && Ic.class.skills[a].tryLevelUp()
					}).appendTo(d)
				},
				jc = function(a, b) {
					Ic.class.skills[b].canLevelUp() ? a.removeClass("skillButtonDisabled") : a.addClass("skillButtonDisabled")
				},
				kc = void 0,
				lc = void 0,
				mc = true,
				nc = true,
				oc = void 0;
			updateUi = function(a) {
				nc || (Ic ? (bc.player.update({
					name: Ic.name,
					level: Ic.class.level,
					relationship: "ally",
					hp: Ic.stats.currenthp,
					maxhp: Ic.stats.maxhp,
					mp: Ic.stats.currentmp,
					maxmp: Ic.stats.maxmp,
					icon: 0 == Ic.faction ? "factionA" : "factionB",
					class: Ic.class.type
				}), Ic.target ? (bc.target.update({
					name: Ic.target.name,
					level: Ic.target.class.level,
					relationship: Ic.target.faction == Ic.faction ? "ally" : "enemy",
					hp: Ic.target.stats.currenthp,
					maxhp: Ic.target.stats.maxhp,
					mp: Ic.target.stats.currentmp,
					maxmp: Ic.target.stats.maxmp,
					icon: 0 == Ic.target.faction ? "factionA" : "factionB",
					class: Ic.target.isAi ? "monster" : Ic.target.class.type
				}), Ic.target != oc && (Ic.clanrole > 0 && Ic.target.faction == Ic.faction && void 0 == Ic.target.class.ai ? gc.claninvite.show() : gc.claninvite.hide())) : bc.target.update({
					hide: true
				})) : (bc.player.update({
					hide: true
				}), bc.target.update({
					hide: true
				})), Tb.mouseElement == kc && Xc == lc || (kc = Tb.mouseElement, lc = Xc, null == Tb.mouseElement ? void 0 != Xc ? (cc.infoPanel.html(Xc.getInfoPanelString()), mc && (cc.infoPanel.stop(true, true), cc.infoPanel.show(), mc = false)) : mc || (cc.infoPanel.stop(true, true), cc.infoPanel.fadeOut(400), mc = true) : ec.hasOwnProperty(Tb.mouseElement) ? (cc.infoPanel.html(ec[Tb.mouseElement]), mc && (cc.infoPanel.stop(true, true), cc.infoPanel.show(), mc = false)) : mc || (cc.infoPanel.stop(true, true), cc.infoPanel.fadeOut(400), mc = true)), Lb && Ic && !Ic.canSellToTrader() && ($("#trader").hide(), Lb = false))
			};
			var pc = function(a, b) {
					cc.ladder[a](b), cc.chatbox[a](b), cc.expbarcontainer[a](b), cc.infoPanel[a](b), cc.skillbar[a](b), cc.statistics[a](b), cc.castbarcontainer[a](b), bc.player.panel[a](b), bc.target.panel[a](b), cc.sysbar[a](b)
				},
				qc = [{}, {}, {}, {}, {}, {}, {}, {}],
				rc = function(a, b) {
					var c = $("#laddertable").find("tr").eq(a).find("td");
					void 0 !== b.name && (c[0].innerHTML = "<img class='classicon' src='data/" + b.class + ".png'> " + b.name), void 0 !== b.lvl && (c[1].innerHTML = parseInt(b.lvl)), void 0 !== b.fame && (c[2].innerHTML = "<b>" + parseInt(b.fame) + "</b>"), void 0 !== b.horde && c.attr("class", 1 == parseInt(b.horde) ? "factionB" : "factionA")
				},
				sc = function() {
					$("nav").fadeOut(300), $("#loginfade").fadeOut(300, function() {
						$("#renderer").fadeOut(300, function() {
							tc()
						})
					})
				};
			fc = function() {
				Jd(Cd)
			};
			var tc = function() {
				fc()
			};
			$.fn.centerMe = function(a, b) {
				this.css("left", $(window).width() / 2 - $(this).width() / 2 + a), this.css("top", $(window).height() / 2 - $(this).height() / 2 + b)
			}, TargetPanel = function(a, b) {
				var c = $("<div/>", {
					class: "panel panel-default targetPanel"
				});
				c.appendTo(a);
				var d = $("<div/>", {
						class: "targetinfo"
					}).appendTo(c),
					e = $("<p/>", {
						class: "targettext targetname",
						text: ""
					}).appendTo(d),
					f = $("<img/>", {
						class: "factionicon",
						src: "data/factionA.png"
					}).prependTo(e),
					g = $("<span/>").appendTo(e),
					h = $("<p/>", {
						class: "targettext targetlevel",
						text: ""
					}).appendTo(d),
					i = $("<span/>").appendTo(h),
					j = $("<img/>", {
						class: "classicon",
						src: "data/warrior.png"
					}).prependTo(h),
					k = $("<div/>", {
						class: "progress hpbarbg"
					}).appendTo(c),
					l = $("<div/>", {
						class: "progress-bar hpbar",
						role: "progressbar"
					}).appendTo(k),
					m = $("<p/>", {
						class: "targettext targethealthtext",
						text: "1321 / 2384"
					}).appendTo(k),
					n = $("<div/>", {
						class: "progress mpbarbg"
					}).appendTo(c),
					o = $("<div/>", {
						class: "progress-bar mpbar",
						role: "progressbar"
					}).appendTo(n),
					p = $("<p/>", {
						class: "targettext targethealthtext manafont",
						text: "1321 / 2384"
					}).appendTo(n);
				this.panel = c, this.name = g, this.icon = f, this.class = j, this.level = i, this.hpbar = l, this.hpbarBg = k, this.mpbar = o, this.mpbarBg = n, this.hptext = m, this.mptext = p, this.targetmode = b, this.tlvl = h, this.hp = 0, this.maxhp = 1, this.mp = 0, this.maxmp = 1, this.relationship = "ally", this.lasticon = "", this.lastclass = "", this.hidden = true, this.panel.hide()
			}, TargetPanel.prototype.update = function(a) {
				if (a.hide) return void(this.hidden || (this.panel.hide(), this.hidden = true));
				this.hidden && (this.panel.show(), this.hidden = false);
				var b = false,
					c = false;
				for (param in a)
					if (a.hasOwnProperty(param)) {
						var d = a[param];
						switch (param) {
							case "name":
								d != this.oldname && (this.oldname = d, this.name.text(d), this[param].append(" <span class='targetMode'>" + this.targetmode + "</span>"));
								break;
							case "level":
								this.level.text() != d && this.level.text(d);
								break;
							case "relationship":
								a[param] != this.relationship && (this.relationship = d, this.name.attr("class", "targettext targetname " + this.relationship));
								break;
							case "hp":
							case "maxhp":
								("hp" == param && d != this.hp || "maxhp" == param && d != this.maxhp) && (b = true, this[param] = d);
								break;
							case "mp":
							case "maxmp":
								("mp" == param && d != this.mp || "maxmp" == param && d != this.maxmp) && (c = true, this[param] = d);
								break;
							case "icon":
								d != this.lasticon && (this.icon.attr("src", "data/" + d + ".png"), this.lasticon = d);
								break;
							case "class":
								d != this.lastclass && (this.class.attr("src", "data/" + d + ".png"), this.lastclass = d)
						}
					}
				b && (this.hptext.text(this.hp + "/" + this.maxhp), this.hpbar.css("width", Math.round(this.hp / this.maxhp * 100) + "%")), c && (this.mptext.text(this.mp + "/" + this.maxmp), this.mpbar.css("width", Math.round(this.mp / this.maxmp * 100) + "%"))
			};
			var uc, vc, wc, xc, yc, zc, Ac, Bc, Cc, Dc, Ec, Fc, Gc, Hc, Ic, Jc, Kc, Lc = 4,
				Mc = function() {
					Va || (zc = Z(oa.heightmap.image));
					var a = Va ? heightmap.shape[0] : oa.heightmap.image.width,
						b = Va ? heightmap.shape[1] : oa.heightmap.image.height;
					wc = a * Lc, xc = 3 * a, Va || (oa.detail.wrapS = THREE.RepeatWrapping, oa.detail.wrapT = THREE.RepeatWrapping, oa.detail2.wrapS = THREE.RepeatWrapping, oa.detail2.wrapT = THREE.RepeatWrapping, oa.detail_h.wrapS = THREE.RepeatWrapping, oa.detail_h.wrapT = THREE.RepeatWrapping, Vc.terrain = new THREE.RawShaderMaterial({
						uniforms: {
							map: {
								value: oa.color
							},
							detail: {
								value: oa.detail
							},
							detailHeight: {
								value: oa.detail_h
							},
							detail2: {
								value: oa.detail2
							},
							shadow: {
								value: Ec.shadow.map
							},
							ambient: {
								value: Dc.color
							},
							directional: {
								value: Ec.color
							},
							directionalDir: {
								value: Ec.position
							},
							directionalMVP: {
								value: new THREE.Matrix4
							},
							fogColor: {
								value: Ac.fog.color
							},
							fogDensity: {
								value: Ac.fog.density
							},
							targetCircle: {
								value: new THREE.Vector4(0, 0, 0, 2)
							},
							targetCirclePos: {
								value: new THREE.Vector2(0, 0)
							},
							shadowSize: {
								value: 0
							}
						},
						vertexShader: pa["terrain.vert"],
						fragmentShader: pa["terrain.frag"],
						depthTest: true,
						depthWrite: true
					})), vc = new THREE.PlaneBufferGeometry(wc, wc, a - 1, b - 1);
					for (var c = 0; c < a; ++c)
						for (var d = 0; d < b; ++d) {
							var e = xc * d + 3 * c;
							vc.attributes.position.array[e + 0] = c * Lc, vc.attributes.position.array[e + 2] = d * Lc, vc.attributes.position.array[e + 1] = .6 * aa(c + 1, d + 1).r
						}
					vc.computeFaceNormals(), vc.computeVertexNormals(), vc.normalsNeedUpdate = true, vc.verticesNeedUpdate = true, yc = vc.attributes.position.array.length, uc = new THREE.Mesh(vc, Va ? void 0 : Vc.terrain), Va || (uc.receiveShadow = true, uc.castShadow = false, Ac.add(uc))
				},
				Nc = void 0,
				Oc = 0,
				Pc = function(a) {
					5e-4 * performance.now();
					uc.material.uniforms.directionalMVP.value = Ec.shadow.matrix, Ec.shadow.map && (uc.material.uniforms.shadow.value = Ec.shadow.map.texture), Oc > 0 && (Oc -= Oc * a * 15);
					var b = Xc && Xc.drop ? Xc : Ic ? Ic.target : void 0;
					Ic && b ? (Nc != b && (Oc = 1), Nc = b, Xc && Xc.drop ? (uc.material.uniforms.targetCirclePos.value = new THREE.Vector2(b.position.x, b.position.z), uc.material.uniforms.targetCircle.value.w = .5 * Math.max(Xc.quad.geometry.sh_h, Xc.quad.geometry.sh_w) + .1 + .5 * Oc, uc.material.uniforms.targetCircle.value.x = .7, uc.material.uniforms.targetCircle.value.y = .7, uc.material.uniforms.targetCircle.value.z = .7) : (uc.material.uniforms.targetCirclePos.value = new THREE.Vector2(b.visualPosition.x, b.visualPosition.z), uc.material.uniforms.targetCircle.value.w = b.stats.scale + .2 + Oc, uc.material.uniforms.targetCircle.value.x = b.faction == Ic.faction ? 0 : 1, uc.material.uniforms.targetCircle.value.y = b.faction == Ic.faction ? 1 : 0, uc.material.uniforms.targetCircle.value.z = 0)) : uc.material.uniforms.targetCirclePos.value = new THREE.Vector2(0, 0)
				},
				Qc = function(a, b) {
					var c = a / Lc,
						d = b / Lc,
						e = c % 1,
						f = d % 1;
					0 == e && (c += 1e-10), 0 == f && (d += 1e-10);
					var g, h, i;
					if (g = xc * Math.ceil(d) + 3 * Math.floor(c), h = xc * Math.floor(d) + 3 * Math.ceil(c), i = e + f > 1 ? xc * Math.ceil(d) + 3 * Math.ceil(c) : xc * Math.floor(d) + 3 * Math.floor(c), g < 0 || h < 0 || i < 0 || g >= yc || h >= yc || i >= yc) return 0;
					var j = Uc(Sc(g), Sc(h), Sc(i), a, b);
					return j || 0
				},
				Rc = function(a, b) {
					var c = a / Lc,
						d = b / Lc,
						e = c % 1,
						f = d % 1;
					0 == e && (c += 1e-10), 0 == f && (d += 1e-10);
					var g, h, i;
					if (g = xc * Math.ceil(d) + 3 * Math.floor(c), h = xc * Math.floor(d) + 3 * Math.ceil(c), e + f > 1) i = xc * Math.ceil(d) + 3 * Math.ceil(c);
					else {
						i = xc * Math.floor(d) + 3 * Math.floor(c);
						var j = i;
						i = h, h = j
					}
					if (g < 0 || h < 0 || i < 0 || g >= yc || h >= yc || i >= yc) return 0;
					var k = new THREE.Triangle(Tc(g), Tc(h), Tc(i));
					return k.normal()
				},
				Sc = function(a) {
					return {
						x: vc.attributes.position.array[a],
						y: vc.attributes.position.array[a + 1],
						z: vc.attributes.position.array[a + 2]
					}
				},
				Tc = function(a) {
					return new THREE.Vector3(vc.attributes.position.array[a], vc.attributes.position.array[a + 1], vc.attributes.position.array[a + 2])
				},
				Uc = function(a, b, c, d, e) {
					var f = (b.z - c.z) * (a.x - c.x) + (c.x - b.x) * (a.z - c.z),
						g = ((b.z - c.z) * (d - c.x) + (c.x - b.x) * (e - c.z)) / f,
						h = ((c.z - a.z) * (d - c.x) + (a.x - c.x) * (e - c.z)) / f,
						i = 1 - g - h;
					return g * a.y + h * b.y + i * c.y
				},
				Vc = {},
				Wc = [],
				Xc = void 0,
				Yc = 0,
				Zc = 0,
				$c = 0,
				_c = 10,
				ad = function() {
					Ka(Cc.domElement), Tb = new Vb, Ac = new THREE.Scene, Bc = new THREE.Scene, Hc = new THREE.Raycaster, Ac.fog = new THREE.FogExp2(6664656, .0065), Cc.setClearColor(9561076), Fc = new THREE.PerspectiveCamera(75, 0, .1, 1e3), Ac.add(Fc), Gc = new THREE.OrthographicCamera(1, 1, 1, 1, 1, 10), Gc.position.z = 10, Dc = new THREE.AmbientLight(6793417), Ac.add(Dc), Ec = new THREE.DirectionalLight(11711133, .65), Ac.add(Ec), Ac.add(Ec.target), Mc(), g(Z(oa.grassmap.image), uc.geometry), id(), ka(), $("#upperLeftContainer").fadeIn(), Yc = performance.now();
					var a = function() {
						requestAnimationFrame(a), $c = performance.now(), Zc += ($c - Yc - Zc) / _c;
						var b = Math.min(($c - Yc) / 1e3, .1);
						Yc = $c, Sb++, gb(), qd = [], rd = [], Kc = [];
						for (var c in Jc) Kc.push(Jc[c]);
						void 0 !== Ic && (Ic.playertick(b), Ic.clienttick(b));
						for (var c in Jc) Jc.hasOwnProperty(c) && void 0 != Jc[c] && Jc[c] != Ic && Jc[c].clienttick(b);
						md(b), updateUi(b), void 0 == Ic ? gd(b) : (zd(), ed(), Rb(b), qb(b)), h(b), Pc(b), Cc.clear(), Cc.render(Ac, Fc), Cc.clearDepth(), Cc.render(Bc, Gc)
					};
					a()
				},
				bd = function() {
					var a = {
						w: oa.items.image.width,
						h: oa.items.image.height
					};
					kd.items = {};
					for (var b in ra.items.frames) {
						var c = ra.items.frames[b].frame,
							d = ra.items.frames[b].rotated,
							e = (d ? c.h : c.w) / a.w,
							f = (d ? c.w : c.h) / a.h,
							g = e / 2,
							h = c.x / a.w,
							i = 1 - c.y / a.h - f;
						kd.items[b] = new THREE.PlaneBufferGeometry(1, 1, 2, 1), kd.items[b].attributes.uv.array[0] = h, kd.items[b].attributes.uv.array[1] = i + f, kd.items[b].attributes.uv.array[2] = h + g, kd.items[b].attributes.uv.array[3] = i + f, kd.items[b].attributes.uv.array[4] = h + e, kd.items[b].attributes.uv.array[5] = i + f, kd.items[b].attributes.uv.array[6] = h, kd.items[b].attributes.uv.array[7] = i, kd.items[b].attributes.uv.array[8] = h + g, kd.items[b].attributes.uv.array[9] = i, kd.items[b].attributes.uv.array[10] = h + e, kd.items[b].attributes.uv.array[11] = i;
						var j = (d ? c.h : c.w) / 38,
							k = (d ? c.w : c.h) / 38,
							l = 0;
						switch (b.replace(/[0-9]/g, "")) {
							default:
								case "gold":
								case "bow":
								l = 0;
							break;
							case "sword":
									case "shield":
									case "totem":
									case "hammer":
									case "glove":
									case "boot":
									case "bag":
									l = .2;
								break;
							case "armor":
									case "staff":
									case "quiver":
									l = .3
						}
						l *= j, kd.items[b].sh_w = j + .5, kd.items[b].sh_h = k + .5, kd.items[b].attributes.position.array[0] = -j, kd.items[b].attributes.position.array[1] = k, kd.items[b].attributes.position.array[3] = 0, kd.items[b].attributes.position.array[4] = k, kd.items[b].attributes.position.array[5] = l, kd.items[b].attributes.position.array[6] = j, kd.items[b].attributes.position.array[7] = k, kd.items[b].attributes.position.array[9] = -j, kd.items[b].attributes.position.array[10] = -k, kd.items[b].attributes.position.array[12] = 0, kd.items[b].attributes.position.array[13] = -k, kd.items[b].attributes.position.array[14] = l, kd.items[b].attributes.position.array[15] = j, kd.items[b].attributes.position.array[16] = -k, kd.items[b].computeFaceNormals(), kd.items[b].computeVertexNormals(), kd.items[b].normalsNeedUpdate = true, kd.items[b].verticesNeedUpdate = true
					}
				},
				cd = function() {
					Vc.item = new THREE.MeshBasicMaterial({
						map: oa.items,
						transparent: true,
						alphaTest: .5,
						color: 6710886,
						side: THREE.DoubleSide
					}), Vc.hpbarbg = new THREE.SpriteMaterial({
						color: 0
					}), Vc.hpbarclan = new THREE.SpriteMaterial({
						color: 4486399
					}), Vc.hpbarfriendly = new THREE.SpriteMaterial({
						color: 65280
					}), Vc.hpbarenemy = new THREE.SpriteMaterial({
						color: 16711680
					}), Vc.hpbarmob = new THREE.SpriteMaterial({
						color: 16147241
					}), Vc.factionA = new THREE.SpriteMaterial({
						map: oa.factionA,
						color: 16777215
					}), Vc.factionB = new THREE.SpriteMaterial({
						map: oa.factionB,
						color: 16777215
					}), Vc.hpbarcantfight = new THREE.SpriteMaterial({
						color: 6710886
					}), Vc.hpbarbgTransparent = new THREE.SpriteMaterial({
						color: 0
					}), Vc.hpbarfriendlyTransparent = new THREE.SpriteMaterial({
						color: 65280
					}), Vc.hpbarenemyTransparent = new THREE.SpriteMaterial({
						color: 16711680
					}), Vc.hpbarmobTransparent = new THREE.SpriteMaterial({
						color: 16147241
					}), Vc.hpbarcantfightTransparent = new THREE.SpriteMaterial({
						color: 6710886
					}), Vc.hpbarcantfightTransparent.transparent = true, Vc.hpbarbgTransparent.transparent = true, Vc.hpbarfriendlyTransparent.transparent = true, Vc.hpbarenemyTransparent.transparent = true, Vc.hpbarmobTransparent.transparent = true, Vc.hpbarcantfightTransparent.opacity = .5, Vc.hpbarbgTransparent.opacity = .2, Vc.hpbarfriendlyTransparent.opacity = .5, Vc.hpbarenemyTransparent.opacity = .8, Vc.hpbarmobTransparent.opacity = .7, Vc.hitbox = new THREE.MeshBasicMaterial({
						visible: false
					}), Vc.ribbon_arrow = new THREE.MeshBasicMaterial({
						side: THREE.DoubleSide,
						alphaMap: oa.gradient,
						transparent: true,
						alphaTest: .15
					}), Vc.ribbon_heal = new THREE.MeshBasicMaterial({
						side: THREE.DoubleSide,
						map: oa.heal_color,
						alphaMap: oa.heal_alpha,
						transparent: true,
						alphaTest: .05
					}), Vc.ribbon_ice = new THREE.MeshBasicMaterial({
						side: THREE.DoubleSide,
						map: oa.ice_color,
						alphaMap: oa.heal_alpha,
						transparent: true,
						alphaTest: .05
					}), Vc.ribbon_decay = new THREE.MeshBasicMaterial({
						side: THREE.DoubleSide,
						map: oa.decay_color,
						alphaMap: oa.decay_alpha,
						transparent: true,
						alphaTest: .05
					}), Vc.ribbon_leech = new THREE.MeshBasicMaterial({
						side: THREE.DoubleSide,
						map: oa.leech_color,
						alphaMap: oa.heal_alpha,
						transparent: true,
						alphaTest: .2
					}), Vc.ribbon_whirlwind = new THREE.MeshBasicMaterial({
						side: THREE.DoubleSide,
						map: oa.swingtest,
						alphaMap: oa.alpha,
						transparent: true,
						alphaTest: .2
					}), Vc.slime_green = new THREE.MeshPhongMaterial({
						color: 11531468,
						transparent: true,
						opacity: .7,
						shininess: 50,
						specular: 8684676,
						map: oa.heal_color
					}), Vc.slime_blue = new THREE.MeshPhongMaterial({
						color: 687583,
						transparent: true,
						opacity: .7,
						shininess: 50,
						specular: 8684676
					}), Vc.slime_red = new THREE.MeshPhongMaterial({
						color: 16711680,
						transparent: true,
						opacity: .7,
						shininess: 50,
						specular: 8684676
					})
				};
			$(document).ready(function() {
				Cc = new THREE.WebGLRenderer({
					antialias: true
				}), Cc.autoClear = false, Cc.domElement.dataset.mouselock = true, Cc.domElement.id = "renderer", $(Cc.domElement).insertBefore("#loginfade"), sa.onFinish(function() {
					ad(), load_g = true, wa(), sa.onFinish(function() {
						createUi(Cc.domElement), pc("hide"), cd(), bd()
					})
				})
			});
			var dd = 0,
				ed = function() {
					if (dd++, null == Tb.mouseElement && (dd > 20 || Tb.mouseOld.x != Tb.mouse.x || Tb.mouseOld.y != Tb.mouse.y)) {
						dd = 0, Tb.mouseOld.copy(Tb.mouse), Hc.setFromCamera(Tb.mouse, Fc);
						var a = Hc.intersectObjects(Wc);
						a.length > 0 ? (Xc = a[0].object.entity, document.body.style.cursor = "pointer") : (Xc = void 0, document.body.style.cursor = "default"), Wc = []
					}
				},
				fd = 0,
				gd = function(a) {
					fd += a;
					var b = new THREE.Vector3(.5 * wc + Math.sin(.003 * fd) * wc * .25, 0, .5 * wc + Math.cos(.003 * fd) * wc * .25);
					b.y = Qc(b.x, b.z) + 2, Fc.position.copy(b), Ec.position.copy(b)
				},
				hd = function() {
					var a = parseInt(Pa.get("resolution"));
					"number" == typeof a && (a = Math.max(.1, Math.min(1, .1 * a)), Cc.setPixelRatio(a))
				},
				id = function() {
					if ("0" != Pa.get("shadows")) {
						Cc.shadowMap.enabled = true, Cc.shadowMap.type = THREE.PCFSoftShadowMap, Ec.castShadow = true, Ec.shadow && delete Ec.shadow, Ec.shadow = new THREE.DirectionalLightShadow, Ec.shadow.camera.left = -100, Ec.shadow.camera.right = 100, Ec.shadow.camera.top = 100, Ec.shadow.camera.bottom = -100, Ec.shadow.camera.near = .5, Ec.shadow.camera.far = 3e3, Ec.shadow.bias = -.001, Cc.shadowMap.renderReverseSided = false;
						var a = 64;
						switch (parseInt(Pa.get("shadows"))) {
							default:
								case 1:
								a = 128;
							break;
							case 2:
									a = 256;
								break;
							case 3:
									a = 512;
								break;
							case 3:
									a = 1024;
								break;
							case 4:
									a = 2048
						}
						Ec.shadow.mapSize.width = a, Ec.shadow.mapSize.height = a, uc && (uc.material.uniforms.shadowSize.value = a, uc.material.uniforms.shadow.value = Ec.shadow.map), Vc.foliage && (Vc.foliage.uniforms.shadowSize.value = a, Vc.foliage.uniforms.shadow.value = Ec.shadow.map)
					} else Cc.shadowMap.enabled = false, Ec.castShadow = false, uc && (uc.material.uniforms.shadowSize.value = 0, uc.material.uniforms.shadow.value = void 0), Vc.foliage && (Vc.foliage.uniforms.shadowSize.value = 0, Vc.foliage.uniforms.shadow.value = void 0)
				},
				jd = {
					box: new THREE.BoxBufferGeometry(1, 1, 1),
					icebolt: new THREE.SphereBufferGeometry(.3, 4, 3),
					frostcall: new THREE.CylinderBufferGeometry(12, 12, .15, 20, 1),
					frostblizz: new THREE.SphereBufferGeometry(.3, 3, 2),
					iceblock: new THREE.SphereBufferGeometry(3, 4, 5),
					bow: new THREE.TorusBufferGeometry(1.3, .15, 3, 4, 2.5),
					slime: new THREE.SphereBufferGeometry(.9, 6, 3, 0, 2 * Math.PI, 0, 1.9)
				},
				kd = {};
			kd.chest = {
				geo: jd.box,
				scale: [1, 1, 1]
			}, kd.leg = {
				geo: jd.box,
				scale: [.4, .4, .4]
			}, kd.hand = {
				geo: jd.box,
				scale: [.45, .4, .4]
			}, kd.hitbox = {
				geo: jd.box,
				scale: [1.4, 2.2, 1.4]
			}, kd.mage_staff = {
				geo: jd.box,
				scale: [.2, 1.8, .2]
			}, kd.mage_shield = {
				geo: jd.box,
				scale: [.4, 2.4, 2.4]
			}, kd.icebolt = {
				geo: jd.icebolt
			}, kd.frostcall = {
				geo: jd.frostcall
			}, kd.frostcallblizz = {
				geo: jd.frostblizz
			}, kd.iceblock = {
				geo: jd.iceblock
			}, kd.shaman_mace1 = {
				geo: jd.box,
				scale: [.6, 2, .6]
			}, kd.shaman_mace2 = {
				geo: jd.box,
				scale: [1.8, .8, 2.7]
			}, kd.shaman_robe = {
				geo: jd.box,
				scale: [.5, .8, .1]
			}, kd.shaman_shield = {
				geo: jd.box,
				scale: [1, 1, .2]
			}, kd.equilibrate = {
				geo: jd.box,
				scale: [.5, .5, .5]
			}, kd.warrior_sword = {
				geo: jd.box,
				scale: [.9, 4.2, .5]
			}, kd.warrior_shield = {
				geo: jd.box,
				scale: [.5, 3.5, 3.5]
			}, kd.archer_bow = {
				geo: jd.bow
			}, kd.archer_bow_end = {
				geo: jd.box,
				scale: [1, .6, .5]
			}, kd.archer_ammo = {
				geo: jd.box,
				scale: [.27, .5, .27]
			}, kd.archer_ammo2 = {
				geo: jd.box,
				scale: [1.2, .8, 1.2]
			}, kd.archer_arrow = {
				geo: jd.box,
				scale: [.1, .1, .8]
			}, kd.generic_sword = {
				geo: jd.box,
				scale: [.3, 1.3, .15]
			}, kd.generic_backpack = {
				geo: jd.box,
				scale: [1.1, .8, .6]
			}, kd.generic_vendorlist = {
				geo: jd.box,
				scale: [.4, 2, 2]
			}, kd.slime = {
				geo: jd.slime,
				scale: [1, 1, 1]
			}, Vc.monster = new THREE.MeshLambertMaterial({
				color: 8286051,
				shading: THREE.FlatShading
			}), Vc.bone = new THREE.MeshLambertMaterial({
				color: 14800547,
				shading: THREE.FlatShading
			}), Vc.shaman = new THREE.MeshLambertMaterial({
				color: 3687924,
				shading: THREE.FlatShading
			}), Vc.warrior = new THREE.MeshLambertMaterial({
				color: 15172191,
				shading: THREE.FlatShading
			}), Vc.archer = new THREE.MeshLambertMaterial({
				color: 10471258,
				shading: THREE.FlatShading
			}), Vc.mage = new THREE.MeshLambertMaterial({
				color: 6607340,
				shading: THREE.FlatShading
			}), Vc.highlight = new THREE.MeshLambertMaterial({
				color: 16776960,
				shading: THREE.FlatShading
			}), Vc.warden = new THREE.MeshLambertMaterial({
				color: 14755623,
				shading: THREE.FlatShading
			}), Vc.damage = new THREE.MeshLambertMaterial({
				color: 13382451,
				emissive: 4393996
			}), Vc.dead = new THREE.MeshBasicMaterial({
				color: 2236962,
				shading: THREE.FlatShading
			}), Vc.vendor = new THREE.MeshLambertMaterial({
				color: 12467195,
				shading: THREE.FlatShading
			}), Vc.leg = new THREE.MeshLambertMaterial({
				color: 3451301,
				shading: THREE.FlatShading
			}), Vc.generic_sword = new THREE.MeshLambertMaterial({
				color: 16711680,
				shading: THREE.FlatShading
			}), Vc.generic_wood = new THREE.MeshLambertMaterial({
				color: 8937028,
				shading: THREE.FlatShading
			}), Vc.generic_metal = new THREE.MeshStandardMaterial({
				color: 14736861,
				shading: THREE.FlatShading
			}), Vc.generic_white = new THREE.MeshLambertMaterial({
				color: 16777215,
				shading: THREE.FlatShading
			}), Vc.generic_ice = new THREE.MeshBasicMaterial({
				color: 16777215
			}), Vc.mage_frost = new THREE.MeshBasicMaterial({
				color: 13434879,
				transparent: true,
				opacity: .6
			}), Vc.shaman_macetop = new THREE.MeshLambertMaterial({
				color: 11643819,
				shading: THREE.FlatShading
			}), Vc.archer_ammo = new THREE.MeshLambertMaterial({
				color: 14795173,
				shading: THREE.FlatShading
			}), Vc.archer_ammo2 = new THREE.MeshLambertMaterial({
				color: 16312288,
				shading: THREE.FlatShading
			}), Vc.gold = new THREE.MeshStandardMaterial({
				color: 16440582,
				emissive: 16740864,
				metalness: .5,
				roughness: .4
			}), Vc.metal = new THREE.MeshStandardMaterial({
				color: 11582396,
				emissive: 3158071,
				metalness: .55,
				roughness: .4
			}), Vc.silver = new THREE.MeshStandardMaterial({
				color: 13891577,
				emissive: 5994641,
				metalness: .58,
				roughness: .4
			});
			var ld = [],
				md = function(a) {
					for (var b = ld.length; b--;) {
						var c = ld[b];
						c.tick(a), c.deleteMe && (c.remove(), ld.splice(b, 1))
					}
				},
				nd = function(a) {
					if (!Va && "false" != Pa.get("skillefx")) {
						var b = new ba(a);
						return ld.push(b), b
					}
				};
			ba.prototype.tick = function(a) {
				this.stepIntervalTimer -= a, this.stepIntervalTimer <= 0 ? (this.stepIntervalTimer = this.stepInterval, this.step()) : "glue" == this.headType && (this.at[this.steps - 1].copy(this.a.getWorldPosition()), this.bt[this.steps - 1].copy(this.b.getWorldPosition()), this.updateVertice(this.steps - 1)), "compress" == this.tailType && (this.uvStepSize = 1 / Math.min(this.steps, this.stepsDone - this.stepIntervalTimer / this.stepInterval)), this.uvShift = this.uvStepSize * (this.stepIntervalTimer / this.stepInterval);
				for (var b = 0; b < this.steps; b++) this.updateUV(b);
				this.timeout && (this.timer -= a, this.timer < 0 && (this.deleteMe = true))
			}, ba.prototype.step = function(a, b) {
				++this.stepsDone;
				var c = a || this.a.getWorldPosition(),
					d = b || this.b.getWorldPosition();
				this.at.shift(), this.bt.shift(), this.at.push(c), this.bt.push(d);
				for (var e = 0; e < this.steps; e++) this.updateVertice(e)
			}, ba.prototype.updateVertice = function(a) {
				this.geom.vertices[2 * a].copy(this.at[a]), this.geom.vertices[2 * a + 1].copy(this.bt[a]), this.geom.verticesNeedUpdate = true, this.geom.normalsNeedUpdate = true
			}, ba.prototype.updateUV = function(a) {
				if (a < this.steps - 1) {
					var b = (this.steps - a - 1) * this.uvStepSize - this.uvShift,
						c = (this.steps - a - 2) * this.uvStepSize - this.uvShift;
					this.geom.faceVertexUvs[0][2 * a][0].y = b, this.geom.faceVertexUvs[0][2 * a][1].y = c, this.geom.faceVertexUvs[0][2 * a][2].y = b, this.geom.faceVertexUvs[0][2 * a + 1][0].y = c, this.geom.faceVertexUvs[0][2 * a + 1][1].y = c, this.geom.faceVertexUvs[0][2 * a + 1][2].y = b, this.geom.uvsNeedUpdate = true
				}
			}, ba.prototype.remove = function() {
				Ac.remove(this.mesh), Ac.remove(this.a), Ac.remove(this.b), this.geom.dispose()
			}, j.prototype.timeSinceLastUpdate = 0, j.prototype.initPlayer = function(a, b) {
				this.id = a, this.geometry = new THREE.Object3D, Ac.add(this.geometry), this.body = new THREE.Group, Ac.add(this.body), this.geometry.add(this.body), this.hitbox = new THREE.Mesh(kd.hitbox.geo, Vc.hitbox), this.hitbox.scale.set(kd.hitbox.scale[0], kd.hitbox.scale[1], kd.hitbox.scale[2]), this.body.add(this.hitbox), this.hitbox.position.y = 1, this.hitbox.entity = this, this.visualPosition = new THREE.Vector3, b && (this.isPlayer = true, Ic = this, this.outofpositioncounter = 0, Ac.remove(Fc), Fc.position.x = 0, Fc.position.z = 8, Fc.position.y = 1.5, this.camPivot = new THREE.Object3D, this.camPivot.rotation.order = "YXZ", Ac.add(this.camPivot), this.camPivot.add(Fc), this.serverpos = new THREE.Vector3, this.ignoreInput = 0), this.visualRotationSpeed = 0, this.visualRotationLast = 0, this.visualRotation = 0, this.dmgSprites = new Array, "true" == Pa.get("nameplates") && (this.namesprite = new ha("", {
					align: Od.center,
					font: "500 18px 'Roboto'",
					fillStyle: "#FFFFFF",
					outlineSize: 4,
					outlineStyle: "black",
					antialias: false
				}), Bc.add(this.namesprite), this.namesprite.position.set(0, 30, 0), this.namesprite.scale.set(1, 1, 1), this.clansprite = new ha("", {
					align: Od.center,
					font: "800 18px 'Roboto'",
					fillStyle: "#FFFFFF",
					outlineSize: 4,
					outlineStyle: "black",
					antialias: false
				}), Bc.add(this.clansprite), this.clansprite.position.set(-50, 30, 0), this.clansprite.scale.set(1, 1, 1)), this.levelsprite = new ha("5", {
					align: Od.center,
					font: "500 18px 'Roboto'",
					fillStyle: "#FFFFFF",
					outlineSize: 4,
					outlineStyle: "black",
					antialias: false
				}), Bc.add(this.levelsprite), this.levelsprite.position.set(0, 0, 0), this.levelsprite.scale.set(1, 1, 1), this.hpbar = new Object, this.hpbar.bg = new THREE.Sprite(Vc.hpbarbg), Bc.add(this.hpbar.bg), this.hpbar.fg = new THREE.Sprite(Vc.hpbarfriendly), Bc.add(this.hpbar.fg), this.factionIcon = new THREE.Sprite(Vc.factionA), this.factionIcon.position.set(0, 0, 0), this.factionIcon.scale.set(1, 1, 1), Bc.add(this.factionIcon)
			}, j.prototype.playertick = function(a) {
				if (this != Ic) return void(this.isPlayer = false);
				if (this.ignoreInput -= a, this.ignoreInput < 0 && (this.ignoreInput = 0), this.stats && !this.stats.isDead() && !this.stats.incapacitated && this.ignoreInput <= 0 && (this.walkForward = 0, this.walkSideward = 0, Ia && (Tb.cameraY -= 2.3 * a), Ja && (Tb.cameraY += 2.3 * a), this.camPivot.rotation.x = Tb.cameraX, this.camPivot.rotation.y = Tb.cameraY, (Tb.rmb || Ia || Ja || "true" == Pa.get("camlock")) && (this.geometry.rotation.y = Tb.cameraY), (Ga || Tb.lmb && Tb.rmb) && (this.walkForward = 1), Ha && (this.walkForward = -1), Fa && (this.walkSideward = 1), Ea && (this.walkSideward = -1), this.rotation = this.geometry.rotation.y, 0 != Ga && !Tb.lmb && !Tb.rmb && "true" != Pa.get("camlock"))) {
					var b = E(Tb.cameraY, this.geometry.rotation.y) * a * 2;
					Math.abs(b) > .03 * a ? (b = b > 0 ? Math.max(b, .6 * a) : Math.min(b, -.6 * a), Tb.cameraY += b) : Tb.cameraY = this.geometry.rotation.y
				}
				this.camPivot.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), Fc.position.z = Tb.cameraZoom
			}, j.prototype.clienttick = function(a) {
				if (this.tick(a), !this.stats.isDead())
					if (this.isPlayer) {
						if (!this.stats.incapacitated) {
							var b = Math.abs(this.serverpos.x - this.position.x),
								c = Math.abs(this.serverpos.z - this.position.z);
							b > 10 || c > 10 ? (this.outofpositioncounter += a, (this.outofpositioncounter > 3 || b > 50 || c > 50) && (this.position.x = this.serverpos.x, this.position.z = this.serverpos.z, this.outofpositioncounter = 0)) : this.outofpositioncounter = 0
						}
						this.geometry.position.x = this.position.x, this.geometry.position.z = this.position.z, this.geometry.position.y = Qc(this.geometry.position.x, this.geometry.position.z), this.visualPosition.copy(this.position), this.geometry.rotation.y = this.rotation
					} else {
						this.next.position.x += this.velocity.x * a * this.stats.movespeed, this.next.position.z += this.velocity.z * a * this.stats.movespeed;
						var d = new THREE.Vector3;
						d.subVectors(this.position, this.visualPosition);
						var e = 0 != d.x || 0 != d.z ? d.length() : 0;
						if (e > .8 * this.stats.movespeed ? (this.visualPosition.copy(this.position), d.x = 0, d.z = 0) : e > .1 * this.stats.movespeed ? d.setLength(a * this.stats.movespeed) : (this.position != this.next.position && (this.position.x = this.next.position.x, this.position.z = this.next.position.z), d.multiplyScalar(10 * a)), this.visualPosition.add(d), this.geometry.position.x = this.visualPosition.x, this.geometry.position.z = this.visualPosition.z, this.geometry.position.y = Qc(this.geometry.position.x, this.geometry.position.z), this.visualRotationLast != this.rotation && (this.visualRotationLast - this.rotation > Math.PI ? this.visualRotationSpeed = 10 * (this.rotation + Ua - this.visualRotation) * a : this.visualRotationLast - this.rotation < -Math.PI ? this.visualRotationSpeed = 10 * (this.rotation - Ua - this.visualRotation) * a : this.visualRotationSpeed = 10 * (this.rotation - this.visualRotation) * a, this.visualRotationLast = this.rotation), Math.abs(this.rotation - this.visualRotation) > Math.abs(this.visualRotationSpeed)) {
							for (this.visualRotation += this.visualRotationSpeed; this.visualRotation < 0;) this.visualRotation += Ua, this.visualRotationLast = this.visualRotation;
							for (; this.visualRotation > Ua;) this.visualRotation -= Ua, this.visualRotationLast = this.visualRotation
						}
						this.geometry.rotation.y = this.visualRotation, Wc.push(this.hitbox), void 0 !== this.desiredTarget && "" != this.desiredTarget && za.entities.hasOwnProperty(this.desiredTarget) && (this.target = za.entities[this.desiredTarget], this.desiredTarget = "")
					}
				if (this.tickAnimations(a), this != Ic) this.timeSinceLastUpdate += a, this.timeSinceLastUpdate > 3 && Ca(this.id);
				else {
					this.camPivot.position.copy(this.geometry.position), this.camPivot.updateMatrixWorld(), Fc.updateMatrixWorld();
					var f = new THREE.Vector3(30 * Math.round(this.geometry.position.x / 30), 30 * Math.round(this.geometry.position.y / 30), 30 * Math.round(this.geometry.position.z / 30));
					f.x == Ec.target.position.x && f.y == Ec.target.position.y && f.z == Ec.target.position.z || (Ec.position.set(f.x + 1500, f.y + 2500, f.z), Ec.target.position.copy(f))
				}
				if (this.stats.scale != this.last.stats.scale) {
					this.last.stats.scale = this.stats.scale;
					var g = Math.max(1, 2 / this.stats.scale);
					this.hitbox.scale.set(g, g, g)
				}
				this.hpbar && this.tickHud(a)
			}, j.prototype.destroyBody = function() {
				this.namesprite && this.namesprite.finalCleanUp(), this.clansprite && this.clansprite.finalCleanUp(), this.levelsprite && this.levelsprite.finalCleanUp(), Bc.remove(this.clansprite), Bc.remove(this.namesprite), Bc.remove(this.hpbar.fg), Bc.remove(this.hpbar.bg), Bc.remove(this.levelsprite), Bc.remove(this.factionIcon), delete this.namesprite, delete this.clansprite, delete this.levelsprite, delete this.hpbar.fg, delete this.hpbar.bg, delete this.factionIcon, this.isPlayer && Ac.remove(this.camPivot);
				for (var a = this.dmgSprites.length; a--;) Bc.remove(this.dmgSprites[a]), this.dmgSprites[a].finalCleanUp(), this.dmgSprites.splice(a, 1);
				ca(this.geometry), Ac.remove(this.geometry), delete this.geometry
			}, j.prototype.takeDamage = function(a) {
				this.stats.invincible || (this.dmgShake = .2)
			}, j.prototype.takeHealing = function(a) {}, j.prototype.updateFaction = function(a, b) {
				if (this.faction = a, !b) {
					var c;
					switch (a) {
						case 0:
							c = Vc.factionA;
							break;
						case 1:
							c = Vc.factionB;
							break;
						case 2:
							return
					}
					this.factionIcon.material = c
				}
				if (Ic && (2 == this.faction ? this.hpbar.fg.material = Vc.hpbarmob : this.hpbar.fg.material = this.faction == Ic.faction ? Vc.hpbarfriendly : Vc.hpbarenemy, this.hpbar.fg.materialNeedsUpdate = true, this == Ic))
					for (var d in Jc) Jc.hasOwnProperty(d) && void 0 !== Jc[d] && Jc[d] != this && Jc[d].updateFaction(Jc[d].faction, true)
			}, j.prototype.getInfoPanelString = function() {
				if (!Ic) return "";
				var a = this.faction == Ic.faction ? "Friendly" : "Hostile",
					b = this.faction == Ic.faction ? "ally" : "enemy",
					c = this.isAi ? "monster" : "player";
				return "<div class='targetinfo targettext " + b + "'><span class='targetname'>" + this.name + "</span> <span class='targetlevel'>" + this.class.level + "</span></div> " + a + " " + c
			};
			var od = function() {
					for (e in za.entities) za.entities[e] && za.entities[e] != Ic && (za.entities[e].canFightPlayer = ib(za.entities[e], Ic).canFight())
				},
				pd = new THREE.Vector2(100, 10),
				qd = [],
				rd = [],
				sd = void 0,
				td = void 0,
				ud = .996,
				vd = .8;
			j.prototype.tickHud = function(a) {
				if (Ic && this.geometry) {
					var b = new THREE.Vector3;
					b.copy(this.geometry.position), b.y += Math.max(.5, this.stats.scale + 1), b = da(b, Fc);
					var c = (ud - b.z) * (1 / (ud - vd));
					this.worlddist = Ic && this != Ic ? ib(Ic, this).distance() : 1;
					var d = false,
						e = 1;
					if (this.isInHud = b.z < 1 && Math.abs(b.x) < .5 * za.width && Math.abs(b.y) < .5 * za.height, this != Ic && !this.stats.isDead() && this.worlddist < 50 && b.z > vd && this.isInHud) {
						var f = Ic && this == Ic.target || this == Ic,
							g = f ? 1 : Math.min(1.5, .4 + 12 * c);
						(f || "" != this.clan && this.clan == Ic.clan) && (b.z = 4), b.y += 8;
						var h = Math.round(b.y + 15 * g);
						this.levelsprite.position.set(b.x + (.5 * pd.x + .5 * this.levelsprite.canvas.textWidth + 2) * g, b.y, b.z + 3e-5);
						var i = pd.x * Math.max(0, Math.min(1, this.stats.currenthp / this.stats.maxhp));
						this.hpbar.bg.position.set(b.x, b.y, b.z + 1e-5), this.hpbar.fg.position.set(b.x + (.5 * i - .5 * pd.x) * g, b.y, b.z + 2e-5), this.factionIcon.position.set(b.x - 55 * g, b.y, b.z + 3e-5), this.hpbar.bg.scale.set((pd.x + 4) * g, (pd.y + 4) * g, 1), this.hpbar.fg.scale.set(i * g, pd.y * g, 1), this.levelsprite.scale.set(g, g, 1), this.factionIcon.scale.set(20 * g, 20 * g, 1), this.hpbar.fg.material = Ic && "" != this.clan && this.clan == Ic.clan ? Vc.hpbarclan : void 0 === Ic || this.faction == Ic.faction ? f ? Vc.hpbarfriendly : Vc.hpbarfriendlyTransparent : f ? 2 == this.faction ? Vc.hpbarmob : this.canFightPlayer ? Vc.hpbarenemy : Vc.hpbarcantfight : 2 == this.faction ? Vc.hpbarmobTransparent : this.canFightPlayer ? Vc.hpbarenemyTransparent : Vc.hpbarcantfightTransparent, this.hpbar.bg.material = f || "" != this.clan && this.clan == Ic.clan ? Vc.hpbarbg : Vc.hpbarbgTransparent, e = f ? 1 : "" != this.clan && this.clan == Ic.clan ? 1 : .4, this.levelsprite.material.opacity = e, this.stats.isDead() || (this.faction != Ic.faction ? qd.push({
							entity: this,
							z: this.worlddist
						}) : rd.push({
							entity: this,
							z: this.worlddist
						})), this.hpbar.fg.visible = true, this.hpbar.bg.visible = true, this.levelsprite.visible = true, this.factionIcon.visible = 2 != this.faction, this.namesprite && (this.namesprite.visible = true, this.namesprite.position.set(Math.round(b.x + (this.clan ? .5 * this.clansprite.canvas.textWidth * g : 0)), h, b.z + 3e-5), this.namesprite.material.opacity = e, this.namesprite.scale.set(g, g, 1)), this.clansprite && ("" != this.clan ? (this.clansprite.visible = true, this.clansprite.position.set(Math.round(b.x - (.5 * this.namesprite.canvas.textWidth + 5) * g), h, b.z + 3e-5), this.clansprite.material.opacity = e, this.clansprite.scale.set(g, g, 1)) : this.clansprite.visible = false), d = true
					} else this.hpbar.fg.visible = false, this.hpbar.bg.visible = false, this != Ic && (this.namesprite && (this.namesprite.visible = false), this.clansprite && (this.clansprite.visible = false)), this.levelsprite.visible = false, this.factionIcon.visible = false;
					this == Ic && X();
					for (var j = this.dmgSprites.length; j--;) {
						var k = this.dmgSprites[j];
						if (k.timer += a, k.timer > 1.5) Bc.remove(k), k.finalCleanUp(), this.dmgSprites.splice(j, 1);
						else if (this.isInHud) {
							var l = Math.max(1, 2 - 3 * k.timer);
							k.scale.set(l, l, 1), k.origin.y += k.yvel * a, k.timer > .8 && (k.material.opacity -= 2 * a);
							var b = da(k.origin, Fc);
							k.position.set(b.x + k.xoffset, b.y + 30, 6), k.isVisible = true
						} else k.isVisible = false
					}
				}
			}, j.prototype.createCombatText = function(a, b, c) {
				if (!Ic || this.faction == Ic.faction || !c) {
					var d = new THREE.Vector3(this.geometry.position.x, this.geometry.position.y + this.stats.scale + 1.2, this.geometry.position.z),
						e = da(d, Fc);
					if (e.z > vd && e.z < 1 && Math.abs(e.x) < .5 * za.width && Math.abs(e.y) < .5 * za.height) {
						var f = this.faction == (Ic ? Ic.faction : 0) ? c ? "#59DD36" : "#FF0000" : "#FFFF00",
							g = new ha(a, {
								align: Od.center,
								font: "500 24px 'Roboto'",
								fillStyle: f
							});
						Bc.add(g), g.origin = d, g.xoffset = (10 * Math.random() - 5) * this.dmgSprites.length, g.yvel = 3 + 10 * Math.min(b / this.stats.maxhp, .3), g.timer = 0, this.dmgSprites.push(g)
					}
				}
			};
			var wd, xd, yd, zd = function() {
					if (sd = void 0, td = void 0, qd.sort(function(a, b) {
							return a.z - b.z
						}), rd.sort(function(a, b) {
							return a.z - b.z
						}), Ic && Ic.target) {
						for (var a = 0, b = qd.length; a < b; ++a) Ic.target == qd[a].entity && (sd = qd[a + 1] ? qd[a + 1].entity : qd[0].entity);
						for (var a = 0, b = rd.length; a < b; ++a) Ic.target == rd[a].entity && (td = rd[a + 1] ? rd[a + 1].entity : rd[0].entity)
					}
					void 0 == sd && qd.length > 0 && (sd = qd[0].entity), void 0 == td && rd.length > 0 && (td = rd[0].entity)
				},
				Ad = void 0,
				Bd = 0,
				Cd = void 0,
				Dd = void 0,
				Ed = void 0,
				Fd = ["Alpheos", "Balius", "Charon", "Deimos", "Ether", "Fates", "Garrosh", "Helios", "Iris"],
				Gd = void 0,
				Hd = void 0;
			$(document).ready(function() {
				Id()
			});
			var Id = function() {
					xd = "localhost" == document.location.hostname ? io("localhost:8123") : io(Xa + ":80"), xd.on("d", function(a) {
						load_c = true, void 0 !== a.address && (Cd = a.address), void 0 !== a.id && (Dd = a.id), Cd = Cd.replace("127.0.0.1", "localhost"), a.sc === true && Jd(Cd)
					}), xd.on("m", function(a) {
						if (a) {
							if (a.m)
								for (var b in a.m) a.m.hasOwnProperty(b) && (a.m[b].hasOwnProperty("dps") && $("#" + b + "dps").html(d(parseInt(a.m[b].dps), 1) + " dps"), a.m[b].hasOwnProperty("pc") && $("#" + b + "players").html(parseInt(a.m[b].pc) + " players"), a.m[b].hasOwnProperty("kh") && $("#" + b + "king").html("King: " + parseInt(a.m[b].kh) + "%"), a.m[b].hasOwnProperty("g") && $("#" + b + "gold").html(d(parseInt(a.m[b].g), 1)));
							if (a.l)
								for (m in a.l) void 0 !== a.l[m].c && (qc[m].class = a.l[m].c), void 0 !== a.l[m].n && (qc[m].name = a.l[m].n), void 0 !== a.l[m].l && (qc[m].level = a.l[m].l), void 0 !== a.l[m].f && (qc[m].fame = a.l[m].f), void 0 !== a.l[m].h && (qc[m].horde = a.l[m].h), rc(parseInt(m) + 1, {
									class: qc[m].class,
									name: qc[m].name,
									fame: qc[m].fame,
									lvl: qc[m].level,
									horde: qc[m].horde
								});
							if (void 0 !== a.s && "object" == typeof a.s) {
								$("#channelname").html((Fd.length - 1 > Dd ? Fd[Dd] + (Fd.length - 1 > Dd ? " (" + a.s[Dd] + ")" : "") : "Channel") + " <span class='caret'>");
								var c = $("#serverselectionlist");
								c.empty();
								for (var e = 0; e < parseInt(a.s.length); ++e) {
									var f = $("<li/>").appendTo(c),
										g = $("<a/>").text(Fd[e] + ("" != a.s[e] ? " (" + a.s[e] + ")" : "")).appendTo(f).data("sr", e);
									e == Dd && g.css("font-weight", 800), g.on("click", function(a) {
										xd.emit("sr", parseInt($(this).data("sr")))
									})
								}
							}
						}
					}), xd.on("c", function(a) {
						a.m && a.i && Y({
							msg: a.m,
							src: a.i,
							name: a.n,
							r: a.r,
							c: a.c,
							f: a.f
						})
					}), xd.on("gm", function(a) {
						switch (a.t) {
							case "pk":
								Y({
									msg: "$" + a.f + a.a + " killed $" + (0 == a.f ? 1 : 0) + a.b + " and stole " + a.fa + " fame and " + a.g + " $g",
									src: "playerkill"
								})
						}
					})
				},
				Jd = function(b) {
					if (void 0 !== b) {
						void 0 != wd && (wd.disconnect(), delete wd), void 0 !== Hd && (clearInterval(Hd), Hd = void 0), void 0 !== Gd && (clearInterval(Gd), Gd = void 0), wd = io(b), wd.on("handshake", function(a) {
							yd = a.playerid, void 0 !== Ed ? (Md(Ed), Ed = void 0) : void 0 !== Ad ? Md(Ad) : Kd(), $("#loginfade").remove()
						});
						var c = [],
							d = 5,
							e = function(a) {
								var b = a.e;
								for (var e in b)
									if (b.hasOwnProperty(e) && (Jc.hasOwnProperty(e) && void 0 != Jc[e] || (Jc[e] = new j(0), Jc[e].initPlayer(e, e == yd), e == yd && b[e].r && (Tb.cameraY = parseFloat(b[e].r), Tb.cameraX = -.5))), Ba(e, b[e]), void 0 === Jc[e].class.type) c.indexOf(e) < 0 && c.push(e + "");
									else {
										var f = c.indexOf(e);
										f > -1 && c.splice(f, 1)
									}
								if (d++, d >= 10 && c.length > 0 && (d = 0, wd.emit("ref", c), c = []), a.pr)
									for (var e in a.pr) a.pr.hasOwnProperty(e) && Jc.hasOwnProperty(e) && Ba(e, a.pr[e]);
								if (a.i)
									for (var g in a.i) a.i.hasOwnProperty(g) && (void 0 !== a.i[g].r ? void 0 !== nb[g] && nb[g].destroy() : void 0 === nb[g] && (a.i[g].i = g, nb[g] = new p(a.i[g])))
							};
						wd.on("e", e), wd.on("c", function(a) {
							a.m && a.i && Y({
								msg: a.m,
								src: a.i,
								name: a.n,
								r: a.r,
								c: a.c,
								f: a.f
							})
						}), wd.on("spawn", function(b) {
							if (e(b.m), b.dbid && ($("#charIdDisplay").text(b.dbid), Ad = b.dbid, xd.emit("a", b.dbid)), Ic && b.abl)
								for (a in b.abl) Ic.class.skills[parseInt(a)].setLevel(b.abl[a]);
							var c = Pa.get("name");
							c && wd.emit("namechange", c), bc.player.panel.hide(), $("#renderer").fadeIn(300, function() {
								pc("fadeIn", 300), bc.target.panel.hide(), nc = false, $("#inventory").show(), $("#characterpanel").show()
							}), Hb()
						}), wd.on("del", function(a) {
							Ca(a)
						}), wd.on("disconnect", function() {
							Da(), pc("fadeOut", 500), Ac.add(Fc)
						}), wd.on("lm", function(a) {
							var b;
							switch (a.r) {
								case "l":
									$("#modal-user").modal("show"), b = "#serverLoginMessage";
									break;
								case "c":
									b = "#createClanMsg";
									break;
								case "n":
									b = "#setNickMsg";
									break;
								case "ca":
									b = "#clanActionMsg"
							}
							$(b).text(a.m), $(b).fadeIn()
						}), wd.on("inv", function(a) {
							yb(a)
						}), wd.on("cl", function(a) {
							sb(a)
						}), wd.on("ci", function(a) {
							$("#userinteract").show().centerMe(0, -150), $("#userinteractmsg").html("<b>" + a.i + "</b> has invited you to join the clan <b>" + a.t + "</b>")
						}), Gd = setInterval(function() {
							if (!document.hidden && performance.now() - Yc < 1e3 && Ic) {
								var a = Ic.getDeltaMsg();
								a !== false && wd.emit("u", a)
							}
						}, Ya);
						var f;
						Hd = setInterval(function() {
							document.hidden || (f = performance.now(), wd.emit("pi"))
						}, 2e3), wd.on("po", function(a) {
							Bd = Math.max(0, (2 * Bd + (performance.now() - f)) / 3)
						})
					}
				},
				Kd = function() {
					Ld($("#usernameInputField").val()), wd.emit("requestSpawn", {
						name: Pa.get("name"),
						class: Pa.get("class"),
						faction: Pa.get("faction")
					})
				},
				Ld = function(a) {
					void 0 != a && "string" == typeof a || (a = ""), Pa.set("name", a)
				},
				Md = function(a) {
					wd.emit("requestSpawn", {
						id: a
					})
				},
				Nd = function(a) {
					wd.emit("cc", a)
				};
			if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); + function(a) {
				"use strict";
				var b = a.fn.jquery.split(" ")[0].split(".");
				if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1 || b[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")
			}(jQuery), + function(a) {
				"use strict";

				function b(b) {
					return this.each(function() {
						var d = a(this),
							e = d.data("bs.button"),
							f = "object" == typeof b && b;
						e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b)
					})
				}
				var c = function(b, d) {
					this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = false
				};
				c.VERSION = "3.3.7", c.DEFAULTS = {
					loadingText: "loading..."
				}, c.prototype.setState = function(b) {
					var c = "disabled",
						d = this.$element,
						e = d.is("input") ? "val" : "html",
						f = d.data();
					b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function() {
						d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = true, d.addClass(c).attr(c, c).prop(c, true)) : this.isLoading && (this.isLoading = false, d.removeClass(c).removeAttr(c).prop(c, false))
					}, this), 0)
				}, c.prototype.toggle = function() {
					var a = true,
						b = this.$element.closest('[data-toggle="buttons"]');
					if (b.length) {
						var c = this.$element.find("input");
						"radio" == c.prop("type") ? (c.prop("checked") && (a = false), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = false), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change")
					} else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
				};
				var d = a.fn.button;
				a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function() {
					return a.fn.button = d, this
				}, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(c) {
					var d = a(c.target).closest(".btn");
					b.call(d, "toggle"), a(c.target).is('input[type="radio"], input[type="checkbox"]') || (c.preventDefault(), d.is("input,button") ? d.trigger("focus") : d.find("input:visible,button:visible").first().trigger("focus"))
				}).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(b) {
					a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type))
				})
			}(jQuery), + function(a) {
				"use strict";

				function b(b) {
					var c = b.attr("data-target");
					c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));
					var d = c && a(c);
					return d && d.length ? d : b.parent()
				}

				function c(c) {
					c && 3 === c.which || (a(e).remove(), a(f).each(function() {
						var d = a(this),
							e = b(d),
							f = {
								relatedTarget: this
							};
						e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger(a.Event("hidden.bs.dropdown", f)))))
					}))
				}

				function d(b) {
					return this.each(function() {
						var c = a(this),
							d = c.data("bs.dropdown");
						d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c)
					})
				}
				var e = ".dropdown-backdrop",
					f = '[data-toggle="dropdown"]',
					g = function(b) {
						a(b).on("click.bs.dropdown", this.toggle)
					};
				g.VERSION = "3.3.7", g.prototype.toggle = function(d) {
					var e = a(this);
					if (!e.is(".disabled, :disabled")) {
						var f = b(e),
							g = f.hasClass("open");
						if (c(), !g) {
							"ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);
							var h = {
								relatedTarget: this
							};
							if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;
							e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h))
						}
						return false
					}
				}, g.prototype.keydown = function(c) {
					if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
						var d = a(this);
						if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
							var e = b(d),
								g = e.hasClass("open");
							if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");
							var h = " li:not(.disabled):visible a",
								i = e.find(".dropdown-menu" + h);
							if (i.length) {
								var j = i.index(c.target);
								38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus")
							}
						}
					}
				};
				var h = a.fn.dropdown;
				a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function() {
					return a.fn.dropdown = h, this
				}, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function(a) {
					a.stopPropagation()
				}).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown)
			}(jQuery), + function(a) {
				"use strict";

				function b(b, d) {
					return this.each(function() {
						var e = a(this),
							f = e.data("bs.modal"),
							g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b);
						f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d)
					})
				}
				var c = function(b, c) {
					this.options = c, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = false, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function() {
						this.$element.trigger("loaded.bs.modal")
					}, this))
				};
				c.VERSION = "3.3.7", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = {
					backdrop: true,
					keyboard: true,
					show: true
				}, c.prototype.toggle = function(a) {
					return this.isShown ? this.hide() : this.show(a)
				}, c.prototype.show = function(b) {
					var d = this,
						e = a.Event("show.bs.modal", {
							relatedTarget: b
						});
					this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = true, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function() {
						d.$element.one("mouseup.dismiss.bs.modal", function(b) {
							a(b.target).is(d.$element) && (d.ignoreBackdropClick = true)
						})
					}), this.backdrop(function() {
						var e = a.support.transition && d.$element.hasClass("fade");
						d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();
						var f = a.Event("shown.bs.modal", {
							relatedTarget: b
						});
						e ? d.$dialog.one("bsTransitionEnd", function() {
							d.$element.trigger("focus").trigger(f)
						}).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f)
					}))
				}, c.prototype.hide = function(b) {
					b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = false, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal())
				}, c.prototype.enforceFocus = function() {
					a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function(a) {
						document === a.target || this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus")
					}, this))
				}, c.prototype.escape = function() {
					this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function(a) {
						27 == a.which && this.hide()
					}, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
				}, c.prototype.resize = function() {
					this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal")
				}, c.prototype.hideModal = function() {
					var a = this;
					this.$element.hide(), this.backdrop(function() {
						a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal")
					})
				}, c.prototype.removeBackdrop = function() {
					this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
				}, c.prototype.backdrop = function(b) {
					var d = this,
						e = this.$element.hasClass("fade") ? "fade" : "";
					if (this.isShown && this.options.backdrop) {
						var f = a.support.transition && e;
						if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function(a) {
								return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = false) : void(a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
							}, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;
						f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b()
					} else if (!this.isShown && this.$backdrop) {
						this.$backdrop.removeClass("in");
						var g = function() {
							d.removeBackdrop(), b && b()
						};
						a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g()
					} else b && b()
				}, c.prototype.handleUpdate = function() {
					this.adjustDialog()
				}, c.prototype.adjustDialog = function() {
					var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;
					this.$element.css({
						paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "",
						paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : ""
					})
				}, c.prototype.resetAdjustments = function() {
					this.$element.css({
						paddingLeft: "",
						paddingRight: ""
					})
				}, c.prototype.checkScrollbar = function() {
					var a = window.innerWidth;
					if (!a) {
						var b = document.documentElement.getBoundingClientRect();
						a = b.right - Math.abs(b.left)
					}
					this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar()
				}, c.prototype.setScrollbar = function() {
					var a = parseInt(this.$body.css("padding-right") || 0, 10);
					this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth)
				}, c.prototype.resetScrollbar = function() {
					this.$body.css("padding-right", this.originalBodyPad)
				}, c.prototype.measureScrollbar = function() {
					var a = document.createElement("div");
					a.className = "modal-scrollbar-measure", this.$body.append(a);
					var b = a.offsetWidth - a.clientWidth;
					return this.$body[0].removeChild(a), b
				};
				var d = a.fn.modal;
				a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function() {
					return a.fn.modal = d, this
				}, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(c) {
					var d = a(this),
						e = d.attr("href"),
						f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
						g = f.data("bs.modal") ? "toggle" : a.extend({
							remote: !/#/.test(e) && e
						}, f.data(), d.data());
					d.is("a") && c.preventDefault(), f.one("show.bs.modal", function(a) {
						a.isDefaultPrevented() || f.one("hidden.bs.modal", function() {
							d.is(":visible") && d.trigger("focus")
						})
					}), b.call(f, g, this)
				})
			}(jQuery), + function(a) {
				"use strict";

				function b(b) {
					return this.each(function() {
						var d = a(this),
							e = d.data("bs.tab");
						e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]()
					})
				}
				var c = function(b) {
					this.element = a(b)
				};
				c.VERSION = "3.3.7", c.TRANSITION_DURATION = 150, c.prototype.show = function() {
					var b = this.element,
						c = b.closest("ul:not(.dropdown-menu)"),
						d = b.data("target");
					if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
						var e = c.find(".active:last a"),
							f = a.Event("hide.bs.tab", {
								relatedTarget: b[0]
							}),
							g = a.Event("show.bs.tab", {
								relatedTarget: e[0]
							});
						if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
							var h = a(d);
							this.activate(b.closest("li"), c), this.activate(h, h.parent(), function() {
								e.trigger({
									type: "hidden.bs.tab",
									relatedTarget: b[0]
								}), b.trigger({
									type: "shown.bs.tab",
									relatedTarget: e[0]
								})
							})
						}
					}
				}, c.prototype.activate = function(b, d, e) {
					function f() {
						g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true), e && e()
					}
					var g = d.find("> .active"),
						h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);
					g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in")
				};
				var d = a.fn.tab;
				a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function() {
					return a.fn.tab = d, this
				};
				var e = function(c) {
					c.preventDefault(), b.call(a(this), "show")
				};
				a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e)
			}(jQuery), + function(a) {
				"use strict";

				function b() {
					var a = document.createElement("bootstrap"),
						b = {
							WebkitTransition: "webkitTransitionEnd",
							MozTransition: "transitionend",
							OTransition: "oTransitionEnd otransitionend",
							transition: "transitionend"
						};
					for (var c in b)
						if (void 0 !== a.style[c]) return {
							end: b[c]
						};
					return false
				}
				a.fn.emulateTransitionEnd = function(b) {
					var c = false,
						d = this;
					a(this).one("bsTransitionEnd", function() {
						c = true
					});
					var e = function() {
						c || a(d).trigger(a.support.transition.end)
					};
					return setTimeout(e, b), this
				}, a(function() {
					a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = {
						bindType: a.support.transition.end,
						delegateType: a.support.transition.end,
						handle: function(b) {
							return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0
						}
					})
				})
			}(jQuery);
			var Od = {
					center: new THREE.Vector2(0, 0),
					left: new THREE.Vector2(1, 0),
					topLeft: new THREE.Vector2(1, -1),
					topRight: new THREE.Vector2(-1, -1),
					right: new THREE.Vector2(-1, 0),
					bottomLeft: new THREE.Vector2(1, 1),
					bottomRight: new THREE.Vector2(-1, 1)
				},
				Pd = {};
			ga.prototype.width = function() {
				return this.canvas.width
			}, ga.prototype.height = function() {
				return this.canvas.height
			}, ga.prototype.drawText = function(a, b) {
				return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx.font = b.font, this.textWidth = Math.max(1, Math.ceil(this.ctx.measureText(a).width)), this.textHeight = fa(this.ctx.font), this.canvas.width = THREE.Math.nextPowerOfTwo(this.textWidth), this.canvas.height = THREE.Math.nextPowerOfTwo(this.textHeight), this.ctx.font = b.font, this.ctx.fillStyle = b.fillStyle, this.ctx.textAlign = "center", this.ctx.textBaseline = "middle", b.shadow > 0 ? (this.ctx.shadowBlur = 1, this.ctx.shadowColor = "black", this.ctx.shadowOffsetX = 1.5, this.ctx.shadowOffsetY = 1.5) : (this.ctx.shadowOffsetX = 0, this.ctx.shadowOffsetY = 0), this.ctx.fillText(a, .5 * this.canvas.width, .5 * this.canvas.height), this.canvas
			}, ha.prototype = new THREE.Object3D, ha.prototype.constructor = ha, ha.prototype.width = function() {
				return this.canvas.textWidth
			}, ha.prototype.height = function() {
				return this.canvas.textHeight
			}, ha.prototype.getText = function() {
				return this._text
			}, ha.prototype.setText = function(a) {
				this._text !== a && (this._text = a, this.updateText())
			}, ha.prototype.getFont = function() {
				return this._font
			}, ha.prototype.setFont = function(a) {
				this._font !== a && (this._font = a, this.updateText())
			}, ha.prototype.getFillStyle = function() {
				return this._fillStyle
			}, ha.prototype.setFillStyle = function(a) {
				this._fillStyle !== a && (this._fillStyle = a, this.updateText())
			}, ha.prototype.updateText = function() {
				this.canvas.drawText(this._text, {
					font: this._font,
					fillStyle: this._fillStyle,
					shadow: this._shadow
				}), this.cleanUp(), this.texture = new THREE.Texture(this.canvas.canvas), this.texture.needsUpdate = true, this.applyAntiAlias(), this.material ? this.material.map = this.texture : this.material = new THREE.SpriteMaterial({
					map: this.texture
				}), this.sprite || (this.sprite = new THREE.Sprite(this.material), this.add(this.sprite)), this.sprite.scale.set(this.canvas.width(), this.canvas.height(), 1)
			}, ha.prototype.cleanUp = function() {
				this.texture && this.texture.dispose()
			}, ha.prototype.finalCleanUp = function() {
				this.cleanUp(), this.material && this.material.dispose(), this.sprite && (this.remove(this.sprite), this.sprite = void 0)
			}, ha.prototype.applyAntiAlias = function() {
				this.antialias === false && (this.texture.magFilter = THREE.NearestFilter, this.texture.minFilter = THREE.LinearMipMapLinearFilter)
			}
		}(window, document);