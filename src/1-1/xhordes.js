! function(b, c) {
    function d(a, b) {
        for (var c = 0; c < ta.length; c++)
            if (a >= ta[c].value) return (a / ta[c].value).toFixed(b).replace(ua, "$1") + ta[c].symbol;
        return a.toFixed(b).replace(ua, "$1")
    }

    function f(a, b) {
        a = a.substring(0, 150), "string" == typeof a && "" != a && xd.emit("c", {
            m: a,
            i: b
        })
    }

    function g(a, b) {
        if (void 0 !== Sa && (Sa.dispose(), delete Sa, Sa = void 0), void 0 !== Ta && (ca(Ta), Ac.remove(Ta), delete Ta, Ta = void 0), "0" != Pa.get("grass")) {
            Sa = new THREE.InstancedBufferGeometry, Sa.copy(new THREE.PlaneBufferGeometry(2, 2)), zc = a;
            var c = 5e3;
            switch (parseInt(Pa.get("grass"))) {
                default:
                    case 1:
                    c = 7;
                break;
                case 2:
                        c = 15;
                    break;
                case 3:
                        c = 30;
                    break;
                case 4:
                        c = 60;
                    break;
                case 5:
                        c = 100
            }
            for (var d = [], e = [], f = [], g = [], h = 0, i = 0, j = 0; j < a.width; ++j)
                for (var k = 0; k < a.height; ++k) {
                    var l = aa(j, k),
                        m = l.a / 255;
                    if (!(l.a <= 5))
                        for (var n = 0; n < c * m; ++n) {
                            var o = (j + Math.random()) / a.width,
                                p = (k + Math.random()) / a.height,
                                q = Math.floor(p * (wc / Lc)) * xc + 3 * Math.floor(o * (wc / Lc));
                            d[i + 0] = o * wc, d[i + 1] = Qc(wc * o, wc * p) + .6, d[i + 2] = p * wc, e[h] = m * (Math.random() + .1) * 2.5 + .4, f[i + 0] = .1 * Math.random() - .05 + l.r / 255, f[i + 1] = .1 * Math.random() - .05 + l.g / 255, f[i + 2] = .1 * Math.random() - .05 + l.b / 255, Math.random() < 1 / (10 * c) && (e[h] += 1.5 * Math.random(), f[i + 0] *= .3 * Math.random() + .7, f[i + 1] *= .3 * Math.random() + .7, f[i + 2] *= .3 * Math.random() + .7), g[i + 0] = b.attributes.normal.array[q], g[i + 1] = b.attributes.normal.array[q + 1], g[i + 2] = b.attributes.normal.array[q + 2], h++, i += 3
                        }
                }
            Sa.addAttribute("translate", new THREE.InstancedBufferAttribute(new Float32Array(d), 3, 1)), Sa.addAttribute("color", new THREE.InstancedBufferAttribute(new Float32Array(f), 3, 1)), Sa.addAttribute("scale", new THREE.InstancedBufferAttribute(new Float32Array(e), 1, 1)), Sa.addAttribute("groundNormal", new THREE.InstancedBufferAttribute(new Float32Array(g), 3, 1)), Vc.foliage || (Vc.foliage = new THREE.RawShaderMaterial({
                uniforms: {
                    map: {
                        value: oa.grass
                    },
                    shadow: {
                        value: Ec.shadow.map
                    },
                    time: {
                        value: 0
                    },
                    camXRot: {
                        value: 0
                    },
                    camYRot: {
                        value: 0
                    },
                    ambient: {
                        value: Dc.color
                    },
                    directional: {
                        value: Ec.color
                    },
                    directionalDir: {
                        value: Ec.position
                    },
                    directionalMVP: {
                        value: new THREE.Matrix4
                    },
                    maxDrawDistance: {
                        value: 150
                    },
                    fogColor: {
                        value: Ac.fog.color
                    },
                    fogDensity: {
                        value: Ac.fog.density
                    },
                    targetCircle: {
                        value: new THREE.Vector4(0, 0, 0, 2)
                    },
                    targetCirclePos: {
                        value: new THREE.Vector2(0, 0)
                    },
                    shadowSize: {
                        value: 0
                    },
                    playerscale: {
                        value: 1
                    }
                },
                vertexShader: pa["grass.vert"],
                fragmentShader: pa["grass.frag"],
                depthTest: !0,
                depthWrite: !0
            })), Ta = new THREE.Mesh(Sa, Vc.foliage), Ta.frustumCulled = !1, Ac.add(Ta)
        }
    }

    function h() {
        if (void 0 !== Sa) {
            var a = 5e-4 * performance.now();
            Vc.foliage.uniforms.time.value = a;
            var b = Fc.getWorldRotation();
            Vc.foliage.uniforms.camXRot.value = b.x, Vc.foliage.uniforms.camYRot.value = b.y, Vc.foliage.uniforms.directionalMVP.value = Ec.shadow.matrix, Ec.shadow.map && Vc.foliage.uniforms.shadow.value != Ec.shadow.map.texture && (Vc.foliage.uniforms.shadow.value = Ec.shadow.map.texture), Ic ? (void 0 !== Ic.stats.scale && (Vc.foliage.uniforms.playerscale.value = Ic.stats.scale), Ic.target || Xc && Xc.drop ? Xc && Xc.drop ? (Vc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(Xc.position.x, Xc.position.z), Vc.foliage.uniforms.targetCircle.value.w = 2, Vc.foliage.uniforms.targetCircle.value.x = 0, Vc.foliage.uniforms.targetCircle.value.y = 0) : (Vc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(Ic.target.visualPosition.x, Ic.target.visualPosition.z), Vc.foliage.uniforms.targetCircle.value.w = Ic.target.stats.scale + .5, Vc.foliage.uniforms.targetCircle.value.x = Ic.target.faction == Ic.faction ? 0 : 1, Vc.foliage.uniforms.targetCircle.value.y = Ic.target.faction == Ic.faction ? 1 : 0) : Vc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(0, 0)) : Vc.foliage.uniforms.playerscale.value = 1
        }
    }

    function j(a, b) {
        this.position = new THREE.Vector3(0, 0, 0), this.velocity = new THREE.Vector3, this.walkForward = 0, this.walkSideward = 0, this.rotation = 0, this.state = new A, this.name = "", this.id = "", this.faction = a, this.stats = new w(this), this.class = new K, this.class.stats = this.stats, this.target = void 0, this.combat = !1, this.clan = "", this.clanrole = 0, this.ignSteep = !1, this.gold = 0, this.fame = 0, this.last = {}, this.last.gold = 0, this.last.faction = -1, this.last.name = "", this.last.id = "", this.last.position = new THREE.Vector3, this.last.walkForward = 0, this.last.walkSideward = 0, this.last.rotation = 0, this.last.updateTime = Date.now(), this.last.state = {}, this.last.class = {}, this.last.class.ai = {}, this.last.class.ai.isresetting = 0, this.last.state.id = 0, this.last.target = {}, this.last.target.id = void 0, this.last.stats = {}, this.last.isAi = !1, this.last.combat = !1, this.visuals = {
            h: 0
        }, this.last.visuals = {
            h: 0
        }, this.serverMsgQueue = {}, Va ? (this.lastDmgTakenTime = 0, this.class = b, this.class.stats = this.stats, this.class.parent = this, this.respawn = !1, this.pickup = void 0, this.fullrequests = [], this.class.ai ? (this.class.ai.class = this.class, this.class.ai.parent = this, this.isAi = !0) : (this.lastPositionUpdate = new THREE.Vector3, this.inventory = new Inventory), this.ignoreMovement = 0, this.class.update(), this.stats.spawn(), this.class.skills[1].setLevel(1), this.personalMessages = {}) : (this.globalAnimStepFuss = Math.round(2 * Math.random()), this.dmgShake = 0, this.class.ai = void 0, this.class.color = Vc.monster, this.next = {}, this.next.position = new THREE.Vector3, this.animationQueue = [])
    }

    function l(a) {
        for (var b in a) return !1;
        return !0
    }

    function n(a, b) {
        var c = b.x - a.x,
            d = b.z - a.z;
        return Math.sqrt(c * c + d * d)
    }

    function o(a, b) {
        this.a = a, this.b = b, this.aggroA = 0, this.aggroB = 0, this.expShareA = 0, this.expShareB = 0
    }

    function p(a) {
        Va ? this.serverInit(a) : this.clientInit(a)
    }

    function q() {
        return Mb = void 0, window.removeEventListener("mousemove", r, !0), !1
    }

    function r(a) {
        Mb && (Mb.style.top = a.clientY - Ob + "px", Mb.style.left = a.clientX - Nb + "px")
    }

    function t(a) {
        return a.charAt(0).toUpperCase() + a.substring(1)
    }

    function u(a) {
        if (this.name = a.name || "", this.target = a.target || void 0, this.source = a.source || void 0, this.ribbon = a.ribbon || void 0, this.effectCallback = a.effect || void 0, this.effectInterval = a.effectInterval || -1, this.effectTimer = this.effectInterval, this.timeout = a.timeout || 30, this.mode = a.mode || "follow", this.movespeed = a.movespeed || 10, this.movedir = a.movedir || void 0, this.position = new THREE.Vector3, a.startposition) this.position.copy(a.startposition);
        else if (this.source) {
            if (this.position.copy(this.source.position), this.source) {
                var b = F(this.source.rotation);
                b.multiplyScalar(1.2 * this.source.stats.scale)
            }
            if (this.position.x += b.x, this.position.z += b.y, !Va) {
                var c = this.source.chest ? this.source.chest.getWorldPosition() : this.source.position;
                this.position.y = c.y
            }
        } else this.deleteMe = !0;
        Va || (a.tick && (this.visualtick = a.tick), this.geometry = a.geometry || new THREE.Mesh(new THREE.BoxGeometry(.3, .3, .3), new THREE.MeshBasicMaterial({
            color: 255
        })), this.geometry.position.copy(this.position), Ac.add(this.geometry), this.ribbon && (this.ribbonObject = nd(this.ribbon)))
    }

    function v(a, b, c) {
        this.slot = a, this.class = b, this.predict = void 0 === c.predict || c.predict, this.ignoreEc = void 0 !== c.ignoreEc && c.ignoreEc, this.simulate = void 0 !== c.simulate && c.simulate, this.allowDeadTarget = void 0 !== c.allowDeadTarget && c.allowDeadTarget, this.description = c.description || "missing description", this.manacost = c.mana || 0, this.levelUpMinLevel = 0, this.level = 0, this.nextLevelCost = 0, this.abilitypower = 0, this.setLevel(c.baselevel || 0), this.name = c.name || "Error: no skill id", this.icon = c.icon || "hpbarbg", this.targettype = c.targettype || "enemy", this.unique = c.unique || !1, this.casttype = c.casttype || "instant", this.casttime = c.casttime || 0, this.casttimer = 0, this.casttarget = void 0, this.cooldown = void 0 !== c.cooldown ? c.cooldown : 0, this.cooldowntimer = 0, this.causeGlobalCooldown = void 0 === c.causeGlobalCD || c.causeGlobalCD, this.maxrange = c.maxrange || 1e3, this.spell = c.spell || void 0, this.hasChanneledSpell = c.spellchannel || void 0, this.effect = c.effect || function() {
            console.log("error, missing skill effect: " + this.name)
        }, this.effecttype = c.effecttype || "instant", this.channelInterval = c.channelInterval || ("channel" == this.effecttype ? 1 : void 0), this.channelDuration = c.channelDuration || ("channel" == this.effecttype ? 2 : void 0), this.channelMoveInterrupt = void 0 === c.channelMoveInterrupt || c.channelMoveInterrupt, this.channelInstantFirstTick = void 0 !== c.channelInstantFirstTick && c.channelInstantFirstTick, this.channelDuration && (this.channelTimer = -1), this.channelInterval && (this.channelIntervalTimer = -1), this.onCastFun = c.onCastFun || void 0;
        var d = this;
        this.effectWrapper = function(a) {
            d.effect && (a.source = a.source || d.parent, a.target = a.target || d.casttarget, d.effect(a))
        }, Va || (this.getCharacterAnim = c.characterAnim || function() {
            return new V({
                id: "release_spell",
                duration: .5
            })
        }), Va || ("timed" == this.casttype && (this.castAnimation = c.castAnim || new V({
            id: "cast",
            duration: .8,
            type: "loop"
        })), "channel" == this.effecttype && (this.channelAnimation = c.channelAnim || new V({
            id: "channel",
            duration: .5,
            type: "loop"
        })))
    }

    function w(a) {
        this.scale = 1, this.currenthp = 1, this.currentmp = 1, this.maxhp = 1, this.maxmp = 1, this.currentmindmg = 1, this.currentmaxdmg = 1, this.hpregen = 0, this.mpregen = 0, this.movespeed = 1, this.basemana = 100, this.healmod = 1, this.defense = 1, this.crit = 0, this.parent = a, this.incapacitated = !1, this.stunned = !1, this.periodicTickTimerHP = 0, this.periodicTickTimerMP = 0, this.mods = []
    }

    function y(a, b, c) {
        this.id = c.id || void 0, this.duration = c.duration || 1, this.effectinterval = c.interval || -1, this.effectfunction = c.effect || void 0, this.name = c.name || "Error: no name", this.overwrite = c.overwrite || !1, this.unique = c.unique || !1, this.invincible = c.invincible || !1, this.incapacitate = c.incapacitate || !1, this.stun = c.stun || !1, this.movespeed = c.movespeed || void 0, this.healmod = c.healmod || void 0, this.target = a, this.source = b, this.timer = this.duration, this.effecttimer = this.effectinterval, this.deleteMe = !1
    }

    function z() {
        this.id = 0, this.timer = 0, this.duration = 0, this.tick = function(a, b) {}
    }

    function A() {
        this.id = 0, this.duration = 0, this.tick = function(a, b) {
            if (Va && void 0 !== b.queuedSkill) 0 !== b.walkForward || 0 !== b.walkSideward ? b.queuedSkill = void 0 : (b.useSkill(b.queuedSkill, !0), b.queuedSkill = void 0);
            else if (!Va && b.animationQueue && b.animationQueue[0]) switch (b.animationQueue[0].id) {
                case "cast":
                case "dead":
                    b.animationQueue[0].deleteMe = !0
            }
        }
    }

    function B(a) {
        this.id = 1, this.skill = a.skill, this.duration = a.casttime || 1, Va || (this.duration += Bd / 1e3), this.maxduration = this.duration, this.active = a.activeCheck, this.interrupt = a.interrupt, this.tick = function(a, b) {
            !this.active.call(this.skill) || this.skill.channelMoveInterrupt && (b.walkForward || b.walkSideward) ? (this.skill.channelMoveInterrupt && (b.walkForward || b.walkSideward) && this.interrupt.call(this.skill), b.state = new A) : (this.duration -= a, this.duration < 0 && Va && (b.state = new A))
        }
    }

    function C() {
        this.id = 2, this.duration = 5, this.tick = function(a, b) {
            this.timer += a
        }
    }

    function D(a) {
        var b = a.angle() + .5 * Math.PI;
        return b > 2 * Math.PI && (b -= 2 * Math.PI), b = 2 * Math.PI - b
    }

    function E(a, b) {
        for (var c = b - a; c < -Math.PI;) c += 2 * Math.PI;
        for (; c > Math.PI;) c -= 2 * Math.PI;
        return c
    }

    function F(a) {
        return new THREE.Vector2(-Math.sin(a), -Math.cos(a))
    }

    function G(a, b) {
        return D(new THREE.Vector2(b.x - a.x, b.z - a.z))
    }

    function H(a, b) {
        return D(new THREE.Vector2(b.position.x - a.position.x, b.position.z - a.position.z))
    }

    function I(a, b) {
        return a.position.distanceTo(b)
    }

    function J(a, b) {
        return a.position.distanceTo(b.position)
    }

    function K() {
        this.level = 1, this.nextLevelExp = 1, this.sumexp = 0, this.exp = 0, this.mindmg = 1, this.maxdmg = 1, this.maxhp = 5, this.scale = 1, this.crit = 0
    }

    function L() {
        var a = new R(100);
        return a.skills[1].setLevel(1), a.skills[2].setLevel(1), a.exp = 0, a.fame = 5e3, a.gold = 1e4, a.type = "king", a.ai = new ea, Va && (a.ai.protect = !0, a.ai.idleinterval = 20, a.ai.idleradius = 2, a.ai.aggrodistance = 45, a.ai.idlewalkduration = .02, a.ai.hardResetDistanceSqr = 6e3), Va || (a.color = Vc.warden), a.getMaxHp = function() {
            return 1e5
        }, a.getMinDmg = function() {
            return 2e3
        }, a.getMaxDmg = function() {
            return 2500
        }, a.getMovespeed = function() {
            return 1 == this.ai.isresetting ? 25 : 15
        }, a.getScale = function() {
            return 6
        }, a
    }

    function M() {
        var a = new R(100);
        return a.skills[1].setLevel(1), a.skills[2].setLevel(1), a.skills[3].setLevel(1), a.skills[4].setLevel(1), a.fame = 300, a.gold = 1e3, a.ai = new ea, Va && (a.ai.protect = !0, a.ai.idleinterval = 20, a.ai.idleradius = 2, a.ai.aggrodistance = 45, a.ai.idlewalkduration = .02, a.ai.hardResetDistanceSqr = 6e3), a.type = "warden", Va || (a.color = Vc.warden), a.getMaxHp = function() {
            return 5e4
        }, a.getMinDmg = function() {
            return 1600
        }, a.getMaxDmg = function() {
            return 1600
        }, this.getHpRegen = function() {
            return 350
        }, a.getMovespeed = function() {
            return 1 == this.ai.isresetting ? 25 : 15
        }, a.getScale = function() {
            return 1.8
        }, a
    }

    function N() {
        var a = new R(100);
        return a.fame = 300, a.gold = 1e3, a.type = "vendor", a.idleAi = !0, Va || (a.color = Vc.vendor), a.getMaxHp = function() {
            return 5e4
        }, a.getHpRegen = function() {
            return 1e4
        }, a.getScale = function() {
            return 1.5
        }, Va || (a.initBodyGeometry = function() {
            this.weapon = new THREE.Mesh(kd.generic_vendorlist.geo, Vc.archer_ammo2), this.weapon.scale.set(kd.generic_vendorlist.scale[0], kd.generic_vendorlist.scale[1], kd.generic_vendorlist.scale[2]), this.weapon.position.set(0, 0, 1), this.hands.r.add(this.weapon), this.backpack = new THREE.Mesh(kd.generic_backpack.geo, Vc.generic_wood), this.backpack.scale.set(kd.generic_backpack.scale[0], kd.generic_backpack.scale[1], kd.generic_backpack.scale[2]), Ac.add(this.backpack), this.backpack.position.set(0, .2, .7), this.chest.add(this.backpack)
        }, a.tickClassAnimation = function(a, b) {
            switch (a) {
                default:
                    case "idle":
                    this.hands.r.position.z -= .5,
                this.hands.r.rotation.y += 4,
                this.hands.r.rotation.z += .5,
                this.hands.r.rotation.x -= .5,
                this.weapon.rotation.set(0, 0, 0),
                this.weapon.position.set(0, 0, 1)
            }
        }), a
    }

    function O(a) {
        this.level = a, this.ai = new ea, this.type = "mob_sword", this.exp = 0, Va || (this.color = Vc.monster), this.skills = {
            1: new v(1, this, {
                name: "Melee Attack",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 3,
                cooldown: 1,
                maxrange: 1.5,
                simulate: !0,
                effect: function() {
                    mb.damage({
                        spread: .2,
                        attacker: this.parent,
                        target: this.casttarget
                    })
                },
                characterAnim: function() {
                    return new V({
                        id: "swing_melee",
                        duration: .5
                    })
                }
            })
        }
    }

    function P(a) {
        this.level = a, this.ai = new ea, this.type = "mob_bow", this.exp = 0, Va || (this.color = Vc.bone, this.initBodyGeometry = function() {
            this.weapon = new THREE.Mesh(kd.archer_bow.geo, Vc.generic_wood), this.weapon.scale.set(2.5, 2.5, 1.9), this.weapon.rotation.z = .32, this.weapon.position.y = -2, this.bowcontainer = new THREE.Object3D, this.bowcontainer.add(this.weapon), this.bowcontainer.rotation.z = 1.5, this.bowcontainer.rotation.x = 1.6, this.bowcontainer.position.x = 1.1, this.bowcontainer.position.z = -.1, this.hands.l.add(this.bowcontainer)
        }, this.tickClassAnimation = T.prototype.tickClassAnimation), this.skills = {
            1: new v(1, this, {
                name: "Piercing Shot",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 2,
                maxrange: 20,
                cooldown: 1.5,
                simulate: !0,
                spell: function(a, b, c) {
                    if (!Va) {
                        var d = new THREE.Mesh(kd.archer_arrow.geo, Vc.generic_wood);
                        d.scale.set(kd.archer_arrow.scale[0], kd.archer_arrow.scale[1], kd.archer_arrow.scale[2])
                    }
                    return new u({
                        name: "Pierce Shot",
                        target: a,
                        source: b,
                        effect: c,
                        mode: "follow",
                        movespeed: 50,
                        geometry: d ? d : void 0,
                        ribbon: Va ? void 0 : {
                            deleteWithSpell: !1,
                            parent: d,
                            stepInterval: .08,
                            steps: 3,
                            timeout: 1,
                            material: Vc.ribbon_arrow,
                            aPos: new THREE.Vector3(.6, 0, 0),
                            bPos: new THREE.Vector3(-.6, -0, 0)
                        }
                    })
                },
                effect: function(a) {
                    a.target && mb.damage({
                        spread: .2,
                        attacker: this.parent,
                        target: this.casttarget
                    })
                },
                characterAnim: function() {
                    return new V({
                        id: "release_spell",
                        duration: .3
                    })
                }
            })
        }
    }

    function Q(a) {
        this.level = a, this.ai = new ea, this.type = "mob_slime", this.exp = 0, Va || (a < 12 ? this.color = Vc.slime_green : a < 30 ? this.color = Vc.slime_blue : this.color = Vc.slime_red), this.skills = {
            1: new v(1, this, {
                name: "Melee Attack",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 3,
                cooldown: 1,
                maxrange: 1.5,
                simulate: !0,
                effect: function() {
                    mb.damage({
                        spread: .2,
                        attacker: this.parent,
                        target: this.casttarget
                    })
                },
                characterAnim: function() {
                    return new V({
                        id: "swing_melee",
                        duration: .5
                    })
                }
            })
        }
    }

    function R(a) {
        this.level = a, this.type = "warrior", Va || (this.color = Vc.warrior), this.skills = {
            1: new v(1, this, {
                name: "Deep Cut",
                mana: .08,
                description: "Slash your enemies arteries, causing them to bleed over a period of time. Heals you for a percentage of your missing health.",
                icon: "data/skill/warrior_rend.jpg",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 1.5,
                simulate: !0,
                effect: function() {
                    var a = this.abilitypower;
                    this.parent.takeHealing(.1 * (this.parent.stats.maxhp - this.parent.stats.currenthp), this.parent), mb.damage({
                        spread: .2,
                        basedmg: 5,
                        scaledmg: .5 + .4 * this.abilitypower,
                        attacker: this.parent,
                        target: this.casttarget,
                        mod: {
                            id: "deepcut",
                            overwrite: !0,
                            duration: 5,
                            interval: 1,
                            movespeed: function(a) {
                                return .65 * a
                            },
                            effect: function() {
                                mb.damage({
                                    attacker: this.source,
                                    target: this.target,
                                    spread: .1,
                                    basedmg: 10,
                                    scaledmg: .2 + .1 * a
                                })
                            }
                        }
                    })
                },
                characterAnim: function() {
                    return nd({
                        parent: this.parent.weapon,
                        aPos: new THREE.Vector3(0, 1.5, 0),
                        bPos: new THREE.Vector3(0, -.3, 0),
                        material: Vc.ribbon_arrow,
                        stepInterval: .01,
                        steps: 10,
                        timeout: .45
                    }), new V({
                        id: "swing_melee",
                        duration: .45
                    })
                }
            }),
            2: new v(2, this, {
                name: "Whirlwind",
                mana: .2,
                icon: "data/skill/warrior_spin.jpg",
                description: "Spin your sword, dealing damage to enemies in a circle around you. Decreases movement speed while active.",
                targettype: "none",
                casttype: "instant",
                cooldown: 6,
                effecttype: "channel",
                channelInterval: .5,
                channelDuration: 4,
                channelMoveInterrupt: !1,
                channelInstantFirstTick: !0,
                maxrange: 8,
                predict: !1,
                effect: function() {
                    mb.damage({
                        scaledmg: .42 + .4 * this.abilitypower,
                        basedmg: 3,
                        spread: .2,
                        attacker: this.parent,
                        mode: "aoe",
                        aoeRange: 4
                    }), this.parent.stats.addMod(new y(this.parent, this.parent, {
                        duration: .8,
                        name: "Whirlwind Slow",
                        movespeed: function(a) {
                            return 5
                        }
                    }))
                },
                channelAnim: Va ? void 0 : new V({
                    id: "spin",
                    duration: .5,
                    type: "loop"
                }),
                onCastFun: Va ? void 0 : function() {
                    nd({
                        parent: this.parent.weapon,
                        aPos: new THREE.Vector3(0, 1.8, 0),
                        bPos: new THREE.Vector3(0, -.3, 0),
                        material: Vc.ribbon_whirlwind,
                        stepInterval: .015,
                        steps: 15,
                        timeout: 4
                    })
                }
            }),
            3: new v(3, this, {
                name: "Charge",
                mana: .2,
                icon: "data/skill/warrior_charge.jpg",
                description: "Charge at your enemy, interrupting his current cast and stopping his movements.",
                casttype: "instant",
                cooldown: 9,
                effecttype: "channel",
                channelInterval: .1,
                channelDuration: 5,
                maxrange: 35,
                channelMoveInterrupt: !1,
                ignoreEc: !0,
                predict: !1,
                effect: function() {
                    this.casttarget && ib(this.parent, this.casttarget).distance() > 3 && !this.casttarget.stats.isDead() ? (this.parent.rotation = H(this.parent, this.casttarget), this.parent.walkForward = 1, this.parent.walkSideward = 0, Va ? this.parent.ignoreMovement = .1 : this.parent.ignoreInput = .15, this.parent.stats.addMod(new y(this.parent, this.parent, {
                        duration: .15,
                        name: "Charge",
                        unique: !0,
                        movespeed: function(a) {
                            return 30
                        }
                    })), this.casttarget.stats.addMod(new y(this.casttarget, this.parent, {
                        duration: 1,
                        name: "Stun",
                        unique: !0,
                        incapacitate: !0
                    })), this.casttarget.walkForward = 0, this.casttarget.walkSideward = 0, mb.interrupt(this.casttarget, this.parent)) : (this.interruptChannel(), this.parent.walkForward = 0, this.parent.walkSideward = 0, this.parent.stats.servermovespeed = void 0)
                }
            }),
            4: new v(4, this, {
                name: "Taunt",
                mana: .2,
                icon: "data/skill/warrior_shout.jpg",
                description: "Intimidate your enemies with a loud roar, generating high levels of threat and regenerating a portion of your missing health. Removes debuffs.",
                targettype: "none",
                casttype: "instant",
                cooldown: 20,
                maxrange: 30,
                simulate: !0,
                effect: function() {
                    var a = this.abilitypower;
                    mb.damage({
                        scaledmg: .2 + .02 * this.abilitypower,
                        basedmg: 3 + 2 * this.abilitypower,
                        spread: .1,
                        attacker: this.parent,
                        mode: "aoe",
                        aoeRange: 23,
                        aggro: 1e3
                    }), this.parent.stats.addMod(new y(this.parent, this.parent, {
                        id: "tauntreg",
                        overwrite: !0,
                        duration: 10,
                        interval: 1,
                        effect: function() {
                            mb.damage({
                                attacker: this.source,
                                target: this.target,
                                spread: .1,
                                basedmg: (this.target.stats.maxhp - this.target.stats.currenthp) * (.04 + .018 * a),
                                scaledmg: 0,
                                heal: !0
                            })
                        }
                    }))
                },
                characterAnim: function() {
                    return new V({
                        id: "boost",
                        duration: 1
                    })
                }
            })
        }
    }

    function S(a) {
        this.level = a, this.type = "mage", Va || (this.color = Vc.mage), this.skills = {
            1: new v(1, this, {
                name: "Ice Bolt",
                mana: .05,
                description: "Fire a magic ice bolt at the enemy, dealing damage to all targets in the area and slowing them for a brief moment.",
                icon: "data/skill/mage_icebolt.jpg",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 30,
                simulate: !0,
                spell: function(a, b, c) {
                    if (!Va) {
                        var d = new THREE.Mesh(kd.icebolt.geo, Vc.generic_ice);
                        d.scale.z = 2
                    }
                    return new u({
                        name: "Ice Bolt",
                        target: a,
                        source: b,
                        effect: c,
                        mode: "follow",
                        movespeed: 20,
                        geometry: d ? d : void 0,
                        ribbon: Va ? void 0 : {
                            deleteWithSpell: !1,
                            parent: d,
                            stepInterval: .1,
                            steps: 5,
                            timeout: 2,
                            material: Vc.ribbon_ice,
                            aPos: new THREE.Vector3(.9, 0, 1),
                            bPos: new THREE.Vector3(-.9, 0, 1)
                        }
                    })
                },
                effect: function(a) {
                    mb.damage({
                        scaledmg: .3 + .3 * this.abilitypower,
                        basedmg: 5,
                        attacker: a.source,
                        mode: "aoe",
                        aoeRange: 9,
                        aoeCenter: a.target.position,
                        mod: {
                            unique: !0,
                            id: "frostcallfrosted",
                            duration: 6,
                            name: "Frosted",
                            movespeed: function(a) {
                                return .6 * a
                            }
                        }
                    })
                }
            }),
            2: new v(2, this, {
                name: "Frostcall",
                mana: .2,
                description: "You call down a blizzard on an enemies position, dealing damage over time. Channeled.",
                icon: "data/skill/mage_blizzard.jpg",
                targettype: "enemy",
                casttype: "timed",
                casttime: 1,
                effecttype: "channel",
                channelInterval: 1,
                channelDuration: 5,
                spellchannel: !0,
                baselevel: 1,
                cooldown: 7,
                maxrange: 35,
                channelInstantFirstTick: !0,
                allowDeadTarget: !0,
                spell: function(a, b, c) {
                    if (a) return new u({
                        name: "Frostcall",
                        startposition: Va ? a.position : a.geometry ? a.geometry.position : a.position,
                        source: b,
                        effect: c,
                        mode: "static",
                        timeout: 5,
                        geometry: Va ? void 0 : new THREE.Mesh(kd.frostcall.geo, Vc.mage_frost)
                    })
                },
                effect: function(a) {
                    if (mb.damage({
                            scaledmg: .8 + .5 * this.abilitypower,
                            basedmg: 8 + 2 * this.abilitypower,
                            spread: .2,
                            attacker: a.source,
                            mode: "aoe",
                            aoeRange: 12,
                            aoeCenter: a.spell.position,
                            mod: {
                                unique: !0,
                                id: "frostcallfrosted",
                                duration: 2,
                                name: "Frosted",
                                movespeed: function(a) {
                                    return .4 * a
                                }
                            }
                        }), !Va && a.target && a.target.geometry)
                        for (var b = 0; b < 15; ++b) {
                            var c = Math.random() * Math.PI * 2,
                                d = 12 * Math.random(),
                                e = new u({
                                    name: "Flake",
                                    mode: "static",
                                    movedir: new THREE.Vector3(0, -1, 0),
                                    startposition: new THREE.Vector3(a.spell.position.x + Math.cos(c) * d, a.target.geometry.position.y + 15 + 10 * Math.random(), a.spell.position.z + Math.sin(c) * d),
                                    timeout: 2,
                                    movespeed: 12,
                                    geometry: new THREE.Mesh(kd.frostcallblizz.geo, Vc.generic_ice)
                                });
                            Qb.push(e)
                        }
                }
            }),
            3: new v(3, this, {
                name: "Teleport",
                mana: .2,
                description: "Teleports you forward in an instant.",
                icon: "data/skill/mage_tp.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 9,
                effecttype: "instant",
                maxrange: 100,
                predict: !1,
                effect: function(a) {
                    var b = F(a.source.rotation);
                    a.source.position.x += 25 * b.x, a.source.position.z += 25 * b.y, Va && (this.parent.ignoreMovement = .5), Va || a.source.animationQueue.push(new V({
                        id: "channel",
                        duration: .5
                    }))
                }
            }),
            4: new v(4, this, {
                name: "Iceblock",
                mana: .3,
                description: "Freezes you in an iceblock, rendering you invincible for a moment and recovering a portion of your health.",
                icon: "data/skill/mage_iceblock.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 18,
                effecttype: "channel",
                channelDuration: 5,
                channelInterval: 8,
                channelInstantFirstTick: !0,
                channelMoveInterrupt: !1,
                spellchannel: !0,
                maxrange: 100,
                predict: !1,
                ignoreEc: !0,
                spell: function(a, b, c) {
                    return new u({
                        name: "Iceblock",
                        startposition: Va ? b.position : b.geometry.position,
                        source: b,
                        mode: "static",
                        effect: c,
                        timeout: 5,
                        geometry: Va ? void 0 : new THREE.Mesh(kd.iceblock.geo, Vc.mage_frost)
                    })
                },
                effect: function(a) {
                    var b = this.abilitypower;
                    a.source.stats.addMod(new y(a.source, a.source, {
                        duration: 5,
                        name: "Iceblock",
                        invincible: !0,
                        interval: 1,
                        id: "iceblock",
                        overwrite: !0,
                        movespeed: function() {
                            return 0
                        },
                        effect: function() {
                            mb.damage({
                                attacker: this.source,
                                target: this.target,
                                spread: .1,
                                basedmg: this.target.stats.maxhp * (.035 + .03 * b),
                                scaledmg: 0,
                                heal: !0
                            })
                        }
                    })), a.source.walkForward = 0, a.source.walkSideward = 0
                },
                channelAnim: Va ? void 0 : new V({
                    id: "channel",
                    duration: 60
                })
            })
        }
    }

    function T(a) {
        this.level = a, this.type = "archer", Va || (this.color = Vc.archer), this.skills = {
            1: new v(1, this, {
                name: "Piercing Shot",
                mana: .05,
                description: "Fires an arrow at your target. Pierces their armor up to 5 times, increasing your next Piercing Shot damage by 18%",
                icon: "data/skill/archer_pierce.jpg",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 30,
                simulate: !0,
                spell: function(a, b, c) {
                    if (!Va) {
                        var d = new THREE.Mesh(kd.archer_arrow.geo, Vc.archer_arrow);
                        d.scale.set(kd.archer_arrow.scale[0], kd.archer_arrow.scale[1], kd.archer_arrow.scale[2])
                    }
                    return new u({
                        name: "Pierce Shot",
                        target: a,
                        source: b,
                        effect: c,
                        mode: "follow",
                        movespeed: 80,
                        geometry: d ? d : void 0,
                        ribbon: Va ? void 0 : {
                            deleteWithSpell: !1,
                            parent: d,
                            stepInterval: .05,
                            steps: 5,
                            timeout: 1,
                            material: Vc.ribbon_arrow,
                            aPos: new THREE.Vector3(.6, 0, 0),
                            bPos: new THREE.Vector3(-.6, -0, 0)
                        }
                    })
                },
                effect: function(a) {
                    if (a.target) {
                        var b = 1 + .18 * a.target.stats.queryMod({
                            source: a.source,
                            id: "pierceshot"
                        }).length;
                        mb.damage({
                            scaledmg: (.5 + .5 * this.abilitypower) * b,
                            basedmg: 3 * b,
                            attacker: a.source,
                            target: a.target,
                            mod: {
                                id: "pierceshot",
                                duration: 6
                            }
                        })
                    }
                },
                characterAnim: function() {
                    return new V({
                        id: "release_spell",
                        duration: .3
                    })
                }
            }),
            2: new v(2, this, {
                name: "Volley",
                mana: .2,
                icon: "data/skill/archer_volley.jpg",
                description: "Shoot all targets infront of you over a duration.",
                targettype: "enemy",
                casttype: "instant",
                cooldown: 6,
                effecttype: "channel",
                channelInterval: Va ? .3 : .1,
                channelDuration: 3,
                channelMoveInterrupt: !1,
                channelInstantFirstTick: !0,
                maxrange: 30,
                predict: !1,
                allowDeadTarget: !0,
                effect: function() {
                    mb.damage({
                        scaledmg: .2 + .3 * this.abilitypower,
                        basedmg: 3,
                        spread: .2,
                        attacker: this.parent,
                        mode: "aoe",
                        aoeRange: 33,
                        aoeArc: .7,
                        aoeFun: Va ? void 0 : function(a, b) {
                            if (!(a.length <= 0)) {
                                var c = new THREE.Mesh(kd.archer_arrow.geo, Vc.generic_wood);
                                c.scale.set(kd.archer_arrow.scale[0], kd.archer_arrow.scale[1], kd.archer_arrow.scale[2]);
                                var d = new u({
                                    name: "Volley",
                                    target: eb(a),
                                    source: b,
                                    mode: "follow",
                                    movespeed: 50,
                                    geometry: c,
                                    ribbon: {
                                        deleteWithSpell: !1,
                                        parent: c,
                                        stepInterval: .05,
                                        steps: 5,
                                        timeout: 1,
                                        material: Vc.ribbon_arrow,
                                        aPos: new THREE.Vector3(.6, 0, 0),
                                        bPos: new THREE.Vector3(-.6, -0, 0)
                                    }
                                });
                                Qb.push(d)
                            }
                        }
                    })
                },
                channelAnim: Va ? void 0 : new V({
                    id: "release_spell",
                    duration: .1,
                    type: "loop"
                })
            }),
            3: new v(3, this, {
                name: "Leeching Arrow",
                mana: .2,
                description: "Fires a condemned arrow at your enemy, reducing their healing and stealing some of their health.",
                icon: "data/skill/archer_siphon.jpg",
                targettype: "enemy",
                casttype: "instant",
                maxrange: 30,
                cooldown: 14,
                simulate: !0,
                spell: function(a, b, c) {
                    if (!Va) var d = new THREE.Object3D;
                    return new u({
                        name: "Leeching Arrow",
                        target: a,
                        source: b,
                        effect: c,
                        mode: "follow",
                        movespeed: 55,
                        geometry: d ? d : void 0,
                        ribbon: Va ? void 0 : {
                            deleteWithSpell: !1,
                            parent: d,
                            stepInterval: .05,
                            steps: 10,
                            timeout: 3,
                            tailType: "default",
                            material: Vc.ribbon_leech,
                            aPos: new THREE.Vector3(1.5, 0, 0),
                            bPos: new THREE.Vector3(-1.5, -0, 0)
                        }
                    })
                },
                effect: function(a) {
                    var b = this.abilitypower,
                        c = .8 + .5 * b;
                    mb.damage({
                        scaledmg: c,
                        basedmg: 15,
                        attacker: a.source,
                        target: a.target,
                        mod: {
                            id: "leeching",
                            unique: !0,
                            duration: 6,
                            name: "Leeching Arrow",
                            healmod: function(a) {
                                return a * (.5 / b * .7 + .3)
                            }
                        }
                    }), mb.damage({
                        scaledmg: 1.2 * c,
                        basedmg: 8,
                        attacker: a.source,
                        target: a.source,
                        heal: !0
                    })
                },
                characterAnim: function() {
                    return new V({
                        id: "release_spell",
                        duration: .3
                    })
                }
            }),
            4: new v(4, this, {
                name: "Sprint",
                mana: .1,
                description: "You sprint at a very high speed for a short moment.",
                icon: "data/skill/archer_sprint.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 5,
                effect: function(a) {
                    mb.damage({
                        attacker: a.source,
                        target: a.source,
                        buff: !0,
                        mod: {
                            id: "windrush",
                            unique: !0,
                            duration: .6,
                            name: "Wind rush",
                            movespeed: function(a) {
                                return 30
                            }
                        }
                    })
                },
                characterAnim: function() {
                    return new V({
                        id: "release_buff",
                        duration: 1
                    })
                }
            })
        }
    }

    function U(a) {
        this.level = a, this.type = "shaman", Va || (this.color = Vc.shaman), this.skills = {
            1: new v(1, this, {
                name: "Healing ritual",
                mana: .08,
                description: "Heals your target upon cast and for a short while afterwards.",
                icon: "data/skill/shaman_heal.jpg",
                targettype: "friendly",
                casttype: "timed",
                casttime: .6,
                baselevel: 1,
                maxrange: 30,
                effect: function() {
                    var a = this.abilitypower;
                    mb.damage({
                        scaledmg: .25 + .1 * a,
                        basedmg: 4,
                        spread: .2,
                        attacker: this.parent,
                        target: this.casttarget,
                        heal: !0,
                        mod: {
                            id: "healritual",
                            overwrite: !0,
                            duration: 10,
                            interval: 1,
                            effect: function() {
                                mb.damage({
                                    attacker: this.source,
                                    target: this.target,
                                    spread: .1,
                                    basedmg: 2,
                                    scaledmg: .12 + .15 * a,
                                    heal: !0
                                })
                            }
                        }
                    })
                },
                spell: Va ? void 0 : function(a, b, c) {
                    if (a && b) {
                        var d = new THREE.Object3D;
                        return new u({
                            name: "Healing ritual",
                            mode: "attach",
                            target: a,
                            source: b,
                            timeout: 10,
                            geometry: d,
                            tick: function(b) {
                                this.geometry.position.copy(this.position);
                                var c = .15 + a.stats.scale;
                                this.geometry.position.x += Math.sin(8 * this.timeout) * c, this.geometry.position.z += Math.cos(8 * this.timeout) * c, this.geometry.position.y += Math.cos(5 + 6 * this.timeout) * c * .5, c *= .5, this.geometry.scale.set(c, c, c)
                            },
                            ribbon: {
                                deleteWithSpell: !0,
                                parent: d,
                                stepInterval: .1,
                                steps: 8,
                                timeout: 10,
                                material: Vc.ribbon_heal,
                                aPos: new THREE.Vector3(1.5, 0, 0),
                                bPos: new THREE.Vector3(-1.5, -0, 0)
                            }
                        })
                    }
                },
                characterAnim: function() {
                    return new V({
                        id: "release_buff",
                        duration: .5
                    })
                }
            }),
            2: new v(2, this, {
                name: "Equilibrate",
                mana: .2,
                description: "Summons a spirit upon a friendly target that heals allys and damages enemies",
                icon: "data/skill/shaman_spirit.jpg",
                targettype: "friendly",
                casttype: "instant",
                maxrange: 30,
                channelInstantFirstTick: !0,
                unique: !0,
                simulate: !0,
                effect: function(a) {
                    var b = this.abilitypower;
                    mb.damage({
                        scaledmg: .2 + .2 * b,
                        basedmg: 3,
                        spread: .2,
                        attacker: a.source,
                        target: a.target,
                        heal: !0
                    }), mb.damage({
                        scaledmg: .3 + .2 * b,
                        basedmg: 6,
                        spread: .1,
                        attacker: a.source,
                        mode: "aoe",
                        aoeRange: 8,
                        aoeCenter: a.spell.position
                    })
                },
                spell: function(a, b, c) {
                    var d = void 0;
                    b.position;
                    return Va || (d = new THREE.Mesh(kd.equilibrate.geo, Vc.generic_wood), d.scale.set(kd.equilibrate.scale[0], kd.equilibrate.scale[1], kd.equilibrate.scale[2])), new u({
                        name: "Spirit",
                        mode: "attach",
                        target: a,
                        source: b,
                        effect: c,
                        effectInterval: 1,
                        timeout: 60,
                        geometry: d,
                        tick: Va ? void 0 : function(b) {
                            this.geometry.position.copy(this.position);
                            var c = .35 + a.stats.scale;
                            this.geometry.position.x += Math.sin(4 * this.timeout) * c, this.geometry.position.z += Math.cos(4 * this.timeout) * c, this.geometry.rotation.x += 3 * b, this.geometry.rotation.z -= 2 * b, this.geometry.rotation.y = 1.5 * b, c *= .4, this.geometry.scale.set(c, c, c)
                        },
                        ribbon: Va ? void 0 : {
                            deleteWithSpell: !0,
                            parent: d,
                            stepInterval: .05,
                            steps: 5,
                            timeout: 60,
                            material: Vc.ribbon_arrow,
                            aPos: new THREE.Vector3(.6, 0, 0),
                            bPos: new THREE.Vector3(-.6, -0, 0)
                        }
                    })
                }
            }),
            3: new v(3, this, {
                name: "Decay",
                mana: .1,
                icon: "data/skill/shaman_decay.jpg",
                description: "Cast a spell of decay upon your enemy, slowing their movement and dealing damage over time.",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 25,
                simulate: !0,
                effect: function(a) {
                    var b = this.abilitypower;
                    mb.damage({
                        attacker: a.source,
                        target: a.target,
                        debuff: !0,
                        mod: {
                            overwrite: !0,
                            id: "decay",
                            duration: 8,
                            name: "Decay",
                            interval: 1,
                            effect: function() {
                                mb.damage({
                                    attacker: this.source,
                                    target: this.target,
                                    spread: .1,
                                    basedmg: 6 + 1 * b,
                                    scaledmg: .32 + .3 * b
                                })
                            }
                        }
                    }), mb.damage({
                        attacker: a.source,
                        target: a.target,
                        debuff: !0,
                        mod: {
                            unique: !0,
                            id: "decayslow",
                            duration: 8,
                            name: "Decay",
                            movespeed: function(a) {
                                return .7 * a
                            }
                        }
                    })
                },
                spell: Va ? void 0 : function(a, b, c) {
                    if (a && b && a != b) {
                        var d = new THREE.Object3D;
                        return new u({
                            name: "Decay",
                            mode: "attach",
                            target: a,
                            source: b,
                            timeout: 10,
                            geometry: d,
                            tick: function(b) {
                                this.geometry.position.copy(this.position);
                                var c = .15 + a.stats.scale;
                                this.geometry.position.x += Math.sin(8 * this.timeout) * c, this.geometry.position.z += Math.cos(8 * this.timeout) * c, this.geometry.position.y += Math.cos(5 + 6 * this.timeout) * c * .5, c *= .5, this.geometry.scale.set(c, c, c)
                            },
                            ribbon: {
                                deleteWithSpell: !0,
                                parent: d,
                                stepInterval: .1,
                                steps: 8,
                                timeout: 10,
                                material: Vc.ribbon_decay,
                                aPos: new THREE.Vector3(1.5, 0, 0),
                                bPos: new THREE.Vector3(-1.5, -0, 0)
                            }
                        })
                    }
                },
                characterAnim: function() {
                    return new V({
                        id: "release_buff",
                        duration: 1
                    })
                }
            }),
            4: new v(4, this, {
                name: "Wind rush",
                mana: .3,
                description: "Temporarily boost the movement speed of you and your allies.",
                icon: "data/skill/shaman_windrush.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 20,
                maxrange: 30,
                simulate: !0,
                effect: function(a) {
                    mb.damage({
                        attacker: a.source,
                        buff: !0,
                        mode: "aoe",
                        aoeRange: 30,
                        mod: {
                            id: "windrush",
                            unique: !0,
                            duration: 6,
                            name: "Wind rush",
                            movespeed: function(a) {
                                return 1.5 * a
                            }
                        }
                    })
                },
                characterAnim: function() {
                    return new V({
                        id: "release_buff",
                        duration: 1
                    })
                }
            })
        }
    }

    function V(a) {
        this.id = a.id || "idle", this.type = a.type || "timed", this.duration = a.duration || 1, this.timer = this.duration, this.deleteMe = !1
    }

    function W() {
        if (cc.expbar && Ic) {
            cc.expbartext.html(Ic.class.exp + " / " + Ic.class.nextLevelExp);
            var a = Math.min(100, Ic.class.exp / Ic.class.nextLevelExp * 100);
            cc.expbar.css("width", a + "%")
        }
    }

    function X() {
        var a;
        cc.castbar && Ic && 1 == Ic.state.id ? (a = 100 - Ic.state.duration / Ic.state.maxduration * 100, cc.castbarcontainer.show()) : (cc.castbarcontainer.hide(), a = 0), cc.castbar.css("width", a + "%")
    }

    function Y(a) {
        if (cc.chatboxWrapper) {
            var b = a.msg || "Message error.",
                c = "chatmsg";
            if (a.src) switch (a.src) {
                case "server":
                case "whisper":
                    c += " chatmsg-w";
                    break;
                case "playerkill":
                    if (!va(Pa.get("chat-pvp"))) return;
                    c += " chatmsg-pk";
                    break;
                case "death":
                    c += " chatmsg-death";
                    break;
                case "system":
                    c += " chatmsg-system";
                    break;
                case "loot":
                    if (!va(Pa.get("chat-loot"))) return;
                    c += " chatmsg-loot";
                    break;
                case "exp":
                    if (!va(Pa.get("chat-exp"))) return;
                    c += " chatmsg-exp";
                    break;
                case "clan":
                    if (!va(Pa.get("chat-chat"))) return;
                    if (c += " chatmsg-clan", !a.name) return !1;
                    b = "[" + a.name + " (clan)]: " + b;
                    break;
                case "global":
                    if (!va(Pa.get("chat-chat"))) return;
                    if (c += " chatmsg-global", 0 === a.r && (c += " unreg"), !a.name) return !1;
					if(typeof window.muted!=="undefined"&&!!~window.muted.indexOf(a.name)) return;
					if ($(".targetname")[0].innerText.substring(0, $(".targetname")[0].innerText.length-4)!=='')(b.startsWith("@"+$(".targetname")[0].innerText.substring(0, $(".targetname")[0].innerText.length-4)+" "))||b==="@"+$(".targetname")[0].innerText.substring(0, $(".targetname")[0].innerText.length-4)?c="chatmsg chatmsg-mention":c=c;
                    b = "[" + a.name + "]: " + b;
                    break;
                case "gm":
                    if (!va(Pa.get("chat-chat"))) return;
                    if (c += " chatmsg-w", !a.name) return !1;
                    b = "[" + a.name + " (GM)]: " + b
            }
            var d = Math.round(cc.chatboxWrapper[0].scrollHeight - cc.chatboxWrapper[0].scrollTop) === Math.round(cc.chatboxWrapper[0].clientHeight),
                e = $("<p class='" + c + "'></p>");
            e.text(b), void 0 !== a.c && void 0 !== a.f && e.html("<span class='" + (0 == a.f ? "factionA" : "factionB") + "'>" + a.c + " </span>" + e.html()), e.html(e.html().replace("$g", dc.goldCoin)), e.html(e.html().replace("$0", dc.faction1)), e.html(e.html().replace("$1", dc.faction2)), e.appendTo(cc.chatboxBody);
            var f = $("#chatboxBody > p");
            f.length > 50 && f[0].remove(), d && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
        }
    }

    function Z(a) {
        var b = document.createElement("canvas");
        b.width = a.width, b.height = a.height;
        var c = b.getContext("2d");
        return c.drawImage(a, 0, 0), c.getImageData(0, 0, a.width, a.height)
    }

    function _(a, b, c) {
        return a <= b ? b : a >= c ? c : a
    }

    function aa(a, b) {
        a = _(a, 0, Va ? heightmap.shape[0] : zc.width - 1), b = _(b, 0, Va ? heightmap.shape[0] : zc.width - 1);
        var c = Va ? 4 * (a + heightmap.shape[0] * b) : 4 * (a + zc.width * b),
            d = Va ? heightmap.data : zc.data;
        return {
            r: d[c],
            g: d[c + 1],
            b: d[c + 2],
            a: d[c + 3]
        }
    }

    function ba(a) {
        if (!a.material) return !1;
        this.steps = a.steps || 10, this.stepInterval = a.stepInterval || .5, this.stepIntervalTimer = this.stepInterval, this.stepsDone = 0, this.headType = a.headType || "glue", this.tailType = a.tailType || "compress", this.geom = new THREE.PlaneGeometry(1, 1, 1, this.steps - 1), this.material = a.material, this.mesh = new THREE.Mesh(this.geom, this.material), this.mesh.frustumCulled = !1, Ac.add(this.mesh), this.timeout = a.timeout || void 0, this.timeout && (this.timer = this.timeout), this.a = new THREE.Object3D, Ac.add(this.a), this.b = new THREE.Object3D, Ac.add(this.b), a.parent && (a.parent.add(this.a), a.parent.add(this.b), a.parent.updateMatrixWorld()), a.aPos && this.a.position.copy(a.aPos), a.bPos && this.b.position.copy(a.bPos), this.at = [];
        var b = this.a.getWorldPosition();
        this.bt = [];
        for (var c = this.b.getWorldPosition(), d = 0; d < this.steps; ++d) this.at.push(new THREE.Vector3(b.x, b.y, b.z)), this.bt.push(new THREE.Vector3(c.x, c.y, c.z));
        this.step(b, c), this.uvStepSize = 1 / this.steps, this.uvShift = 0, this.deleteMe = !1
    }

    function ca(a) {
        "use strict";
        var b, c = a.children;
        if (c)
            for (var d = 0; d < c.length; d += 1) b = c[d], ca(b)
    }

    function da(a, b) {
        var c = new THREE.Vector3;
        return c.copy(a), c.project(b), c.x = Math.round(c.x * za.width * .5), c.y = Math.round(c.y * za.height * .5), c
    }

    function ea() {
        this.isresetting = 0, this.goal = new THREE.Vector2(0, 0), this.hasReachedGoal = !1, this.tick = function(a) {
            if (this.parent.target && !za.entities.hasOwnProperty(this.parent.target.id) && (this.parent.desiredTarget = this.parent.target.id, this.parent.target = void 0), this.parent.target) {
                var b = ib(this.parent.target, this.parent),
                    c = void 0 != b && b.distance() < this.parent.class.skills[1].maxrange + 1.2;
                this.parent.walkForward = c ? 0 : 1, this.parent.rotation = H(this.parent, this.parent.target)
            } else this.parent.walkForward = 0, 0 == this.goal.x || 0 == this.goal.z || this.hasReachedGoal || (I(this.parent, this.goal) > this.parent.stats.movespeed * a ? (this.parent.walkForward = 1, this.parent.rotation = G(this.parent.position, this.goal)) : (this.parent.walkForward = 0, this.hasReachedGoal = !0))
        }
    }

    function fa(a) {
        var b = Pd[a];
        if (!b) {
            var c = document.getElementsByTagName("body")[0],
                d = document.createElement("div"),
                e = document.createTextNode("Mq");
            d.appendChild(e), d.setAttribute("style", "font:" + a + ";position:absolute;top:0;left:0"), c.appendChild(d), b = d.offsetHeight, Pd[a] = b, c.removeChild(d)
        }
        return b
    }

    function ga() {
        return this.textWidth = null, this.textHeight = null, this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this
    }

    function ha(a, b) {
        THREE.Object3D.call(this), this._font = b.font || "30px Arial", this._fillStyle = b.fillStyle || "#FFFFFF", this._shadow = void 0 !== b.shadow ? b.shadow : 1, this.canvas = new ga, this.align = b.align || Od.center, this.antialias = ("undefined" === b.antialias, !0), this.setText(a)
    }
    var ia = window.location != window.parent.location ? document.referrer : document.location.href,
        ja = function(a, b) {
            return a.indexOf(b) !== -1
        };
    (ja(ia, "hordesio.com") || ja(ia, "hordes-io.com")) && (window.top.location.href = "http://hordes.io"), window.onerror = function(a, b, c, d, e) {
            if (window.onerror = null, e && (e = e.toString()), "undefined" != typeof WebSocket && (null == b || b.indexOf("hordes") != -1)) {
                var f = new XMLHttpRequest,
                    g = JSON.stringify({
                        message: a,
                        source: b,
                        lineno: c,
                        colno: d,
                        error: e
                    });
                f.open("POST", "/error", !0), f.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), f.send(g), console.log("Error: " + g)
            }
        }, ! function(a, b) {
            "use strict";
            "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
                if (!a.document) throw new Error("jQuery requires a window with a document");
                return b(a)
            } : b(a)
        }("undefined" != typeof window ? window : this, function(a, b) {
            "use strict";

            function c(a, b) {
                b = b || ca;
                var c = b.createElement("script");
                c.text = a, b.head.appendChild(c).parentNode.removeChild(c)
            }

            function d(a) {
                var b = !!a && "length" in a && a.length,
                    c = pa.type(a);
                return "function" !== c && !pa.isWindow(a) && ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a)
            }

            function e(a, b) {
                return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
            }

            function f(a, b, c) {
                return pa.isFunction(b) ? pa.grep(a, function(a, d) {
                    return !!b.call(a, d, a) !== c
                }) : b.nodeType ? pa.grep(a, function(a) {
                    return a === b !== c
                }) : "string" != typeof b ? pa.grep(a, function(a) {
                    return ha.call(b, a) > -1 !== c
                }) : za.test(b) ? pa.filter(b, a, c) : (b = pa.filter(b, a), pa.grep(a, function(a) {
                    return ha.call(b, a) > -1 !== c && 1 === a.nodeType
                }))
            }

            function g(a, b) {
                for (;
                    (a = a[b]) && 1 !== a.nodeType;);
                return a
            }

            function h(a) {
                var b = {};
                return pa.each(a.match(Fa) || [], function(a, c) {
                    b[c] = !0
                }), b
            }

            function i(a) {
                return a
            }

            function j(a) {
                throw a
            }

            function k(a, b, c, d) {
                var e;
                try {
                    a && pa.isFunction(e = a.promise) ? e.call(a).done(b).fail(c) : a && pa.isFunction(e = a.then) ? e.call(a, b, c) : b.apply(void 0, [a].slice(d))
                } catch (a) {
                    c.apply(void 0, [a])
                }
            }

            function l() {
                ca.removeEventListener("DOMContentLoaded", l), a.removeEventListener("load", l), pa.ready()
            }

            function m() {
                this.expando = pa.expando + m.uid++
            }

            function n(a) {
                return "true" === a || "false" !== a && ("null" === a ? null : a === +a + "" ? +a : Ma.test(a) ? JSON.parse(a) : a)
            }

            function o(a, b, c) {
                var d;
                if (void 0 === c && 1 === a.nodeType)
                    if (d = "data-" + b.replace(Na, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
                        try {
                            c = n(c)
                        } catch (a) {}
                        La.set(a, b, c)
                    } else c = void 0;
                return c
            }

            function p(a, b, c, d) {
                var e, f = 1,
                    g = 20,
                    h = d ? function() {
                        return d.cur()
                    } : function() {
                        return pa.css(a, b, "")
                    },
                    i = h(),
                    j = c && c[3] || (pa.cssNumber[b] ? "" : "px"),
                    k = (pa.cssNumber[b] || "px" !== j && +i) && Pa.exec(pa.css(a, b));
                if (k && k[3] !== j) {
                    j = j || k[3], c = c || [], k = +i || 1;
                    do f = f || ".5", k /= f, pa.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g)
                }
                return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e
            }

            function q(a) {
                var b, c = a.ownerDocument,
                    d = a.nodeName,
                    e = Ta[d];
                return e ? e : (b = c.body.appendChild(c.createElement(d)), e = pa.css(b, "display"), b.parentNode.removeChild(b), "none" === e && (e = "block"), Ta[d] = e, e)
            }

            function r(a, b) {
                for (var c, d, e = [], f = 0, g = a.length; f < g; f++) d = a[f], d.style && (c = d.style.display, b ? ("none" === c && (e[f] = Ka.get(d, "display") || null, e[f] || (d.style.display = "")), "" === d.style.display && Ra(d) && (e[f] = q(d))) : "none" !== c && (e[f] = "none", Ka.set(d, "display", c)));
                for (f = 0; f < g; f++) null != e[f] && (a[f].style.display = e[f]);
                return a
            }

            function s(a, b) {
                var c;
                return c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [], void 0 === b || b && e(a, b) ? pa.merge([a], c) : c
            }

            function t(a, b) {
                for (var c = 0, d = a.length; c < d; c++) Ka.set(a[c], "globalEval", !b || Ka.get(b[c], "globalEval"))
            }

            function u(a, b, c, d, e) {
                for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], n = 0, o = a.length; n < o; n++)
                    if (f = a[n], f || 0 === f)
                        if ("object" === pa.type(f)) pa.merge(m, f.nodeType ? [f] : f);
                        else if (Ya.test(f)) {
                    for (g = g || l.appendChild(b.createElement("div")), h = (Va.exec(f) || ["", ""])[1].toLowerCase(), i = Xa[h] || Xa._default, g.innerHTML = i[1] + pa.htmlPrefilter(f) + i[2], k = i[0]; k--;) g = g.lastChild;
                    pa.merge(m, g.childNodes), g = l.firstChild, g.textContent = ""
                } else m.push(b.createTextNode(f));
                for (l.textContent = "", n = 0; f = m[n++];)
                    if (d && pa.inArray(f, d) > -1) e && e.push(f);
                    else if (j = pa.contains(f.ownerDocument, f), g = s(l.appendChild(f), "script"), j && t(g), c)
                    for (k = 0; f = g[k++];) Wa.test(f.type || "") && c.push(f);
                return l
            }

            function v() {
                return !0
            }

            function w() {
                return !1
            }

            function x() {
                try {
                    return ca.activeElement
                } catch (a) {}
            }

            function y(a, b, c, d, e, f) {
                var g, h;
                if ("object" == typeof b) {
                    "string" != typeof c && (d = d || c, c = void 0);
                    for (h in b) y(a, h, c, d, b[h], f);
                    return a
                }
                if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = w;
                else if (!e) return a;
                return 1 === f && (g = e, e = function(a) {
                    return pa().off(a), g.apply(this, arguments)
                }, e.guid = g.guid || (g.guid = pa.guid++)), a.each(function() {
                    pa.event.add(this, b, e, d, c)
                })
            }

            function z(a, b) {
                return e(a, "table") && e(11 !== b.nodeType ? b : b.firstChild, "tr") ? pa(">tbody", a)[0] || a : a
            }

            function A(a) {
                return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
            }

            function B(a) {
                var b = eb.exec(a.type);
                return b ? a.type = b[1] : a.removeAttribute("type"), a
            }

            function C(a, b) {
                var c, d, e, f, g, h, i, j;
                if (1 === b.nodeType) {
                    if (Ka.hasData(a) && (f = Ka.access(a), g = Ka.set(b, f), j = f.events)) {
                        delete g.handle, g.events = {};
                        for (e in j)
                            for (c = 0, d = j[e].length; c < d; c++) pa.event.add(b, e, j[e][c])
                    }
                    La.hasData(a) && (h = La.access(a), i = pa.extend({}, h), La.set(b, i))
                }
            }

            function D(a, b) {
                var c = b.nodeName.toLowerCase();
                "input" === c && Ua.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue)
            }

            function E(a, b, d, e) {
                b = fa.apply([], b);
                var f, g, h, i, j, k, l = 0,
                    m = a.length,
                    n = m - 1,
                    o = b[0],
                    p = pa.isFunction(o);
                if (p || m > 1 && "string" == typeof o && !na.checkClone && db.test(o)) return a.each(function(c) {
                    var f = a.eq(c);
                    p && (b[0] = o.call(this, c, f.html())), E(f, b, d, e)
                });
                if (m && (f = u(b, a[0].ownerDocument, !1, a, e), g = f.firstChild, 1 === f.childNodes.length && (f = g), g || e)) {
                    for (h = pa.map(s(f, "script"), A), i = h.length; l < m; l++) j = f, l !== n && (j = pa.clone(j, !0, !0), i && pa.merge(h, s(j, "script"))), d.call(a[l], j, l);
                    if (i)
                        for (k = h[h.length - 1].ownerDocument, pa.map(h, B), l = 0; l < i; l++) j = h[l], Wa.test(j.type || "") && !Ka.access(j, "globalEval") && pa.contains(k, j) && (j.src ? pa._evalUrl && pa._evalUrl(j.src) : c(j.textContent.replace(fb, ""), k))
                }
                return a
            }

            function F(a, b, c) {
                for (var d, e = b ? pa.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || pa.cleanData(s(d)), d.parentNode && (c && pa.contains(d.ownerDocument, d) && t(s(d, "script")), d.parentNode.removeChild(d));
                return a
            }

            function G(a, b, c) {
                var d, e, f, g, h = a.style;
                return c = c || ib(a), c && (g = c.getPropertyValue(b) || c[b], "" !== g || pa.contains(a.ownerDocument, a) || (g = pa.style(a, b)), !na.pixelMarginRight() && hb.test(g) && gb.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g
            }

            function H(a, b) {
                return {
                    get: function() {
                        return a() ? void delete this.get : (this.get = b).apply(this, arguments)
                    }
                }
            }

            function I(a) {
                if (a in ob) return a;
                for (var b = a[0].toUpperCase() + a.slice(1), c = nb.length; c--;)
                    if (a = nb[c] + b, a in ob) return a
            }

            function J(a) {
                var b = pa.cssProps[a];
                return b || (b = pa.cssProps[a] = I(a) || a), b
            }

            function K(a, b, c) {
                var d = Pa.exec(b);
                return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b
            }

            function L(a, b, c, d, e) {
                var f, g = 0;
                for (f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0; f < 4; f += 2) "margin" === c && (g += pa.css(a, c + Qa[f], !0, e)), d ? ("content" === c && (g -= pa.css(a, "padding" + Qa[f], !0, e)), "margin" !== c && (g -= pa.css(a, "border" + Qa[f] + "Width", !0, e))) : (g += pa.css(a, "padding" + Qa[f], !0, e), "padding" !== c && (g += pa.css(a, "border" + Qa[f] + "Width", !0, e)));
                return g
            }

            function M(a, b, c) {
                var d, e = ib(a),
                    f = G(a, b, e),
                    g = "border-box" === pa.css(a, "boxSizing", !1, e);
                return hb.test(f) ? f : (d = g && (na.boxSizingReliable() || f === a.style[b]), f = parseFloat(f) || 0, f + L(a, b, c || (g ? "border" : "content"), d, e) + "px")
            }

            function N(a, b, c, d, e) {
                return new N.prototype.init(a, b, c, d, e)
            }

            function O() {
                qb && (ca.hidden === !1 && a.requestAnimationFrame ? a.requestAnimationFrame(O) : a.setTimeout(O, pa.fx.interval), pa.fx.tick())
            }

            function P() {
                return a.setTimeout(function() {
                    pb = void 0
                }), pb = pa.now()
            }

            function Q(a, b) {
                var c, d = 0,
                    e = {
                        height: a
                    };
                for (b = b ? 1 : 0; d < 4; d += 2 - b) c = Qa[d], e["margin" + c] = e["padding" + c] = a;
                return b && (e.opacity = e.width = a), e
            }

            function R(a, b, c) {
                for (var d, e = (U.tweeners[b] || []).concat(U.tweeners["*"]), f = 0, g = e.length; f < g; f++)
                    if (d = e[f].call(c, b, a)) return d
            }

            function S(a, b, c) {
                var d, e, f, g, h, i, j, k, l = "width" in b || "height" in b,
                    m = this,
                    n = {},
                    o = a.style,
                    p = a.nodeType && Ra(a),
                    q = Ka.get(a, "fxshow");
                c.queue || (g = pa._queueHooks(a, "fx"), null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function() {
                    g.unqueued || h()
                }), g.unqueued++, m.always(function() {
                    m.always(function() {
                        g.unqueued--, pa.queue(a, "fx").length || g.empty.fire()
                    })
                }));
                for (d in b)
                    if (e = b[d], rb.test(e)) {
                        if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
                            if ("show" !== e || !q || void 0 === q[d]) continue;
                            p = !0
                        }
                        n[d] = q && q[d] || pa.style(a, d)
                    }
                if (i = !pa.isEmptyObject(b), i || !pa.isEmptyObject(n)) {
                    l && 1 === a.nodeType && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = q && q.display, null == j && (j = Ka.get(a, "display")), k = pa.css(a, "display"), "none" === k && (j ? k = j : (r([a], !0), j = a.style.display || j, k = pa.css(a, "display"), r([a]))), ("inline" === k || "inline-block" === k && null != j) && "none" === pa.css(a, "float") && (i || (m.done(function() {
                        o.display = j
                    }), null == j && (k = o.display, j = "none" === k ? "" : k)), o.display = "inline-block")), c.overflow && (o.overflow = "hidden", m.always(function() {
                        o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
                    })), i = !1;
                    for (d in n) i || (q ? "hidden" in q && (p = q.hidden) : q = Ka.access(a, "fxshow", {
                        display: j
                    }), f && (q.hidden = !p), p && r([a], !0), m.done(function() {
                        p || r([a]), Ka.remove(a, "fxshow");
                        for (d in n) pa.style(a, d, n[d])
                    })), i = R(p ? q[d] : 0, d, m), d in q || (q[d] = i.start, p && (i.end = i.start, i.start = 0))
                }
            }

            function T(a, b) {
                var c, d, e, f, g;
                for (c in a)
                    if (d = pa.camelCase(c), e = b[d], f = a[c], Array.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = pa.cssHooks[d], g && "expand" in g) {
                        f = g.expand(f), delete a[d];
                        for (c in f) c in a || (a[c] = f[c], b[c] = e)
                    } else b[d] = e
            }

            function U(a, b, c) {
                var d, e, f = 0,
                    g = U.prefilters.length,
                    h = pa.Deferred().always(function() {
                        delete i.elem
                    }),
                    i = function() {
                        if (e) return !1;
                        for (var b = pb || P(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.neonates.length; g < i; g++) j.neonates[g].run(f);
                        return h.notifyWith(a, [j, f, c]), f < 1 && i ? c : (i || h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j]), !1)
                    },
                    j = h.promise({
                        elem: a,
                        props: pa.extend({}, b),
                        opts: pa.extend(!0, {
                            specialEasing: {},
                            easing: pa.easing._default
                        }, c),
                        originalProperties: b,
                        originalOptions: c,
                        startTime: pb || P(),
                        duration: c.duration,
                        neonates: [],
                        createTween: function(b, c) {
                            var d = pa.Neonate(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                            return j.neonates.push(d), d
                        },
                        stop: function(b) {
                            var c = 0,
                                d = b ? j.neonates.length : 0;
                            if (e) return this;
                            for (e = !0; c < d; c++) j.neonates[c].run(1);
                            return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this
                        }
                    }),
                    k = j.props;
                for (T(k, j.opts.specialEasing); f < g; f++)
                    if (d = U.prefilters[f].call(j, a, k, j.opts)) return pa.isFunction(d.stop) && (pa._queueHooks(j.elem, j.opts.queue).stop = pa.proxy(d.stop, d)), d;
                return pa.map(k, R, j), pa.isFunction(j.opts.start) && j.opts.start.call(a, j), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always), pa.fx.timer(pa.extend(i, {
                    elem: a,
                    anim: j,
                    queue: j.opts.queue
                })), j
            }

            function V(a) {
                var b = a.match(Fa) || [];
                return b.join(" ")
            }

            function W(a) {
                return a.getAttribute && a.getAttribute("class") || ""
            }

            function X(a, b, c, d) {
                var e;
                if (Array.isArray(b)) pa.each(b, function(b, e) {
                    c || Cb.test(a) ? d(a, e) : X(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d)
                });
                else if (c || "object" !== pa.type(b)) d(a, b);
                else
                    for (e in b) X(a + "[" + e + "]", b[e], c, d)
            }

            function Y(a) {
                return function(b, c) {
                    "string" != typeof b && (c = b, b = "*");
                    var d, e = 0,
                        f = b.toLowerCase().match(Fa) || [];
                    if (pa.isFunction(c))
                        for (; d = f[e++];) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
                }
            }

            function Z(a, b, c, d) {
                function e(h) {
                    var i;
                    return f[h] = !0, pa.each(a[h] || [], function(a, h) {
                        var j = h(b, c, d);
                        return "string" != typeof j || g || f[j] ? g ? !(i = j) : void 0 : (b.dataTypes.unshift(j), e(j), !1)
                    }), i
                }
                var f = {},
                    g = a === Ob;
                return e(b.dataTypes[0]) || !f["*"] && e("*")
            }

            function $(a, b) {
                var c, d, e = pa.ajaxSettings.flatOptions || {};
                for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
                return d && pa.extend(!0, a, d), a
            }

            function _(a, b, c) {
                for (var d, e, f, g, h = a.contents, i = a.dataTypes;
                    "*" === i[0];) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
                if (d)
                    for (e in h)
                        if (h[e] && h[e].test(d)) {
                            i.unshift(e);
                            break
                        }
                if (i[0] in c) f = i[0];
                else {
                    for (e in c) {
                        if (!i[0] || a.converters[e + " " + i[0]]) {
                            f = e;
                            break
                        }
                        g || (g = e)
                    }
                    f = f || g
                }
                if (f) return f !== i[0] && i.unshift(f), c[f]
            }

            function aa(a, b, c, d) {
                var e, f, g, h, i, j = {},
                    k = a.dataTypes.slice();
                if (k[1])
                    for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
                for (f = k.shift(); f;)
                    if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
                        if ("*" === f) f = i;
                        else if ("*" !== i && i !== f) {
                    if (g = j[i + " " + f] || j["* " + f], !g)
                        for (e in j)
                            if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                                break
                            }
                    if (g !== !0)
                        if (g && a.throws) b = g(b);
                        else try {
                            b = g(b)
                        } catch (a) {
                            return {
                                state: "parsererror",
                                error: g ? a : "No conversion from " + i + " to " + f
                            }
                        }
                }
                return {
                    state: "success",
                    data: b
                }
            }
            var ba = [],
                ca = a.document,
                da = Object.getPrototypeOf,
                ea = ba.slice,
                fa = ba.concat,
                ga = ba.push,
                ha = ba.indexOf,
                ia = {},
                ja = ia.toString,
                ka = ia.hasOwnProperty,
                la = ka.toString,
                ma = la.call(Object),
                na = {},
                oa = "3.2.0",
                pa = function(a, b) {
                    return new pa.fn.init(a, b)
                },
                qa = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
                ra = /^-ms-/,
                sa = /-([a-z])/g,
                ta = function(a, b) {
                    return b.toUpperCase()
                };
            pa.fn = pa.prototype = {
                jquery: oa,
                constructor: pa,
                length: 0,
                toArray: function() {
                    return ea.call(this)
                },
                get: function(a) {
                    return null == a ? ea.call(this) : a < 0 ? this[a + this.length] : this[a]
                },
                pushStack: function(a) {
                    var b = pa.merge(this.constructor(), a);
                    return b.prevObject = this, b
                },
                each: function(a) {
                    return pa.each(this, a)
                },
                map: function(a) {
                    return this.pushStack(pa.map(this, function(b, c) {
                        return a.call(b, c, b)
                    }))
                },
                slice: function() {
                    return this.pushStack(ea.apply(this, arguments))
                },
                first: function() {
                    return this.eq(0)
                },
                last: function() {
                    return this.eq(-1)
                },
                eq: function(a) {
                    var b = this.length,
                        c = +a + (a < 0 ? b : 0);
                    return this.pushStack(c >= 0 && c < b ? [this[c]] : [])
                },
                end: function() {
                    return this.prevObject || this.constructor()
                },
                push: ga,
                sort: ba.sort,
                splice: ba.splice
            }, pa.extend = pa.fn.extend = function() {
                var a, b, c, d, e, f, g = arguments[0] || {},
                    h = 1,
                    i = arguments.length,
                    j = !1;
                for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || pa.isFunction(g) || (g = {}), h === i && (g = this, h--); h < i; h++)
                    if (null != (a = arguments[h]))
                        for (b in a) c = g[b], d = a[b], g !== d && (j && d && (pa.isPlainObject(d) || (e = Array.isArray(d))) ? (e ? (e = !1, f = c && Array.isArray(c) ? c : []) : f = c && pa.isPlainObject(c) ? c : {}, g[b] = pa.extend(j, f, d)) : void 0 !== d && (g[b] = d));
                return g
            }, pa.extend({
                expando: "jQuery" + (oa + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: function(a) {
                    throw new Error(a)
                },
                noop: function() {},
                isFunction: function(a) {
                    return "function" === pa.type(a)
                },
                isWindow: function(a) {
                    return null != a && a === a.window
                },
                isNumeric: function(a) {
                    var b = pa.type(a);
                    return ("number" === b || "string" === b) && !isNaN(a - parseFloat(a))
                },
                isPlainObject: function(a) {
                    var b, c;
                    return !(!a || "[object Object]" !== ja.call(a) || (b = da(a)) && (c = ka.call(b, "constructor") && b.constructor, "function" != typeof c || la.call(c) !== ma))
                },
                isEmptyObject: function(a) {
                    var b;
                    for (b in a) return !1;
                    return !0
                },
                type: function(a) {
                    return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? ia[ja.call(a)] || "object" : typeof a
                },
                globalEval: function(a) {
                    c(a)
                },
                camelCase: function(a) {
                    return a.replace(ra, "ms-").replace(sa, ta)
                },
                each: function(a, b) {
                    var c, e = 0;
                    if (d(a))
                        for (c = a.length; e < c && b.call(a[e], e, a[e]) !== !1; e++);
                    else
                        for (e in a)
                            if (b.call(a[e], e, a[e]) === !1) break;
                    return a
                },
                trim: function(a) {
                    return null == a ? "" : (a + "").replace(qa, "")
                },
                makeArray: function(a, b) {
                    var c = b || [];
                    return null != a && (d(Object(a)) ? pa.merge(c, "string" == typeof a ? [a] : a) : ga.call(c, a)), c
                },
                inArray: function(a, b, c) {
                    return null == b ? -1 : ha.call(b, a, c)
                },
                merge: function(a, b) {
                    for (var c = +b.length, d = 0, e = a.length; d < c; d++) a[e++] = b[d];
                    return a.length = e, a
                },
                grep: function(a, b, c) {
                    for (var d, e = [], f = 0, g = a.length, h = !c; f < g; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
                    return e
                },
                map: function(a, b, c) {
                    var e, f, g = 0,
                        h = [];
                    if (d(a))
                        for (e = a.length; g < e; g++) f = b(a[g], g, c), null != f && h.push(f);
                    else
                        for (g in a) f = b(a[g], g, c), null != f && h.push(f);
                    return fa.apply([], h)
                },
                guid: 1,
                proxy: function(a, b) {
                    var c, d, e;
                    if ("string" == typeof b && (c = a[b], b = a, a = c), pa.isFunction(a)) return d = ea.call(arguments, 2), e = function() {
                        return a.apply(b || this, d.concat(ea.call(arguments)))
                    }, e.guid = a.guid = a.guid || pa.guid++, e
                },
                now: Date.now,
                support: na
            }), "function" == typeof Symbol && (pa.fn[Symbol.iterator] = ba[Symbol.iterator]), pa.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(a, b) {
                ia["[object " + b + "]"] = b.toLowerCase()
            });
            var ua = function(a) {
                function b(a, b, c, d) {
                    var e, f, g, h, i, j, k, m = b && b.ownerDocument,
                        o = b ? b.nodeType : 9;
                    if (c = c || [], "string" != typeof a || !a || 1 !== o && 9 !== o && 11 !== o) return c;
                    if (!d && ((b ? b.ownerDocument || b : P) !== H && G(b), b = b || H, J)) {
                        if (11 !== o && (i = ra.exec(a)))
                            if (e = i[1]) {
                                if (9 === o) {
                                    if (!(g = b.getElementById(e))) return c;
                                    if (g.id === e) return c.push(g), c
                                } else if (m && (g = m.getElementById(e)) && N(b, g) && g.id === e) return c.push(g), c
                            } else {
                                if (i[2]) return $.apply(c, b.getElementsByTagName(a)), c;
                                if ((e = i[3]) && w.getElementsByClassName && b.getElementsByClassName) return $.apply(c, b.getElementsByClassName(e)), c
                            }
                        if (w.qsa && !U[a + " "] && (!K || !K.test(a))) {
                            if (1 !== o) m = b, k = a;
                            else if ("object" !== b.nodeName.toLowerCase()) {
                                for ((h = b.getAttribute("id")) ? h = h.replace(va, wa) : b.setAttribute("id", h = O), j = A(a), f = j.length; f--;) j[f] = "#" + h + " " + n(j[f]);
                                k = j.join(","), m = sa.test(a) && l(b.parentNode) || b
                            }
                            if (k) try {
                                return $.apply(c, m.querySelectorAll(k)), c
                            } catch (a) {} finally {
                                h === O && b.removeAttribute("id")
                            }
                        }
                    }
                    return C(a.replace(ha, "$1"), b, c, d)
                }

                function c() {
                    function a(c, d) {
                        return b.push(c + " ") > x.cacheLength && delete a[b.shift()], a[c + " "] = d
                    }
                    var b = [];
                    return a
                }

                function d(a) {
                    return a[O] = !0, a
                }

                function e(a) {
                    var b = H.createElement("fieldset");
                    try {
                        return !!a(b)
                    } catch (a) {
                        return !1
                    } finally {
                        b.parentNode && b.parentNode.removeChild(b), b = null
                    }
                }

                function f(a, b) {
                    for (var c = a.split("|"), d = c.length; d--;) x.attrHandle[c[d]] = b
                }

                function g(a, b) {
                    var c = b && a,
                        d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
                    if (d) return d;
                    if (c)
                        for (; c = c.nextSibling;)
                            if (c === b) return -1;
                    return a ? 1 : -1
                }

                function h(a) {
                    return function(b) {
                        var c = b.nodeName.toLowerCase();
                        return "input" === c && b.type === a
                    }
                }

                function i(a) {
                    return function(b) {
                        var c = b.nodeName.toLowerCase();
                        return ("input" === c || "button" === c) && b.type === a
                    }
                }

                function j(a) {
                    return function(b) {
                        return "form" in b ? b.parentNode && b.disabled === !1 ? "label" in b ? "label" in b.parentNode ? b.parentNode.disabled === a : b.disabled === a : b.isDisabled === a || b.isDisabled !== !a && ya(b) === a : b.disabled === a : "label" in b && b.disabled === a
                    }
                }

                function k(a) {
                    return d(function(b) {
                        return b = +b, d(function(c, d) {
                            for (var e, f = a([], c.length, b), g = f.length; g--;) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
                        })
                    })
                }

                function l(a) {
                    return a && "undefined" != typeof a.getElementsByTagName && a
                }

                function m() {}

                function n(a) {
                    for (var b = 0, c = a.length, d = ""; b < c; b++) d += a[b].value;
                    return d
                }

                function o(a, b, c) {
                    var d = b.dir,
                        e = b.next,
                        f = e || d,
                        g = c && "parentNode" === f,
                        h = R++;
                    return b.first ? function(b, c, e) {
                        for (; b = b[d];)
                            if (1 === b.nodeType || g) return a(b, c, e);
                        return !1
                    } : function(b, c, i) {
                        var j, k, l, m = [Q, h];
                        if (i) {
                            for (; b = b[d];)
                                if ((1 === b.nodeType || g) && a(b, c, i)) return !0
                        } else
                            for (; b = b[d];)
                                if (1 === b.nodeType || g)
                                    if (l = b[O] || (b[O] = {}), k = l[b.uniqueID] || (l[b.uniqueID] = {}), e && e === b.nodeName.toLowerCase()) b = b[d] || b;
                                    else {
                                        if ((j = k[f]) && j[0] === Q && j[1] === h) return m[2] = j[2];
                                        if (k[f] = m, m[2] = a(b, c, i)) return !0
                                    } return !1
                    }
                }

                function p(a) {
                    return a.length > 1 ? function(b, c, d) {
                        for (var e = a.length; e--;)
                            if (!a[e](b, c, d)) return !1;
                        return !0
                    } : a[0]
                }

                function q(a, c, d) {
                    for (var e = 0, f = c.length; e < f; e++) b(a, c[e], d);
                    return d
                }

                function r(a, b, c, d, e) {
                    for (var f, g = [], h = 0, i = a.length, j = null != b; h < i; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
                    return g
                }

                function s(a, b, c, e, f, g) {
                    return e && !e[O] && (e = s(e)), f && !f[O] && (f = s(f, g)), d(function(d, g, h, i) {
                        var j, k, l, m = [],
                            n = [],
                            o = g.length,
                            p = d || q(b || "*", h.nodeType ? [h] : h, []),
                            s = !a || !d && b ? p : r(p, m, a, h, i),
                            t = c ? f || (d ? a : o || e) ? [] : g : s;
                        if (c && c(s, t, h, i), e)
                            for (j = r(t, n), e(j, [], h, i), k = j.length; k--;)(l = j[k]) && (t[n[k]] = !(s[n[k]] = l));
                        if (d) {
                            if (f || a) {
                                if (f) {
                                    for (j = [], k = t.length; k--;)(l = t[k]) && j.push(s[k] = l);
                                    f(null, t = [], j, i)
                                }
                                for (k = t.length; k--;)(l = t[k]) && (j = f ? aa(d, l) : m[k]) > -1 && (d[j] = !(g[j] = l))
                            }
                        } else t = r(t === g ? t.splice(o, t.length) : t), f ? f(null, g, t, i) : $.apply(g, t)
                    })
                }

                function t(a) {
                    for (var b, c, d, e = a.length, f = x.relative[a[0].type], g = f || x.relative[" "], h = f ? 1 : 0, i = o(function(a) {
                            return a === b
                        }, g, !0), j = o(function(a) {
                            return aa(b, a) > -1
                        }, g, !0), k = [function(a, c, d) {
                            var e = !f && (d || c !== D) || ((b = c).nodeType ? i(a, c, d) : j(a, c, d));
                            return b = null, e
                        }]; h < e; h++)
                        if (c = x.relative[a[h].type]) k = [o(p(k), c)];
                        else {
                            if (c = x.filter[a[h].type].apply(null, a[h].matches), c[O]) {
                                for (d = ++h; d < e && !x.relative[a[d].type]; d++);
                                return s(h > 1 && p(k), h > 1 && n(a.slice(0, h - 1).concat({
                                    value: " " === a[h - 2].type ? "*" : ""
                                })).replace(ha, "$1"), c, h < d && t(a.slice(h, d)), d < e && t(a = a.slice(d)), d < e && n(a))
                            }
                            k.push(c)
                        }
                    return p(k)
                }

                function u(a, c) {
                    var e = c.length > 0,
                        f = a.length > 0,
                        g = function(d, g, h, i, j) {
                            var k, l, m, n = 0,
                                o = "0",
                                p = d && [],
                                q = [],
                                s = D,
                                t = d || f && x.find.TAG("*", j),
                                u = Q += null == s ? 1 : Math.random() || .1,
                                v = t.length;
                            for (j && (D = g === H || g || j); o !== v && null != (k = t[o]); o++) {
                                if (f && k) {
                                    for (l = 0, g || k.ownerDocument === H || (G(k), h = !J); m = a[l++];)
                                        if (m(k, g || H, h)) {
                                            i.push(k);
                                            break
                                        }
                                    j && (Q = u)
                                }
                                e && ((k = !m && k) && n--, d && p.push(k))
                            }
                            if (n += o, e && o !== n) {
                                for (l = 0; m = c[l++];) m(p, q, g, h);
                                if (d) {
                                    if (n > 0)
                                        for (; o--;) p[o] || q[o] || (q[o] = Y.call(i));
                                    q = r(q)
                                }
                                $.apply(i, q), j && !d && q.length > 0 && n + c.length > 1 && b.uniqueSort(i)
                            }
                            return j && (Q = u, D = s), p
                        };
                    return e ? d(g) : g
                }
                var v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O = "sizzle" + 1 * new Date,
                    P = a.document,
                    Q = 0,
                    R = 0,
                    S = c(),
                    T = c(),
                    U = c(),
                    V = function(a, b) {
                        return a === b && (F = !0), 0
                    },
                    W = {}.hasOwnProperty,
                    X = [],
                    Y = X.pop,
                    Z = X.push,
                    $ = X.push,
                    _ = X.slice,
                    aa = function(a, b) {
                        for (var c = 0, d = a.length; c < d; c++)
                            if (a[c] === b) return c;
                        return -1
                    },
                    ba = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    ca = "[\\x20\\t\\r\\n\\f]",
                    da = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
                    ea = "\\[" + ca + "*(" + da + ")(?:" + ca + "*([*^$|!~]?=)" + ca + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + da + "))|)" + ca + "*\\]",
                    fa = ":(" + da + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ea + ")*)|.*)\\)|)",
                    ga = new RegExp(ca + "+", "g"),
                    ha = new RegExp("^" + ca + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ca + "+$", "g"),
                    ia = new RegExp("^" + ca + "*," + ca + "*"),
                    ja = new RegExp("^" + ca + "*([>+~]|" + ca + ")" + ca + "*"),
                    ka = new RegExp("=" + ca + "*([^\\]'\"]*?)" + ca + "*\\]", "g"),
                    la = new RegExp(fa),
                    ma = new RegExp("^" + da + "$"),
                    na = {
                        ID: new RegExp("^#(" + da + ")"),
                        CLASS: new RegExp("^\\.(" + da + ")"),
                        TAG: new RegExp("^(" + da + "|[*])"),
                        ATTR: new RegExp("^" + ea),
                        PSEUDO: new RegExp("^" + fa),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ca + "*(even|odd|(([+-]|)(\\d*)n|)" + ca + "*(?:([+-]|)" + ca + "*(\\d+)|))" + ca + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + ba + ")$", "i"),
                        needsContext: new RegExp("^" + ca + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ca + "*((?:-\\d)?\\d*)" + ca + "*\\)|)(?=[^-]|$)", "i")
                    },
                    oa = /^(?:input|select|textarea|button)$/i,
                    pa = /^h\d$/i,
                    qa = /^[^{]+\{\s*\[native \w/,
                    ra = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    sa = /[+~]/,
                    ta = new RegExp("\\\\([\\da-f]{1,6}" + ca + "?|(" + ca + ")|.)", "ig"),
                    ua = function(a, b, c) {
                        var d = "0x" + b - 65536;
                        return d !== d || c ? b : d < 0 ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
                    },
                    va = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                    wa = function(a, b) {
                        return b ? "\0" === a ? "" : a.slice(0, -1) + "\\" + a.charCodeAt(a.length - 1).toString(16) + " " : "\\" + a
                    },
                    xa = function() {
                        G()
                    },
                    ya = o(function(a) {
                        return a.disabled === !0 && ("form" in a || "label" in a)
                    }, {
                        dir: "parentNode",
                        next: "legend"
                    });
                try {
                    $.apply(X = _.call(P.childNodes), P.childNodes), X[P.childNodes.length].nodeType
                } catch (a) {
                    $ = {
                        apply: X.length ? function(a, b) {
                            Z.apply(a, _.call(b))
                        } : function(a, b) {
                            for (var c = a.length, d = 0; a[c++] = b[d++];);
                            a.length = c - 1
                        }
                    }
                }
                w = b.support = {}, z = b.isXML = function(a) {
                    var b = a && (a.ownerDocument || a).documentElement;
                    return !!b && "HTML" !== b.nodeName
                }, G = b.setDocument = function(a) {
                    var b, c, d = a ? a.ownerDocument || a : P;
                    return d !== H && 9 === d.nodeType && d.documentElement ? (H = d, I = H.documentElement, J = !z(H), P !== H && (c = H.defaultView) && c.top !== c && (c.addEventListener ? c.addEventListener("unload", xa, !1) : c.attachEvent && c.attachEvent("onunload", xa)), w.attributes = e(function(a) {
                        return a.className = "i", !a.getAttribute("className")
                    }), w.getElementsByTagName = e(function(a) {
                        return a.appendChild(H.createComment("")), !a.getElementsByTagName("*").length
                    }), w.getElementsByClassName = qa.test(H.getElementsByClassName), w.getById = e(function(a) {
                        return I.appendChild(a).id = O, !H.getElementsByName || !H.getElementsByName(O).length
                    }), w.getById ? (x.filter.ID = function(a) {
                        var b = a.replace(ta, ua);
                        return function(a) {
                            return a.getAttribute("id") === b
                        }
                    }, x.find.ID = function(a, b) {
                        if ("undefined" != typeof b.getElementById && J) {
                            var c = b.getElementById(a);
                            return c ? [c] : []
                        }
                    }) : (x.filter.ID = function(a) {
                        var b = a.replace(ta, ua);
                        return function(a) {
                            var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                            return c && c.value === b
                        }
                    }, x.find.ID = function(a, b) {
                        if ("undefined" != typeof b.getElementById && J) {
                            var c, d, e, f = b.getElementById(a);
                            if (f) {
                                if (c = f.getAttributeNode("id"), c && c.value === a) return [f];
                                for (e = b.getElementsByName(a), d = 0; f = e[d++];)
                                    if (c = f.getAttributeNode("id"), c && c.value === a) return [f]
                            }
                            return []
                        }
                    }), x.find.TAG = w.getElementsByTagName ? function(a, b) {
                        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : w.qsa ? b.querySelectorAll(a) : void 0
                    } : function(a, b) {
                        var c, d = [],
                            e = 0,
                            f = b.getElementsByTagName(a);
                        if ("*" === a) {
                            for (; c = f[e++];) 1 === c.nodeType && d.push(c);
                            return d
                        }
                        return f
                    }, x.find.CLASS = w.getElementsByClassName && function(a, b) {
                        if ("undefined" != typeof b.getElementsByClassName && J) return b.getElementsByClassName(a)
                    }, L = [], K = [], (w.qsa = qa.test(H.querySelectorAll)) && (e(function(a) {
                        I.appendChild(a).innerHTML = "<a id='" + O + "'></a><select id='" + O + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && K.push("[*^$]=" + ca + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || K.push("\\[" + ca + "*(?:value|" + ba + ")"), a.querySelectorAll("[id~=" + O + "-]").length || K.push("~="), a.querySelectorAll(":checked").length || K.push(":checked"), a.querySelectorAll("a#" + O + "+*").length || K.push(".#.+[+~]")
                    }), e(function(a) {
                        a.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var b = H.createElement("input");
                        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && K.push("name" + ca + "*[*^$|!~]?="), 2 !== a.querySelectorAll(":enabled").length && K.push(":enabled", ":disabled"), I.appendChild(a).disabled = !0, 2 !== a.querySelectorAll(":disabled").length && K.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), K.push(",.*:")
                    })), (w.matchesSelector = qa.test(M = I.matches || I.webkitMatchesSelector || I.mozMatchesSelector || I.oMatchesSelector || I.msMatchesSelector)) && e(function(a) {
                        w.disconnectedMatch = M.call(a, "*"), M.call(a, "[s!='']:x"), L.push("!=", fa)
                    }), K = K.length && new RegExp(K.join("|")), L = L.length && new RegExp(L.join("|")), b = qa.test(I.compareDocumentPosition), N = b || qa.test(I.contains) ? function(a, b) {
                        var c = 9 === a.nodeType ? a.documentElement : a,
                            d = b && b.parentNode;
                        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
                    } : function(a, b) {
                        if (b)
                            for (; b = b.parentNode;)
                                if (b === a) return !0;
                        return !1
                    }, V = b ? function(a, b) {
                        if (a === b) return F = !0, 0;
                        var c = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return c ? c : (c = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & c || !w.sortDetached && b.compareDocumentPosition(a) === c ? a === H || a.ownerDocument === P && N(P, a) ? -1 : b === H || b.ownerDocument === P && N(P, b) ? 1 : E ? aa(E, a) - aa(E, b) : 0 : 4 & c ? -1 : 1)
                    } : function(a, b) {
                        if (a === b) return F = !0, 0;
                        var c, d = 0,
                            e = a.parentNode,
                            f = b.parentNode,
                            h = [a],
                            i = [b];
                        if (!e || !f) return a === H ? -1 : b === H ? 1 : e ? -1 : f ? 1 : E ? aa(E, a) - aa(E, b) : 0;
                        if (e === f) return g(a, b);
                        for (c = a; c = c.parentNode;) h.unshift(c);
                        for (c = b; c = c.parentNode;) i.unshift(c);
                        for (; h[d] === i[d];) d++;
                        return d ? g(h[d], i[d]) : h[d] === P ? -1 : i[d] === P ? 1 : 0
                    }, H) : H
                }, b.matches = function(a, c) {
                    return b(a, null, null, c)
                }, b.matchesSelector = function(a, c) {
                    if ((a.ownerDocument || a) !== H && G(a), c = c.replace(ka, "='$1']"), w.matchesSelector && J && !U[c + " "] && (!L || !L.test(c)) && (!K || !K.test(c))) try {
                        var d = M.call(a, c);
                        if (d || w.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
                    } catch (a) {}
                    return b(c, H, null, [a]).length > 0
                }, b.contains = function(a, b) {
                    return (a.ownerDocument || a) !== H && G(a), N(a, b)
                }, b.attr = function(a, b) {
                    (a.ownerDocument || a) !== H && G(a);
                    var c = x.attrHandle[b.toLowerCase()],
                        d = c && W.call(x.attrHandle, b.toLowerCase()) ? c(a, b, !J) : void 0;
                    return void 0 !== d ? d : w.attributes || !J ? a.getAttribute(b) : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
                }, b.escape = function(a) {
                    return (a + "").replace(va, wa)
                }, b.error = function(a) {
                    throw new Error("Syntax error, unrecognized expression: " + a)
                }, b.uniqueSort = function(a) {
                    var b, c = [],
                        d = 0,
                        e = 0;
                    if (F = !w.detectDuplicates, E = !w.sortStable && a.slice(0), a.sort(V), F) {
                        for (; b = a[e++];) b === a[e] && (d = c.push(e));
                        for (; d--;) a.splice(c[d], 1)
                    }
                    return E = null, a
                }, y = b.getText = function(a) {
                    var b, c = "",
                        d = 0,
                        e = a.nodeType;
                    if (e) {
                        if (1 === e || 9 === e || 11 === e) {
                            if ("string" == typeof a.textContent) return a.textContent;
                            for (a = a.firstChild; a; a = a.nextSibling) c += y(a)
                        } else if (3 === e || 4 === e) return a.nodeValue
                    } else
                        for (; b = a[d++];) c += y(b);
                    return c
                }, x = b.selectors = {
                    cacheLength: 50,
                    createPseudo: d,
                    match: na,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(a) {
                            return a[1] = a[1].replace(ta, ua), a[3] = (a[3] || a[4] || a[5] || "").replace(ta, ua), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
                        },
                        CHILD: function(a) {
                            return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || b.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && b.error(a[0]), a
                        },
                        PSEUDO: function(a) {
                            var b, c = !a[6] && a[2];
                            return na.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && la.test(c) && (b = A(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function(a) {
                            var b = a.replace(ta, ua).toLowerCase();
                            return "*" === a ? function() {
                                return !0
                            } : function(a) {
                                return a.nodeName && a.nodeName.toLowerCase() === b
                            }
                        },
                        CLASS: function(a) {
                            var b = S[a + " "];
                            return b || (b = new RegExp("(^|" + ca + ")" + a + "(" + ca + "|$)")) && S(a, function(a) {
                                return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
                            })
                        },
                        ATTR: function(a, c, d) {
                            return function(e) {
                                var f = b.attr(e, a);
                                return null == f ? "!=" === c : !c || (f += "", "=" === c ? f === d : "!=" === c ? f !== d : "^=" === c ? d && 0 === f.indexOf(d) : "*=" === c ? d && f.indexOf(d) > -1 : "$=" === c ? d && f.slice(-d.length) === d : "~=" === c ? (" " + f.replace(ga, " ") + " ").indexOf(d) > -1 : "|=" === c && (f === d || f.slice(0, d.length + 1) === d + "-"))
                            }
                        },
                        CHILD: function(a, b, c, d, e) {
                            var f = "nth" !== a.slice(0, 3),
                                g = "last" !== a.slice(-4),
                                h = "of-type" === b;
                            return 1 === d && 0 === e ? function(a) {
                                return !!a.parentNode
                            } : function(b, c, i) {
                                var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
                                    q = b.parentNode,
                                    r = h && b.nodeName.toLowerCase(),
                                    s = !i && !h,
                                    t = !1;
                                if (q) {
                                    if (f) {
                                        for (; p;) {
                                            for (m = b; m = m[p];)
                                                if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;
                                            o = p = "only" === a && !o && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (o = [g ? q.firstChild : q.lastChild], g && s) {
                                        for (m = q, l = m[O] || (m[O] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === Q && j[1], t = n && j[2], m = n && q.childNodes[n]; m = ++n && m && m[p] || (t = n = 0) || o.pop();)
                                            if (1 === m.nodeType && ++t && m === b) {
                                                k[a] = [Q, n, t];
                                                break
                                            }
                                    } else if (s && (m = b, l = m[O] || (m[O] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === Q && j[1], t = n), t === !1)
                                        for (;
                                            (m = ++n && m && m[p] || (t = n = 0) || o.pop()) && ((h ? m.nodeName.toLowerCase() !== r : 1 !== m.nodeType) || !++t || (s && (l = m[O] || (m[O] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [Q, t]), m !== b)););
                                    return t -= e, t === d || t % d === 0 && t / d >= 0
                                }
                            }
                        },
                        PSEUDO: function(a, c) {
                            var e, f = x.pseudos[a] || x.setFilters[a.toLowerCase()] || b.error("unsupported pseudo: " + a);
                            return f[O] ? f(c) : f.length > 1 ? (e = [a, a, "", c], x.setFilters.hasOwnProperty(a.toLowerCase()) ? d(function(a, b) {
                                for (var d, e = f(a, c), g = e.length; g--;) d = aa(a, e[g]), a[d] = !(b[d] = e[g])
                            }) : function(a) {
                                return f(a, 0, e)
                            }) : f
                        }
                    },
                    pseudos: {
                        not: d(function(a) {
                            var b = [],
                                c = [],
                                e = B(a.replace(ha, "$1"));
                            return e[O] ? d(function(a, b, c, d) {
                                for (var f, g = e(a, null, d, []), h = a.length; h--;)(f = g[h]) && (a[h] = !(b[h] = f))
                            }) : function(a, d, f) {
                                return b[0] = a, e(b, null, f, c), b[0] = null, !c.pop()
                            }
                        }),
                        has: d(function(a) {
                            return function(c) {
                                return b(a, c).length > 0
                            }
                        }),
                        contains: d(function(a) {
                            return a = a.replace(ta, ua),
                                function(b) {
                                    return (b.textContent || b.innerText || y(b)).indexOf(a) > -1
                                }
                        }),
                        lang: d(function(a) {
                            return ma.test(a || "") || b.error("unsupported lang: " + a), a = a.replace(ta, ua).toLowerCase(),
                                function(b) {
                                    var c;
                                    do
                                        if (c = J ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                                    return !1
                                }
                        }),
                        target: function(b) {
                            var c = a.location && a.location.hash;
                            return c && c.slice(1) === b.id
                        },
                        root: function(a) {
                            return a === I
                        },
                        focus: function(a) {
                            return a === H.activeElement && (!H.hasFocus || H.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
                        },
                        enabled: j(!1),
                        disabled: j(!0),
                        checked: function(a) {
                            var b = a.nodeName.toLowerCase();
                            return "input" === b && !!a.checked || "option" === b && !!a.selected
                        },
                        selected: function(a) {
                            return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
                        },
                        empty: function(a) {
                            for (a = a.firstChild; a; a = a.nextSibling)
                                if (a.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function(a) {
                            return !x.pseudos.empty(a)
                        },
                        header: function(a) {
                            return pa.test(a.nodeName)
                        },
                        input: function(a) {
                            return oa.test(a.nodeName)
                        },
                        button: function(a) {
                            var b = a.nodeName.toLowerCase();
                            return "input" === b && "button" === a.type || "button" === b
                        },
                        text: function(a) {
                            var b;
                            return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
                        },
                        first: k(function() {
                            return [0]
                        }),
                        last: k(function(a, b) {
                            return [b - 1]
                        }),
                        eq: k(function(a, b, c) {
                            return [c < 0 ? c + b : c]
                        }),
                        even: k(function(a, b) {
                            for (var c = 0; c < b; c += 2) a.push(c);
                            return a
                        }),
                        odd: k(function(a, b) {
                            for (var c = 1; c < b; c += 2) a.push(c);
                            return a
                        }),
                        lt: k(function(a, b, c) {
                            for (var d = c < 0 ? c + b : c; --d >= 0;) a.push(d);
                            return a
                        }),
                        gt: k(function(a, b, c) {
                            for (var d = c < 0 ? c + b : c; ++d < b;) a.push(d);
                            return a
                        })
                    }
                }, x.pseudos.nth = x.pseudos.eq;
                for (v in {
                        radio: !0,
                        checkbox: !0,
                        file: !0,
                        password: !0,
                        image: !0
                    }) x.pseudos[v] = h(v);
                for (v in {
                        submit: !0,
                        reset: !0
                    }) x.pseudos[v] = i(v);
                return m.prototype = x.filters = x.pseudos, x.setFilters = new m, A = b.tokenize = function(a, c) {
                    var d, e, f, g, h, i, j, k = T[a + " "];
                    if (k) return c ? 0 : k.slice(0);
                    for (h = a, i = [], j = x.preFilter; h;) {
                        d && !(e = ia.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), d = !1, (e = ja.exec(h)) && (d = e.shift(), f.push({
                            value: d,
                            type: e[0].replace(ha, " ")
                        }), h = h.slice(d.length));
                        for (g in x.filter) !(e = na[g].exec(h)) || j[g] && !(e = j[g](e)) || (d = e.shift(), f.push({
                            value: d,
                            type: g,
                            matches: e
                        }), h = h.slice(d.length));
                        if (!d) break
                    }
                    return c ? h.length : h ? b.error(a) : T(a, i).slice(0)
                }, B = b.compile = function(a, b) {
                    var c, d = [],
                        e = [],
                        f = U[a + " "];
                    if (!f) {
                        for (b || (b = A(a)), c = b.length; c--;) f = t(b[c]), f[O] ? d.push(f) : e.push(f);
                        f = U(a, u(e, d)), f.selector = a
                    }
                    return f
                }, C = b.select = function(a, b, c, d) {
                    var e, f, g, h, i, j = "function" == typeof a && a,
                        k = !d && A(a = j.selector || a);
                    if (c = c || [], 1 === k.length) {
                        if (f = k[0] = k[0].slice(0), f.length > 2 && "ID" === (g = f[0]).type && 9 === b.nodeType && J && x.relative[f[1].type]) {
                            if (b = (x.find.ID(g.matches[0].replace(ta, ua), b) || [])[0], !b) return c;
                            j && (b = b.parentNode), a = a.slice(f.shift().value.length)
                        }
                        for (e = na.needsContext.test(a) ? 0 : f.length; e-- && (g = f[e], !x.relative[h = g.type]);)
                            if ((i = x.find[h]) && (d = i(g.matches[0].replace(ta, ua), sa.test(f[0].type) && l(b.parentNode) || b))) {
                                if (f.splice(e, 1), a = d.length && n(f), !a) return $.apply(c, d), c;
                                break
                            }
                    }
                    return (j || B(a, k))(d, b, !J, c, !b || sa.test(a) && l(b.parentNode) || b), c
                }, w.sortStable = O.split("").sort(V).join("") === O, w.detectDuplicates = !!F, G(), w.sortDetached = e(function(a) {
                    return 1 & a.compareDocumentPosition(H.createElement("fieldset"))
                }), e(function(a) {
                    return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
                }) || f("type|href|height|width", function(a, b, c) {
                    if (!c) return a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
                }), w.attributes && e(function(a) {
                    return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
                }) || f("value", function(a, b, c) {
                    if (!c && "input" === a.nodeName.toLowerCase()) return a.defaultValue
                }), e(function(a) {
                    return null == a.getAttribute("disabled")
                }) || f(ba, function(a, b, c) {
                    var d;
                    if (!c) return a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
                }), b
            }(a);
            pa.find = ua, pa.expr = ua.selectors, pa.expr[":"] = pa.expr.pseudos, pa.uniqueSort = pa.unique = ua.uniqueSort, pa.text = ua.getText, pa.isXMLDoc = ua.isXML, pa.contains = ua.contains, pa.escapeSelector = ua.escape;
            var va = function(a, b, c) {
                    for (var d = [], e = void 0 !== c;
                        (a = a[b]) && 9 !== a.nodeType;)
                        if (1 === a.nodeType) {
                            if (e && pa(a).is(c)) break;
                            d.push(a)
                        }
                    return d
                },
                wa = function(a, b) {
                    for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
                    return c
                },
                xa = pa.expr.match.needsContext,
                ya = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,
                za = /^.[^:#\[\.,]*$/;
            pa.filter = function(a, b, c) {
                var d = b[0];
                return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? pa.find.matchesSelector(d, a) ? [d] : [] : pa.find.matches(a, pa.grep(b, function(a) {
                    return 1 === a.nodeType
                }))
            }, pa.fn.extend({
                find: function(a) {
                    var b, c, d = this.length,
                        e = this;
                    if ("string" != typeof a) return this.pushStack(pa(a).filter(function() {
                        for (b = 0; b < d; b++)
                            if (pa.contains(e[b], this)) return !0
                    }));
                    for (c = this.pushStack([]), b = 0; b < d; b++) pa.find(a, e[b], c);
                    return d > 1 ? pa.uniqueSort(c) : c
                },
                filter: function(a) {
                    return this.pushStack(f(this, a || [], !1))
                },
                not: function(a) {
                    return this.pushStack(f(this, a || [], !0))
                },
                is: function(a) {
                    return !!f(this, "string" == typeof a && xa.test(a) ? pa(a) : a || [], !1).length
                }
            });
            var Aa, Ba = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
                Ca = pa.fn.init = function(a, b, c) {
                    var d, e;
                    if (!a) return this;
                    if (c = c || Aa, "string" == typeof a) {
                        if (d = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : Ba.exec(a), !d || !d[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
                        if (d[1]) {
                            if (b = b instanceof pa ? b[0] : b, pa.merge(this, pa.parseHTML(d[1], b && b.nodeType ? b.ownerDocument || b : ca, !0)), ya.test(d[1]) && pa.isPlainObject(b))
                                for (d in b) pa.isFunction(this[d]) ? this[d](b[d]) : this.attr(d, b[d]);
                            return this
                        }
                        return e = ca.getElementById(d[2]), e && (this[0] = e, this.length = 1), this
                    }
                    return a.nodeType ? (this[0] = a, this.length = 1, this) : pa.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(pa) : pa.makeArray(a, this)
                };
            Ca.prototype = pa.fn, Aa = pa(ca);
            var Da = /^(?:parents|prev(?:Until|All))/,
                Ea = {
                    children: !0,
                    contents: !0,
                    next: !0,
                    prev: !0
                };
            pa.fn.extend({
                has: function(a) {
                    var b = pa(a, this),
                        c = b.length;
                    return this.filter(function() {
                        for (var a = 0; a < c; a++)
                            if (pa.contains(this, b[a])) return !0
                    })
                },
                closest: function(a, b) {
                    var c, d = 0,
                        e = this.length,
                        f = [],
                        g = "string" != typeof a && pa(a);
                    if (!xa.test(a))
                        for (; d < e; d++)
                            for (c = this[d]; c && c !== b; c = c.parentNode)
                                if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && pa.find.matchesSelector(c, a))) {
                                    f.push(c);
                                    break
                                }
                    return this.pushStack(f.length > 1 ? pa.uniqueSort(f) : f)
                },
                index: function(a) {
                    return a ? "string" == typeof a ? ha.call(pa(a), this[0]) : ha.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                },
                add: function(a, b) {
                    return this.pushStack(pa.uniqueSort(pa.merge(this.get(), pa(a, b))))
                },
                addBack: function(a) {
                    return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
                }
            }), pa.each({
                parent: function(a) {
                    var b = a.parentNode;
                    return b && 11 !== b.nodeType ? b : null
                },
                parents: function(a) {
                    return va(a, "parentNode")
                },
                parentsUntil: function(a, b, c) {
                    return va(a, "parentNode", c)
                },
                next: function(a) {
                    return g(a, "nextSibling")
                },
                prev: function(a) {
                    return g(a, "previousSibling")
                },
                nextAll: function(a) {
                    return va(a, "nextSibling")
                },
                prevAll: function(a) {
                    return va(a, "previousSibling")
                },
                nextUntil: function(a, b, c) {
                    return va(a, "nextSibling", c)
                },
                prevUntil: function(a, b, c) {
                    return va(a, "previousSibling", c)
                },
                siblings: function(a) {
                    return wa((a.parentNode || {}).firstChild, a)
                },
                children: function(a) {
                    return wa(a.firstChild)
                },
                contents: function(a) {
                    return e(a, "iframe") ? a.contentDocument : (e(a, "template") && (a = a.content || a), pa.merge([], a.childNodes))
                }
            }, function(a, b) {
                pa.fn[a] = function(c, d) {
                    var e = pa.map(this, b, c);
                    return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = pa.filter(d, e)), this.length > 1 && (Ea[a] || pa.uniqueSort(e), Da.test(a) && e.reverse()), this.pushStack(e)
                }
            });
            var Fa = /[^\x20\t\r\n\f]+/g;
            pa.Callbacks = function(a) {
                a = "string" == typeof a ? h(a) : pa.extend({}, a);
                var b, c, d, e, f = [],
                    g = [],
                    i = -1,
                    j = function() {
                        for (e = e || a.once, d = b = !0; g.length; i = -1)
                            for (c = g.shift(); ++i < f.length;) f[i].apply(c[0], c[1]) === !1 && a.stopOnFalse && (i = f.length, c = !1);
                        a.memory || (c = !1), b = !1, e && (f = c ? [] : "")
                    },
                    k = {
                        add: function() {
                            return f && (c && !b && (i = f.length - 1, g.push(c)), function b(c) {
                                pa.each(c, function(c, d) {
                                    pa.isFunction(d) ? a.unique && k.has(d) || f.push(d) : d && d.length && "string" !== pa.type(d) && b(d)
                                })
                            }(arguments), c && !b && j()), this
                        },
                        remove: function() {
                            return pa.each(arguments, function(a, b) {
                                for (var c;
                                    (c = pa.inArray(b, f, c)) > -1;) f.splice(c, 1), c <= i && i--
                            }), this
                        },
                        has: function(a) {
                            return a ? pa.inArray(a, f) > -1 : f.length > 0
                        },
                        empty: function() {
                            return f && (f = []), this
                        },
                        disable: function() {
                            return e = g = [], f = c = "", this
                        },
                        disabled: function() {
                            return !f
                        },
                        lock: function() {
                            return e = g = [], c || b || (f = c = ""), this
                        },
                        locked: function() {
                            return !!e
                        },
                        fireWith: function(a, c) {
                            return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || j()), this
                        },
                        fire: function() {
                            return k.fireWith(this, arguments), this
                        },
                        fired: function() {
                            return !!d
                        }
                    };
                return k
            }, pa.extend({
                Deferred: function(b) {
                    var c = [
                            ["notify", "progress", pa.Callbacks("memory"), pa.Callbacks("memory"), 2],
                            ["resolve", "done", pa.Callbacks("once memory"), pa.Callbacks("once memory"), 0, "resolved"],
                            ["reject", "fail", pa.Callbacks("once memory"), pa.Callbacks("once memory"), 1, "rejected"]
                        ],
                        d = "pending",
                        e = {
                            state: function() {
                                return d
                            },
                            always: function() {
                                return f.done(arguments).fail(arguments), this
                            },
                            catch: function(a) {
                                return e.then(null, a)
                            },
                            pipe: function() {
                                var a = arguments;
                                return pa.Deferred(function(b) {
                                    pa.each(c, function(c, d) {
                                        var e = pa.isFunction(a[d[4]]) && a[d[4]];
                                        f[d[1]](function() {
                                            var a = e && e.apply(this, arguments);
                                            a && pa.isFunction(a.promise) ? a.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[d[0] + "With"](this, e ? [a] : arguments)
                                        })
                                    }), a = null
                                }).promise()
                            },
                            then: function(b, d, e) {
                                function f(b, c, d, e) {
                                    return function() {
                                        var h = this,
                                            k = arguments,
                                            l = function() {
                                                var a, l;
                                                if (!(b < g)) {
                                                    if (a = d.apply(h, k), a === c.promise()) throw new TypeError("Thenable self-resolution");
                                                    l = a && ("object" == typeof a || "function" == typeof a) && a.then, pa.isFunction(l) ? e ? l.call(a, f(g, c, i, e), f(g, c, j, e)) : (g++, l.call(a, f(g, c, i, e), f(g, c, j, e), f(g, c, i, c.notifyWith))) : (d !== i && (h = void 0, k = [a]), (e || c.resolveWith)(h, k))
                                                }
                                            },
                                            m = e ? l : function() {
                                                try {
                                                    l()
                                                } catch (a) {
                                                    pa.Deferred.exceptionHook && pa.Deferred.exceptionHook(a, m.stackTrace), b + 1 >= g && (d !== j && (h = void 0, k = [a]), c.rejectWith(h, k))
                                                }
                                            };
                                        b ? m() : (pa.Deferred.getStackHook && (m.stackTrace = pa.Deferred.getStackHook()), a.setTimeout(m))
                                    }
                                }
                                var g = 0;
                                return pa.Deferred(function(a) {
                                    c[0][3].add(f(0, a, pa.isFunction(e) ? e : i, a.notifyWith)), c[1][3].add(f(0, a, pa.isFunction(b) ? b : i)), c[2][3].add(f(0, a, pa.isFunction(d) ? d : j))
                                }).promise()
                            },
                            promise: function(a) {
                                return null != a ? pa.extend(a, e) : e
                            }
                        },
                        f = {};
                    return pa.each(c, function(a, b) {
                        var g = b[2],
                            h = b[5];
                        e[b[1]] = g.add, h && g.add(function() {
                            d = h
                        }, c[3 - a][2].disable, c[0][2].lock), g.add(b[3].fire), f[b[0]] = function() {
                            return f[b[0] + "With"](this === f ? void 0 : this, arguments), this
                        }, f[b[0] + "With"] = g.fireWith
                    }), e.promise(f), b && b.call(f, f), f
                },
                when: function(a) {
                    var b = arguments.length,
                        c = b,
                        d = Array(c),
                        e = ea.call(arguments),
                        f = pa.Deferred(),
                        g = function(a) {
                            return function(c) {
                                d[a] = this, e[a] = arguments.length > 1 ? ea.call(arguments) : c, --b || f.resolveWith(d, e)
                            }
                        };
                    if (b <= 1 && (k(a, f.done(g(c)).resolve, f.reject, !b), "pending" === f.state() || pa.isFunction(e[c] && e[c].then))) return f.then();
                    for (; c--;) k(e[c], g(c), f.reject);
                    return f.promise()
                }
            });
            var Ga = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            pa.Deferred.exceptionHook = function(b, c) {
                a.console && a.console.warn && b && Ga.test(b.name) && a.console.warn("jQuery.Deferred exception: " + b.message, b.stack, c)
            }, pa.readyException = function(b) {
                a.setTimeout(function() {
                    throw b
                })
            };
            var Ha = pa.Deferred();
            pa.fn.ready = function(a) {
                return Ha.then(a).catch(function(a) {
                    pa.readyException(a)
                }), this
            }, pa.extend({
                isReady: !1,
                readyWait: 1,
                ready: function(a) {
                    (a === !0 ? --pa.readyWait : pa.isReady) || (pa.isReady = !0, a !== !0 && --pa.readyWait > 0 || Ha.resolveWith(ca, [pa]))
                }
            }), pa.ready.then = Ha.then, "complete" === ca.readyState || "loading" !== ca.readyState && !ca.documentElement.doScroll ? a.setTimeout(pa.ready) : (ca.addEventListener("DOMContentLoaded", l), a.addEventListener("load", l));
            var Ia = function(a, b, c, d, e, f, g) {
                    var h = 0,
                        i = a.length,
                        j = null == c;
                    if ("object" === pa.type(c)) {
                        e = !0;
                        for (h in c) Ia(a, b, h, c[h], !0, f, g)
                    } else if (void 0 !== d && (e = !0, pa.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
                            return j.call(pa(a), c)
                        })), b))
                        for (; h < i; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
                    return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
                },
                Ja = function(a) {
                    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
                };
            m.uid = 1, m.prototype = {
                cache: function(a) {
                    var b = a[this.expando];
                    return b || (b = {}, Ja(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
                        value: b,
                        configurable: !0
                    }))), b
                },
                set: function(a, b, c) {
                    var d, e = this.cache(a);
                    if ("string" == typeof b) e[pa.camelCase(b)] = c;
                    else
                        for (d in b) e[pa.camelCase(d)] = b[d];
                    return e
                },
                get: function(a, b) {
                    return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][pa.camelCase(b)]
                },
                access: function(a, b, c) {
                    return void 0 === b || b && "string" == typeof b && void 0 === c ? this.get(a, b) : (this.set(a, b, c), void 0 !== c ? c : b)
                },
                remove: function(a, b) {
                    var c, d = a[this.expando];
                    if (void 0 !== d) {
                        if (void 0 !== b) {
                            Array.isArray(b) ? b = b.map(pa.camelCase) : (b = pa.camelCase(b), b = b in d ? [b] : b.match(Fa) || []), c = b.length;
                            for (; c--;) delete d[b[c]]
                        }(void 0 === b || pa.isEmptyObject(d)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando])
                    }
                },
                hasData: function(a) {
                    var b = a[this.expando];
                    return void 0 !== b && !pa.isEmptyObject(b)
                }
            };
            var Ka = new m,
                La = new m,
                Ma = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                Na = /[A-Z]/g;
            pa.extend({
                hasData: function(a) {
                    return La.hasData(a) || Ka.hasData(a)
                },
                data: function(a, b, c) {
                    return La.access(a, b, c)
                },
                removeData: function(a, b) {
                    La.remove(a, b)
                },
                _data: function(a, b, c) {
                    return Ka.access(a, b, c)
                },
                _removeData: function(a, b) {
                    Ka.remove(a, b)
                }
            }), pa.fn.extend({
                data: function(a, b) {
                    var c, d, e, f = this[0],
                        g = f && f.attributes;
                    if (void 0 === a) {
                        if (this.length && (e = La.get(f), 1 === f.nodeType && !Ka.get(f, "hasDataAttrs"))) {
                            for (c = g.length; c--;) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = pa.camelCase(d.slice(5)), o(f, d, e[d])));
                            Ka.set(f, "hasDataAttrs", !0)
                        }
                        return e
                    }
                    return "object" == typeof a ? this.each(function() {
                        La.set(this, a)
                    }) : Ia(this, function(b) {
                        var c;
                        if (f && void 0 === b) {
                            if (c = La.get(f, a), void 0 !== c) return c;
                            if (c = o(f, a), void 0 !== c) return c
                        } else this.each(function() {
                            La.set(this, a, b)
                        })
                    }, null, b, arguments.length > 1, null, !0)
                },
                removeData: function(a) {
                    return this.each(function() {
                        La.remove(this, a)
                    })
                }
            }), pa.extend({
                queue: function(a, b, c) {
                    var d;
                    if (a) return b = (b || "fx") + "queue", d = Ka.get(a, b), c && (!d || Array.isArray(c) ? d = Ka.access(a, b, pa.makeArray(c)) : d.push(c)), d || []
                },
                dequeue: function(a, b) {
                    b = b || "fx";
                    var c = pa.queue(a, b),
                        d = c.length,
                        e = c.shift(),
                        f = pa._queueHooks(a, b),
                        g = function() {
                            pa.dequeue(a, b)
                        };
                    "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
                },
                _queueHooks: function(a, b) {
                    var c = b + "queueHooks";
                    return Ka.get(a, c) || Ka.access(a, c, {
                        empty: pa.Callbacks("once memory").add(function() {
                            Ka.remove(a, [b + "queue", c])
                        })
                    })
                }
            }), pa.fn.extend({
                queue: function(a, b) {
                    var c = 2;
                    return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? pa.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                        var c = pa.queue(this, a, b);
                        pa._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && pa.dequeue(this, a)
                    })
                },
                dequeue: function(a) {
                    return this.each(function() {
                        pa.dequeue(this, a)
                    })
                },
                clearQueue: function(a) {
                    return this.queue(a || "fx", [])
                },
                promise: function(a, b) {
                    var c, d = 1,
                        e = pa.Deferred(),
                        f = this,
                        g = this.length,
                        h = function() {
                            --d || e.resolveWith(f, [f])
                        };
                    for ("string" != typeof a && (b = a, a = void 0), a = a || "fx"; g--;) c = Ka.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
                    return h(), e.promise(b)
                }
            });
            var Oa = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                Pa = new RegExp("^(?:([+-])=|)(" + Oa + ")([a-z%]*)$", "i"),
                Qa = ["Top", "Right", "Bottom", "Left"],
                Ra = function(a, b) {
                    return a = b || a, "none" === a.style.display || "" === a.style.display && pa.contains(a.ownerDocument, a) && "none" === pa.css(a, "display")
                },
                Sa = function(a, b, c, d) {
                    var e, f, g = {};
                    for (f in b) g[f] = a.style[f], a.style[f] = b[f];
                    e = c.apply(a, d || []);
                    for (f in b) a.style[f] = g[f];
                    return e
                },
                Ta = {};
            pa.fn.extend({
                show: function() {
                    return r(this, !0)
                },
                hide: function() {
                    return r(this)
                },
                toggle: function(a) {
                    return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                        Ra(this) ? pa(this).show() : pa(this).hide()
                    })
                }
            });
            var Ua = /^(?:checkbox|radio)$/i,
                Va = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
                Wa = /^$|\/(?:java|ecma)script/i,
                Xa = {
                    option: [1, "<select multiple='multiple'>", "</select>"],
                    thead: [1, "<table>", "</table>"],
                    col: [2, "<table><colgroup>", "</colgroup></table>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                    _default: [0, "", ""]
                };
            Xa.optgroup = Xa.option, Xa.tbody = Xa.tfoot = Xa.colgroup = Xa.caption = Xa.thead, Xa.th = Xa.td;
            var Ya = /<|&#?\w+;/;
            ! function() {
                var a = ca.createDocumentFragment(),
                    b = a.appendChild(ca.createElement("div")),
                    c = ca.createElement("input");
                c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), na.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", na.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue
            }();
            var Za = ca.documentElement,
                $a = /^key/,
                _a = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                ab = /^([^.]*)(?:\.(.+)|)/;
            pa.event = {
                global: {},
                add: function(a, b, c, d, e) {
                    var f, g, h, i, j, k, l, m, n, o, p, q = Ka.get(a);
                    if (q)
                        for (c.handler && (f = c, c = f.handler, e = f.selector), e && pa.find.matchesSelector(Za, e), c.guid || (c.guid = pa.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function(b) {
                                return "undefined" != typeof pa && pa.event.triggered !== b.type ? pa.event.dispatch.apply(a, arguments) : void 0
                            }), b = (b || "").match(Fa) || [""], j = b.length; j--;) h = ab.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n && (l = pa.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = pa.event.special[n] || {}, k = pa.extend({
                            type: n,
                            origType: p,
                            data: d,
                            handler: c,
                            guid: c.guid,
                            selector: e,
                            needsContext: e && pa.expr.match.needsContext.test(e),
                            namespace: o.join(".")
                        }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, o, g) !== !1 || a.addEventListener && a.addEventListener(n, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), pa.event.global[n] = !0)
                },
                remove: function(a, b, c, d, e) {
                    var f, g, h, i, j, k, l, m, n, o, p, q = Ka.hasData(a) && Ka.get(a);
                    if (q && (i = q.events)) {
                        for (b = (b || "").match(Fa) || [""], j = b.length; j--;)
                            if (h = ab.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n) {
                                for (l = pa.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length; f--;) k = m[f], !e && p !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
                                g && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== !1 || pa.removeEvent(a, n, q.handle), delete i[n])
                            } else
                                for (n in i) pa.event.remove(a, n + b[j], c, d, !0);
                        pa.isEmptyObject(i) && Ka.remove(a, "handle events")
                    }
                },
                dispatch: function(a) {
                    var b, c, d, e, f, g, h = pa.event.fix(a),
                        i = new Array(arguments.length),
                        j = (Ka.get(this, "events") || {})[h.type] || [],
                        k = pa.event.special[h.type] || {};
                    for (i[0] = h, b = 1; b < arguments.length; b++) i[b] = arguments[b];
                    if (h.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, h) !== !1) {
                        for (g = pa.event.handlers.call(this, h, j), b = 0;
                            (e = g[b++]) && !h.isPropagationStopped();)
                            for (h.currentTarget = e.elem, c = 0;
                                (f = e.handlers[c++]) && !h.isImmediatePropagationStopped();) h.rnamespace && !h.rnamespace.test(f.namespace) || (h.handleObj = f, h.data = f.data, d = ((pa.event.special[f.origType] || {}).handle || f.handler).apply(e.elem, i), void 0 !== d && (h.result = d) === !1 && (h.preventDefault(), h.stopPropagation()));
                        return k.postDispatch && k.postDispatch.call(this, h), h.result
                    }
                },
                handlers: function(a, b) {
                    var c, d, e, f, g, h = [],
                        i = b.delegateCount,
                        j = a.target;
                    if (i && j.nodeType && !("click" === a.type && a.button >= 1))
                        for (; j !== this; j = j.parentNode || this)
                            if (1 === j.nodeType && ("click" !== a.type || j.disabled !== !0)) {
                                for (f = [], g = {}, c = 0; c < i; c++) d = b[c], e = d.selector + " ", void 0 === g[e] && (g[e] = d.needsContext ? pa(e, this).index(j) > -1 : pa.find(e, this, null, [j]).length), g[e] && f.push(d);
                                f.length && h.push({
                                    elem: j,
                                    handlers: f
                                })
                            }
                    return j = this, i < b.length && h.push({
                        elem: j,
                        handlers: b.slice(i)
                    }), h
                },
                addProp: function(a, b) {
                    Object.defineProperty(pa.Event.prototype, a, {
                        enumerable: !0,
                        configurable: !0,
                        get: pa.isFunction(b) ? function() {
                            if (this.originalEvent) return b(this.originalEvent)
                        } : function() {
                            if (this.originalEvent) return this.originalEvent[a]
                        },
                        set: function(b) {
                            Object.defineProperty(this, a, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: b
                            })
                        }
                    })
                },
                fix: function(a) {
                    return a[pa.expando] ? a : new pa.Event(a)
                },
                special: {
                    load: {
                        noBubble: !0
                    },
                    focus: {
                        trigger: function() {
                            if (this !== x() && this.focus) return this.focus(), !1
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if (this === x() && this.blur) return this.blur(), !1
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        trigger: function() {
                            if (Ua.test(this.type) && this.click && e(this, "input")) return this.click(), !1
                        },
                        _default: function(a) {
                            return e(a.target, "a")
                        }
                    },
                    beforeunload: {
                        postDispatch: function(a) {
                            void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
                        }
                    }
                }
            }, pa.removeEvent = function(a, b, c) {
                a.removeEventListener && a.removeEventListener(b, c)
            }, pa.Event = function(a, b) {
                return this instanceof pa.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? v : w, this.target = a.target && 3 === a.target.nodeType ? a.target.parentNode : a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget) : this.type = a, b && pa.extend(this, b), this.timeStamp = a && a.timeStamp || pa.now(), void(this[pa.expando] = !0)) : new pa.Event(a, b)
            }, pa.Event.prototype = {
                constructor: pa.Event,
                isDefaultPrevented: w,
                isPropagationStopped: w,
                isImmediatePropagationStopped: w,
                isSimulated: !1,
                preventDefault: function() {
                    var a = this.originalEvent;
                    this.isDefaultPrevented = v, a && !this.isSimulated && a.preventDefault()
                },
                stopPropagation: function() {
                    var a = this.originalEvent;
                    this.isPropagationStopped = v, a && !this.isSimulated && a.stopPropagation()
                },
                stopImmediatePropagation: function() {
                    var a = this.originalEvent;
                    this.isImmediatePropagationStopped = v, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation()
                }
            }, pa.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: function(a) {
                    var b = a.button;
                    return null == a.which && $a.test(a.type) ? null != a.charCode ? a.charCode : a.keyCode : !a.which && void 0 !== b && _a.test(a.type) ? 1 & b ? 1 : 2 & b ? 3 : 4 & b ? 2 : 0 : a.which
                }
            }, pa.event.addProp), pa.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(a, b) {
                pa.event.special[a] = {
                    delegateType: b,
                    bindType: b,
                    handle: function(a) {
                        var c, d = this,
                            e = a.relatedTarget,
                            f = a.handleObj;
                        return e && (e === d || pa.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
                    }
                }
            }), pa.fn.extend({
                on: function(a, b, c, d) {
                    return y(this, a, b, c, d)
                },
                one: function(a, b, c, d) {
                    return y(this, a, b, c, d, 1)
                },
                off: function(a, b, c) {
                    var d, e;
                    if (a && a.preventDefault && a.handleObj) return d = a.handleObj, pa(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
                    if ("object" == typeof a) {
                        for (e in a) this.off(e, b, a[e]);
                        return this
                    }
                    return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = w), this.each(function() {
                        pa.event.remove(this, a, c, b)
                    })
                }
            });
            var bb = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
                cb = /<script|<style|<link/i,
                db = /checked\s*(?:[^=]|=\s*.checked.)/i,
                eb = /^true\/(.*)/,
                fb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            pa.extend({
                htmlPrefilter: function(a) {
                    return a.replace(bb, "<$1></$2>")
                },
                clone: function(a, b, c) {
                    var d, e, f, g, h = a.cloneNode(!0),
                        i = pa.contains(a.ownerDocument, a);
                    if (!(na.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || pa.isXMLDoc(a)))
                        for (g = s(h), f = s(a), d = 0, e = f.length; d < e; d++) D(f[d], g[d]);
                    if (b)
                        if (c)
                            for (f = f || s(a), g = g || s(h), d = 0, e = f.length; d < e; d++) C(f[d], g[d]);
                        else C(a, h);
                    return g = s(h, "script"), g.length > 0 && t(g, !i && s(a, "script")), h
                },
                cleanData: function(a) {
                    for (var b, c, d, e = pa.event.special, f = 0; void 0 !== (c = a[f]); f++)
                        if (Ja(c)) {
                            if (b = c[Ka.expando]) {
                                if (b.events)
                                    for (d in b.events) e[d] ? pa.event.remove(c, d) : pa.removeEvent(c, d, b.handle);
                                c[Ka.expando] = void 0
                            }
                            c[La.expando] && (c[La.expando] = void 0)
                        }
                }
            }), pa.fn.extend({
                detach: function(a) {
                    return F(this, a, !0)
                },
                remove: function(a) {
                    return F(this, a)
                },
                text: function(a) {
                    return Ia(this, function(a) {
                        return void 0 === a ? pa.text(this) : this.empty().each(function() {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a)
                        })
                    }, null, a, arguments.length)
                },
                append: function() {
                    return E(this, arguments, function(a) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var b = z(this, a);
                            b.appendChild(a)
                        }
                    })
                },
                prepend: function() {
                    return E(this, arguments, function(a) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var b = z(this, a);
                            b.insertBefore(a, b.firstChild)
                        }
                    })
                },
                before: function() {
                    return E(this, arguments, function(a) {
                        this.parentNode && this.parentNode.insertBefore(a, this)
                    })
                },
                after: function() {
                    return E(this, arguments, function(a) {
                        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
                    })
                },
                empty: function() {
                    for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (pa.cleanData(s(a, !1)), a.textContent = "");
                    return this
                },
                clone: function(a, b) {
                    return a = null != a && a, b = null == b ? a : b, this.map(function() {
                        return pa.clone(this, a, b)
                    })
                },
                html: function(a) {
                    return Ia(this, function(a) {
                        var b = this[0] || {},
                            c = 0,
                            d = this.length;
                        if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
                        if ("string" == typeof a && !cb.test(a) && !Xa[(Va.exec(a) || ["", ""])[1].toLowerCase()]) {
                            a = pa.htmlPrefilter(a);
                            try {
                                for (; c < d; c++) b = this[c] || {}, 1 === b.nodeType && (pa.cleanData(s(b, !1)), b.innerHTML = a);
                                b = 0
                            } catch (a) {}
                        }
                        b && this.empty().append(a)
                    }, null, a, arguments.length)
                },
                replaceWith: function() {
                    var a = [];
                    return E(this, arguments, function(b) {
                        var c = this.parentNode;
                        pa.inArray(this, a) < 0 && (pa.cleanData(s(this)), c && c.replaceChild(b, this))
                    }, a)
                }
            }), pa.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(a, b) {
                pa.fn[a] = function(a) {
                    for (var c, d = [], e = pa(a), f = e.length - 1, g = 0; g <= f; g++) c = g === f ? this : this.clone(!0), pa(e[g])[b](c), ga.apply(d, c.get());
                    return this.pushStack(d)
                }
            });
            var gb = /^margin/,
                hb = new RegExp("^(" + Oa + ")(?!px)[a-z%]+$", "i"),
                ib = function(b) {
                    var c = b.ownerDocument.defaultView;
                    return c && c.opener || (c = a), c.getComputedStyle(b)
                };
            ! function() {
                function b() {
                    if (h) {
                        h.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", h.innerHTML = "", Za.appendChild(g);
                        var b = a.getComputedStyle(h);
                        c = "1%" !== b.top, f = "2px" === b.marginLeft, d = "4px" === b.width, h.style.marginRight = "50%", e = "4px" === b.marginRight, Za.removeChild(g), h = null
                    }
                }
                var c, d, e, f, g = ca.createElement("div"),
                    h = ca.createElement("div");
                h.style && (h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", na.clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", g.appendChild(h), pa.extend(na, {
                    pixelPosition: function() {
                        return b(), c
                    },
                    boxSizingReliable: function() {
                        return b(), d
                    },
                    pixelMarginRight: function() {
                        return b(), e
                    },
                    reliableMarginLeft: function() {
                        return b(), f
                    }
                }))
            }();
            var jb = /^(none|table(?!-c[ea]).+)/,
                kb = /^--/,
                lb = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                mb = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },
                nb = ["Webkit", "Moz", "ms"],
                ob = ca.createElement("div").style;
            pa.extend({
                cssHooks: {
                    opacity: {
                        get: function(a, b) {
                            if (b) {
                                var c = G(a, "opacity");
                                return "" === c ? "1" : c
                            }
                        }
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                cssProps: {
                    float: "cssFloat"
                },
                style: function(a, b, c, d) {
                    if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                        var e, f, g, h = pa.camelCase(b),
                            i = kb.test(b),
                            j = a.style;
                        return i || (b = J(h)), g = pa.cssHooks[b] || pa.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : j[b] : (f = typeof c, "string" === f && (e = Pa.exec(c)) && e[1] && (c = p(a, b, e), f = "number"), void(null != c && c === c && ("number" === f && (c += e && e[3] || (pa.cssNumber[h] ? "" : "px")),
                            na.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (j[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i ? j.setProperty(b, c) : j[b] = c))))
                    }
                },
                css: function(a, b, c, d) {
                    var e, f, g, h = pa.camelCase(b),
                        i = kb.test(b);
                    return i || (b = J(h)), g = pa.cssHooks[b] || pa.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = G(a, b, d)), "normal" === e && b in mb && (e = mb[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e
                }
            }), pa.each(["height", "width"], function(a, b) {
                pa.cssHooks[b] = {
                    get: function(a, c, d) {
                        if (c) return !jb.test(pa.css(a, "display")) || a.getClientRects().length && a.getBoundingClientRect().width ? M(a, b, d) : Sa(a, lb, function() {
                            return M(a, b, d)
                        })
                    },
                    set: function(a, c, d) {
                        var e, f = d && ib(a),
                            g = d && L(a, b, d, "border-box" === pa.css(a, "boxSizing", !1, f), f);
                        return g && (e = Pa.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = pa.css(a, b)), K(a, c, g)
                    }
                }
            }), pa.cssHooks.marginLeft = H(na.reliableMarginLeft, function(a, b) {
                if (b) return (parseFloat(G(a, "marginLeft")) || a.getBoundingClientRect().left - Sa(a, {
                    marginLeft: 0
                }, function() {
                    return a.getBoundingClientRect().left
                })) + "px"
            }), pa.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(a, b) {
                pa.cssHooks[a + b] = {
                    expand: function(c) {
                        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; d < 4; d++) e[a + Qa[d] + b] = f[d] || f[d - 2] || f[0];
                        return e
                    }
                }, gb.test(a) || (pa.cssHooks[a + b].set = K)
            }), pa.fn.extend({
                css: function(a, b) {
                    return Ia(this, function(a, b, c) {
                        var d, e, f = {},
                            g = 0;
                        if (Array.isArray(b)) {
                            for (d = ib(a), e = b.length; g < e; g++) f[b[g]] = pa.css(a, b[g], !1, d);
                            return f
                        }
                        return void 0 !== c ? pa.style(a, b, c) : pa.css(a, b)
                    }, a, b, arguments.length > 1)
                }
            }), pa.Neonate = N, N.prototype = {
                constructor: N,
                init: function(a, b, c, d, e, f) {
                    this.elem = a, this.prop = c, this.easing = e || pa.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (pa.cssNumber[c] ? "" : "px")
                },
                cur: function() {
                    var a = N.propHooks[this.prop];
                    return a && a.get ? a.get(this) : N.propHooks._default.get(this)
                },
                run: function(a) {
                    var b, c = N.propHooks[this.prop];
                    return this.options.duration ? this.pos = b = pa.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : N.propHooks._default.set(this), this
                }
            }, N.prototype.init.prototype = N.prototype, N.propHooks = {
                _default: {
                    get: function(a) {
                        var b;
                        return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = pa.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0)
                    },
                    set: function(a) {
                        pa.fx.step[a.prop] ? pa.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[pa.cssProps[a.prop]] && !pa.cssHooks[a.prop] ? a.elem[a.prop] = a.now : pa.style(a.elem, a.prop, a.now + a.unit)
                    }
                }
            }, N.propHooks.scrollTop = N.propHooks.scrollLeft = {
                set: function(a) {
                    a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
                }
            }, pa.easing = {
                linear: function(a) {
                    return a
                },
                swing: function(a) {
                    return .5 - Math.cos(a * Math.PI) / 2
                },
                _default: "swing"
            }, pa.fx = N.prototype.init, pa.fx.step = {};
            var pb, qb, rb = /^(?:toggle|show|hide)$/,
                sb = /queueHooks$/;
            pa.Animation = pa.extend(U, {
                    tweeners: {
                        "*": [function(a, b) {
                            var c = this.createTween(a, b);
                            return p(c.elem, a, Pa.exec(b), c), c
                        }]
                    },
                    tweener: function(a, b) {
                        pa.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(Fa);
                        for (var c, d = 0, e = a.length; d < e; d++) c = a[d], U.tweeners[c] = U.tweeners[c] || [], U.tweeners[c].unshift(b)
                    },
                    prefilters: [S],
                    prefilter: function(a, b) {
                        b ? U.prefilters.unshift(a) : U.prefilters.push(a)
                    }
                }), pa.speed = function(a, b, c) {
                    var d = a && "object" == typeof a ? pa.extend({}, a) : {
                        complete: c || !c && b || pa.isFunction(a) && a,
                        duration: a,
                        easing: c && b || b && !pa.isFunction(b) && b
                    };
                    return pa.fx.off ? d.duration = 0 : "number" != typeof d.duration && (d.duration in pa.fx.speeds ? d.duration = pa.fx.speeds[d.duration] : d.duration = pa.fx.speeds._default), null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function() {
                        pa.isFunction(d.old) && d.old.call(this), d.queue && pa.dequeue(this, d.queue)
                    }, d
                }, pa.fn.extend({
                    fadeTo: function(a, b, c, d) {
                        return this.filter(Ra).css("opacity", 0).show().end().animate({
                            opacity: b
                        }, a, c, d)
                    },
                    animate: function(a, b, c, d) {
                        var e = pa.isEmptyObject(a),
                            f = pa.speed(b, c, d),
                            g = function() {
                                var b = U(this, pa.extend({}, a), f);
                                (e || Ka.get(this, "finish")) && b.stop(!0)
                            };
                        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
                    },
                    stop: function(a, b, c) {
                        var d = function(a) {
                            var b = a.stop;
                            delete a.stop, b(c)
                        };
                        return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
                            var b = !0,
                                e = null != a && a + "queueHooks",
                                f = pa.timers,
                                g = Ka.get(this);
                            if (e) g[e] && g[e].stop && d(g[e]);
                            else
                                for (e in g) g[e] && g[e].stop && sb.test(e) && d(g[e]);
                            for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
                            !b && c || pa.dequeue(this, a)
                        })
                    },
                    finish: function(a) {
                        return a !== !1 && (a = a || "fx"), this.each(function() {
                            var b, c = Ka.get(this),
                                d = c[a + "queue"],
                                e = c[a + "queueHooks"],
                                f = pa.timers,
                                g = d ? d.length : 0;
                            for (c.finish = !0, pa.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
                            for (b = 0; b < g; b++) d[b] && d[b].finish && d[b].finish.call(this);
                            delete c.finish
                        })
                    }
                }), pa.each(["toggle", "show", "hide"], function(a, b) {
                    var c = pa.fn[b];
                    pa.fn[b] = function(a, d, e) {
                        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Q(b, !0), a, d, e)
                    }
                }), pa.each({
                    slideDown: Q("show"),
                    slideUp: Q("hide"),
                    slideToggle: Q("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, function(a, b) {
                    pa.fn[a] = function(a, c, d) {
                        return this.animate(b, a, c, d)
                    }
                }), pa.timers = [], pa.fx.tick = function() {
                    var a, b = 0,
                        c = pa.timers;
                    for (pb = pa.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
                    c.length || pa.fx.stop(), pb = void 0
                }, pa.fx.timer = function(a) {
                    pa.timers.push(a), pa.fx.start()
                }, pa.fx.interval = 13, pa.fx.start = function() {
                    qb || (qb = !0, O())
                }, pa.fx.stop = function() {
                    qb = null
                }, pa.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    _default: 400
                }, pa.fn.delay = function(b, c) {
                    return b = pa.fx ? pa.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function(c, d) {
                        var e = a.setTimeout(c, b);
                        d.stop = function() {
                            a.clearTimeout(e)
                        }
                    })
                },
                function() {
                    var a = ca.createElement("input"),
                        b = ca.createElement("select"),
                        c = b.appendChild(ca.createElement("option"));
                    a.type = "checkbox", na.checkOn = "" !== a.value, na.optSelected = c.selected, a = ca.createElement("input"), a.value = "t", a.type = "radio", na.radioValue = "t" === a.value
                }();
            var tb, ub = pa.expr.attrHandle;
            pa.fn.extend({
                attr: function(a, b) {
                    return Ia(this, pa.attr, a, b, arguments.length > 1)
                },
                removeAttr: function(a) {
                    return this.each(function() {
                        pa.removeAttr(this, a)
                    })
                }
            }), pa.extend({
                attr: function(a, b, c) {
                    var d, e, f = a.nodeType;
                    if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? pa.prop(a, b, c) : (1 === f && pa.isXMLDoc(a) || (e = pa.attrHooks[b.toLowerCase()] || (pa.expr.match.bool.test(b) ? tb : void 0)), void 0 !== c ? null === c ? void pa.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = pa.find.attr(a, b), null == d ? void 0 : d))
                },
                attrHooks: {
                    type: {
                        set: function(a, b) {
                            if (!na.radioValue && "radio" === b && e(a, "input")) {
                                var c = a.value;
                                return a.setAttribute("type", b), c && (a.value = c), b
                            }
                        }
                    }
                },
                removeAttr: function(a, b) {
                    var c, d = 0,
                        e = b && b.match(Fa);
                    if (e && 1 === a.nodeType)
                        for (; c = e[d++];) a.removeAttribute(c)
                }
            }), tb = {
                set: function(a, b, c) {
                    return b === !1 ? pa.removeAttr(a, c) : a.setAttribute(c, c), c
                }
            }, pa.each(pa.expr.match.bool.source.match(/\w+/g), function(a, b) {
                var c = ub[b] || pa.find.attr;
                ub[b] = function(a, b, d) {
                    var e, f, g = b.toLowerCase();
                    return d || (f = ub[g], ub[g] = e, e = null != c(a, b, d) ? g : null, ub[g] = f), e
                }
            });
            var vb = /^(?:input|select|textarea|button)$/i,
                wb = /^(?:a|area)$/i;
            pa.fn.extend({
                prop: function(a, b) {
                    return Ia(this, pa.prop, a, b, arguments.length > 1)
                },
                removeProp: function(a) {
                    return this.each(function() {
                        delete this[pa.propFix[a] || a]
                    })
                }
            }), pa.extend({
                prop: function(a, b, c) {
                    var d, e, f = a.nodeType;
                    if (3 !== f && 8 !== f && 2 !== f) return 1 === f && pa.isXMLDoc(a) || (b = pa.propFix[b] || b, e = pa.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
                },
                propHooks: {
                    tabIndex: {
                        get: function(a) {
                            var b = pa.find.attr(a, "tabindex");
                            return b ? parseInt(b, 10) : vb.test(a.nodeName) || wb.test(a.nodeName) && a.href ? 0 : -1
                        }
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            }), na.optSelected || (pa.propHooks.selected = {
                get: function(a) {
                    var b = a.parentNode;
                    return b && b.parentNode && b.parentNode.selectedIndex, null
                },
                set: function(a) {
                    var b = a.parentNode;
                    b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
                }
            }), pa.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
                pa.propFix[this.toLowerCase()] = this
            }), pa.fn.extend({
                addClass: function(a) {
                    var b, c, d, e, f, g, h, i = 0;
                    if (pa.isFunction(a)) return this.each(function(b) {
                        pa(this).addClass(a.call(this, b, W(this)))
                    });
                    if ("string" == typeof a && a)
                        for (b = a.match(Fa) || []; c = this[i++];)
                            if (e = W(c), d = 1 === c.nodeType && " " + V(e) + " ") {
                                for (g = 0; f = b[g++];) d.indexOf(" " + f + " ") < 0 && (d += f + " ");
                                h = V(d), e !== h && c.setAttribute("class", h)
                            }
                    return this
                },
                removeClass: function(a) {
                    var b, c, d, e, f, g, h, i = 0;
                    if (pa.isFunction(a)) return this.each(function(b) {
                        pa(this).removeClass(a.call(this, b, W(this)))
                    });
                    if (!arguments.length) return this.attr("class", "");
                    if ("string" == typeof a && a)
                        for (b = a.match(Fa) || []; c = this[i++];)
                            if (e = W(c), d = 1 === c.nodeType && " " + V(e) + " ") {
                                for (g = 0; f = b[g++];)
                                    for (; d.indexOf(" " + f + " ") > -1;) d = d.replace(" " + f + " ", " ");
                                h = V(d), e !== h && c.setAttribute("class", h)
                            }
                    return this
                },
                toggleClass: function(a, b) {
                    var c = typeof a;
                    return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : pa.isFunction(a) ? this.each(function(c) {
                        pa(this).toggleClass(a.call(this, c, W(this), b), b)
                    }) : this.each(function() {
                        var b, d, e, f;
                        if ("string" === c)
                            for (d = 0, e = pa(this), f = a.match(Fa) || []; b = f[d++];) e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
                        else void 0 !== a && "boolean" !== c || (b = W(this), b && Ka.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : Ka.get(this, "__className__") || ""))
                    })
                },
                hasClass: function(a) {
                    var b, c, d = 0;
                    for (b = " " + a + " "; c = this[d++];)
                        if (1 === c.nodeType && (" " + V(W(c)) + " ").indexOf(b) > -1) return !0;
                    return !1
                }
            });
            var xb = /\r/g;
            pa.fn.extend({
                val: function(a) {
                    var b, c, d, e = this[0];
                    return arguments.length ? (d = pa.isFunction(a), this.each(function(c) {
                        var e;
                        1 === this.nodeType && (e = d ? a.call(this, c, pa(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : Array.isArray(e) && (e = pa.map(e, function(a) {
                            return null == a ? "" : a + ""
                        })), b = pa.valHooks[this.type] || pa.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
                    })) : e ? (b = pa.valHooks[e.type] || pa.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(xb, "") : null == c ? "" : c)) : void 0
                }
            }), pa.extend({
                valHooks: {
                    option: {
                        get: function(a) {
                            var b = pa.find.attr(a, "value");
                            return null != b ? b : V(pa.text(a))
                        }
                    },
                    select: {
                        get: function(a) {
                            var b, c, d, f = a.options,
                                g = a.selectedIndex,
                                h = "select-one" === a.type,
                                i = h ? null : [],
                                j = h ? g + 1 : f.length;
                            for (d = g < 0 ? j : h ? g : 0; d < j; d++)
                                if (c = f[d], (c.selected || d === g) && !c.disabled && (!c.parentNode.disabled || !e(c.parentNode, "optgroup"))) {
                                    if (b = pa(c).val(), h) return b;
                                    i.push(b)
                                }
                            return i
                        },
                        set: function(a, b) {
                            for (var c, d, e = a.options, f = pa.makeArray(b), g = e.length; g--;) d = e[g], (d.selected = pa.inArray(pa.valHooks.option.get(d), f) > -1) && (c = !0);
                            return c || (a.selectedIndex = -1), f
                        }
                    }
                }
            }), pa.each(["radio", "checkbox"], function() {
                pa.valHooks[this] = {
                    set: function(a, b) {
                        if (Array.isArray(b)) return a.checked = pa.inArray(pa(a).val(), b) > -1
                    }
                }, na.checkOn || (pa.valHooks[this].get = function(a) {
                    return null === a.getAttribute("value") ? "on" : a.value
                })
            });
            var yb = /^(?:focusinfocus|focusoutblur)$/;
            pa.extend(pa.event, {
                trigger: function(b, c, d, e) {
                    var f, g, h, i, j, k, l, m = [d || ca],
                        n = ka.call(b, "type") ? b.type : b,
                        o = ka.call(b, "namespace") ? b.namespace.split(".") : [];
                    if (g = h = d = d || ca, 3 !== d.nodeType && 8 !== d.nodeType && !yb.test(n + pa.event.triggered) && (n.indexOf(".") > -1 && (o = n.split("."), n = o.shift(), o.sort()), j = n.indexOf(":") < 0 && "on" + n, b = b[pa.expando] ? b : new pa.Event(n, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = o.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : pa.makeArray(c, [b]), l = pa.event.special[n] || {}, e || !l.trigger || l.trigger.apply(d, c) !== !1)) {
                        if (!e && !l.noBubble && !pa.isWindow(d)) {
                            for (i = l.delegateType || n, yb.test(i + n) || (g = g.parentNode); g; g = g.parentNode) m.push(g), h = g;
                            h === (d.ownerDocument || ca) && m.push(h.defaultView || h.parentWindow || a)
                        }
                        for (f = 0;
                            (g = m[f++]) && !b.isPropagationStopped();) b.type = f > 1 ? i : l.bindType || n, k = (Ka.get(g, "events") || {})[b.type] && Ka.get(g, "handle"), k && k.apply(g, c), k = j && g[j], k && k.apply && Ja(g) && (b.result = k.apply(g, c), b.result === !1 && b.preventDefault());
                        return b.type = n, e || b.isDefaultPrevented() || l._default && l._default.apply(m.pop(), c) !== !1 || !Ja(d) || j && pa.isFunction(d[n]) && !pa.isWindow(d) && (h = d[j], h && (d[j] = null), pa.event.triggered = n, d[n](), pa.event.triggered = void 0, h && (d[j] = h)), b.result
                    }
                },
                simulate: function(a, b, c) {
                    var d = pa.extend(new pa.Event, c, {
                        type: a,
                        isSimulated: !0
                    });
                    pa.event.trigger(d, null, b)
                }
            }), pa.fn.extend({
                trigger: function(a, b) {
                    return this.each(function() {
                        pa.event.trigger(a, b, this)
                    })
                },
                triggerHandler: function(a, b) {
                    var c = this[0];
                    if (c) return pa.event.trigger(a, b, c, !0)
                }
            }), pa.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(a, b) {
                pa.fn[b] = function(a, c) {
                    return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
                }
            }), pa.fn.extend({
                hover: function(a, b) {
                    return this.mouseenter(a).mouseleave(b || a)
                }
            }), na.focusin = "onfocusin" in a, na.focusin || pa.each({
                focus: "focusin",
                blur: "focusout"
            }, function(a, b) {
                var c = function(a) {
                    pa.event.simulate(b, a.target, pa.event.fix(a))
                };
                pa.event.special[b] = {
                    setup: function() {
                        var d = this.ownerDocument || this,
                            e = Ka.access(d, b);
                        e || d.addEventListener(a, c, !0), Ka.access(d, b, (e || 0) + 1)
                    },
                    teardown: function() {
                        var d = this.ownerDocument || this,
                            e = Ka.access(d, b) - 1;
                        e ? Ka.access(d, b, e) : (d.removeEventListener(a, c, !0), Ka.remove(d, b))
                    }
                }
            });
            var zb = a.location,
                Ab = pa.now(),
                Bb = /\?/;
            pa.parseXML = function(b) {
                var c;
                if (!b || "string" != typeof b) return null;
                try {
                    c = (new a.DOMParser).parseFromString(b, "text/xml")
                } catch (a) {
                    c = void 0
                }
                return c && !c.getElementsByTagName("parsererror").length || pa.error("Invalid XML: " + b), c
            };
            var Cb = /\[\]$/,
                Db = /\r?\n/g,
                Eb = /^(?:submit|button|image|reset|file)$/i,
                Fb = /^(?:input|select|textarea|keygen)/i;
            pa.param = function(a, b) {
                var c, d = [],
                    e = function(a, b) {
                        var c = pa.isFunction(b) ? b() : b;
                        d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(null == c ? "" : c)
                    };
                if (Array.isArray(a) || a.jquery && !pa.isPlainObject(a)) pa.each(a, function() {
                    e(this.name, this.value)
                });
                else
                    for (c in a) X(c, a[c], b, e);
                return d.join("&")
            }, pa.fn.extend({
                serialize: function() {
                    return pa.param(this.serializeArray())
                },
                serializeArray: function() {
                    return this.map(function() {
                        var a = pa.prop(this, "elements");
                        return a ? pa.makeArray(a) : this
                    }).filter(function() {
                        var a = this.type;
                        return this.name && !pa(this).is(":disabled") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !Ua.test(a))
                    }).map(function(a, b) {
                        var c = pa(this).val();
                        return null == c ? null : Array.isArray(c) ? pa.map(c, function(a) {
                            return {
                                name: b.name,
                                value: a.replace(Db, "\r\n")
                            }
                        }) : {
                            name: b.name,
                            value: c.replace(Db, "\r\n")
                        }
                    }).get()
                }
            });
            var Gb = /%20/g,
                Hb = /#.*$/,
                Ib = /([?&])_=[^&]*/,
                Jb = /^(.*?):[ \t]*([^\r\n]*)$/gm,
                Kb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                Lb = /^(?:GET|HEAD)$/,
                Mb = /^\/\//,
                Nb = {},
                Ob = {},
                Pb = "*/".concat("*"),
                Qb = ca.createElement("a");
            Qb.href = zb.href, pa.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: zb.href,
                    type: "GET",
                    isLocal: Kb.test(zb.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": Pb,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": !0,
                        "text json": JSON.parse,
                        "text xml": pa.parseXML
                    },
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                ajaxSetup: function(a, b) {
                    return b ? $($(a, pa.ajaxSettings), b) : $(pa.ajaxSettings, a)
                },
                ajaxPrefilter: Y(Nb),
                ajaxTransport: Y(Ob),
                ajax: function(b, c) {
                    function d(b, c, d, h) {
                        var j, m, n, u, v, w = c;
                        k || (k = !0, i && a.clearTimeout(i), e = void 0, g = h || "", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && b < 300 || 304 === b, d && (u = _(o, x, d)), u = aa(o, u, x, j), j ? (o.ifModified && (v = x.getResponseHeader("Last-Modified"), v && (pa.lastModified[f] = v), v = x.getResponseHeader("etag"), v && (pa.etag[f] = v)), 204 === b || "HEAD" === o.type ? w = "nocontent" : 304 === b ? w = "notmodified" : (w = u.state, m = u.data, n = u.error, j = !n)) : (n = w, !b && w || (w = "error", b < 0 && (b = 0))), x.status = b, x.statusText = (c || w) + "", j ? r.resolveWith(p, [m, w, x]) : r.rejectWith(p, [x, w, n]), x.statusCode(t), t = void 0, l && q.trigger(j ? "ajaxSuccess" : "ajaxError", [x, o, j ? m : n]), s.fireWith(p, [x, w]), l && (q.trigger("ajaxComplete", [x, o]), --pa.active || pa.event.trigger("ajaxStop")))
                    }
                    "object" == typeof b && (c = b, b = void 0), c = c || {};
                    var e, f, g, h, i, j, k, l, m, n, o = pa.ajaxSetup({}, c),
                        p = o.context || o,
                        q = o.context && (p.nodeType || p.jquery) ? pa(p) : pa.event,
                        r = pa.Deferred(),
                        s = pa.Callbacks("once memory"),
                        t = o.statusCode || {},
                        u = {},
                        v = {},
                        w = "canceled",
                        x = {
                            readyState: 0,
                            getResponseHeader: function(a) {
                                var b;
                                if (k) {
                                    if (!h)
                                        for (h = {}; b = Jb.exec(g);) h[b[1].toLowerCase()] = b[2];
                                    b = h[a.toLowerCase()]
                                }
                                return null == b ? null : b
                            },
                            getAllResponseHeaders: function() {
                                return k ? g : null
                            },
                            setRequestHeader: function(a, b) {
                                return null == k && (a = v[a.toLowerCase()] = v[a.toLowerCase()] || a, u[a] = b), this
                            },
                            overrideMimeType: function(a) {
                                return null == k && (o.mimeType = a), this
                            },
                            statusCode: function(a) {
                                var b;
                                if (a)
                                    if (k) x.always(a[x.status]);
                                    else
                                        for (b in a) t[b] = [t[b], a[b]];
                                return this
                            },
                            abort: function(a) {
                                var b = a || w;
                                return e && e.abort(b), d(0, b), this
                            }
                        };
                    if (r.promise(x), o.url = ((b || o.url || zb.href) + "").replace(Mb, zb.protocol + "//"), o.type = c.method || c.type || o.method || o.type, o.dataTypes = (o.dataType || "*").toLowerCase().match(Fa) || [""], null == o.crossDomain) {
                        j = ca.createElement("a");
                        try {
                            j.href = o.url, j.href = j.href, o.crossDomain = Qb.protocol + "//" + Qb.host != j.protocol + "//" + j.host
                        } catch (a) {
                            o.crossDomain = !0
                        }
                    }
                    if (o.data && o.processData && "string" != typeof o.data && (o.data = pa.param(o.data, o.traditional)), Z(Nb, o, c, x), k) return x;
                    l = pa.event && o.global, l && 0 === pa.active++ && pa.event.trigger("ajaxStart"), o.type = o.type.toUpperCase(), o.hasContent = !Lb.test(o.type), f = o.url.replace(Hb, ""), o.hasContent ? o.data && o.processData && 0 === (o.contentType || "").indexOf("application/x-www-form-urlencoded") && (o.data = o.data.replace(Gb, "+")) : (n = o.url.slice(f.length), o.data && (f += (Bb.test(f) ? "&" : "?") + o.data, delete o.data), o.cache === !1 && (f = f.replace(Ib, "$1"), n = (Bb.test(f) ? "&" : "?") + "_=" + Ab++ + n), o.url = f + n), o.ifModified && (pa.lastModified[f] && x.setRequestHeader("If-Modified-Since", pa.lastModified[f]), pa.etag[f] && x.setRequestHeader("If-None-Match", pa.etag[f])), (o.data && o.hasContent && o.contentType !== !1 || c.contentType) && x.setRequestHeader("Content-Type", o.contentType), x.setRequestHeader("Accept", o.dataTypes[0] && o.accepts[o.dataTypes[0]] ? o.accepts[o.dataTypes[0]] + ("*" !== o.dataTypes[0] ? ", " + Pb + "; q=0.01" : "") : o.accepts["*"]);
                    for (m in o.headers) x.setRequestHeader(m, o.headers[m]);
                    if (o.beforeSend && (o.beforeSend.call(p, x, o) === !1 || k)) return x.abort();
                    if (w = "abort", s.add(o.complete), x.done(o.success), x.fail(o.error), e = Z(Ob, o, c, x)) {
                        if (x.readyState = 1, l && q.trigger("ajaxSend", [x, o]), k) return x;
                        o.async && o.timeout > 0 && (i = a.setTimeout(function() {
                            x.abort("timeout")
                        }, o.timeout));
                        try {
                            k = !1, e.send(u, d)
                        } catch (a) {
                            if (k) throw a;
                            d(-1, a)
                        }
                    } else d(-1, "No Transport");
                    return x
                },
                getJSON: function(a, b, c) {
                    return pa.get(a, b, c, "json")
                },
                getScript: function(a, b) {
                    return pa.get(a, void 0, b, "script")
                }
            }), pa.each(["get", "post"], function(a, b) {
                pa[b] = function(a, c, d, e) {
                    return pa.isFunction(c) && (e = e || d, d = c, c = void 0), pa.ajax(pa.extend({
                        url: a,
                        type: b,
                        dataType: e,
                        data: c,
                        success: d
                    }, pa.isPlainObject(a) && a))
                }
            }), pa._evalUrl = function(a) {
                return pa.ajax({
                    url: a,
                    type: "GET",
                    dataType: "script",
                    cache: !0,
                    async: !1,
                    global: !1,
                    throws: !0
                })
            }, pa.fn.extend({
                wrapAll: function(a) {
                    var b;
                    return this[0] && (pa.isFunction(a) && (a = a.call(this[0])), b = pa(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                        for (var a = this; a.firstElementChild;) a = a.firstElementChild;
                        return a
                    }).append(this)), this
                },
                wrapInner: function(a) {
                    return pa.isFunction(a) ? this.each(function(b) {
                        pa(this).wrapInner(a.call(this, b))
                    }) : this.each(function() {
                        var b = pa(this),
                            c = b.contents();
                        c.length ? c.wrapAll(a) : b.append(a)
                    })
                },
                wrap: function(a) {
                    var b = pa.isFunction(a);
                    return this.each(function(c) {
                        pa(this).wrapAll(b ? a.call(this, c) : a)
                    })
                },
                unwrap: function(a) {
                    return this.parent(a).not("body").each(function() {
                        pa(this).replaceWith(this.childNodes)
                    }), this
                }
            }), pa.expr.pseudos.hidden = function(a) {
                return !pa.expr.pseudos.visible(a)
            }, pa.expr.pseudos.visible = function(a) {
                return !!(a.offsetWidth || a.offsetHeight || a.getClientRects().length)
            }, pa.ajaxSettings.xhr = function() {
                try {
                    return new a.XMLHttpRequest
                } catch (a) {}
            };
            var Rb = {
                    0: 200,
                    1223: 204
                },
                Sb = pa.ajaxSettings.xhr();
            na.cors = !!Sb && "withCredentials" in Sb, na.ajax = Sb = !!Sb, pa.ajaxTransport(function(b) {
                var c, d;
                if (na.cors || Sb && !b.crossDomain) return {
                    send: function(e, f) {
                        var g, h = b.xhr();
                        if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
                            for (g in b.xhrFields) h[g] = b.xhrFields[g];
                        b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");
                        for (g in e) h.setRequestHeader(g, e[g]);
                        c = function(a) {
                            return function() {
                                c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Rb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {
                                    binary: h.response
                                } : {
                                    text: h.responseText
                                }, h.getAllResponseHeaders()))
                            }
                        }, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function() {
                            4 === h.readyState && a.setTimeout(function() {
                                c && d()
                            })
                        }, c = c("abort");
                        try {
                            h.send(b.hasContent && b.data || null)
                        } catch (a) {
                            if (c) throw a
                        }
                    },
                    abort: function() {
                        c && c()
                    }
                }
            }), pa.ajaxPrefilter(function(a) {
                a.crossDomain && (a.contents.script = !1)
            }), pa.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(a) {
                        return pa.globalEval(a), a
                    }
                }
            }), pa.ajaxPrefilter("script", function(a) {
                void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
            }), pa.ajaxTransport("script", function(a) {
                if (a.crossDomain) {
                    var b, c;
                    return {
                        send: function(d, e) {
                            b = pa("<script>").prop({
                                charset: a.scriptCharset,
                                src: a.url
                            }).on("load error", c = function(a) {
                                b.remove(), c = null, a && e("error" === a.type ? 404 : 200, a.type)
                            }), ca.head.appendChild(b[0])
                        },
                        abort: function() {
                            c && c()
                        }
                    }
                }
            });
            var Tb = [],
                Ub = /(=)\?(?=&|$)|\?\?/;
            pa.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var a = Tb.pop() || pa.expando + "_" + Ab++;
                    return this[a] = !0, a
                }
            }), pa.ajaxPrefilter("json jsonp", function(b, c, d) {
                var e, f, g, h = b.jsonp !== !1 && (Ub.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Ub.test(b.data) && "data");
                if (h || "jsonp" === b.dataTypes[0]) return e = b.jsonpCallback = pa.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Ub, "$1" + e) : b.jsonp !== !1 && (b.url += (Bb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
                    return g || pa.error(e + " was not called"), g[0]
                }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
                    g = arguments
                }, d.always(function() {
                    void 0 === f ? pa(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Tb.push(e)), g && pa.isFunction(f) && f(g[0]), g = f = void 0
                }), "script"
            }), na.createHTMLDocument = function() {
                var a = ca.implementation.createHTMLDocument("").body;
                return a.innerHTML = "<form></form><form></form>", 2 === a.childNodes.length
            }(), pa.parseHTML = function(a, b, c) {
                if ("string" != typeof a) return [];
                "boolean" == typeof b && (c = b, b = !1);
                var d, e, f;
                return b || (na.createHTMLDocument ? (b = ca.implementation.createHTMLDocument(""), d = b.createElement("base"), d.href = ca.location.href, b.head.appendChild(d)) : b = ca), e = ya.exec(a), f = !c && [], e ? [b.createElement(e[1])] : (e = u([a], b, f), f && f.length && pa(f).remove(), pa.merge([], e.childNodes))
            }, pa.fn.load = function(a, b, c) {
                var d, e, f, g = this,
                    h = a.indexOf(" ");
                return h > -1 && (d = V(a.slice(h)), a = a.slice(0, h)), pa.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && pa.ajax({
                    url: a,
                    type: e || "GET",
                    dataType: "html",
                    data: b
                }).done(function(a) {
                    f = arguments, g.html(d ? pa("<div>").append(pa.parseHTML(a)).find(d) : a)
                }).always(c && function(a, b) {
                    g.each(function() {
                        c.apply(this, f || [a.responseText, b, a])
                    })
                }), this
            }, pa.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
                pa.fn[b] = function(a) {
                    return this.on(b, a)
                }
            }), pa.expr.pseudos.animated = function(a) {
                return pa.grep(pa.timers, function(b) {
                    return a === b.elem
                }).length
            }, pa.offset = {
                setOffset: function(a, b, c) {
                    var d, e, f, g, h, i, j, k = pa.css(a, "position"),
                        l = pa(a),
                        m = {};
                    "static" === k && (a.style.position = "relative"), h = l.offset(), f = pa.css(a, "top"), i = pa.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), pa.isFunction(b) && (b = b.call(a, c, pa.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
                }
            }, pa.fn.extend({
                offset: function(a) {
                    if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                        pa.offset.setOffset(this, a, b)
                    });
                    var b, c, d, e, f = this[0];
                    return f ? f.getClientRects().length ? (d = f.getBoundingClientRect(), b = f.ownerDocument, c = b.documentElement, e = b.defaultView, {
                        top: d.top + e.pageYOffset - c.clientTop,
                        left: d.left + e.pageXOffset - c.clientLeft
                    }) : {
                        top: 0,
                        left: 0
                    } : void 0
                },
                position: function() {
                    if (this[0]) {
                        var a, b, c = this[0],
                            d = {
                                top: 0,
                                left: 0
                            };
                        return "fixed" === pa.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), e(a[0], "html") || (d = a.offset()), d = {
                            top: d.top + pa.css(a[0], "borderTopWidth", !0),
                            left: d.left + pa.css(a[0], "borderLeftWidth", !0)
                        }), {
                            top: b.top - d.top - pa.css(c, "marginTop", !0),
                            left: b.left - d.left - pa.css(c, "marginLeft", !0)
                        }
                    }
                },
                offsetParent: function() {
                    return this.map(function() {
                        for (var a = this.offsetParent; a && "static" === pa.css(a, "position");) a = a.offsetParent;
                        return a || Za
                    })
                }
            }), pa.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(a, b) {
                var c = "pageYOffset" === b;
                pa.fn[a] = function(d) {
                    return Ia(this, function(a, d, e) {
                        var f;
                        return pa.isWindow(a) ? f = a : 9 === a.nodeType && (f = a.defaultView), void 0 === e ? f ? f[b] : a[d] : void(f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e)
                    }, a, d, arguments.length)
                }
            }), pa.each(["top", "left"], function(a, b) {
                pa.cssHooks[b] = H(na.pixelPosition, function(a, c) {
                    if (c) return c = G(a, b), hb.test(c) ? pa(a).position()[b] + "px" : c
                })
            }), pa.each({
                Height: "height",
                Width: "width"
            }, function(a, b) {
                pa.each({
                    padding: "inner" + a,
                    content: b,
                    "": "outer" + a
                }, function(c, d) {
                    pa.fn[d] = function(e, f) {
                        var g = arguments.length && (c || "boolean" != typeof e),
                            h = c || (e === !0 || f === !0 ? "margin" : "border");
                        return Ia(this, function(b, c, e) {
                            var f;
                            return pa.isWindow(b) ? 0 === d.indexOf("outer") ? b["inner" + a] : b.document.documentElement["client" + a] : 9 === b.nodeType ? (f = b.documentElement, Math.max(b.body["scroll" + a], f["scroll" + a], b.body["offset" + a], f["offset" + a], f["client" + a])) : void 0 === e ? pa.css(b, c, h) : pa.style(b, c, e, h)
                        }, b, g ? e : void 0, g)
                    }
                })
            }), pa.fn.extend({
                bind: function(a, b, c) {
                    return this.on(a, null, b, c)
                },
                unbind: function(a, b) {
                    return this.off(a, null, b)
                },
                delegate: function(a, b, c, d) {
                    return this.on(b, a, c, d)
                },
                undelegate: function(a, b, c) {
                    return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
                },
                holdReady: function(a) {
                    a ? pa.readyWait++ : pa.ready(!0)
                }
            }), pa.isArray = Array.isArray, pa.parseJSON = JSON.parse, pa.nodeName = e, "function" == typeof define && define.amd && define("jquery", [], function() {
                return pa
            });
            var Vb = a.jQuery,
                Wb = a.$;
            return pa.noConflict = function(b) {
                return a.$ === pa && (a.$ = Wb), b && a.jQuery === pa && (a.jQuery = Vb), pa
            }, b || (a.jQuery = a.$ = pa), pa
        }), ! function(a) {
            function b() {}

            function c(a, b) {
                return function() {
                    a.apply(b, arguments)
                }
            }

            function d(a) {
                if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
                if ("function" != typeof a) throw new TypeError("not a function");
                this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], j(a, this)
            }

            function e(a, b) {
                for (; 3 === a._state;) a = a._value;
                return 0 === a._state ? void a._deferreds.push(b) : (a._handled = !0, void d._immediateFn(function() {
                    var c = 1 === a._state ? b.onFulfilled : b.onRejected;
                    if (null === c) return void(1 === a._state ? f : g)(b.promise, a._value);
                    var d;
                    try {
                        d = c(a._value)
                    } catch (a) {
                        return void g(b.promise, a)
                    }
                    f(b.promise, d)
                }))
            }

            function f(a, b) {
                try {
                    if (b === a) throw new TypeError("A promise cannot be resolved with itself.");
                    if (b && ("object" == typeof b || "function" == typeof b)) {
                        var e = b.then;
                        if (b instanceof d) return a._state = 3, a._value = b, void h(a);
                        if ("function" == typeof e) return void j(c(e, b), a)
                    }
                    a._state = 1, a._value = b, h(a)
                } catch (b) {
                    g(a, b)
                }
            }

            function g(a, b) {
                a._state = 2, a._value = b, h(a)
            }

            function h(a) {
                2 === a._state && 0 === a._deferreds.length && d._immediateFn(function() {
                    a._handled || d._unhandledRejectionFn(a._value)
                });
                for (var b = 0, c = a._deferreds.length; b < c; b++) e(a, a._deferreds[b]);
                a._deferreds = null
            }

            function i(a, b, c) {
                this.onFulfilled = "function" == typeof a ? a : null, this.onRejected = "function" == typeof b ? b : null, this.promise = c
            }

            function j(a, b) {
                var c = !1;
                try {
                    a(function(a) {
                        c || (c = !0, f(b, a))
                    }, function(a) {
                        c || (c = !0, g(b, a))
                    })
                } catch (a) {
                    if (c) return;
                    c = !0, g(b, a)
                }
            }
            var k = setTimeout;
            d.prototype.catch = function(a) {
                return this.then(null, a)
            }, d.prototype.then = function(a, c) {
                var d = new this.constructor(b);
                return e(this, new i(a, c, d)), d
            }, d.all = function(a) {
                var b = Array.prototype.slice.call(a);
                return new d(function(a, c) {
                    function d(f, g) {
                        try {
                            if (g && ("object" == typeof g || "function" == typeof g)) {
                                var h = g.then;
                                if ("function" == typeof h) return void h.call(g, function(a) {
                                    d(f, a)
                                }, c)
                            }
                            b[f] = g, 0 === --e && a(b)
                        } catch (a) {
                            c(a)
                        }
                    }
                    if (0 === b.length) return a([]);
                    for (var e = b.length, f = 0; f < b.length; f++) d(f, b[f])
                })
            }, d.resolve = function(a) {
                return a && "object" == typeof a && a.constructor === d ? a : new d(function(b) {
                    b(a)
                })
            }, d.reject = function(a) {
                return new d(function(b, c) {
                    c(a)
                })
            }, d.race = function(a) {
                return new d(function(b, c) {
                    for (var d = 0, e = a.length; d < e; d++) a[d].then(b, c)
                })
            }, d._immediateFn = "function" == typeof setImmediate && function(a) {
                setImmediate(a)
            } || function(a) {
                k(a, 0)
            }, d._unhandledRejectionFn = function(a) {
                "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", a)
            }, d._setImmediateFn = function(a) {
                d._immediateFn = a
            }, d._setUnhandledRejectionFn = function(a) {
                d._unhandledRejectionFn = a
            }, "undefined" != typeof module && module.exports ? module.exports = d : a.Promise || (a.Promise = d)
        }(this),
        function(a, b) {
            "object" == typeof exports && "undefined" != typeof module ? b(exports) : "function" == typeof define && define.amd ? define(["exports"], b) : b(a.THREE = a.THREE || {})
        }(this, function(a) {
            function b() {}

            function c(a, b) {
                this.x = a || 0, this.y = b || 0
            }

            function d(a, b, e, f, g, h, i, j, k, l) {
                Object.defineProperty(this, "id", {
                    value: se++
                }), this.uuid = re.generateUUID(), this.name = "", this.image = void 0 !== a ? a : d.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== b ? b : d.DEFAULT_MAPPING, this.wrapS = void 0 !== e ? e : 1001, this.wrapT = void 0 !== f ? f : 1001, this.magFilter = void 0 !== g ? g : 1006, this.minFilter = void 0 !== h ? h : 1008, this.anisotropy = void 0 !== k ? k : 1, this.format = void 0 !== i ? i : 1023, this.type = void 0 !== j ? j : 1009, this.offset = new c(0, 0), this.repeat = new c(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : 3e3, this.version = 0, this.onUpdate = null
            }

            function e(a, b, c, d) {
                this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1
            }

            function f(a, b, c) {
                this.uuid = re.generateUUID(), this.width = a, this.height = b, this.scissor = new e(0, 0, a, b), this.scissorTest = !1, this.viewport = new e(0, 0, a, b), c = c || {}, void 0 === c.minFilter && (c.minFilter = 1006), this.texture = new d(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding), this.depthBuffer = void 0 === c.depthBuffer || c.depthBuffer, this.stencilBuffer = void 0 === c.stencilBuffer || c.stencilBuffer, this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null
            }

            function g(a, b, c) {
                f.call(this, a, b, c), this.activeMipMapLevel = this.activeCubeFace = 0
            }

            function h(a, b, c, d) {
                this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1
            }

            function i(a, b, c) {
                this.x = a || 0, this.y = b || 0, this.z = c || 0
            }

            function j() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function k(a, b, c, e, f, g, h, i, j, k, l, m) {
                d.call(this, null, g, h, i, j, k, e, f, l, m),
                    this.image = {
                        data: a,
                        width: b,
                        height: c
                    }, this.magFilter = void 0 !== j ? j : 1003, this.minFilter = void 0 !== k ? k : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
            }

            function l(a, b, c, e, f, g, h, i, j, k) {
                a = void 0 !== a ? a : [], d.call(this, a, void 0 !== b ? b : 301, c, e, f, g, h, i, j, k), this.flipY = !1
            }

            function m(a, b, c) {
                var d = a[0];
                if (0 >= d || 0 < d) return a;
                var e = b * c,
                    f = ve[e];
                if (void 0 === f && (f = new Float32Array(e), ve[e] = f), 0 !== b)
                    for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
                return f
            }

            function n(a, b) {
                var c = we[b];
                void 0 === c && (c = new Int32Array(b), we[b] = c);
                for (var d = 0; d !== b; ++d) c[d] = a.allocTextureUnit();
                return c
            }

            function o(a, b) {
                a.uniform1f(this.addr, b)
            }

            function p(a, b) {
                a.uniform1i(this.addr, b)
            }

            function q(a, b) {
                void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y)
            }

            function r(a, b) {
                void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b)
            }

            function s(a, b) {
                void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w)
            }

            function t(a, b) {
                a.uniformMatrix2fv(this.addr, !1, b.elements || b)
            }

            function u(a, b) {
                void 0 === b.elements ? a.uniformMatrix3fv(this.addr, !1, b) : (ye.set(b.elements), a.uniformMatrix3fv(this.addr, !1, ye))
            }

            function v(a, b) {
                void 0 === b.elements ? a.uniformMatrix4fv(this.addr, !1, b) : (xe.set(b.elements), a.uniformMatrix4fv(this.addr, !1, xe))
            }

            function w(a, b, c) {
                var d = c.allocTextureUnit();
                a.uniform1i(this.addr, d), c.setTexture2D(b || te, d)
            }

            function x(a, b, c) {
                var d = c.allocTextureUnit();
                a.uniform1i(this.addr, d), c.setTextureCube(b || ue, d)
            }

            function y(a, b) {
                a.uniform2iv(this.addr, b)
            }

            function z(a, b) {
                a.uniform3iv(this.addr, b)
            }

            function A(a, b) {
                a.uniform4iv(this.addr, b)
            }

            function B(a) {
                switch (a) {
                    case 5126:
                        return o;
                    case 35664:
                        return q;
                    case 35665:
                        return r;
                    case 35666:
                        return s;
                    case 35674:
                        return t;
                    case 35675:
                        return u;
                    case 35676:
                        return v;
                    case 35678:
                        return w;
                    case 35680:
                        return x;
                    case 5124:
                    case 35670:
                        return p;
                    case 35667:
                    case 35671:
                        return y;
                    case 35668:
                    case 35672:
                        return z;
                    case 35669:
                    case 35673:
                        return A
                }
            }

            function C(a, b) {
                a.uniform1fv(this.addr, b)
            }

            function D(a, b) {
                a.uniform1iv(this.addr, b)
            }

            function E(a, b) {
                a.uniform2fv(this.addr, m(b, this.size, 2))
            }

            function F(a, b) {
                a.uniform3fv(this.addr, m(b, this.size, 3))
            }

            function G(a, b) {
                a.uniform4fv(this.addr, m(b, this.size, 4))
            }

            function H(a, b) {
                a.uniformMatrix2fv(this.addr, !1, m(b, this.size, 4))
            }

            function I(a, b) {
                a.uniformMatrix3fv(this.addr, !1, m(b, this.size, 9))
            }

            function J(a, b) {
                a.uniformMatrix4fv(this.addr, !1, m(b, this.size, 16))
            }

            function K(a, b, c) {
                var d = b.length,
                    e = n(c, d);
                for (a.uniform1iv(this.addr, e), a = 0; a !== d; ++a) c.setTexture2D(b[a] || te, e[a])
            }

            function L(a, b, c) {
                var d = b.length,
                    e = n(c, d);
                for (a.uniform1iv(this.addr, e), a = 0; a !== d; ++a) c.setTextureCube(b[a] || ue, e[a])
            }

            function M(a) {
                switch (a) {
                    case 5126:
                        return C;
                    case 35664:
                        return E;
                    case 35665:
                        return F;
                    case 35666:
                        return G;
                    case 35674:
                        return H;
                    case 35675:
                        return I;
                    case 35676:
                        return J;
                    case 35678:
                        return K;
                    case 35680:
                        return L;
                    case 5124:
                    case 35670:
                        return D;
                    case 35667:
                    case 35671:
                        return y;
                    case 35668:
                    case 35672:
                        return z;
                    case 35669:
                    case 35673:
                        return A
                }
            }

            function N(a, b, c) {
                this.id = a, this.addr = c, this.setValue = B(b.type)
            }

            function O(a, b, c) {
                this.id = a, this.addr = c, this.size = b.size, this.setValue = M(b.type)
            }

            function P(a) {
                this.id = a, this.seq = [], this.map = {}
            }

            function Q(a, b, c) {
                this.seq = [], this.map = {}, this.renderer = c, c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
                for (var d = 0; d < c; ++d) {
                    var e = a.getActiveUniform(b, d),
                        f = a.getUniformLocation(b, e.name),
                        g = this,
                        h = e.name,
                        i = h.length;
                    for (ze.lastIndex = 0;;) {
                        var j = ze.exec(h),
                            k = ze.lastIndex,
                            l = j[1],
                            m = j[3];
                        if ("]" === j[2] && (l |= 0), void 0 === m || "[" === m && k + 2 === i) {
                            h = g, e = void 0 === m ? new N(l, e, f) : new O(l, e, f), h.seq.push(e), h.map[e.id] = e;
                            break
                        }
                        m = g.map[l], void 0 === m && (m = new P(l), l = g, g = m, l.seq.push(g), l.map[g.id] = g), g = m
                    }
                }
            }

            function R(a, b, c) {
                return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
            }

            function S(a, b) {
                this.min = void 0 !== a ? a : new c(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new c(-(1 / 0), -(1 / 0))
            }

            function T(a, b) {
                var d, e, f, g, h, j, k, l, m, n, o, p, q, r, s, t, u = a.context,
                    v = a.state;
                this.render = function(w, x, y) {
                    if (0 !== b.length) {
                        w = new i;
                        var z = y.w / y.z,
                            A = .5 * y.z,
                            B = .5 * y.w,
                            C = 16 / y.w,
                            D = new c(C * z, C),
                            E = new i(1, 1, 0),
                            F = new c(1, 1),
                            G = new S;
                        if (G.min.set(y.x, y.y), G.max.set(y.x + (y.z - 16), y.y + (y.w - 16)), void 0 === r) {
                            var C = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                                H = new Uint16Array([0, 1, 2, 0, 2, 3]);
                            o = u.createBuffer(), p = u.createBuffer(), u.bindBuffer(u.ARRAY_BUFFER, o), u.bufferData(u.ARRAY_BUFFER, C, u.STATIC_DRAW), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, p), u.bufferData(u.ELEMENT_ARRAY_BUFFER, H, u.STATIC_DRAW), s = u.createTexture(), t = u.createTexture(), v.bindTexture(u.TEXTURE_2D, s), u.texImage2D(u.TEXTURE_2D, 0, u.RGB, 16, 16, 0, u.RGB, u.UNSIGNED_BYTE, null), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST), v.bindTexture(u.TEXTURE_2D, t), u.texImage2D(u.TEXTURE_2D, 0, u.RGBA, 16, 16, 0, u.RGBA, u.UNSIGNED_BYTE, null), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST);
                            var C = q = {
                                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                                    fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                                },
                                H = u.createProgram(),
                                I = u.createShader(u.FRAGMENT_SHADER),
                                J = u.createShader(u.VERTEX_SHADER),
                                K = "precision " + a.getPrecision() + " float;\n";
                            u.shaderSource(I, K + C.fragmentShader), u.shaderSource(J, K + C.vertexShader), u.compileShader(I), u.compileShader(J), u.attachShader(H, I), u.attachShader(H, J), u.linkProgram(H), r = H, m = u.getAttribLocation(r, "position"), n = u.getAttribLocation(r, "uv"), d = u.getUniformLocation(r, "renderType"), e = u.getUniformLocation(r, "map"), f = u.getUniformLocation(r, "occlusionMap"), g = u.getUniformLocation(r, "opacity"), h = u.getUniformLocation(r, "color"), j = u.getUniformLocation(r, "scale"), k = u.getUniformLocation(r, "rotation"), l = u.getUniformLocation(r, "screenPosition")
                        }
                        for (u.useProgram(r), v.initAttributes(), v.enableAttribute(m), v.enableAttribute(n), v.disableUnusedAttributes(), u.uniform1i(f, 0), u.uniform1i(e, 1), u.bindBuffer(u.ARRAY_BUFFER, o), u.vertexAttribPointer(m, 2, u.FLOAT, !1, 16, 0), u.vertexAttribPointer(n, 2, u.FLOAT, !1, 16, 8), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, p), v.disable(u.CULL_FACE), v.buffers.depth.setMask(!1), H = 0, I = b.length; H < I; H++)
                            if (C = 16 / y.w, D.set(C * z, C), J = b[H], w.set(J.matrixWorld.elements[12], J.matrixWorld.elements[13], J.matrixWorld.elements[14]), w.applyMatrix4(x.matrixWorldInverse), w.applyMatrix4(x.projectionMatrix), E.copy(w), F.x = y.x + E.x * A + A - 8, F.y = y.y + E.y * B + B - 8, !0 === G.containsPoint(F)) {
                                v.activeTexture(u.TEXTURE0), v.bindTexture(u.TEXTURE_2D, null), v.activeTexture(u.TEXTURE1), v.bindTexture(u.TEXTURE_2D, s), u.copyTexImage2D(u.TEXTURE_2D, 0, u.RGB, F.x, F.y, 16, 16, 0), u.uniform1i(d, 0), u.uniform2f(j, D.x, D.y), u.uniform3f(l, E.x, E.y, E.z), v.disable(u.BLEND), v.enable(u.DEPTH_TEST), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0), v.activeTexture(u.TEXTURE0), v.bindTexture(u.TEXTURE_2D, t), u.copyTexImage2D(u.TEXTURE_2D, 0, u.RGBA, F.x, F.y, 16, 16, 0), u.uniform1i(d, 1), v.disable(u.DEPTH_TEST), v.activeTexture(u.TEXTURE1), v.bindTexture(u.TEXTURE_2D, s), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0), J.positionScreen.copy(E), J.customUpdateCallback ? J.customUpdateCallback(J) : J.updateLensFlares(), u.uniform1i(d, 2), v.enable(u.BLEND);
                                for (var K = 0, L = J.lensFlares.length; K < L; K++) {
                                    var M = J.lensFlares[K];
                                    .001 < M.opacity && .001 < M.scale && (E.x = M.x, E.y = M.y, E.z = M.z, C = M.size * M.scale / y.w, D.x = C * z, D.y = C, u.uniform3f(l, E.x, E.y, E.z), u.uniform2f(j, D.x, D.y), u.uniform1f(k, M.rotation), u.uniform1f(g, M.opacity), u.uniform3f(h, M.color.r, M.color.g, M.color.b), v.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), a.setTexture2D(M.texture, 1), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0))
                                }
                            }
                        v.enable(u.CULL_FACE), v.enable(u.DEPTH_TEST), v.buffers.depth.setMask(!0), a.resetGLState()
                    }
                }
            }

            function U(a, b) {
                function c(a, b) {
                    return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
                }
                var e, f, g, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B = a.context,
                    C = a.state,
                    D = new i,
                    E = new h,
                    F = new i;
                this.render = function(h, i) {
                    if (0 !== b.length) {
                        if (void 0 === z) {
                            var G = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                                H = new Uint16Array([0, 1, 2, 0, 2, 3]);
                            x = B.createBuffer(), y = B.createBuffer(), B.bindBuffer(B.ARRAY_BUFFER, x), B.bufferData(B.ARRAY_BUFFER, G, B.STATIC_DRAW), B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, y), B.bufferData(B.ELEMENT_ARRAY_BUFFER, H, B.STATIC_DRAW);
                            var G = B.createProgram(),
                                H = B.createShader(B.VERTEX_SHADER),
                                I = B.createShader(B.FRAGMENT_SHADER);
                            B.shaderSource(H, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), B.shaderSource(I, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), B.compileShader(H), B.compileShader(I), B.attachShader(G, H), B.attachShader(G, I), B.linkProgram(G), z = G, v = B.getAttribLocation(z, "position"), w = B.getAttribLocation(z, "uv"), e = B.getUniformLocation(z, "uvOffset"), f = B.getUniformLocation(z, "uvScale"), g = B.getUniformLocation(z, "rotation"), j = B.getUniformLocation(z, "scale"), k = B.getUniformLocation(z, "color"), l = B.getUniformLocation(z, "map"), m = B.getUniformLocation(z, "opacity"), n = B.getUniformLocation(z, "modelViewMatrix"), o = B.getUniformLocation(z, "projectionMatrix"), p = B.getUniformLocation(z, "fogType"), q = B.getUniformLocation(z, "fogDensity"), r = B.getUniformLocation(z, "fogNear"), s = B.getUniformLocation(z, "fogFar"), t = B.getUniformLocation(z, "fogColor"), u = B.getUniformLocation(z, "alphaTest"), G = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), G.width = 8, G.height = 8, H = G.getContext("2d"), H.fillStyle = "white", H.fillRect(0, 0, 8, 8), A = new d(G), A.needsUpdate = !0
                        }
                        B.useProgram(z), C.initAttributes(), C.enableAttribute(v), C.enableAttribute(w), C.disableUnusedAttributes(), C.disable(B.CULL_FACE), C.enable(B.BLEND), B.bindBuffer(B.ARRAY_BUFFER, x), B.vertexAttribPointer(v, 2, B.FLOAT, !1, 16, 0), B.vertexAttribPointer(w, 2, B.FLOAT, !1, 16, 8), B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, y), B.uniformMatrix4fv(o, !1, i.projectionMatrix.elements), C.activeTexture(B.TEXTURE0), B.uniform1i(l, 0), H = G = 0, (I = h.fog) ? (B.uniform3f(t, I.color.r, I.color.g, I.color.b), I.isFog ? (B.uniform1f(r, I.near), B.uniform1f(s, I.far), B.uniform1i(p, 1), H = G = 1) : I.isFogExp2 && (B.uniform1f(q, I.density), B.uniform1i(p, 2), H = G = 2)) : (B.uniform1i(p, 0), H = G = 0);
                        for (var I = 0, J = b.length; I < J; I++) {
                            var K = b[I];
                            K.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, K.matrixWorld), K.z = -K.modelViewMatrix.elements[14]
                        }
                        b.sort(c);
                        for (var L = [], I = 0, J = b.length; I < J; I++) {
                            var K = b[I],
                                M = K.material;
                            !1 !== M.visible && (B.uniform1f(u, M.alphaTest), B.uniformMatrix4fv(n, !1, K.modelViewMatrix.elements), K.matrixWorld.decompose(D, E, F), L[0] = F.x, L[1] = F.y, K = 0, h.fog && M.fog && (K = H), G !== K && (B.uniform1i(p, K), G = K), null !== M.map ? (B.uniform2f(e, M.map.offset.x, M.map.offset.y), B.uniform2f(f, M.map.repeat.x, M.map.repeat.y)) : (B.uniform2f(e, 0, 0), B.uniform2f(f, 1, 1)), B.uniform1f(m, M.opacity), B.uniform3f(k, M.color.r, M.color.g, M.color.b), B.uniform1f(g, M.rotation), B.uniform2fv(j, L), C.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), C.buffers.depth.setTest(M.depthTest), C.buffers.depth.setMask(M.depthWrite), M.map ? a.setTexture2D(M.map, 0) : a.setTexture2D(A, 0), B.drawElements(B.TRIANGLES, 6, B.UNSIGNED_SHORT, 0))
                        }
                        C.enable(B.CULL_FACE), a.resetGLState()
                    }
                }
            }

            function V() {
                Object.defineProperty(this, "id", {
                    value: Fe++
                }), this.uuid = re.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.shading = 2, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.needsUpdate = this.visible = !0
            }

            function W(a) {
                V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
            }

            function X(a) {
                V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(a)
            }

            function Y(a, b) {
                this.min = void 0 !== a ? a : new i(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new i(-(1 / 0), -(1 / 0), -(1 / 0))
            }

            function Z(a, b) {
                this.center = void 0 !== a ? a : new i, this.radius = void 0 !== b ? b : 0
            }

            function $() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }

            function _(a, b) {
                this.normal = void 0 !== a ? a : new i(1, 0, 0), this.constant = void 0 !== b ? b : 0
            }

            function aa(a, b, c, d, e, f) {
                this.planes = [void 0 !== a ? a : new _, void 0 !== b ? b : new _, void 0 !== c ? c : new _, void 0 !== d ? d : new _, void 0 !== e ? e : new _, void 0 !== f ? f : new _]
            }

            function ba(a, b, d, g) {
                function h(b, c, d, e) {
                    var f, g = b.geometry;
                    f = u;
                    var h = b.customDepthMaterial;
                    return d && (f = v, h = b.customDistanceMaterial), h ? f = h : (h = !1, c.morphTargets && (g && g.isBufferGeometry ? h = g.morphAttributes && g.morphAttributes.position && 0 < g.morphAttributes.position.length : g && g.isGeometry && (h = g.morphTargets && 0 < g.morphTargets.length)), b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, g = 0, h && (g |= 1), b && (g |= 2), f = f[g]), a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (g = f.uuid, h = c.uuid, b = w[g], void 0 === b && (b = {}, w[g] = b), g = b[h], void 0 === g && (g = f.clone(), b[h] = g), f = g), f.visible = c.visible, f.wireframe = c.wireframe, h = c.side, F.renderSingleSided && 2 == h && (h = 0), F.renderReverseSided && (0 === h ? h = 1 : 1 === h && (h = 0)), f.side = h, f.clipShadows = c.clipShadows, f.clippingPlanes = c.clippingPlanes, f.wireframeLinewidth = c.wireframeLinewidth, f.linewidth = c.linewidth, d && void 0 !== f.uniforms.lightPos && f.uniforms.lightPos.value.copy(e), f
                }

                function k(b, c, e, f) {
                    if (!1 !== b.visible) {
                        if (b.layers.test(c.layers) && (b.isMesh || b.isLine || b.isPoints) && b.castShadow && (!b.frustumCulled || n.intersectsObject(b))) {
                            b.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, b.matrixWorld);
                            var g = d.update(b),
                                i = b.material;
                            if (Array.isArray(i))
                                for (var j = g.groups, l = 0, m = j.length; l < m; l++) {
                                    var o = j[l],
                                        p = i[o.materialIndex];
                                    p && p.visible && (p = h(b, p, f, t), a.renderBufferDirect(e, null, g, p, b, o))
                                } else i.visible && (p = h(b, i, f, t), a.renderBufferDirect(e, null, g, p, b, null))
                        }
                        for (b = b.children, g = 0, i = b.length; g < i; g++) k(b[g], c, e, f)
                    }
                }
                var l = a.context,
                    m = a.state,
                    n = new aa,
                    o = new j,
                    p = b.shadows,
                    q = new c,
                    r = new c(g.maxTextureSize, g.maxTextureSize),
                    s = new i,
                    t = new i,
                    u = Array(4),
                    v = Array(4),
                    w = {},
                    x = [new i(1, 0, 0), new i(-1, 0, 0), new i(0, 0, 1), new i(0, 0, -1), new i(0, 1, 0), new i(0, -1, 0)],
                    y = [new i(0, 1, 0), new i(0, 1, 0), new i(0, 1, 0), new i(0, 1, 0), new i(0, 0, 1), new i(0, 0, -1)],
                    z = [new e, new e, new e, new e, new e, new e];
                b = new X, b.depthPacking = 3201, b.clipping = !0, g = Ee.distanceRGBA;
                for (var A = Ce.clone(g.uniforms), B = 0; 4 !== B; ++B) {
                    var C = 0 !== (1 & B),
                        D = 0 !== (2 & B),
                        E = b.clone();
                    E.morphTargets = C, E.skinning = D, u[B] = E, C = new W({
                        defines: {
                            USE_SHADOWMAP: ""
                        },
                        uniforms: A,
                        vertexShader: g.vertexShader,
                        fragmentShader: g.fragmentShader,
                        morphTargets: C,
                        skinning: D,
                        clipping: !0
                    }), v[B] = C
                }
                var F = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.renderSingleSided = this.renderReverseSided = !0, this.render = function(b, c) {
                    if (!1 !== F.enabled && (!1 !== F.autoUpdate || !1 !== F.needsUpdate) && 0 !== p.length) {
                        m.disable(l.BLEND), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
                        for (var d, e, g = 0, h = p.length; g < h; g++) {
                            var i = p[g],
                                j = i.shadow;
                            if (void 0 === j) console.warn("THREE.WebGLShadowMap:", i, "has no shadow.");
                            else {
                                var u = j.camera,
                                    v = j.matrix;
                                if (t.setFromMatrixPosition(i.matrixWorld), u.position.copy(t), q.copy(j.mapSize), q.min(r), i && i.isPointLight) {
                                    d = 6, e = !0;
                                    var w = q.x,
                                        A = q.y;
                                    z[0].set(2 * w, A, w, A), z[1].set(0, A, w, A), z[2].set(3 * w, A, w, A), z[3].set(w, A, w, A), z[4].set(3 * w, 0, w, A), z[5].set(w, 0, w, A), q.x *= 4, q.y *= 2, v.makeTranslation(-t.x, -t.y, -t.z)
                                } else d = 1, e = !1, s.setFromMatrixPosition(i.target.matrixWorld), u.lookAt(s), u.updateMatrixWorld(), u.matrixWorldInverse.getInverse(u.matrixWorld), v.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), v.multiply(u.projectionMatrix), v.multiply(u.matrixWorldInverse);
                                for (null === j.map && (j.map = new f(q.x, q.y, {
                                        minFilter: 1003,
                                        magFilter: 1003,
                                        format: 1023
                                    }), j.map.texture.name = i.name + ".shadowMap", u.updateProjectionMatrix()), j.isSpotLightShadow && j.update(i), a.setRenderTarget(j.map), a.clear(), i = 0; i < d; i++) e && (s.copy(u.position), s.add(x[i]), u.up.copy(y[i]), u.lookAt(s), u.updateMatrixWorld(), u.matrixWorldInverse.getInverse(u.matrixWorld), m.viewport(z[i])), o.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), n.setFromMatrix(o), k(b, c, u, e)
                            }
                        }
                        d = a.getClearColor(), e = a.getClearAlpha(), a.setClearColor(d, e), F.needsUpdate = !1
                    }
                }
            }

            function ca(a, b) {
                this.origin = void 0 !== a ? a : new i, this.direction = void 0 !== b ? b : new i
            }

            function da(a, b, c, d) {
                this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || da.DefaultOrder
            }

            function ea() {
                this.mask = 1
            }

            function fa() {
                Object.defineProperty(this, "id", {
                    value: Ge++
                }), this.uuid = re.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fa.DefaultUp.clone();
                var a = new i,
                    b = new da,
                    c = new h,
                    d = new i(1, 1, 1);
                b.onChange(function() {
                    c.setFromEuler(b, !1)
                }), c.onChange(function() {
                    b.setFromQuaternion(c, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        enumerable: !0,
                        value: a
                    },
                    rotation: {
                        enumerable: !0,
                        value: b
                    },
                    quaternion: {
                        enumerable: !0,
                        value: c
                    },
                    scale: {
                        enumerable: !0,
                        value: d
                    },
                    modelViewMatrix: {
                        value: new j
                    },
                    normalMatrix: {
                        value: new $
                    }
                }), this.matrix = new j, this.matrixWorld = new j, this.matrixAutoUpdate = fa.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ea, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}, this.onBeforeRender = function() {}, this.onAfterRender = function() {}
            }

            function ga(a, b) {
                this.start = void 0 !== a ? a : new i, this.end = void 0 !== b ? b : new i
            }

            function ha(a, b, c) {
                this.a = void 0 !== a ? a : new i, this.b = void 0 !== b ? b : new i, this.c = void 0 !== c ? c : new i
            }

            function ia(a, b, c, d, e, f) {
                this.a = a, this.b = b, this.c = c, this.normal = d && d.isVector3 ? d : new i, this.vertexNormals = Array.isArray(d) ? d : [], this.color = e && e.isColor ? e : new R, this.vertexColors = Array.isArray(e) ? e : [], this.materialIndex = void 0 !== f ? f : 0
            }

            function ja(a) {
                V.call(this), this.type = "MeshBasicMaterial", this.color = new R(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(a)
            }

            function ka(a, b, c) {
                if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.uuid = re.generateUUID(), this.array = a, this.itemSize = b, this.count = void 0 !== a ? a.length / b : 0, this.normalized = !0 === c, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.onUploadCallback = function() {}, this.version = 0
            }

            function la(a, b) {
                ka.call(this, new Int8Array(a), b)
            }

            function ma(a, b) {
                ka.call(this, new Uint8Array(a), b)
            }

            function na(a, b) {
                ka.call(this, new Uint8ClampedArray(a), b)
            }

            function oa(a, b) {
                ka.call(this, new Int16Array(a), b)
            }

            function pa(a, b) {
                ka.call(this, new Uint16Array(a), b)
            }

            function qa(a, b) {
                ka.call(this, new Int32Array(a), b)
            }

            function ra(a, b) {
                ka.call(this, new Uint32Array(a), b)
            }

            function sa(a, b) {
                ka.call(this, new Float32Array(a), b)
            }

            function ta(a, b) {
                ka.call(this, new Float64Array(a), b)
            }

            function ua() {
                this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
            }

            function va(a) {
                if (0 === a.length) return -(1 / 0);
                for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
                return b
            }

            function wa() {
                Object.defineProperty(this, "id", {
                    value: He++
                }), this.uuid = re.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
            }

            function xa() {
                Object.defineProperty(this, "id", {
                    value: He++
                }), this.uuid = re.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }
            }

            function ya(a, b) {
                fa.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new xa, this.material = void 0 !== b ? b : new ja({
                    color: 16777215 * Math.random()
                }), this.drawMode = 0, this.updateMorphTargets()
            }

            function za(a, b, c, d, e, f) {
                wa.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: a,
                    height: b,
                    depth: c,
                    widthSegments: d,
                    heightSegments: e,
                    depthSegments: f
                }, this.fromBufferGeometry(new Aa(a, b, c, d, e, f)), this.mergeVertices()
            }

            function Aa(a, b, c, d, e, f) {
                function g(a, b, c, d, e, f, g, p, q, r, s) {
                    var t = f / q,
                        u = g / r,
                        v = f / 2,
                        w = g / 2,
                        x = p / 2;
                    g = q + 1;
                    var y, z, A = r + 1,
                        B = f = 0,
                        C = new i;
                    for (z = 0; z < A; z++) {
                        var D = z * u - w;
                        for (y = 0; y < g; y++) C[a] = (y * t - v) * d, C[b] = D * e, C[c] = x, k.push(C.x, C.y, C.z), C[a] = 0, C[b] = 0, C[c] = 0 < p ? 1 : -1, l.push(C.x, C.y, C.z), m.push(y / q), m.push(1 - z / r), f += 1
                    }
                    for (z = 0; z < r; z++)
                        for (y = 0; y < q; y++) a = n + y + g * (z + 1), b = n + (y + 1) + g * (z + 1), c = n + (y + 1) + g * z, j.push(n + y + g * z, a, c), j.push(a, b, c), B += 6;
                    h.addGroup(o, B, s), o += B, n += f
                }
                xa.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: a,
                    height: b,
                    depth: c,
                    widthSegments: d,
                    heightSegments: e,
                    depthSegments: f
                };
                var h = this;
                d = Math.floor(d) || 1, e = Math.floor(e) || 1, f = Math.floor(f) || 1;
                var j = [],
                    k = [],
                    l = [],
                    m = [],
                    n = 0,
                    o = 0;
                g("z", "y", "x", -1, -1, c, b, a, f, e, 0), g("z", "y", "x", 1, -1, c, b, -a, f, e, 1), g("x", "z", "y", 1, 1, a, c, b, d, f, 2), g("x", "z", "y", 1, -1, a, c, -b, d, f, 3), g("x", "y", "z", 1, -1, a, b, c, d, e, 4), g("x", "y", "z", -1, -1, a, b, -c, d, e, 5), this.setIndex(j), this.addAttribute("position", new sa(k, 3)), this.addAttribute("normal", new sa(l, 3)), this.addAttribute("uv", new sa(m, 2))
            }

            function Ba(a, b, c, d) {
                wa.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: a,
                    height: b,
                    widthSegments: c,
                    heightSegments: d
                }, this.fromBufferGeometry(new Ca(a, b, c, d)), this.mergeVertices()
            }

            function Ca(a, b, c, d) {
                xa.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: a,
                    height: b,
                    widthSegments: c,
                    heightSegments: d
                };
                var e = a / 2,
                    f = b / 2;
                c = Math.floor(c) || 1, d = Math.floor(d) || 1;
                var g = c + 1,
                    h = d + 1,
                    i = a / c,
                    j = b / d,
                    k = [],
                    l = [],
                    m = [],
                    n = [];
                for (a = 0; a < h; a++) {
                    var o = a * j - f;
                    for (b = 0; b < g; b++) l.push(b * i - e, -o, 0), m.push(0, 0, 1), n.push(b / c), n.push(1 - a / d)
                }
                for (a = 0; a < d; a++)
                    for (b = 0; b < c; b++) e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k.push(b + g * a, e, h), k.push(e, f, h);
                this.setIndex(k), this.addAttribute("position", new sa(l, 3)), this.addAttribute("normal", new sa(m, 3)), this.addAttribute("uv", new sa(n, 2))
            }

            function Da() {
                fa.call(this), this.type = "Camera", this.matrixWorldInverse = new j, this.projectionMatrix = new j
            }

            function Ea(a, b, c, d) {
                Da.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== a ? a : 50, this.zoom = 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, this.focus = 10, this.aspect = void 0 !== b ? b : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function Fa(a, b, c, d, e, f) {
                Da.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = a, this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix()
            }

            function Ga(a) {
                var b = {};
                return {
                    get: function(a) {
                        return a.isInterleavedBufferAttribute && (a = a.data), b[a.uuid]
                    },
                    remove: function(c) {
                        var d = b[c.uuid];
                        d && (a.deleteBuffer(d.buffer), delete b[c.uuid])
                    },
                    update: function(c, d) {
                        c.isInterleavedBufferAttribute && (c = c.data);
                        var e = b[c.uuid];
                        if (void 0 === e) {
                            var e = c.uuid,
                                f = c,
                                g = f.array,
                                h = f.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW,
                                i = a.createBuffer();
                            a.bindBuffer(d, i), a.bufferData(d, g, h), f.onUploadCallback(), h = a.FLOAT, g instanceof Float32Array ? h = a.FLOAT : g instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : g instanceof Uint16Array ? h = a.UNSIGNED_SHORT : g instanceof Int16Array ? h = a.SHORT : g instanceof Uint32Array ? h = a.UNSIGNED_INT : g instanceof Int32Array ? h = a.INT : g instanceof Int8Array ? h = a.BYTE : g instanceof Uint8Array && (h = a.UNSIGNED_BYTE), b[e] = {
                                buffer: i,
                                type: h,
                                bytesPerElement: g.BYTES_PER_ELEMENT,
                                version: f.version
                            }
                        } else e.version < c.version && (f = c, g = f.array, i = f.updateRange, a.bindBuffer(d, e.buffer), !1 === f.dynamic ? a.bufferData(d, g, a.STATIC_DRAW) : -1 === i.count ? a.bufferSubData(d, 0, g) : 0 === i.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, i.offset * g.BYTES_PER_ELEMENT, g.subarray(i.offset, i.offset + i.count)), i.count = 0), e.version = c.version)
                    }
                }
            }

            function Ha(a, b) {
                return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
            }

            function Ia(a, b) {
                return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
            }

            function Ja() {
                var a = [],
                    b = -1,
                    c = [],
                    d = -1;
                return {
                    opaque: a,
                    transparent: c,
                    init: function() {
                        d = b = -1
                    },
                    push: function(e, f, g, h, i) {
                        var j, k;
                        g.transparent ? (j = c, k = ++d) : (j = a, k = ++b), (k = j[k]) ? (k.id = e.id, k.object = e, k.geometry = f, k.material = g, k.program = g.program, k.renderOrder = e.renderOrder, k.z = h, k.group = i) : (k = {
                            id: e.id,
                            object: e,
                            geometry: f,
                            material: g,
                            program: g.program,
                            renderOrder: e.renderOrder,
                            z: h,
                            group: i
                        }, j.push(k))
                    },
                    finish: function() {
                        a.length = b + 1, c.length = d + 1
                    },
                    sort: function() {
                        a.sort(Ha), c.sort(Ia)
                    }
                }
            }

            function Ka() {
                var a = {};
                return {
                    get: function(b, c) {
                        var d = b.id + "," + c.id,
                            e = a[d];
                        return void 0 === e && (e = new Ja, a[d] = e), e
                    },
                    dispose: function() {
                        a = {}
                    }
                }
            }

            function La(a, b, c) {
                var d, e, f;
                this.setMode = function(a) {
                    d = a
                }, this.setIndex = function(c) {
                    c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (e = a.UNSIGNED_INT, f = 4) : c.array instanceof Uint16Array ? (e = a.UNSIGNED_SHORT, f = 2) : (e = a.UNSIGNED_BYTE, f = 1)
                }, this.render = function(b, g) {
                    a.drawElements(d, g, e, b * f), c.calls++, c.vertices += g, d === a.TRIANGLES && (c.faces += g / 3)
                }, this.renderInstances = function(g, h, i) {
                    var j = b.get("ANGLE_instanced_arrays");
                    null === j ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (j.drawElementsInstancedANGLE(d, i, e, h * f, g.maxInstancedCount), c.calls++, c.vertices += i * g.maxInstancedCount, d === a.TRIANGLES && (c.faces += g.maxInstancedCount * i / 3))
                }
            }

            function Ma(a, b, c) {
                var d;
                this.setMode = function(a) {
                    d = a
                }, this.render = function(b, e) {
                    a.drawArrays(d, b, e), c.calls++, c.vertices += e, d === a.TRIANGLES && (c.faces += e / 3)
                }, this.renderInstances = function(e, f, g) {
                    var h = b.get("ANGLE_instanced_arrays");
                    if (null === h) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    else {
                        var i = e.attributes.position;
                        i.isInterleavedBufferAttribute ? (g = i.data.count, h.drawArraysInstancedANGLE(d, 0, g, e.maxInstancedCount)) : h.drawArraysInstancedANGLE(d, f, g, e.maxInstancedCount), c.calls++, c.vertices += g * e.maxInstancedCount, d === a.TRIANGLES && (c.faces += e.maxInstancedCount * g / 3)
                    }
                }
            }

            function Na(a, b, c) {
                function d(a) {
                    a = a.target;
                    var g = e[a.id];
                    null !== g.index && b.remove(g.index);
                    for (var h in g.attributes) b.remove(g.attributes[h]);
                    a.removeEventListener("dispose", d), delete e[a.id], (h = f[a.id]) && (b.remove(h), delete f[a.id]), (h = f[g.id]) && (b.remove(h), delete f[g.id]), c.geometries--
                }
                var e = {},
                    f = {};
                return {
                    get: function(a, b) {
                        var f = e[b.id];
                        return f ? f : (b.addEventListener("dispose", d), b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new xa).setFromObject(a)), f = b._bufferGeometry), e[b.id] = f, c.geometries++, f)
                    },
                    update: function(c) {
                        var d = c.index,
                            e = c.attributes;
                        null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER);
                        for (var f in e) b.update(e[f], a.ARRAY_BUFFER);
                        c = c.morphAttributes;
                        for (f in c)
                            for (var d = c[f], e = 0, g = d.length; e < g; e++) b.update(d[e], a.ARRAY_BUFFER)
                    },
                    getWireframeAttribute: function(c) {
                        var d = f[c.id];
                        if (d) return d;
                        var d = [],
                            e = c.index,
                            g = c.attributes;
                        if (null !== e)
                            for (var e = e.array, g = 0, h = e.length; g < h; g += 3) {
                                var i = e[g + 0],
                                    j = e[g + 1],
                                    k = e[g + 2];
                                d.push(i, j, j, k, k, i)
                            } else
                                for (e = g.position.array, g = 0, h = e.length / 3 - 1; g < h; g += 3) i = g + 0, j = g + 1, k = g + 2, d.push(i, j, j, k, k, i);
                        return d = new(65535 < va(d) ? ra : pa)(d, 1), b.update(d, a.ELEMENT_ARRAY_BUFFER), f[c.id] = d
                    }
                }
            }

            function Oa() {
                var a = {};
                return {
                    get: function(b) {
                        if (void 0 !== a[b.id]) return a[b.id];
                        var d;
                        switch (b.type) {
                            case "DirectionalLight":
                                d = {
                                    direction: new i,
                                    color: new R,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new c
                                };
                                break;
                            case "SpotLight":
                                d = {
                                    position: new i,
                                    direction: new i,
                                    color: new R,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new c
                                };
                                break;
                            case "PointLight":
                                d = {
                                    position: new i,
                                    color: new R,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new c
                                };
                                break;
                            case "HemisphereLight":
                                d = {
                                    direction: new i,
                                    skyColor: new R,
                                    groundColor: new R
                                };
                                break;
                            case "RectAreaLight":
                                d = {
                                    color: new R,
                                    position: new i,
                                    halfWidth: new i,
                                    halfHeight: new i
                                }
                        }
                        return a[b.id] = d
                    }
                }
            }

            function Pa(a, b, c) {
                var d = {};
                return {
                    update: function(a) {
                        var e = c.frame,
                            f = a.geometry,
                            g = b.get(a, f);
                        return d[g.id] !== e && (f.isGeometry && g.updateFromObject(a), b.update(g), d[g.id] = e), g
                    },
                    clear: function() {
                        d = {}
                    }
                }
            }

            function Qa(a) {
                a = a.split("\n");
                for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
                return a.join("\n")
            }

            function Ra(a, b, c) {
                var d = a.createShader(b);
                return a.shaderSource(d, c), a.compileShader(d), !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), Qa(c)), d
            }

            function Sa(a) {
                switch (a) {
                    case 3e3:
                        return ["Linear", "( value )"];
                    case 3001:
                        return ["sRGB", "( value )"];
                    case 3002:
                        return ["RGBE", "( value )"];
                    case 3004:
                        return ["RGBM", "( value, 7.0 )"];
                    case 3005:
                        return ["RGBM", "( value, 16.0 )"];
                    case 3006:
                        return ["RGBD", "( value, 256.0 )"];
                    case 3007:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw Error("unsupported encoding: " + a)
                }
            }

            function Ta(a, b) {
                var c = Sa(b);
                return "vec4 " + a + "( vec4 value ) { return " + c[0] + "ToLinear" + c[1] + "; }"
            }

            function Ua(a, b) {
                var c = Sa(b);
                return "vec4 " + a + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"
            }

            function Va(a, b) {
                var c;
                switch (b) {
                    case 1:
                        c = "Linear";
                        break;
                    case 2:
                        c = "Reinhard";
                        break;
                    case 3:
                        c = "Uncharted2";
                        break;
                    case 4:
                        c = "OptimizedCineon";
                        break;
                    default:
                        throw Error("unsupported toneMapping: " + b)
                }
                return "vec3 " + a + "( vec3 color ) { return " + c + "ToneMapping( color ); }"
            }

            function Wa(a, b, c) {
                return a = a || {}, [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ya).join("\n")
            }

            function Xa(a) {
                var b, c = [];
                for (b in a) {
                    var d = a[b];
                    !1 !== d && c.push("#define " + b + " " + d)
                }
                return c.join("\n")
            }

            function Ya(a) {
                return "" !== a
            }

            function Za(a, b) {
                return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
            }

            function $a(a) {
                return a.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(a, b) {
                    var c = De[b];
                    if (void 0 === c) throw Error("Can not resolve #include <" + b + ">");
                    return $a(c)
                })
            }

            function _a(a) {
                return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, b, c, d) {
                    for (a = "", b = parseInt(b); b < parseInt(c); b++) a += d.replace(/\[ i \]/g, "[ " + b + " ]");
                    return a
                })
            }

            function ab(a, b, c, d) {
                var e = a.context,
                    f = c.extensions,
                    g = c.defines,
                    h = c.__webglShader.vertexShader,
                    i = c.__webglShader.fragmentShader,
                    j = "SHADOWMAP_TYPE_BASIC";
                1 === d.shadowMapType ? j = "SHADOWMAP_TYPE_PCF" : 2 === d.shadowMapType && (j = "SHADOWMAP_TYPE_PCF_SOFT");
                var k = "ENVMAP_TYPE_CUBE",
                    l = "ENVMAP_MODE_REFLECTION",
                    m = "ENVMAP_BLENDING_MULTIPLY";
                if (d.envMap) {
                    switch (c.envMap.mapping) {
                        case 301:
                        case 302:
                            k = "ENVMAP_TYPE_CUBE";
                            break;
                        case 306:
                        case 307:
                            k = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case 303:
                        case 304:
                            k = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case 305:
                            k = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (c.envMap.mapping) {
                        case 302:
                        case 304:
                            l = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (c.combine) {
                        case 0:
                            m = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            m = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            m = "ENVMAP_BLENDING_ADD"
                    }
                }
                var n = 0 < a.gammaFactor ? a.gammaFactor : 1,
                    f = Wa(f, d, a.extensions),
                    o = Xa(g),
                    p = e.createProgram();
                c.isRawShaderMaterial ? (g = [o, "\n"].filter(Ya).join("\n"), j = [f, o, "\n"].filter(Ya).join("\n")) : (g = ["precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, o, d.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + n, "#define MAX_BONES " + d.maxBones, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + l : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.displacementMap && d.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.skinning ? "#define USE_SKINNING" : "", d.useVertexTexture ? "#define BONE_TEXTURE" : "", d.morphTargets ? "#define USE_MORPHTARGETS" : "", d.morphNormals && !1 === d.flatShading ? "#define USE_MORPHNORMALS" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + j : "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ya).join("\n"), j = [f, "precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, o, d.alphaTest ? "#define ALPHATEST " + d.alphaTest : "", "#define GAMMA_FACTOR " + n, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + k : "", d.envMap ? "#define " + l : "", d.envMap ? "#define " + m : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.gradientMap ? "#define USE_GRADIENTMAP" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (d.numClippingPlanes - d.numClipIntersection), d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + j : "", d.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", d.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", d.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== d.toneMapping ? "#define TONE_MAPPING" : "", 0 !== d.toneMapping ? De.tonemapping_pars_fragment : "", 0 !== d.toneMapping ? Va("toneMapping", d.toneMapping) : "", d.dithering ? "#define DITHERING" : "", d.outputEncoding || d.mapEncoding || d.envMapEncoding || d.emissiveMapEncoding ? De.encodings_pars_fragment : "", d.mapEncoding ? Ta("mapTexelToLinear", d.mapEncoding) : "", d.envMapEncoding ? Ta("envMapTexelToLinear", d.envMapEncoding) : "", d.emissiveMapEncoding ? Ta("emissiveMapTexelToLinear", d.emissiveMapEncoding) : "", d.outputEncoding ? Ua("linearToOutputTexel", d.outputEncoding) : "", d.depthPacking ? "#define DEPTH_PACKING " + c.depthPacking : "", "\n"].filter(Ya).join("\n")), h = $a(h, d), h = Za(h, d), i = $a(i, d), i = Za(i, d), c.isShaderMaterial || (h = _a(h), i = _a(i)), i = j + i, h = Ra(e, e.VERTEX_SHADER, g + h), i = Ra(e, e.FRAGMENT_SHADER, i), e.attachShader(p, h), e.attachShader(p, i), void 0 !== c.index0AttributeName ? e.bindAttribLocation(p, 0, c.index0AttributeName) : !0 === d.morphTargets && e.bindAttribLocation(p, 0, "position"), e.linkProgram(p), d = e.getProgramInfoLog(p), k = e.getShaderInfoLog(h), l = e.getShaderInfoLog(i), n = m = !0, !1 === e.getProgramParameter(p, e.LINK_STATUS) ? (m = !1, console.error("THREE.WebGLProgram: shader error: ", e.getError(), "gl.VALIDATE_STATUS", e.getProgramParameter(p, e.VALIDATE_STATUS), "gl.getProgramInfoLog", d, k, l)) : "" !== d ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", d) : "" !== k && "" !== l || (n = !1), n && (this.diagnostics = {
                    runnable: m,
                    material: c,
                    programLog: d,
                    vertexShader: {
                        log: k,
                        prefix: g
                    },
                    fragmentShader: {
                        log: l,
                        prefix: j
                    }
                }), e.deleteShader(h), e.deleteShader(i);
                var q;
                this.getUniforms = function() {
                    return void 0 === q && (q = new Q(e, p, a)), q
                };
                var r;
                return this.getAttributes = function() {
                    if (void 0 === r) {
                        for (var a = {}, b = e.getProgramParameter(p, e.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) {
                            var d = e.getActiveAttrib(p, c).name;
                            a[d] = e.getAttribLocation(p, d)
                        }
                        r = a
                    }
                    return r
                }, this.destroy = function() {
                    e.deleteProgram(p), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.id = Ie++, this.code = b, this.usedTimes = 1, this.program = p, this.vertexShader = h, this.fragmentShader = i, this
            }

            function bb(a, b) {
                function c(a, b) {
                    var c;
                    return a ? a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding) : c = 3e3, 3e3 === c && b && (c = 3007), c
                }
                var d = [],
                    e = {
                        MeshDepthMaterial: "depth",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points"
                    },
                    f = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
                this.getParameters = function(d, f, g, h, i, j) {
                    var k, l = e[d.type];
                    if (j.isSkinnedMesh)
                        if (k = j.skeleton.bones, b.floatVertexTextures) k = 1024;
                        else {
                            var m = Math.min(Math.floor((b.maxVertexUniforms - 20) / 4), k.length);
                            m < k.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + k.length + " bones. This GPU supports " + m + "."), k = 0) : k = m
                        }
                    else k = 0;
                    m = a.getPrecision(), null !== d.precision && (m = b.getMaxPrecision(d.precision), m !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", m, "instead."));
                    var n = a.getRenderTarget();
                    return {
                        shaderID: l,
                        precision: m,
                        supportsVertexTextures: b.vertexTextures,
                        outputEncoding: c(n ? n.texture : null, a.gammaOutput),
                        map: !!d.map,
                        mapEncoding: c(d.map, a.gammaInput),
                        envMap: !!d.envMap,
                        envMapMode: d.envMap && d.envMap.mapping,
                        envMapEncoding: c(d.envMap, a.gammaInput),
                        envMapCubeUV: !!d.envMap && (306 === d.envMap.mapping || 307 === d.envMap.mapping),
                        lightMap: !!d.lightMap,
                        aoMap: !!d.aoMap,
                        emissiveMap: !!d.emissiveMap,
                        emissiveMapEncoding: c(d.emissiveMap, a.gammaInput),
                        bumpMap: !!d.bumpMap,
                        normalMap: !!d.normalMap,
                        displacementMap: !!d.displacementMap,
                        roughnessMap: !!d.roughnessMap,
                        metalnessMap: !!d.metalnessMap,
                        specularMap: !!d.specularMap,
                        alphaMap: !!d.alphaMap,
                        gradientMap: !!d.gradientMap,
                        combine: d.combine,
                        vertexColors: d.vertexColors,
                        fog: !!g,
                        useFog: d.fog,
                        fogExp: g && g.isFogExp2,
                        flatShading: 1 === d.shading,
                        sizeAttenuation: d.sizeAttenuation,
                        logarithmicDepthBuffer: b.logarithmicDepthBuffer,
                        skinning: d.skinning && 0 < k,
                        maxBones: k,
                        useVertexTexture: b.floatVertexTextures,
                        morphTargets: d.morphTargets,
                        morphNormals: d.morphNormals,
                        maxMorphTargets: a.maxMorphTargets,
                        maxMorphNormals: a.maxMorphNormals,
                        numDirLights: f.directional.length,
                        numPointLights: f.point.length,
                        numSpotLights: f.spot.length,
                        numRectAreaLights: f.rectArea.length,
                        numHemiLights: f.hemi.length,
                        numClippingPlanes: h,
                        numClipIntersection: i,
                        dithering: d.dithering,
                        shadowMapEnabled: a.shadowMap.enabled && j.receiveShadow && 0 < f.shadows.length,
                        shadowMapType: a.shadowMap.type,
                        toneMapping: a.toneMapping,
                        physicallyCorrectLights: a.physicallyCorrectLights,
                        premultipliedAlpha: d.premultipliedAlpha,
                        alphaTest: d.alphaTest,
                        doubleSided: 2 === d.side,
                        flipSided: 1 === d.side,
                        depthPacking: void 0 !== d.depthPacking && d.depthPacking
                    }
                }, this.getProgramCode = function(a, b) {
                    var c = [];
                    if (b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader)), void 0 !== a.defines)
                        for (var d in a.defines) c.push(d), c.push(a.defines[d]);
                    for (d = 0; d < f.length; d++) c.push(b[f[d]]);
                    return c.join()
                }, this.acquireProgram = function(b, c, e) {
                    for (var f, g = 0, h = d.length; g < h; g++) {
                        var i = d[g];
                        if (i.code === e) {
                            f = i, ++f.usedTimes;
                            break
                        }
                    }
                    return void 0 === f && (f = new ab(a, e, b, c), d.push(f)), f
                }, this.releaseProgram = function(a) {
                    if (0 === --a.usedTimes) {
                        var b = d.indexOf(a);
                        d[b] = d[d.length - 1], d.pop(), a.destroy()
                    }
                }, this.programs = d
            }

            function cb(a, b, c, d, e, f, g) {
                function h(a, b) {
                    if (a.width > b || a.height > b) {
                        var c = b / Math.max(a.width, a.height),
                            d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c), d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a), d
                    }
                    return a
                }

                function i(a) {
                    return re.isPowerOfTwo(a.width) && re.isPowerOfTwo(a.height)
                }

                function j(b) {
                    return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR
                }

                function k(b) {
                    b = b.target, b.removeEventListener("dispose", k);
                    a: {
                        var c = d.get(b);
                        if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube);
                        else {
                            if (void 0 === c.__webglInit) break a;
                            a.deleteTexture(c.__webglTexture)
                        }
                        d.remove(b)
                    }
                    g.textures--
                }

                function l(b) {
                    b = b.target, b.removeEventListener("dispose", l);
                    var c = d.get(b),
                        e = d.get(b.texture);
                    if (b) {
                        if (void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture), b.depthTexture && b.depthTexture.dispose(), b.isWebGLRenderTargetCube)
                            for (e = 0; 6 > e; e++) a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
                        else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
                        d.remove(b.texture), d.remove(b)
                    }
                    g.textures--
                }

                function m(b, j) {
                    var l = d.get(b);
                    if (0 < b.version && l.__version !== b.version) {
                        var m = b.image;
                        if (void 0 === m) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", b);
                        else {
                            if (!1 !== m.complete) {
                                void 0 === l.__webglInit && (l.__webglInit = !0, b.addEventListener("dispose", k), l.__webglTexture = a.createTexture(), g.textures++), c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_2D, l.__webglTexture), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment);
                                var o = h(b.image, e.maxTextureSize);
                                if ((1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && !1 === i(o))
                                    if (m = o, m instanceof HTMLImageElement || m instanceof HTMLCanvasElement) {
                                        var p = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                                        p.width = re.nearestPowerOfTwo(m.width), p.height = re.nearestPowerOfTwo(m.height), p.getContext("2d").drawImage(m, 0, 0, p.width, p.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + m.width + "x" + m.height + "). Resized to " + p.width + "x" + p.height, m), o = p
                                    } else o = m;
                                var m = i(o),
                                    p = f(b.format),
                                    r = f(b.type);
                                n(a.TEXTURE_2D, b, m);
                                var s = b.mipmaps;
                                if (b.isDepthTexture) {
                                    if (s = a.DEPTH_COMPONENT, 1015 === b.type) {
                                        if (!q) throw Error("Float Depth Texture only supported in WebGL2.0");
                                        s = a.DEPTH_COMPONENT32F
                                    } else q && (s = a.DEPTH_COMPONENT16);
                                    1026 === b.format && s === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), b.type = 1012, r = f(b.type)), 1027 === b.format && (s = a.DEPTH_STENCIL, 1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, r = f(b.type))), c.texImage2D(a.TEXTURE_2D, 0, s, o.width, o.height, 0, p, r, null)
                                } else if (b.isDataTexture)
                                    if (0 < s.length && m) {
                                        for (var t = 0, u = s.length; t < u; t++) o = s[t], c.texImage2D(a.TEXTURE_2D, t, p, o.width, o.height, 0, p, r, o.data);
                                        b.generateMipmaps = !1
                                    } else c.texImage2D(a.TEXTURE_2D, 0, p, o.width, o.height, 0, p, r, o.data);
                                else if (b.isCompressedTexture)
                                    for (t = 0, u = s.length; t < u; t++) o = s[t], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(p) ? c.compressedTexImage2D(a.TEXTURE_2D, t, p, o.width, o.height, 0, o.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, t, p, o.width, o.height, 0, p, r, o.data);
                                else if (0 < s.length && m) {
                                    for (t = 0, u = s.length; t < u; t++) o = s[t], c.texImage2D(a.TEXTURE_2D, t, p, p, r, o);
                                    b.generateMipmaps = !1
                                } else c.texImage2D(a.TEXTURE_2D, 0, p, p, r, o);
                                return b.generateMipmaps && m && a.generateMipmap(a.TEXTURE_2D), l.__version = b.version, void(b.onUpdate && b.onUpdate(b))
                            }
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", b)
                        }
                    }
                    c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_2D, l.__webglTexture)
                }

                function n(c, g, h) {
                    h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", g), a.texParameteri(c, a.TEXTURE_MAG_FILTER, j(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, j(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", g)), !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === b.get("OES_texture_half_float_linear") || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy)
                }

                function o(b, e, g, h) {
                    var i = f(e.texture.format),
                        j = f(e.texture.type);
                    c.texImage2D(h, 0, i, e.width, e.height, 0, i, j, null), a.bindFramebuffer(a.FRAMEBUFFER, b), a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0), a.bindFramebuffer(a.FRAMEBUFFER, null)
                }

                function p(b, c) {
                    a.bindRenderbuffer(a.RENDERBUFFER, b), c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height), a.bindRenderbuffer(a.RENDERBUFFER, null)
                }
                var q = "undefined" != typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext;
                this.setTexture2D = m, this.setTextureCube = function(b, j) {
                    var l = d.get(b);
                    if (6 === b.image.length)
                        if (0 < b.version && l.__version !== b.version) {
                            l.__image__webglTextureCube || (b.addEventListener("dispose", k), l.__image__webglTextureCube = a.createTexture(), g.textures++), c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_CUBE_MAP, l.__image__webglTextureCube), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
                            for (var m = b && b.isCompressedTexture, o = b.image[0] && b.image[0].isDataTexture, p = [], q = 0; 6 > q; q++) p[q] = m || o ? o ? b.image[q].image : b.image[q] : h(b.image[q], e.maxCubemapSize);
                            var r = i(p[0]),
                                s = f(b.format),
                                t = f(b.type);
                            for (n(a.TEXTURE_CUBE_MAP, b, r), q = 0; 6 > q; q++)
                                if (m)
                                    for (var u, v = p[q].mipmaps, w = 0, x = v.length; w < x; w++) u = v[w], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(s) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, w, s, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, w, s, u.width, u.height, 0, s, t, u.data);
                                else o ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, 0, s, p[q].width, p[q].height, 0, s, t, p[q].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, 0, s, s, t, p[q]);
                            b.generateMipmaps && r && a.generateMipmap(a.TEXTURE_CUBE_MAP), l.__version = b.version, b.onUpdate && b.onUpdate(b)
                        } else c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_CUBE_MAP, l.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function(b, e) {
                    c.activeTexture(a.TEXTURE0 + e), c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture)
                }, this.setupRenderTarget = function(b) {
                    var e = d.get(b),
                        f = d.get(b.texture);
                    b.addEventListener("dispose", l), f.__webglTexture = a.createTexture(), g.textures++;
                    var h = !0 === b.isWebGLRenderTargetCube,
                        j = i(b);
                    if (h) {
                        e.__webglFramebuffer = [];
                        for (var k = 0; 6 > k; k++) e.__webglFramebuffer[k] = a.createFramebuffer()
                    } else e.__webglFramebuffer = a.createFramebuffer();
                    if (h) {
                        for (c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture), n(a.TEXTURE_CUBE_MAP, b.texture, j), k = 0; 6 > k; k++) o(e.__webglFramebuffer[k], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + k);
                        b.texture.generateMipmaps && j && a.generateMipmap(a.TEXTURE_CUBE_MAP), c.bindTexture(a.TEXTURE_CUBE_MAP, null)
                    } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), n(a.TEXTURE_2D, b.texture, j), o(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), b.texture.generateMipmaps && j && a.generateMipmap(a.TEXTURE_2D), c.bindTexture(a.TEXTURE_2D, null);
                    if (b.depthBuffer) {
                        if (e = d.get(b), f = !0 === b.isWebGLRenderTargetCube, b.depthTexture) {
                            if (f) throw Error("target.depthTexture not supported in Cube render targets");
                            if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
                            if (a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), !b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            if (d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0), m(b.depthTexture, 0), e = d.get(b.depthTexture).__webglTexture, 1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0);
                            else {
                                if (1027 !== b.depthTexture.format) throw Error("Unknown depthTexture format");
                                a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0)
                            }
                        } else if (f)
                            for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++) a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), p(e.__webglDepthbuffer[f], b);
                        else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), p(e.__webglDepthbuffer, b);
                        a.bindFramebuffer(a.FRAMEBUFFER, null)
                    }
                }, this.updateRenderTargetMipmap = function(b) {
                    var e = b.texture;
                    e.generateMipmaps && i(b) && 1003 !== e.minFilter && 1006 !== e.minFilter && (b = b && b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D, e = d.get(e).__webglTexture, c.bindTexture(b, e), a.generateMipmap(b), c.bindTexture(b, null))
                }
            }

            function db() {
                var a = {};
                return {
                    get: function(b) {
                        b = b.uuid;
                        var c = a[b];
                        return void 0 === c && (c = {}, a[b] = c), c
                    },
                    remove: function(b) {
                        delete a[b.uuid]
                    },
                    clear: function() {
                        a = {}
                    }
                }
            }

            function eb(a, b, c) {
                function d(b, c, d) {
                    var e = new Uint8Array(4),
                        f = a.createTexture();
                    for (a.bindTexture(b, f), a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST), b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
                    return f
                }

                function f(b) {
                    !0 !== t[b] && (a.enable(b), t[b] = !0)
                }

                function g(b) {
                    !1 !== t[b] && (a.disable(b), t[b] = !1)
                }

                function h(b, d, e, h, i, j, k, l) {
                    0 !== b ? f(a.BLEND) : g(a.BLEND), b === v && l === C || (2 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : 3 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : 4 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), v = b, C = l), 5 === b ? (i = i || d, j = j || e, k = k || h, d === w && i === z || (a.blendEquationSeparate(c(d), c(i)), w = d, z = i), e === x && h === y && j === A && k === B || (a.blendFuncSeparate(c(e), c(h), c(j), c(k)), x = e, y = h, A = j, B = k)) : B = A = z = y = x = w = null
                }

                function i(b) {
                    D !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), D = b)
                }

                function j(b) {
                    0 !== b ? (f(a.CULL_FACE), b !== E && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : g(a.CULL_FACE), E = b
                }

                function k(b, c, d) {
                    b ? (f(a.POLYGON_OFFSET_FILL), (G !== c || H !== d) && (a.polygonOffset(c, d), G = c, H = d)) : g(a.POLYGON_OFFSET_FILL)
                }

                function l(b) {
                    void 0 === b && (b = a.TEXTURE0 + J - 1), L !== b && (a.activeTexture(b), L = b)
                }
                var m = new function() {
                        var b = !1,
                            c = new e,
                            d = null,
                            f = new e;
                        return {
                            setMask: function(c) {
                                d === c || b || (a.colorMask(c, c, c, c), d = c)
                            },
                            setLocked: function(a) {
                                b = a
                            },
                            setClear: function(b, d, e, g, h) {
                                !0 === h && (b *= g, d *= g, e *= g), c.set(b, d, e, g), !1 === f.equals(c) && (a.clearColor(b, d, e, g), f.copy(c))
                            },
                            reset: function() {
                                b = !1, d = null, f.set(0, 0, 0, 1)
                            }
                        }
                    },
                    n = new function() {
                        var b = !1,
                            c = null,
                            d = null,
                            e = null;
                        return {
                            setTest: function(b) {
                                b ? f(a.DEPTH_TEST) : g(a.DEPTH_TEST)
                            },
                            setMask: function(d) {
                                c === d || b || (a.depthMask(d), c = d)
                            },
                            setFunc: function(b) {
                                if (d !== b) {
                                    if (b) switch (b) {
                                        case 0:
                                            a.depthFunc(a.NEVER);
                                            break;
                                        case 1:
                                            a.depthFunc(a.ALWAYS);
                                            break;
                                        case 2:
                                            a.depthFunc(a.LESS);
                                            break;
                                        case 3:
                                            a.depthFunc(a.LEQUAL);
                                            break;
                                        case 4:
                                            a.depthFunc(a.EQUAL);
                                            break;
                                        case 5:
                                            a.depthFunc(a.GEQUAL);
                                            break;
                                        case 6:
                                            a.depthFunc(a.GREATER);
                                            break;
                                        case 7:
                                            a.depthFunc(a.NOTEQUAL);
                                            break;
                                        default:
                                            a.depthFunc(a.LEQUAL)
                                    } else a.depthFunc(a.LEQUAL);
                                    d = b
                                }
                            },
                            setLocked: function(a) {
                                b = a
                            },
                            setClear: function(b) {
                                e !== b && (a.clearDepth(b), e = b)
                            },
                            reset: function() {
                                b = !1, e = d = c = null
                            }
                        }
                    },
                    o = new function() {
                        var b = !1,
                            c = null,
                            d = null,
                            e = null,
                            h = null,
                            i = null,
                            j = null,
                            k = null,
                            l = null;
                        return {
                            setTest: function(b) {
                                b ? f(a.STENCIL_TEST) : g(a.STENCIL_TEST)
                            },
                            setMask: function(d) {
                                c === d || b || (a.stencilMask(d), c = d)
                            },
                            setFunc: function(b, c, f) {
                                d === b && e === c && h === f || (a.stencilFunc(b, c, f), d = b, e = c, h = f)
                            },
                            setOp: function(b, c, d) {
                                i === b && j === c && k === d || (a.stencilOp(b, c, d), i = b, j = c, k = d)
                            },
                            setLocked: function(a) {
                                b = a
                            },
                            setClear: function(b) {
                                l !== b && (a.clearStencil(b), l = b)
                            },
                            reset: function() {
                                b = !1, l = k = j = i = h = e = d = c = null
                            }
                        }
                    },
                    p = a.getParameter(a.MAX_VERTEX_ATTRIBS),
                    q = new Uint8Array(p),
                    r = new Uint8Array(p),
                    s = new Uint8Array(p),
                    t = {},
                    u = null,
                    v = null,
                    w = null,
                    x = null,
                    y = null,
                    z = null,
                    A = null,
                    B = null,
                    C = !1,
                    D = null,
                    E = null,
                    F = null,
                    G = null,
                    H = null,
                    I = null,
                    J = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
                    p = parseFloat(/^WebGL\ ([0-9])/.exec(a.getParameter(a.VERSION))[1]),
                    K = 1 <= parseFloat(p),
                    L = null,
                    M = {},
                    N = new e,
                    O = new e,
                    P = {};
                return P[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1), P[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
                    buffers: {
                        color: m,
                        depth: n,
                        stencil: o
                    },
                    init: function() {
                        m.setClear(0, 0, 0, 1), n.setClear(1), o.setClear(0), f(a.DEPTH_TEST), n.setFunc(3), i(!1), j(1), f(a.CULL_FACE), f(a.BLEND), h(1)
                    },
                    initAttributes: function() {
                        for (var a = 0, b = q.length; a < b; a++) q[a] = 0
                    },
                    enableAttribute: function(c) {
                        q[c] = 1, 0 === r[c] && (a.enableVertexAttribArray(c), r[c] = 1), 0 !== s[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), s[c] = 0)
                    },
                    enableAttributeAndDivisor: function(c, d) {
                        q[c] = 1, 0 === r[c] && (a.enableVertexAttribArray(c), r[c] = 1), s[c] !== d && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, d), s[c] = d)
                    },
                    disableUnusedAttributes: function() {
                        for (var b = 0, c = r.length; b !== c; ++b) r[b] !== q[b] && (a.disableVertexAttribArray(b), r[b] = 0)
                    },
                    enable: f,
                    disable: g,
                    getCompressedTextureFormats: function() {
                        if (null === u && (u = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1")))
                            for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) u.push(c[d]);
                        return u
                    },
                    setBlending: h,
                    setMaterial: function(b) {
                        2 === b.side ? g(a.CULL_FACE) : f(a.CULL_FACE), i(1 === b.side), !0 === b.transparent ? h(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha) : h(0), n.setFunc(b.depthFunc), n.setTest(b.depthTest), n.setMask(b.depthWrite), m.setMask(b.colorWrite), k(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits)
                    },
                    setFlipSided: i,
                    setCullFace: j,
                    setLineWidth: function(b) {
                        b !== F && (K && a.lineWidth(b), F = b)
                    },
                    setPolygonOffset: k,
                    getScissorTest: function() {
                        return I
                    },
                    setScissorTest: function(b) {
                        (I = b) ? f(a.SCISSOR_TEST): g(a.SCISSOR_TEST)
                    },
                    activeTexture: l,
                    bindTexture: function(b, c) {
                        null === L && l();
                        var d = M[L];
                        void 0 === d && (d = {
                            type: void 0,
                            texture: void 0
                        }, M[L] = d), d.type === b && d.texture === c || (a.bindTexture(b, c || P[b]), d.type = b, d.texture = c)
                    },
                    compressedTexImage2D: function() {
                        try {
                            a.compressedTexImage2D.apply(a, arguments)
                        } catch (a) {
                            console.error(a)
                        }
                    },
                    texImage2D: function() {
                        try {
                            a.texImage2D.apply(a, arguments)
                        } catch (a) {
                            console.error(a)
                        }
                    },
                    scissor: function(b) {
                        !1 === N.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), N.copy(b))
                    },
                    viewport: function(b) {
                        !1 === O.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), O.copy(b))
                    },
                    reset: function() {
                        for (var b = 0; b < r.length; b++) 1 === r[b] && (a.disableVertexAttribArray(b), r[b] = 0);
                        t = {}, L = u = null, M = {}, E = D = v = null, m.reset(), n.reset(), o.reset()
                    }
                }
            }

            function fb(a, b, c) {
                function d(b) {
                    if ("highp" === b) {
                        if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
                        b = "mediump"
                    }
                    return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
                }
                var e, f = void 0 !== c.precision ? c.precision : "highp",
                    g = d(f);
                g !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", g, "instead."), f = g), c = !0 === c.logarithmicDepthBuffer && !!b.get("EXT_frag_depth");
                var g = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
                    h = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    i = a.getParameter(a.MAX_TEXTURE_SIZE),
                    j = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
                    k = a.getParameter(a.MAX_VERTEX_ATTRIBS),
                    l = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
                    m = a.getParameter(a.MAX_VARYING_VECTORS),
                    n = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
                    o = 0 < h,
                    p = !!b.get("OES_texture_float");
                return {
                    getMaxAnisotropy: function() {
                        if (void 0 !== e) return e;
                        var c = b.get("EXT_texture_filter_anisotropic");
                        return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: d,
                    precision: f,
                    logarithmicDepthBuffer: c,
                    maxTextures: g,
                    maxVertexTextures: h,
                    maxTextureSize: i,
                    maxCubemapSize: j,
                    maxAttributes: k,
                    maxVertexUniforms: l,
                    maxVaryings: m,
                    maxFragmentUniforms: n,
                    vertexTextures: o,
                    floatFragmentTextures: p,
                    floatVertexTextures: o && p
                }
            }

            function gb(a) {
                var b = {};
                return {
                    get: function(c) {
                        if (void 0 !== b[c]) return b[c];
                        var d;
                        switch (c) {
                            case "WEBGL_depth_texture":
                                d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            case "WEBGL_compressed_texture_etc1":
                                d = a.getExtension("WEBGL_compressed_texture_etc1");
                                break;
                            default:
                                d = a.getExtension(c)
                        }
                        return null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."), b[c] = d
                    }
                }
            }

            function hb() {
                function a() {
                    j.value !== d && (j.value = d, j.needsUpdate = 0 < e), c.numPlanes = e, c.numIntersection = 0
                }

                function b(a, b, d, e) {
                    var f = null !== a ? a.length : 0,
                        g = null;
                    if (0 !== f) {
                        if (g = j.value, !0 !== e || null === g)
                            for (e = d + 4 * f, b = b.matrixWorldInverse, i.getNormalMatrix(b), (null === g || g.length < e) && (g = new Float32Array(e)), e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, i), h.normal.toArray(g, d), g[d + 3] = h.constant;
                        j.value = g, j.needsUpdate = !0
                    }
                    return c.numPlanes = f, g
                }
                var c = this,
                    d = null,
                    e = 0,
                    f = !1,
                    g = !1,
                    h = new _,
                    i = new $,
                    j = {
                        value: null,
                        needsUpdate: !1
                    };
                this.uniform = j, this.numIntersection = this.numPlanes = 0, this.init = function(a, c, g) {
                    var h = 0 !== a.length || c || 0 !== e || f;
                    return f = c, d = b(a, g, 0), e = a.length, h
                }, this.beginShadows = function() {
                    g = !0, b(null)
                }, this.endShadows = function() {
                    g = !1, a()
                }, this.setState = function(c, h, i, k, l, m) {
                    if (!f || null === c || 0 === c.length || g && !i) g ? b(null) : a();
                    else {
                        i = g ? 0 : e;
                        var n = 4 * i,
                            o = l.clippingState || null;
                        for (j.value = o, o = b(c, k, n, m), c = 0; c !== n; ++c) o[c] = d[c];
                        l.clippingState = o, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += i
                    }
                }
            }

            function ib(a) {
                function b() {
                    va.init(), va.scissor(P.copy(da).multiplyScalar(ca)), va.viewport(V.copy(fa).multiplyScalar(ca)), va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B)
                }

                function c() {
                    O = J = null, N = "", M = -1, va.reset()
                }

                function d(a) {
                    a.preventDefault(), c(), b(), wa.clear(), Ha.clear()
                }

                function f(a) {
                    a = a.target, a.removeEventListener("dispose", f), g(a), wa.remove(a)
                }

                function g(a) {
                    var b = wa.get(a).program;
                    a.program = void 0, void 0 !== b && Ia.releaseProgram(b)
                }

                function h(a, b, c) {
                    a.render(function(a) {
                        I.renderBufferImmediate(a, b, c)
                    })
                }

                function l(a, b) {
                    return Math.abs(b[0]) - Math.abs(a[0])
                }

                function m(a, b, c) {
                    if (a.visible) {
                        if (a.layers.test(b.layers))
                            if (a.isLight) D.push(a);
                            else if (a.isSprite) a.frustumCulled && !ga.intersectsSprite(a) || G.push(a);
                        else if (a.isLensFlare) H.push(a);
                        else if (a.isImmediateRenderObject) c && ma.setFromMatrixPosition(a.matrixWorld).applyMatrix4(la), E.push(a, null, a.material, ma.z, null);
                        else if ((a.isMesh || a.isLine || a.isPoints) && (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || ga.intersectsObject(a))) {
                            c && ma.setFromMatrixPosition(a.matrixWorld).applyMatrix4(la);
                            var d = Ha.update(a),
                                e = a.material;
                            if (Array.isArray(e))
                                for (var f = d.groups, g = 0, h = f.length; g < h; g++) {
                                    var i = f[g],
                                        j = e[i.materialIndex];
                                    j && j.visible && E.push(a, d, j, ma.z, i)
                                } else e.visible && E.push(a, d, e, ma.z, null)
                        }
                        for (a = a.children, g = 0, h = a.length; g < h; g++) m(a[g], b, c)
                    }
                }

                function n(a, b, c, d) {
                    for (var e = 0, f = a.length; e < f; e++) {
                        var g = a[e],
                            h = g.object,
                            i = g.geometry,
                            j = void 0 === d ? g.material : d,
                            g = g.group;
                        if (h.onBeforeRender(I, b, c, i, j, g), c.isArrayCamera && c.enabled)
                            for (var k = c.cameras, l = 0, m = k.length; l < m; l++) {
                                var n = k[l],
                                    p = n.bounds;
                                I.setViewport(p.x * $ * ca, p.y * _ * ca, p.z * $ * ca, p.w * _ * ca), I.setScissor(p.x * $ * ca, p.y * _ * ca, p.z * $ * ca, p.w * _ * ca), I.setScissorTest(!0), o(h, b, n, i, j, g)
                            } else o(h, b, c, i, j, g);
                        h.onAfterRender(I, b, c, i, j, g)
                    }
                }

                function o(a, b, c, d, e, f) {
                    a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), a.normalMatrix.getNormalMatrix(a.modelViewMatrix), a.isImmediateRenderObject ? (va.setMaterial(e), b = q(c, b.fog, e, a), N = "", h(a, b, e)) : I.renderBufferDirect(c, b.fog, d, e, a, f)
                }

                function p(a, b, c) {
                    var d = wa.get(a);
                    c = Ia.getParameters(a, pa, b, ha.numPlanes, ha.numIntersection, c);
                    var e = Ia.getProgramCode(a, c),
                        h = d.program,
                        i = !0;
                    if (void 0 === h) a.addEventListener("dispose", f);
                    else if (h.code !== e) g(a);
                    else {
                        if (void 0 !== c.shaderID) return;
                        i = !1
                    }
                    if (i && (c.shaderID ? (h = Ee[c.shaderID], d.__webglShader = {
                            name: a.type,
                            uniforms: Ce.clone(h.uniforms),
                            vertexShader: h.vertexShader,
                            fragmentShader: h.fragmentShader
                        }) : d.__webglShader = {
                            name: a.type,
                            uniforms: a.uniforms,
                            vertexShader: a.vertexShader,
                            fragmentShader: a.fragmentShader
                        }, a.__webglShader = d.__webglShader, h = Ia.acquireProgram(a, c, e), d.program = h, a.program = h), c = h.getAttributes(), a.morphTargets)
                        for (e = a.numSupportedMorphTargets = 0; e < I.maxMorphTargets; e++) 0 <= c["morphTarget" + e] && a.numSupportedMorphTargets++;
                    if (a.morphNormals)
                        for (e = a.numSupportedMorphNormals = 0; e < I.maxMorphNormals; e++) 0 <= c["morphNormal" + e] && a.numSupportedMorphNormals++;
                    c = d.__webglShader.uniforms, (a.isShaderMaterial || a.isRawShaderMaterial) && !0 !== a.clipping || (d.numClippingPlanes = ha.numPlanes, d.numIntersection = ha.numIntersection, c.clippingPlanes = ha.uniform), d.fog = b, d.lightsHash = pa.hash, a.lights && (c.ambientLightColor.value = pa.ambient, c.directionalLights.value = pa.directional, c.spotLights.value = pa.spot, c.rectAreaLights.value = pa.rectArea, c.pointLights.value = pa.point, c.hemisphereLights.value = pa.hemi, c.directionalShadowMap.value = pa.directionalShadowMap, c.directionalShadowMatrix.value = pa.directionalShadowMatrix, c.spotShadowMap.value = pa.spotShadowMap, c.spotShadowMatrix.value = pa.spotShadowMatrix, c.pointShadowMap.value = pa.pointShadowMap, c.pointShadowMatrix.value = pa.pointShadowMatrix), a = d.program.getUniforms(), a = Q.seqWithValue(a.seq, c), d.uniformsList = a
                }

                function q(a, b, c, d) {
                    X = 0;
                    var e = wa.get(c);
                    ia && (ka || a !== O) && ha.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === O && c.id === M), !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : c.lights && e.lightsHash !== pa.hash ? c.needsUpdate = !0 : void 0 === e.numClippingPlanes || e.numClippingPlanes === ha.numPlanes && e.numIntersection === ha.numIntersection || (c.needsUpdate = !0)), c.needsUpdate && (p(c, b, d), c.needsUpdate = !1);
                    var f = !1,
                        g = !1,
                        h = !1,
                        i = e.program,
                        j = i.getUniforms(),
                        l = e.__webglShader.uniforms;
                    if (i.id !== J && (sa.useProgram(i.program), J = i.id, h = g = f = !0), c.id !== M && (M = c.id, g = !0), (f || a !== O) && (j.setValue(sa, "projectionMatrix", a.projectionMatrix), ua.logarithmicDepthBuffer && j.setValue(sa, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)), a !== O && (O = a, h = g = !0), (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) && (f = j.map.cameraPosition, void 0 !== f && f.setValue(sa, ma.setFromMatrixPosition(a.matrixWorld))), (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && j.setValue(sa, "viewMatrix", a.matrixWorldInverse), j.setValue(sa, "toneMappingExposure", I.toneMappingExposure), j.setValue(sa, "toneMappingWhitePoint", I.toneMappingWhitePoint)), c.skinning && (j.setOptional(sa, d, "bindMatrix"), j.setOptional(sa, d, "bindMatrixInverse"), a = d.skeleton))
                        if (f = a.bones, ua.floatVertexTextures) {
                            if (void 0 === a.boneTexture) {
                                var f = Math.sqrt(4 * f.length),
                                    f = re.nextPowerOfTwo(Math.ceil(f)),
                                    f = Math.max(f, 4),
                                    m = new Float32Array(f * f * 4);
                                m.set(a.boneMatrices);
                                var n = new k(m, f, f, 1023, 1015);
                                a.boneMatrices = m, a.boneTexture = n, a.boneTextureSize = f
                            }
                            j.setValue(sa, "boneTexture", a.boneTexture), j.setValue(sa, "boneTextureSize", a.boneTextureSize)
                        } else j.setOptional(sa, a, "boneMatrices");
                    if (g) {
                        if (c.lights && (g = h, l.ambientLightColor.needsUpdate = g, l.directionalLights.needsUpdate = g, l.pointLights.needsUpdate = g, l.spotLights.needsUpdate = g, l.rectAreaLights.needsUpdate = g, l.hemisphereLights.needsUpdate = g), b && c.fog && (l.fogColor.value = b.color, b.isFog ? (l.fogNear.value = b.near, l.fogFar.value = b.far) : b.isFogExp2 && (l.fogDensity.value = b.density)), c.isMeshBasicMaterial || c.isMeshLambertMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.isMeshNormalMaterial || c.isMeshDepthMaterial) {
                            l.opacity.value = c.opacity, l.diffuse.value = c.color, c.emissive && l.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity), l.map.value = c.map, l.specularMap.value = c.specularMap, l.alphaMap.value = c.alphaMap, c.lightMap && (l.lightMap.value = c.lightMap, l.lightMapIntensity.value = c.lightMapIntensity), c.aoMap && (l.aoMap.value = c.aoMap, l.aoMapIntensity.value = c.aoMapIntensity);
                            var o;
                            c.map ? o = c.map : c.specularMap ? o = c.specularMap : c.displacementMap ? o = c.displacementMap : c.normalMap ? o = c.normalMap : c.bumpMap ? o = c.bumpMap : c.roughnessMap ? o = c.roughnessMap : c.metalnessMap ? o = c.metalnessMap : c.alphaMap ? o = c.alphaMap : c.emissiveMap && (o = c.emissiveMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), b = o.offset, o = o.repeat, l.offsetRepeat.value.set(b.x, b.y, o.x, o.y)), l.envMap.value = c.envMap, l.flipEnvMap.value = c.envMap && c.envMap.isCubeTexture ? -1 : 1, l.reflectivity.value = c.reflectivity, l.refractionRatio.value = c.refractionRatio
                        }
                        c.isLineBasicMaterial ? (l.diffuse.value = c.color, l.opacity.value = c.opacity) : c.isLineDashedMaterial ? (l.diffuse.value = c.color, l.opacity.value = c.opacity, l.dashSize.value = c.dashSize, l.totalSize.value = c.dashSize + c.gapSize, l.scale.value = c.scale) : c.isPointsMaterial ? (l.diffuse.value = c.color, l.opacity.value = c.opacity, l.size.value = c.size * ca, l.scale.value = .5 * _, l.map.value = c.map, null !== c.map && (o = c.map.offset, c = c.map.repeat, l.offsetRepeat.value.set(o.x, o.y, c.x, c.y))) : c.isMeshLambertMaterial ? c.emissiveMap && (l.emissiveMap.value = c.emissiveMap) : c.isMeshToonMaterial ? (r(l, c), c.gradientMap && (l.gradientMap.value = c.gradientMap)) : c.isMeshPhongMaterial ? r(l, c) : c.isMeshPhysicalMaterial ? (l.clearCoat.value = c.clearCoat, l.clearCoatRoughness.value = c.clearCoatRoughness, s(l, c)) : c.isMeshStandardMaterial ? s(l, c) : c.isMeshDepthMaterial ? c.displacementMap && (l.displacementMap.value = c.displacementMap, l.displacementScale.value = c.displacementScale, l.displacementBias.value = c.displacementBias) : c.isMeshNormalMaterial && (c.bumpMap && (l.bumpMap.value = c.bumpMap, l.bumpScale.value = c.bumpScale), c.normalMap && (l.normalMap.value = c.normalMap, l.normalScale.value.copy(c.normalScale)), c.displacementMap && (l.displacementMap.value = c.displacementMap, l.displacementScale.value = c.displacementScale, l.displacementBias.value = c.displacementBias)), void 0 !== l.ltcMat && (l.ltcMat.value = Be.LTC_MAT_TEXTURE), void 0 !== l.ltcMag && (l.ltcMag.value = Be.LTC_MAG_TEXTURE), Q.upload(sa, e.uniformsList, l, I)
                    }
                    return j.setValue(sa, "modelViewMatrix", d.modelViewMatrix), j.setValue(sa, "normalMatrix", d.normalMatrix), j.setValue(sa, "modelMatrix", d.matrixWorld), i
                }

                function r(a, b) {
                    a.specular.value = b.specular, a.shininess.value = Math.max(b.shininess, 1e-4), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias)
                }

                function s(a, b) {
                    a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
                }

                function t(a, b) {
                    var c, d, e, f, g, h, i, j = 0,
                        k = 0,
                        l = 0,
                        m = b.matrixWorldInverse,
                        n = 0,
                        o = 0,
                        p = 0,
                        q = 0,
                        r = 0;
                    for (c = 0, d = a.length; c < d; c++)
                        if (e = a[c], f = e.color, g = e.intensity, h = e.distance, i = e.shadow && e.shadow.map ? e.shadow.map.texture : null, e.isAmbientLight) j += f.r * g, k += f.g * g, l += f.b * g;
                        else if (e.isDirectionalLight) {
                        var s = Ja.get(e);
                        s.color.copy(e.color).multiplyScalar(e.intensity), s.direction.setFromMatrixPosition(e.matrixWorld), ma.setFromMatrixPosition(e.target.matrixWorld), s.direction.sub(ma), s.direction.transformDirection(m), (s.shadow = e.castShadow) && (f = e.shadow, s.shadowBias = f.bias, s.shadowRadius = f.radius, s.shadowMapSize = f.mapSize), pa.directionalShadowMap[n] = i, pa.directionalShadowMatrix[n] = e.shadow.matrix, pa.directional[n] = s, n++
                    } else e.isSpotLight ? (s = Ja.get(e), s.position.setFromMatrixPosition(e.matrixWorld), s.position.applyMatrix4(m), s.color.copy(f).multiplyScalar(g), s.distance = h, s.direction.setFromMatrixPosition(e.matrixWorld), ma.setFromMatrixPosition(e.target.matrixWorld), s.direction.sub(ma), s.direction.transformDirection(m), s.coneCos = Math.cos(e.angle), s.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), s.decay = 0 === e.distance ? 0 : e.decay, (s.shadow = e.castShadow) && (f = e.shadow, s.shadowBias = f.bias, s.shadowRadius = f.radius, s.shadowMapSize = f.mapSize), pa.spotShadowMap[p] = i, pa.spotShadowMatrix[p] = e.shadow.matrix, pa.spot[p] = s, p++) : e.isRectAreaLight ? (s = Ja.get(e), s.color.copy(f).multiplyScalar(g / (e.width * e.height)), s.position.setFromMatrixPosition(e.matrixWorld), s.position.applyMatrix4(m), oa.identity(), na.copy(e.matrixWorld), na.premultiply(m), oa.extractRotation(na), s.halfWidth.set(.5 * e.width, 0, 0), s.halfHeight.set(0, .5 * e.height, 0), s.halfWidth.applyMatrix4(oa), s.halfHeight.applyMatrix4(oa), pa.rectArea[q] = s, q++) : e.isPointLight ? (s = Ja.get(e), s.position.setFromMatrixPosition(e.matrixWorld), s.position.applyMatrix4(m), s.color.copy(e.color).multiplyScalar(e.intensity), s.distance = e.distance, s.decay = 0 === e.distance ? 0 : e.decay, (s.shadow = e.castShadow) && (f = e.shadow, s.shadowBias = f.bias, s.shadowRadius = f.radius, s.shadowMapSize = f.mapSize), pa.pointShadowMap[o] = i, pa.pointShadowMatrix[o] = e.shadow.matrix, pa.point[o] = s, o++) : e.isHemisphereLight && (s = Ja.get(e), s.direction.setFromMatrixPosition(e.matrixWorld), s.direction.transformDirection(m), s.direction.normalize(), s.skyColor.copy(e.color).multiplyScalar(g), s.groundColor.copy(e.groundColor).multiplyScalar(g), pa.hemi[r] = s, r++);
                    pa.ambient[0] = j, pa.ambient[1] = k, pa.ambient[2] = l, pa.directional.length = n, pa.spot.length = p, pa.rectArea.length = q, pa.point.length = o, pa.hemi.length = r, pa.hash = n + "," + o + "," + p + "," + q + "," + r + "," + pa.shadows.length
                }

                function u(a) {
                    var b;
                    if (1e3 === a) return sa.REPEAT;
                    if (1001 === a) return sa.CLAMP_TO_EDGE;
                    if (1002 === a) return sa.MIRRORED_REPEAT;
                    if (1003 === a) return sa.NEAREST;
                    if (1004 === a) return sa.NEAREST_MIPMAP_NEAREST;
                    if (1005 === a) return sa.NEAREST_MIPMAP_LINEAR;
                    if (1006 === a) return sa.LINEAR;
                    if (1007 === a) return sa.LINEAR_MIPMAP_NEAREST;
                    if (1008 === a) return sa.LINEAR_MIPMAP_LINEAR;
                    if (1009 === a) return sa.UNSIGNED_BYTE;
                    if (1017 === a) return sa.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === a) return sa.UNSIGNED_SHORT_5_5_5_1;
                    if (1019 === a) return sa.UNSIGNED_SHORT_5_6_5;
                    if (1010 === a) return sa.BYTE;
                    if (1011 === a) return sa.SHORT;
                    if (1012 === a) return sa.UNSIGNED_SHORT;
                    if (1013 === a) return sa.INT;
                    if (1014 === a) return sa.UNSIGNED_INT;
                    if (1015 === a) return sa.FLOAT;
                    if (1016 === a && (b = ta.get("OES_texture_half_float"), null !== b)) return b.HALF_FLOAT_OES;
                    if (1021 === a) return sa.ALPHA;
                    if (1022 === a) return sa.RGB;
                    if (1023 === a) return sa.RGBA;
                    if (1024 === a) return sa.LUMINANCE;
                    if (1025 === a) return sa.LUMINANCE_ALPHA;
                    if (1026 === a) return sa.DEPTH_COMPONENT;
                    if (1027 === a) return sa.DEPTH_STENCIL;
                    if (100 === a) return sa.FUNC_ADD;
                    if (101 === a) return sa.FUNC_SUBTRACT;
                    if (102 === a) return sa.FUNC_REVERSE_SUBTRACT;
                    if (200 === a) return sa.ZERO;
                    if (201 === a) return sa.ONE;
                    if (202 === a) return sa.SRC_COLOR;
                    if (203 === a) return sa.ONE_MINUS_SRC_COLOR;
                    if (204 === a) return sa.SRC_ALPHA;
                    if (205 === a) return sa.ONE_MINUS_SRC_ALPHA;
                    if (206 === a) return sa.DST_ALPHA;
                    if (207 === a) return sa.ONE_MINUS_DST_ALPHA;
                    if (208 === a) return sa.DST_COLOR;
                    if (209 === a) return sa.ONE_MINUS_DST_COLOR;
                    if (210 === a) return sa.SRC_ALPHA_SATURATE;
                    if ((2001 === a || 2002 === a || 2003 === a || 2004 === a) && (b = ta.get("WEBGL_compressed_texture_s3tc"), null !== b)) {
                        if (2001 === a) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (2002 === a) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (2003 === a) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (2004 === a) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((2100 === a || 2101 === a || 2102 === a || 2103 === a) && (b = ta.get("WEBGL_compressed_texture_pvrtc"), null !== b)) {
                        if (2100 === a) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (2101 === a) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (2102 === a) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (2103 === a) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (2151 === a && (b = ta.get("WEBGL_compressed_texture_etc1"), null !== b)) return b.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((103 === a || 104 === a) && (b = ta.get("EXT_blend_minmax"), null !== b)) {
                        if (103 === a) return b.MIN_EXT;
                        if (104 === a) return b.MAX_EXT
                    }
                    return 1020 === a && (b = ta.get("WEBGL_depth_texture"), null !== b) ? b.UNSIGNED_INT_24_8_WEBGL : 0
                }
                console.log("THREE.WebGLRenderer", "85"), a = a || {};
                var v = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    w = void 0 !== a.context ? a.context : null,
                    x = void 0 !== a.alpha && a.alpha,
                    y = void 0 === a.depth || a.depth,
                    z = void 0 === a.stencil || a.stencil,
                    A = void 0 !== a.antialias && a.antialias,
                    B = void 0 === a.premultipliedAlpha || a.premultipliedAlpha,
                    C = void 0 !== a.preserveDrawingBuffer && a.preserveDrawingBuffer,
                    D = [],
                    E = null,
                    F = new Float32Array(8),
                    G = [],
                    H = [];
                this.domElement = v, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var I = this,
                    J = null,
                    K = null,
                    L = null,
                    M = -1,
                    N = "",
                    O = null,
                    P = new e,
                    S = null,
                    V = new e,
                    X = 0,
                    Y = new R(0),
                    Z = 0,
                    $ = v.width,
                    _ = v.height,
                    ca = 1,
                    da = new e(0, 0, $, _),
                    ea = !1,
                    fa = new e(0, 0, $, _),
                    ga = new aa,
                    ha = new hb,
                    ia = !1,
                    ka = !1,
                    la = new j,
                    ma = new i,
                    na = new j,
                    oa = new j,
                    pa = {
                        hash: "",
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        shadows: []
                    },
                    qa = {
                        geometries: 0,
                        textures: 0
                    },
                    ra = {
                        frame: 0,
                        calls: 0,
                        vertices: 0,
                        faces: 0,
                        points: 0
                    };
                this.info = {
                    render: ra,
                    memory: qa,
                    programs: null
                };
                var sa;
                try {
                    if (x = {
                            alpha: x,
                            depth: y,
                            stencil: z,
                            antialias: A,
                            premultipliedAlpha: B,
                            preserveDrawingBuffer: C
                        }, sa = w || v.getContext("webgl", x) || v.getContext("experimental-webgl", x), null === sa) {
                        if (null !== v.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
                        throw "Error creating WebGL context."
                    }
                    void 0 === sa.getShaderPrecisionFormat && (sa.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }), v.addEventListener("webglcontextlost", d, !1)
                } catch (a) {
                    console.error("THREE.WebGLRenderer: " + a)
                }
                var ta = new gb(sa);
                ta.get("WEBGL_depth_texture"), ta.get("OES_texture_float"), ta.get("OES_texture_float_linear"), ta.get("OES_texture_half_float"), ta.get("OES_texture_half_float_linear"), ta.get("OES_standard_derivatives"), ta.get("ANGLE_instanced_arrays"), ta.get("OES_element_index_uint") && (xa.MaxIndex = 4294967296);
                var ua = new fb(sa, ta, a),
                    va = new eb(sa, ta, u),
                    wa = new db,
                    za = new cb(sa, ta, va, wa, ua, u, qa),
                    Ba = new Ga(sa),
                    Da = new Na(sa, Ba, qa),
                    Ha = new Pa(sa, Da, ra),
                    Ia = new bb(this, ua),
                    Ja = new Oa,
                    Qa = new Ka;
                this.info.programs = Ia.programs;
                var Ra, Sa, Ta, Ua, Va = new Ma(sa, ta, ra),
                    Wa = new La(sa, ta, ra);
                b(), this.context = sa, this.capabilities = ua, this.extensions = ta, this.properties = wa, this.state = va;
                var Xa = new ba(this, pa, Ha, ua);
                this.shadowMap = Xa;
                var Ya = new U(this, G),
                    Za = new T(this, H);
                this.getContext = function() {
                    return sa
                }, this.getContextAttributes = function() {
                    return sa.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var a = ta.get("WEBGL_lose_context");
                    a && a.loseContext()
                }, this.getMaxAnisotropy = function() {
                    return ua.getMaxAnisotropy()
                }, this.getPrecision = function() {
                    return ua.precision
                }, this.getPixelRatio = function() {
                    return ca
                }, this.setPixelRatio = function(a) {
                    void 0 !== a && (ca = a, this.setSize(fa.z, fa.w, !1))
                }, this.getSize = function() {
                    return {
                        width: $,
                        height: _
                    }
                }, this.setSize = function(a, b, c) {
                    $ = a, _ = b, v.width = a * ca, v.height = b * ca, !1 !== c && (v.style.width = a + "px", v.style.height = b + "px"), this.setViewport(0, 0, a, b)
                }, this.setViewport = function(a, b, c, d) {
                    va.viewport(fa.set(a, b, c, d))
                }, this.setScissor = function(a, b, c, d) {
                    va.scissor(da.set(a, b, c, d))
                }, this.setScissorTest = function(a) {
                    va.setScissorTest(ea = a)
                }, this.getClearColor = function() {
                    return Y
                }, this.setClearColor = function(a, b) {
                    Y.set(a), Z = void 0 !== b ? b : 1, va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B)
                }, this.getClearAlpha = function() {
                    return Z
                }, this.setClearAlpha = function(a) {
                    Z = a, va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B)
                }, this.clear = function(a, b, c) {
                    var d = 0;
                    (void 0 === a || a) && (d |= sa.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= sa.DEPTH_BUFFER_BIT), (void 0 === c || c) && (d |= sa.STENCIL_BUFFER_BIT), sa.clear(d)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.clearTarget = function(a, b, c, d) {
                    this.setRenderTarget(a), this.clear(b, c, d)
                }, this.resetGLState = c, this.dispose = function() {
                    v.removeEventListener("webglcontextlost", d, !1), Qa.dispose()
                }, this.renderBufferImmediate = function(a, b, c) {
                    va.initAttributes();
                    var d = wa.get(a);
                    if (a.hasPositions && !d.position && (d.position = sa.createBuffer()), a.hasNormals && !d.normal && (d.normal = sa.createBuffer()), a.hasUvs && !d.uv && (d.uv = sa.createBuffer()), a.hasColors && !d.color && (d.color = sa.createBuffer()), b = b.getAttributes(), a.hasPositions && (sa.bindBuffer(sa.ARRAY_BUFFER, d.position), sa.bufferData(sa.ARRAY_BUFFER, a.positionArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.position), sa.vertexAttribPointer(b.position, 3, sa.FLOAT, !1, 0, 0)), a.hasNormals) {
                        if (sa.bindBuffer(sa.ARRAY_BUFFER, d.normal), !c.isMeshPhongMaterial && !c.isMeshStandardMaterial && !c.isMeshNormalMaterial && 1 === c.shading)
                            for (var e = 0, f = 3 * a.count; e < f; e += 9) {
                                var g = a.normalArray,
                                    h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3,
                                    i = (g[e + 1] + g[e + 4] + g[e + 7]) / 3,
                                    j = (g[e + 2] + g[e + 5] + g[e + 8]) / 3;
                                g[e + 0] = h, g[e + 1] = i, g[e + 2] = j, g[e + 3] = h, g[e + 4] = i, g[e + 5] = j, g[e + 6] = h, g[e + 7] = i, g[e + 8] = j
                            }
                        sa.bufferData(sa.ARRAY_BUFFER, a.normalArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.normal), sa.vertexAttribPointer(b.normal, 3, sa.FLOAT, !1, 0, 0)
                    }
                    a.hasUvs && c.map && (sa.bindBuffer(sa.ARRAY_BUFFER, d.uv), sa.bufferData(sa.ARRAY_BUFFER, a.uvArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.uv), sa.vertexAttribPointer(Ba.uv, 2, sa.FLOAT, !1, 0, 0)), a.hasColors && 0 !== c.vertexColors && (sa.bindBuffer(sa.ARRAY_BUFFER, d.color), sa.bufferData(sa.ARRAY_BUFFER, a.colorArray, sa.DYNAMIC_DRAW), va.enableAttribute(b.color), sa.vertexAttribPointer(b.color, 3, sa.FLOAT, !1, 0, 0)), va.disableUnusedAttributes(), sa.drawArrays(sa.TRIANGLES, 0, a.count), a.count = 0
                }, this.renderBufferDirect = function(a, b, c, d, e, f) {
                    va.setMaterial(d);
                    var g = q(a, b, d, e);
                    a = c.id + "_" + g.id + "_" + (!0 === d.wireframe);
                    var h = !1;
                    if (a !== N && (N = a, h = !0), b = e.morphTargetInfluences, void 0 !== b) {
                        var i = [];
                        a = 0;
                        for (var j = b.length; a < j; a++) h = b[a], i.push([h, a]);
                        i.sort(l), 8 < i.length && (i.length = 8);
                        var k = c.morphAttributes;
                        for (a = 0, j = i.length; a < j; a++) h = i[a], F[a] = h[0], 0 !== h[0] ? (b = h[1], !0 === d.morphTargets && k.position && c.addAttribute("morphTarget" + a, k.position[b]), !0 === d.morphNormals && k.normal && c.addAttribute("morphNormal" + a, k.normal[b])) : (!0 === d.morphTargets && c.removeAttribute("morphTarget" + a), !0 === d.morphNormals && c.removeAttribute("morphNormal" + a));
                        for (a = i.length, b = F.length; a < b; a++) F[a] = 0;
                        g.getUniforms().setValue(sa, "morphTargetInfluences", F), h = !0
                    }
                    if (b = c.index, j = c.attributes.position, i = 1, !0 === d.wireframe && (b = Da.getWireframeAttribute(c), i = 2), a = Va, null !== b && (a = Wa, a.setIndex(b)), h) {
                        if (h = void 0, c && c.isInstancedBufferGeometry && null === ta.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        else {
                            void 0 === h && (h = 0), va.initAttributes();
                            var m, k = c.attributes,
                                g = g.getAttributes(),
                                n = d.defaultAttributeValues;
                            for (m in g) {
                                var o = g[m];
                                if (0 <= o) {
                                    var p = k[m];
                                    if (void 0 !== p) {
                                        var r = p.normalized,
                                            s = p.itemSize,
                                            t = Ba.get(p),
                                            u = t.buffer,
                                            v = t.type,
                                            t = t.bytesPerElement;
                                        if (p.isInterleavedBufferAttribute) {
                                            var w = p.data,
                                                x = w.stride,
                                                p = p.offset;
                                            w && w.isInstancedInterleavedBuffer ? (va.enableAttributeAndDivisor(o, w.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = w.meshPerAttribute * w.count)) : va.enableAttribute(o), sa.bindBuffer(sa.ARRAY_BUFFER, u), sa.vertexAttribPointer(o, s, v, r, x * t, (h * x + p) * t)
                                        } else p.isInstancedBufferAttribute ? (va.enableAttributeAndDivisor(o, p.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = p.meshPerAttribute * p.count)) : va.enableAttribute(o), sa.bindBuffer(sa.ARRAY_BUFFER, u), sa.vertexAttribPointer(o, s, v, r, 0, h * s * t)
                                    } else if (void 0 !== n && (r = n[m], void 0 !== r)) switch (r.length) {
                                        case 2:
                                            sa.vertexAttrib2fv(o, r);
                                            break;
                                        case 3:
                                            sa.vertexAttrib3fv(o, r);
                                            break;
                                        case 4:
                                            sa.vertexAttrib4fv(o, r);
                                            break;
                                        default:
                                            sa.vertexAttrib1fv(o, r)
                                    }
                                }
                            }
                            va.disableUnusedAttributes()
                        }
                        null !== b && sa.bindBuffer(sa.ELEMENT_ARRAY_BUFFER, Ba.get(b).buffer)
                    }
                    if (m = 0, null !== b ? m = b.count : void 0 !== j && (m = j.count), j = c.drawRange.start * i, h = null !== f ? f.start * i : 0, b = Math.max(j, h), f = Math.max(0, Math.min(m, j + c.drawRange.count * i, h + (null !== f ? f.count * i : 1 / 0)) - 1 - b + 1), 0 !== f) {
                        if (e.isMesh)
                            if (!0 === d.wireframe) va.setLineWidth(d.wireframeLinewidth * (null === K ? ca : 1)), a.setMode(sa.LINES);
                            else switch (e.drawMode) {
                                case 0:
                                    a.setMode(sa.TRIANGLES);
                                    break;
                                case 1:
                                    a.setMode(sa.TRIANGLE_STRIP);
                                    break;
                                case 2:
                                    a.setMode(sa.TRIANGLE_FAN)
                            } else e.isLine ? (d = d.linewidth, void 0 === d && (d = 1), va.setLineWidth(d * (null === K ? ca : 1)), e.isLineSegments ? a.setMode(sa.LINES) : e.isLineLoop ? a.setMode(sa.LINE_LOOP) : a.setMode(sa.LINE_STRIP)) : e.isPoints && a.setMode(sa.POINTS);
                        c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, b, f) : a.render(b, f)
                    }
                }, this.compile = function(a, b) {
                    D = [], a.traverse(function(a) {
                        a.isLight && D.push(a)
                    }), t(D, b), a.traverse(function(b) {
                        if (b.material)
                            if (Array.isArray(b.material))
                                for (var c = 0; c < b.material.length; c++) p(b.material[c], a.fog, b);
                            else p(b.material, a.fog, b)
                    })
                }, this.render = function(a, b, c, d) {
                    if (void 0 !== b && !0 !== b.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    else {
                        N = "", M = -1, O = null, !0 === a.autoUpdate && a.updateMatrixWorld(), b.onBeforeRender(I), null === b.parent && b.updateMatrixWorld(), b.matrixWorldInverse.getInverse(b.matrixWorld), la.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), ga.setFromMatrix(la), D.length = 0, G.length = 0, H.length = 0, ka = this.localClippingEnabled, ia = ha.init(this.clippingPlanes, ka, b), E = Qa.get(a, b), E.init(), m(a, b, I.sortObjects), E.finish(), !0 === I.sortObjects && E.sort(), ia && ha.beginShadows();
                        for (var e = D, f = 0, g = 0, h = e.length; g < h; g++) {
                            var i = e[g];
                            i.castShadow && (pa.shadows[f] = i, f++)
                        }
                        pa.shadows.length = f, Xa.render(a, b), t(D, b), ia && ha.endShadows(), ra.frame++, ra.calls = 0, ra.vertices = 0, ra.faces = 0, ra.points = 0, void 0 === c && (c = null), this.setRenderTarget(c), e = a.background, null === e ? va.buffers.color.setClear(Y.r, Y.g, Y.b, Z, B) : e && e.isColor && (va.buffers.color.setClear(e.r, e.g, e.b, 1, B), d = !0), (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), e && e.isCubeTexture ? (void 0 === Ta && (Ta = new Ea, Ua = new ya(new Aa(5, 5, 5), new W({
                            uniforms: Ee.cube.uniforms,
                            vertexShader: Ee.cube.vertexShader,
                            fragmentShader: Ee.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))), Ta.projectionMatrix.copy(b.projectionMatrix), Ta.matrixWorld.extractRotation(b.matrixWorld), Ta.matrixWorldInverse.getInverse(Ta.matrixWorld), Ua.material.uniforms.tCube.value = e, Ua.modelViewMatrix.multiplyMatrices(Ta.matrixWorldInverse, Ua.matrixWorld), Ha.update(Ua), I.renderBufferDirect(Ta, null, Ua.geometry, Ua.material, Ua, null)) : e && e.isTexture && (void 0 === Ra && (Ra = new Fa(-1, 1, 1, -1, 0, 1), Sa = new ya(new Ca(2, 2), new ja({
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))), Sa.material.map = e, Ha.update(Sa), I.renderBufferDirect(Ra, null, Sa.geometry, Sa.material, Sa, null)), d = E.opaque, e = E.transparent, a.overrideMaterial ? (f = a.overrideMaterial, d.length && n(d, a, b, f), e.length && n(e, a, b, f)) : (d.length && n(d, a, b), e.length && n(e, a, b)), Ya.render(a, b), Za.render(a, b, V), c && za.updateRenderTargetMipmap(c), va.buffers.depth.setTest(!0), va.buffers.depth.setMask(!0), va.buffers.color.setMask(!0), b.isArrayCamera && b.enabled && I.setScissorTest(!1), b.onAfterRender(I)
                    }
                }, this.setFaceCulling = function(a, b) {
                    va.setCullFace(a), va.setFlipSided(0 === b)
                }, this.allocTextureUnit = function() {
                    var a = X;
                    return a >= ua.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + ua.maxTextures), X += 1, a
                }, this.setTexture2D = function() {
                    var a = !1;
                    return function(b, c) {
                        b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture), za.setTexture2D(b, c)
                    }
                }(), this.setTexture = function() {
                    var a = !1;
                    return function(b, c) {
                        a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0), za.setTexture2D(b, c)
                    }
                }(), this.setTextureCube = function() {
                    var a = !1;
                    return function(b, c) {
                        b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture), b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? za.setTextureCube(b, c) : za.setTextureCubeDynamic(b, c)
                    }
                }(), this.getRenderTarget = function() {
                    return K
                }, this.setRenderTarget = function(a) {
                    (K = a) && void 0 === wa.get(a).__webglFramebuffer && za.setupRenderTarget(a);
                    var b, c = a && a.isWebGLRenderTargetCube;
                    a ? (b = wa.get(a), b = c ? b.__webglFramebuffer[a.activeCubeFace] : b.__webglFramebuffer, P.copy(a.scissor), S = a.scissorTest, V.copy(a.viewport)) : (b = null, P.copy(da).multiplyScalar(ca), S = ea, V.copy(fa).multiplyScalar(ca)), L !== b && (sa.bindFramebuffer(sa.FRAMEBUFFER, b), L = b), va.scissor(P), va.setScissorTest(S), va.viewport(V), c && (c = wa.get(a.texture), sa.framebufferTexture2D(sa.FRAMEBUFFER, sa.COLOR_ATTACHMENT0, sa.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel))
                }, this.readRenderTargetPixels = function(a, b, c, d, e, f) {
                    if (!1 === (a && a.isWebGLRenderTarget)) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    else {
                        var g = wa.get(a).__webglFramebuffer;
                        if (g) {
                            var h = !1;
                            g !== L && (sa.bindFramebuffer(sa.FRAMEBUFFER, g), h = !0);
                            try {
                                var i = a.texture,
                                    j = i.format,
                                    k = i.type;
                                1023 !== j && u(j) !== sa.getParameter(sa.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === k || u(k) === sa.getParameter(sa.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === k && (ta.get("OES_texture_float") || ta.get("WEBGL_color_buffer_float")) || 1016 === k && ta.get("EXT_color_buffer_half_float") ? sa.checkFramebufferStatus(sa.FRAMEBUFFER) === sa.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && sa.readPixels(b, c, d, e, u(j), u(k), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                            } finally {
                                h && sa.bindFramebuffer(sa.FRAMEBUFFER, L)
                            }
                        }
                    }
                }
            }

            function jb(a, b) {
                this.name = "", this.color = new R(a), this.density = void 0 !== b ? b : 25e-5
            }

            function kb(a, b, c) {
                this.name = "", this.color = new R(a), this.near = void 0 !== b ? b : 1, this.far = void 0 !== c ? c : 1e3
            }

            function lb() {
                fa.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
            }

            function mb(a, b, c, d, e) {
                fa.call(this), this.lensFlares = [], this.positionScreen = new i, this.customUpdateCallback = void 0, void 0 !== a && this.add(a, b, c, d, e)
            }

            function nb(a) {
                V.call(this), this.type = "SpriteMaterial", this.color = new R(16777215), this.map = null, this.rotation = 0, this.lights = this.fog = !1, this.setValues(a)
            }

            function ob(a) {
                fa.call(this), this.type = "Sprite", this.material = void 0 !== a ? a : new nb
            }

            function pb() {
                fa.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function qb(a, b) {
                if (a = a || [], this.bones = a.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === b) this.calculateInverses();
                else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var c = 0, d = this.bones.length; c < d; c++) this.boneInverses.push(new j)
                }
            }

            function rb() {
                fa.call(this), this.type = "Bone"
            }

            function sb(a, b) {
                ya.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new j, this.bindMatrixInverse = new j;
                var c = this.initBones(),
                    c = new qb(c);
                this.bind(c, this.matrixWorld), this.normalizeSkinWeights()
            }

            function tb(a) {
                V.call(this), this.type = "LineBasicMaterial", this.color = new R(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(a)
            }

            function ub(a, b, c) {
                return 1 === c ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new vb(a, b)) : (fa.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new xa, void(this.material = void 0 !== b ? b : new tb({
                    color: 16777215 * Math.random()
                })))
            }

            function vb(a, b) {
                ub.call(this, a, b), this.type = "LineSegments"
            }

            function wb(a, b) {
                ub.call(this, a, b), this.type = "LineLoop"
            }

            function xb(a) {
                V.call(this), this.type = "PointsMaterial", this.color = new R(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(a)
            }

            function yb(a, b) {
                fa.call(this), this.type = "Points", this.geometry = void 0 !== a ? a : new xa, this.material = void 0 !== b ? b : new xb({
                    color: 16777215 * Math.random()
                })
            }

            function zb() {
                fa.call(this), this.type = "Group"
            }

            function Ab(a, b, c, e, f, g, h, i, j) {
                function k() {
                    requestAnimationFrame(k), a.readyState >= a.HAVE_CURRENT_DATA && (l.needsUpdate = !0)
                }
                d.call(this, a, b, c, e, f, g, h, i, j), this.generateMipmaps = !1;
                var l = this;
                k()
            }

            function Bb(a, b, c, e, f, g, h, i, j, k, l, m) {
                d.call(this, null, g, h, i, j, k, e, f, l, m), this.image = {
                    width: b,
                    height: c
                }, this.mipmaps = a, this.generateMipmaps = this.flipY = !1
            }

            function Cb(a, b, c, e, f, g, h, i, j) {
                d.call(this, a, b, c, e, f, g, h, i, j), this.needsUpdate = !0
            }

            function Db(a, b, c, e, f, g, h, i, j, k) {
                if (k = void 0 !== k ? k : 1026, 1026 !== k && 1027 !== k) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === c && 1026 === k && (c = 1012), void 0 === c && 1027 === k && (c = 1020), d.call(this, null, e, f, g, h, i, k, c, j), this.image = {
                    width: a,
                    height: b
                }, this.magFilter = void 0 !== h ? h : 1003, this.minFilter = void 0 !== i ? i : 1003, this.generateMipmaps = this.flipY = !1
            }

            function Eb(a) {
                xa.call(this), this.type = "WireframeGeometry";
                var b, c, d, e, f, g, h = [],
                    j = [0, 0],
                    k = {},
                    l = ["a", "b", "c"];
                if (a && a.isGeometry) {
                    var m = a.faces;
                    for (b = 0, d = m.length; b < d; b++) {
                        var n = m[b];
                        for (c = 0; 3 > c; c++) f = n[l[c]], g = n[l[(c + 1) % 3]], j[0] = Math.min(f, g), j[1] = Math.max(f, g), f = j[0] + "," + j[1], void 0 === k[f] && (k[f] = {
                            index1: j[0],
                            index2: j[1]
                        })
                    }
                    for (f in k) b = k[f], l = a.vertices[b.index1], h.push(l.x, l.y, l.z), l = a.vertices[b.index2], h.push(l.x, l.y, l.z)
                } else if (a && a.isBufferGeometry) {
                    var o, l = new i;
                    if (null !== a.index) {
                        for (m = a.attributes.position, n = a.index, o = a.groups, 0 === o.length && (o = [{
                                start: 0,
                                count: n.count,
                                materialIndex: 0
                            }]), a = 0, e = o.length; a < e; ++a)
                            for (b = o[a], c = b.start, d = b.count, b = c, d = c + d; b < d; b += 3)
                                for (c = 0; 3 > c; c++) f = n.getX(b + c), g = n.getX(b + (c + 1) % 3), j[0] = Math.min(f, g), j[1] = Math.max(f, g), f = j[0] + "," + j[1], void 0 === k[f] && (k[f] = {
                                    index1: j[0],
                                    index2: j[1]
                                });
                        for (f in k) b = k[f], l.fromBufferAttribute(m, b.index1), h.push(l.x, l.y, l.z), l.fromBufferAttribute(m, b.index2), h.push(l.x, l.y, l.z)
                    } else
                        for (m = a.attributes.position, b = 0, d = m.count / 3; b < d; b++)
                            for (c = 0; 3 > c; c++) k = 3 * b + c, l.fromBufferAttribute(m, k), h.push(l.x, l.y, l.z), k = 3 * b + (c + 1) % 3, l.fromBufferAttribute(m, k), h.push(l.x, l.y, l.z)
                }
                this.addAttribute("position", new sa(h, 3))
            }

            function Fb(a, b, c) {
                wa.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: a,
                    slices: b,
                    stacks: c
                }, this.fromBufferGeometry(new Gb(a, b, c)), this.mergeVertices()
            }

            function Gb(a, b, c) {
                xa.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: a,
                    slices: b,
                    stacks: c
                };
                var d, e, f = [],
                    g = [],
                    h = [],
                    j = [],
                    k = new i,
                    l = new i,
                    m = new i,
                    n = new i,
                    o = new i,
                    p = b + 1;
                for (d = 0; d <= c; d++) {
                    var q = d / c;
                    for (e = 0; e <= b; e++) {
                        var r = e / b,
                            l = a(r, q, l);
                        g.push(l.x, l.y, l.z), 0 <= r - 1e-5 ? (m = a(r - 1e-5, q, m), n.subVectors(l, m)) : (m = a(r + 1e-5, q, m), n.subVectors(m, l)), 0 <= q - 1e-5 ? (m = a(r, q - 1e-5, m), o.subVectors(l, m)) : (m = a(r, q + 1e-5, m), o.subVectors(m, l)), k.crossVectors(n, o).normalize(), h.push(k.x, k.y, k.z), j.push(r, q)
                    }
                }
                for (d = 0; d < c; d++)
                    for (e = 0; e < b; e++) a = d * p + e + 1, k = (d + 1) * p + e + 1, l = (d + 1) * p + e, f.push(d * p + e, a, l), f.push(a, k, l);
                this.setIndex(f), this.addAttribute("position", new sa(g, 3)), this.addAttribute("normal", new sa(h, 3)), this.addAttribute("uv", new sa(j, 2))
            }

            function Hb(a, b, c, d) {
                wa.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: a,
                    indices: b,
                    radius: c,
                    detail: d
                }, this.fromBufferGeometry(new Ib(a, b, c, d)), this.mergeVertices()
            }

            function Ib(a, b, d, e) {
                function f(a) {
                    j.push(a.x, a.y, a.z)
                }

                function g(b, c) {
                    var d = 3 * b;
                    c.x = a[d + 0], c.y = a[d + 1], c.z = a[d + 2]
                }

                function h(a, b, c, d) {
                    0 > d && 1 === a.x && (k[b] = a.x - 1), 0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5)
                }
                xa.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: a,
                    indices: b,
                    radius: d,
                    detail: e
                }, d = d || 1;
                var j = [],
                    k = [];
                ! function(a) {
                    for (var c = new i, d = new i, e = new i, h = 0; h < b.length; h += 3) {
                        g(b[h + 0], c), g(b[h + 1], d), g(b[h + 2], e);
                        var j, k, l = c,
                            m = d,
                            n = e,
                            o = Math.pow(2, a),
                            p = [];
                        for (j = 0; j <= o; j++) {
                            p[j] = [];
                            var q = l.clone().lerp(n, j / o),
                                r = m.clone().lerp(n, j / o),
                                s = o - j;
                            for (k = 0; k <= s; k++) p[j][k] = 0 === k && j === o ? q : q.clone().lerp(r, k / s)
                        }
                        for (j = 0; j < o; j++)
                            for (k = 0; k < 2 * (o - j) - 1; k++) l = Math.floor(k / 2), 0 === k % 2 ? (f(p[j][l + 1]), f(p[j + 1][l]), f(p[j][l])) : (f(p[j][l + 1]), f(p[j + 1][l + 1]), f(p[j + 1][l]))
                    }
                }(e || 0),
                function(a) {
                    for (var b = new i, c = 0; c < j.length; c += 3) b.x = j[c + 0], b.y = j[c + 1], b.z = j[c + 2], b.normalize().multiplyScalar(a), j[c + 0] = b.x, j[c + 1] = b.y, j[c + 2] = b.z
                }(d),
                function() {
                    for (var a = new i, b = 0; b < j.length; b += 3) a.x = j[b + 0], a.y = j[b + 1], a.z = j[b + 2], k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
                    for (var a = new i, b = new i, d = new i, e = new i, f = new c, g = new c, l = new c, m = 0, n = 0; m < j.length; m += 9, n += 6) {
                        a.set(j[m + 0], j[m + 1], j[m + 2]), b.set(j[m + 3], j[m + 4], j[m + 5]), d.set(j[m + 6], j[m + 7], j[m + 8]), f.set(k[n + 0], k[n + 1]), g.set(k[n + 2], k[n + 3]), l.set(k[n + 4], k[n + 5]), e.copy(a).add(b).add(d).divideScalar(3);
                        var o = Math.atan2(e.z, -e.x);
                        h(f, n + 0, a, o), h(g, n + 2, b, o), h(l, n + 4, d, o)
                    }
                    for (a = 0; a < k.length; a += 6) b = k[a + 0], d = k[a + 2], e = k[a + 4], f = Math.min(b, d, e), .9 < Math.max(b, d, e) && .1 > f && (.2 > b && (k[a + 0] += 1), .2 > d && (k[a + 2] += 1), .2 > e && (k[a + 4] += 1))
                }(), this.addAttribute("position", new sa(j, 3)), this.addAttribute("normal", new sa(j.slice(), 3)), this.addAttribute("uv", new sa(k, 2)), this.normalizeNormals()
            }

            function Jb(a, b) {
                wa.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }, this.fromBufferGeometry(new Kb(a, b)), this.mergeVertices()
            }

            function Kb(a, b) {
                Ib.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }
            }

            function Lb(a, b) {
                wa.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }, this.fromBufferGeometry(new Mb(a, b)), this.mergeVertices()
            }

            function Mb(a, b) {
                Ib.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }
            }

            function Nb(a, b) {
                wa.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }, this.fromBufferGeometry(new Ob(a, b)), this.mergeVertices()
            }

            function Ob(a, b) {
                var c = (1 + Math.sqrt(5)) / 2;
                Ib.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }
            }

            function Pb(a, b) {
                wa.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }, this.fromBufferGeometry(new Qb(a, b)), this.mergeVertices()
            }

            function Qb(a, b) {
                var c = (1 + Math.sqrt(5)) / 2,
                    d = 1 / c;
                Ib.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: a,
                    detail: b
                }
            }

            function Rb(a, b, c, d, e, f) {
                wa.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: a,
                    tubularSegments: b,
                    radius: c,
                    radialSegments: d,
                    closed: e
                }, void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."), a = new Sb(a, b, c, d, e), this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Sb(a, b, d, e, f) {
                function g(c) {
                    var f = a.getPointAt(c / b),
                        g = h.normals[c];
                    for (c = h.binormals[c], k = 0; k <= e; k++) {
                        var i = k / e * Math.PI * 2,
                            j = Math.sin(i),
                            i = -Math.cos(i);
                        m.x = i * g.x + j * c.x, m.y = i * g.y + j * c.y, m.z = i * g.z + j * c.z, m.normalize(), p.push(m.x, m.y, m.z), l.x = f.x + d * m.x, l.y = f.y + d * m.y, l.z = f.z + d * m.z, o.push(l.x, l.y, l.z)
                    }
                }
                xa.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: a,
                    tubularSegments: b,
                    radius: d,
                    radialSegments: e,
                    closed: f
                }, b = b || 64, d = d || 1, e = e || 8, f = f || !1;
                var h = a.computeFrenetFrames(b, f);
                this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals;
                var j, k, l = new i,
                    m = new i,
                    n = new c,
                    o = [],
                    p = [],
                    q = [],
                    r = [];
                for (j = 0; j < b; j++) g(j);
                for (g(!1 === f ? b : 0), j = 0; j <= b; j++)
                    for (k = 0; k <= e; k++) n.x = j / b, n.y = k / e, q.push(n.x, n.y);
                ! function() {
                    for (k = 1; k <= b; k++)
                        for (j = 1; j <= e; j++) {
                            var a = (e + 1) * k + (j - 1),
                                c = (e + 1) * k + j,
                                d = (e + 1) * (k - 1) + j;
                            r.push((e + 1) * (k - 1) + (j - 1), a, d), r.push(a, c, d)
                        }
                }(), this.setIndex(r), this.addAttribute("position", new sa(o, 3)), this.addAttribute("normal", new sa(p, 3)), this.addAttribute("uv", new sa(q, 2))
            }

            function Tb(a, b, c, d, e, f, g) {
                wa.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: a,
                    tube: b,
                    tubularSegments: c,
                    radialSegments: d,
                    p: e,
                    q: f
                }, void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Ub(a, b, c, d, e, f)), this.mergeVertices()
            }

            function Ub(a, b, c, d, e, f) {
                function g(a, b, c, d, e) {
                    var f = Math.sin(a);
                    b = c / b * a, c = Math.cos(b), e.x = d * (2 + c) * .5 * Math.cos(a), e.y = d * (2 + c) * f * .5, e.z = d * Math.sin(b) * .5
                }
                xa.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: a,
                    tube: b,
                    tubularSegments: c,
                    radialSegments: d,
                    p: e,
                    q: f
                }, a = a || 100, b = b || 40, c = Math.floor(c) || 64, d = Math.floor(d) || 8, e = e || 2, f = f || 3;
                var h, j, k = [],
                    l = [],
                    m = [],
                    n = [],
                    o = new i,
                    p = new i,
                    q = new i,
                    r = new i,
                    s = new i,
                    t = new i,
                    u = new i;
                for (h = 0; h <= c; ++h)
                    for (j = h / c * e * Math.PI * 2, g(j, e, f, a, q), g(j + .01, e, f, a, r), t.subVectors(r, q), u.addVectors(r, q), s.crossVectors(t, u), u.crossVectors(s, t), s.normalize(), u.normalize(), j = 0; j <= d; ++j) {
                        var v = j / d * Math.PI * 2,
                            w = -b * Math.cos(v),
                            v = b * Math.sin(v);
                        o.x = q.x + (w * u.x + v * s.x), o.y = q.y + (w * u.y + v * s.y), o.z = q.z + (w * u.z + v * s.z), l.push(o.x, o.y, o.z), p.subVectors(o, q).normalize(), m.push(p.x, p.y, p.z), n.push(h / c), n.push(j / d)
                    }
                for (j = 1; j <= c; j++)
                    for (h = 1; h <= d; h++) a = (d + 1) * j + (h - 1), b = (d + 1) * j + h, e = (d + 1) * (j - 1) + h, k.push((d + 1) * (j - 1) + (h - 1), a, e), k.push(a, b, e);
                this.setIndex(k), this.addAttribute("position", new sa(l, 3)), this.addAttribute("normal", new sa(m, 3)), this.addAttribute("uv", new sa(n, 2))
            }

            function Vb(a, b, c, d, e) {
                wa.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: a,
                    tube: b,
                    radialSegments: c,
                    tubularSegments: d,
                    arc: e
                }, this.fromBufferGeometry(new Wb(a, b, c, d, e)), this.mergeVertices()
            }

            function Wb(a, b, c, d, e) {
                xa.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: a,
                    tube: b,
                    radialSegments: c,
                    tubularSegments: d,
                    arc: e
                }, a = a || 100, b = b || 40, c = Math.floor(c) || 8, d = Math.floor(d) || 6, e = e || 2 * Math.PI;
                var f, g, h = [],
                    j = [],
                    k = [],
                    l = [],
                    m = new i,
                    n = new i,
                    o = new i;
                for (f = 0; f <= c; f++)
                    for (g = 0; g <= d; g++) {
                        var p = g / d * e,
                            q = f / c * Math.PI * 2;
                        n.x = (a + b * Math.cos(q)) * Math.cos(p), n.y = (a + b * Math.cos(q)) * Math.sin(p), n.z = b * Math.sin(q), j.push(n.x, n.y, n.z), m.x = a * Math.cos(p), m.y = a * Math.sin(p), o.subVectors(n, m).normalize(), k.push(o.x, o.y, o.z), l.push(g / d), l.push(f / c)
                    }
                for (f = 1; f <= c; f++)
                    for (g = 1; g <= d; g++) a = (d + 1) * (f - 1) + g - 1, b = (d + 1) * (f - 1) + g, e = (d + 1) * f + g, h.push((d + 1) * f + g - 1, a, e), h.push(a, b, e);
                this.setIndex(h), this.addAttribute("position", new sa(j, 3)), this.addAttribute("normal", new sa(k, 3)), this.addAttribute("uv", new sa(l, 2))
            }

            function Xb(a, b) {
                wa.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: a,
                    options: b
                }, this.fromBufferGeometry(new Yb(a, b)), this.mergeVertices()
            }

            function Yb(a, b) {
                "undefined" != typeof a && (xa.call(this), this.type = "ExtrudeBufferGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeVertexNormals())
            }

            function Zb(a, b) {
                wa.call(this), this.type = "TextGeometry", this.parameters = {
                    text: a,
                    parameters: b
                }, this.fromBufferGeometry(new $b(a, b)), this.mergeVertices()
            }

            function $b(a, b) {
                b = b || {};
                var c = b.font;
                return !1 === (c && c.isFont) ? (console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new wa) : (c = c.generateShapes(a, b.size, b.curveSegments), b.amount = void 0 !== b.height ? b.height : 50, void 0 === b.bevelThickness && (b.bevelThickness = 10), void 0 === b.bevelSize && (b.bevelSize = 8), void 0 === b.bevelEnabled && (b.bevelEnabled = !1), Yb.call(this, c, b), void(this.type = "TextBufferGeometry"))
            }

            function _b(a, b, c, d, e, f, g) {
                wa.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: a,
                    widthSegments: b,
                    heightSegments: c,
                    phiStart: d,
                    phiLength: e,
                    thetaStart: f,
                    thetaLength: g
                }, this.fromBufferGeometry(new ac(a, b, c, d, e, f, g)), this.mergeVertices()
            }

            function ac(a, b, c, d, e, f, g) {
                xa.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: a,
                    widthSegments: b,
                    heightSegments: c,
                    phiStart: d,
                    phiLength: e,
                    thetaStart: f,
                    thetaLength: g
                }, a = a || 50, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : Math.PI;
                var h, j, k = f + g,
                    l = 0,
                    m = [],
                    n = new i,
                    o = new i,
                    p = [],
                    q = [],
                    r = [],
                    s = [];
                for (j = 0; j <= c; j++) {
                    var t = [],
                        u = j / c;
                    for (h = 0; h <= b; h++) {
                        var v = h / b;
                        n.x = -a * Math.cos(d + v * e) * Math.sin(f + u * g), n.y = a * Math.cos(f + u * g), n.z = a * Math.sin(d + v * e) * Math.sin(f + u * g), q.push(n.x, n.y, n.z), o.set(n.x, n.y, n.z).normalize(), r.push(o.x, o.y, o.z), s.push(v, 1 - u), t.push(l++)
                    }
                    m.push(t)
                }
                for (j = 0; j < c; j++)
                    for (h = 0; h < b; h++) a = m[j][h + 1], d = m[j][h], e = m[j + 1][h], g = m[j + 1][h + 1], (0 !== j || 0 < f) && p.push(a, d, g), (j !== c - 1 || k < Math.PI) && p.push(d, e, g);
                this.setIndex(p), this.addAttribute("position", new sa(q, 3)), this.addAttribute("normal", new sa(r, 3)), this.addAttribute("uv", new sa(s, 2))
            }

            function bc(a, b, c, d, e, f) {
                wa.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: a,
                    outerRadius: b,
                    thetaSegments: c,
                    phiSegments: d,
                    thetaStart: e,
                    thetaLength: f
                }, this.fromBufferGeometry(new cc(a, b, c, d, e, f)), this.mergeVertices()
            }

            function cc(a, b, d, e, f, g) {
                xa.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: a,
                    outerRadius: b,
                    thetaSegments: d,
                    phiSegments: e,
                    thetaStart: f,
                    thetaLength: g
                }, a = a || 20, b = b || 50, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : 2 * Math.PI, d = void 0 !== d ? Math.max(3, d) : 8, e = void 0 !== e ? Math.max(1, e) : 1;
                var h, j, k = [],
                    l = [],
                    m = [],
                    n = [],
                    o = a,
                    p = (b - a) / e,
                    q = new i,
                    r = new c;
                for (h = 0; h <= e; h++) {
                    for (j = 0; j <= d; j++) a = f + j / d * g, q.x = o * Math.cos(a), q.y = o * Math.sin(a), l.push(q.x, q.y, q.z), m.push(0, 0, 1), r.x = (q.x / b + 1) / 2, r.y = (q.y / b + 1) / 2, n.push(r.x, r.y);
                    o += p
                }
                for (h = 0; h < e; h++)
                    for (b = h * (d + 1), j = 0; j < d; j++) a = j + b, f = a + d + 1, g = a + d + 2, o = a + 1, k.push(a, f, o), k.push(f, g, o);
                this.setIndex(k), this.addAttribute("position", new sa(l, 3)), this.addAttribute("normal", new sa(m, 3)), this.addAttribute("uv", new sa(n, 2))
            }

            function dc(a, b, c, d) {
                wa.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: a,
                    segments: b,
                    phiStart: c,
                    phiLength: d
                }, this.fromBufferGeometry(new ec(a, b, c, d)), this.mergeVertices()
            }

            function ec(a, b, d, e) {
                xa.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: a,
                    segments: b,
                    phiStart: d,
                    phiLength: e
                }, b = Math.floor(b) || 12, d = d || 0, e = e || 2 * Math.PI, e = re.clamp(e, 0, 2 * Math.PI);
                var f, g, h = [],
                    j = [],
                    k = [],
                    l = 1 / b,
                    m = new i,
                    n = new c;
                for (f = 0; f <= b; f++) {
                    g = d + f * l * e;
                    var o = Math.sin(g),
                        p = Math.cos(g);
                    for (g = 0; g <= a.length - 1; g++) m.x = a[g].x * o, m.y = a[g].y, m.z = a[g].x * p, j.push(m.x, m.y, m.z), n.x = f / b, n.y = g / (a.length - 1), k.push(n.x, n.y)
                }
                for (f = 0; f < b; f++)
                    for (g = 0; g < a.length - 1; g++) d = g + f * a.length, l = d + a.length, m = d + a.length + 1, n = d + 1, h.push(d, l, n), h.push(l, m, n);
                if (this.setIndex(h), this.addAttribute("position", new sa(j, 3)), this.addAttribute("uv", new sa(k, 2)), this.computeVertexNormals(), e === 2 * Math.PI)
                    for (e = this.attributes.normal.array, h = new i, j = new i, k = new i, d = b * a.length * 3, g = f = 0; f < a.length; f++, g += 3) h.x = e[g + 0], h.y = e[g + 1], h.z = e[g + 2], j.x = e[d + g + 0], j.y = e[d + g + 1], j.z = e[d + g + 2], k.addVectors(h, j).normalize(), e[g + 0] = e[d + g + 0] = k.x, e[g + 1] = e[d + g + 1] = k.y, e[g + 2] = e[d + g + 2] = k.z
            }

            function fc(a, b) {
                wa.call(this), this.type = "ShapeGeometry", "object" == typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments), this.parameters = {
                    shapes: a,
                    curveSegments: b
                }, this.fromBufferGeometry(new gc(a, b)), this.mergeVertices()
            }

            function gc(a, b) {
                function c(a) {
                    var c, h, j = e.length / 3;
                    a = a.extractPoints(b);
                    var k = a.shape,
                        l = a.holes;
                    if (!1 === Je.isClockWise(k))
                        for (k = k.reverse(), a = 0, c = l.length; a < c; a++) h = l[a], !0 === Je.isClockWise(h) && (l[a] = h.reverse());
                    var m = Je.triangulateShape(k, l);
                    for (a = 0, c = l.length; a < c; a++) h = l[a], k = k.concat(h);
                    for (a = 0, c = k.length; a < c; a++) h = k[a], e.push(h.x, h.y, 0), f.push(0, 0, 1), g.push(h.x, h.y);
                    for (a = 0, c = m.length; a < c; a++) k = m[a], d.push(k[0] + j, k[1] + j, k[2] + j), i += 3
                }
                xa.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: a,
                    curveSegments: b
                }, b = b || 12;
                var d = [],
                    e = [],
                    f = [],
                    g = [],
                    h = 0,
                    i = 0;
                if (!1 === Array.isArray(a)) c(a);
                else
                    for (var j = 0; j < a.length; j++) c(a[j]), this.addGroup(h, i, j), h += i, i = 0;
                this.setIndex(d), this.addAttribute("position", new sa(e, 3)), this.addAttribute("normal", new sa(f, 3)), this.addAttribute("uv", new sa(g, 2))
            }

            function hc(a, b) {
                xa.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: b
                };
                var c, d, e, f = [],
                    g = Math.cos(re.DEG2RAD * (void 0 !== b ? b : 1)),
                    h = [0, 0],
                    i = {},
                    j = ["a", "b", "c"];
                a.isBufferGeometry ? (e = new wa, e.fromBufferGeometry(a)) : e = a.clone(), e.mergeVertices(), e.computeFaceNormals();
                var k = e.vertices;
                e = e.faces;
                for (var l = 0, m = e.length; l < m; l++)
                    for (var n = e[l], o = 0; 3 > o; o++) c = n[j[o]], d = n[j[(o + 1) % 3]], h[0] = Math.min(c, d), h[1] = Math.max(c, d), c = h[0] + "," + h[1], void 0 === i[c] ? i[c] = {
                        index1: h[0],
                        index2: h[1],
                        face1: l,
                        face2: void 0
                    } : i[c].face2 = l;
                for (c in i) h = i[c], (void 0 === h.face2 || e[h.face1].normal.dot(e[h.face2].normal) <= g) && (j = k[h.index1], f.push(j.x, j.y, j.z), j = k[h.index2], f.push(j.x, j.y, j.z));
                this.addAttribute("position", new sa(f, 3))
            }

            function ic(a, b, c, d, e, f, g, h) {
                wa.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: a,
                    radiusBottom: b,
                    height: c,
                    radialSegments: d,
                    heightSegments: e,
                    openEnded: f,
                    thetaStart: g,
                    thetaLength: h
                }, this.fromBufferGeometry(new jc(a, b, c, d, e, f, g, h)), this.mergeVertices()
            }

            function jc(a, b, d, e, f, g, h, j) {
                function k(d) {
                    var f, g, k, r = new c,
                        u = new i,
                        v = 0,
                        w = !0 === d ? a : b,
                        x = !0 === d ? 1 : -1;
                    for (g = q, f = 1; f <= e; f++) n.push(0, s * x, 0), o.push(0, x, 0), p.push(.5, .5), q++;
                    for (k = q, f = 0; f <= e; f++) {
                        var y = f / e * j + h,
                            z = Math.cos(y),
                            y = Math.sin(y);
                        u.x = w * y, u.y = s * x, u.z = w * z, n.push(u.x, u.y, u.z), o.push(0, x, 0), r.x = .5 * z + .5, r.y = .5 * y * x + .5, p.push(r.x, r.y), q++
                    }
                    for (f = 0; f < e; f++) r = g + f, u = k + f, !0 === d ? m.push(u, u + 1, r) : m.push(u + 1, u, r), v += 3;
                    l.addGroup(t, v, !0 === d ? 1 : 2), t += v
                }
                xa.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: a,
                    radiusBottom: b,
                    height: d,
                    radialSegments: e,
                    heightSegments: f,
                    openEnded: g,
                    thetaStart: h,
                    thetaLength: j
                };
                var l = this;
                a = void 0 !== a ? a : 20, b = void 0 !== b ? b : 20, d = void 0 !== d ? d : 100, e = Math.floor(e) || 8, f = Math.floor(f) || 1, g = void 0 !== g && g, h = void 0 !== h ? h : 0, j = void 0 !== j ? j : 2 * Math.PI;
                var m = [],
                    n = [],
                    o = [],
                    p = [],
                    q = 0,
                    r = [],
                    s = d / 2,
                    t = 0;
                ! function() {
                    var c, g, k = new i,
                        u = new i,
                        v = 0,
                        w = (b - a) / d;
                    for (g = 0; g <= f; g++) {
                        var x = [],
                            y = g / f,
                            z = y * (b - a) + a;
                        for (c = 0; c <= e; c++) {
                            var A = c / e,
                                B = A * j + h,
                                C = Math.sin(B),
                                B = Math.cos(B);
                            u.x = z * C, u.y = -y * d + s, u.z = z * B, n.push(u.x, u.y, u.z), k.set(C, w, B).normalize(), o.push(k.x, k.y, k.z), p.push(A, 1 - y), x.push(q++)
                        }
                        r.push(x)
                    }
                    for (c = 0; c < e; c++)
                        for (g = 0; g < f; g++) k = r[g + 1][c], u = r[g + 1][c + 1], w = r[g][c + 1], m.push(r[g][c], k, w), m.push(k, u, w), v += 6;
                    l.addGroup(t, v, 0), t += v
                }(), !1 === g && (0 < a && k(!0), 0 < b && k(!1)), this.setIndex(m), this.addAttribute("position", new sa(n, 3)), this.addAttribute("normal", new sa(o, 3)), this.addAttribute("uv", new sa(p, 2))
            }

            function kc(a, b, c, d, e, f, g) {
                ic.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeGeometry", this.parameters = {
                    radius: a,
                    height: b,
                    radialSegments: c,
                    heightSegments: d,
                    openEnded: e,
                    thetaStart: f,
                    thetaLength: g
                }
            }

            function lc(a, b, c, d, e, f, g) {
                jc.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: a,
                    height: b,
                    radialSegments: c,
                    heightSegments: d,
                    openEnded: e,
                    thetaStart: f,
                    thetaLength: g
                }
            }

            function mc(a, b, c, d) {
                wa.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: a,
                    segments: b,
                    thetaStart: c,
                    thetaLength: d
                }, this.fromBufferGeometry(new nc(a, b, c, d)), this.mergeVertices()
            }

            function nc(a, b, d, e) {
                xa.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: a,
                    segments: b,
                    thetaStart: d,
                    thetaLength: e
                }, a = a || 50, b = void 0 !== b ? Math.max(3, b) : 8, d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI;
                var f, g, h = [],
                    j = [],
                    k = [],
                    l = [],
                    m = new i,
                    n = new c;
                for (j.push(0, 0, 0), k.push(0, 0, 1), l.push(.5, .5), g = 0, f = 3; g <= b; g++, f += 3) {
                    var o = d + g / b * e;
                    m.x = a * Math.cos(o), m.y = a * Math.sin(o), j.push(m.x, m.y, m.z), k.push(0, 0, 1), n.x = (j[f] / a + 1) / 2, n.y = (j[f + 1] / a + 1) / 2, l.push(n.x, n.y)
                }
                for (f = 1; f <= b; f++) h.push(f, f + 1, 0);
                this.setIndex(h), this.addAttribute("position", new sa(j, 3)), this.addAttribute("normal", new sa(k, 3)), this.addAttribute("uv", new sa(l, 2))
            }

            function oc(a) {
                W.call(this, {
                    uniforms: Ce.merge([Be.lights, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: De.shadow_vert,
                    fragmentShader: De.shadow_frag
                }), this.transparent = this.lights = !0, Object.defineProperties(this, {
                    opacity: {
                        enumerable: !0,
                        get: function() {
                            return this.uniforms.opacity.value
                        },
                        set: function(a) {
                            this.uniforms.opacity.value = a
                        }
                    }
                }), this.setValues(a)
            }

            function pc(a) {
                W.call(this, a), this.type = "RawShaderMaterial"
            }

            function qc(a) {
                V.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new R(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new R(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
            }

            function rc(a) {
                qc.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(a)
            }

            function sc(a) {
                V.call(this), this.type = "MeshPhongMaterial", this.color = new R(16777215), this.specular = new R(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new R(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
            }

            function tc(a) {
                sc.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(a)
            }

            function uc(a) {
                V.call(this, a), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(a)
            }

            function vc(a) {
                V.call(this), this.type = "MeshLambertMaterial", this.color = new R(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new R(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
            }

            function wc(a) {
                V.call(this), this.type = "LineDashedMaterial", this.color = new R(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(a)
            }

            function xc(a, b, c) {
                var d = this,
                    e = !1,
                    f = 0,
                    g = 0;
                this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function(a) {
                    g++, !1 === e && void 0 !== d.onStart && d.onStart(a, f, g), e = !0
                }, this.itemEnd = function(a) {
                    f++, void 0 !== d.onProgress && d.onProgress(a, f, g), f === g && (e = !1, void 0 !== d.onLoad) && d.onLoad()
                }, this.itemError = function(a) {
                    void 0 !== d.onError && d.onError(a)
                }
            }

            function yc(a) {
                this.manager = void 0 !== a ? a : Ne
            }

            function zc(a) {
                this.manager = void 0 !== a ? a : Ne, this._parser = null
            }

            function Ac(a) {
                this.manager = void 0 !== a ? a : Ne, this._parser = null
            }

            function Bc(a) {
                this.manager = void 0 !== a ? a : Ne
            }

            function Cc(a) {
                this.manager = void 0 !== a ? a : Ne
            }

            function Dc(a) {
                this.manager = void 0 !== a ? a : Ne
            }

            function Ec(a, b) {
                fa.call(this), this.type = "Light", this.color = new R(a), this.intensity = void 0 !== b ? b : 1, this.receiveShadow = void 0
            }

            function Fc(a, b, c) {
                Ec.call(this, a, c), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(fa.DefaultUp), this.updateMatrix(), this.groundColor = new R(b)
            }

            function Gc(a) {
                this.camera = a, this.bias = 0, this.radius = 1, this.mapSize = new c(512, 512), this.map = null, this.matrix = new j
            }

            function Hc() {
                Gc.call(this, new Ea(50, 1, .5, 500))
            }

            function Ic(a, b, c, d, e, f) {
                Ec.call(this, a, b), this.type = "SpotLight", this.position.copy(fa.DefaultUp), this.updateMatrix(), this.target = new fa, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(a) {
                        this.intensity = a / Math.PI
                    }
                }), this.distance = void 0 !== c ? c : 0, this.angle = void 0 !== d ? d : Math.PI / 3, this.penumbra = void 0 !== e ? e : 0, this.decay = void 0 !== f ? f : 1, this.shadow = new Hc
            }

            function Jc(a, b, c, d) {
                Ec.call(this, a, b), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(a) {
                        this.intensity = a / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== c ? c : 0, this.decay = void 0 !== d ? d : 1, this.shadow = new Gc(new Ea(90, 1, .5, 500))
            }

            function Kc() {
                Gc.call(this, new Fa(-5, 5, 5, -5, .5, 500))
            }

            function Lc(a, b) {
                Ec.call(this, a, b), this.type = "DirectionalLight", this.position.copy(fa.DefaultUp), this.updateMatrix(), this.target = new fa, this.shadow = new Kc
            }

            function Mc(a, b) {
                Ec.call(this, a, b), this.type = "AmbientLight", this.castShadow = void 0
            }

            function Nc(a, b, c, d) {
                Ec.call(this, a, b), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== c ? c : 10, this.height = void 0 !== d ? d : 10
            }

            function Oc(a, b, c, d) {
                this.parameterPositions = a, this._cachedIndex = 0, this.resultBuffer = void 0 !== d ? d : new b.constructor(c), this.sampleValues = b, this.valueSize = c
            }

            function Pc(a, b, c, d) {
                Oc.call(this, a, b, c, d), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
            }

            function Qc(a, b, c, d) {
                Oc.call(this, a, b, c, d)
            }

            function Rc(a, b, c, d) {
                Oc.call(this, a, b, c, d)
            }

            function Sc(a, b, c, d) {
                if (void 0 === a) throw Error("track name is undefined");
                if (void 0 === b || 0 === b.length) throw Error("no keyframes in track named " + a);
                this.name = a, this.times = Oe.convertArray(b, this.TimeBufferType), this.values = Oe.convertArray(c, this.ValueBufferType), this.setInterpolation(d || this.DefaultInterpolation), this.validate(), this.optimize()
            }

            function Tc(a, b, c, d) {
                Sc.call(this, a, b, c, d)
            }

            function Uc(a, b, c, d) {
                Oc.call(this, a, b, c, d)
            }

            function Vc(a, b, c, d) {
                Sc.call(this, a, b, c, d)
            }

            function Wc(a, b, c, d) {
                Sc.call(this, a, b, c, d)
            }

            function Xc(a, b, c, d) {
                Sc.call(this, a, b, c, d)
            }

            function Yc(a, b, c) {
                Sc.call(this, a, b, c)
            }

            function Zc(a, b, c, d) {
                Sc.call(this, a, b, c, d)
            }

            function $c(a, b, c, d) {
                Sc.apply(this, arguments)
            }

            function _c(a, b, c) {
                this.name = a, this.tracks = c, this.duration = void 0 !== b ? b : -1, this.uuid = re.generateUUID(), 0 > this.duration && this.resetDuration(), this.optimize()
            }

            function ad(a) {
                this.manager = void 0 !== a ? a : Ne, this.textures = {}
            }

            function bd(a) {
                this.manager = void 0 !== a ? a : Ne
            }

            function cd() {
                this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
            }

            function dd(a) {
                "boolean" == typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0), this.manager = void 0 !== a ? a : Ne, this.withCredentials = !1
            }

            function ed(a) {
                this.manager = void 0 !== a ? a : Ne, this.texturePath = ""
            }

            function fd(a, b, c, d, e) {
                b = .5 * (d - b), e = .5 * (e - c);
                var f = a * a;
                return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c
            }

            function gd(a, b, c, d) {
                var e = 1 - a;
                return e * e * b + 2 * (1 - a) * a * c + a * a * d
            }

            function hd(a, b, c, d, e) {
                var f = 1 - a,
                    g = 1 - a;
                return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
            }

            function id() {
                this.arcLengthDivisions = 200
            }

            function jd(a, b) {
                this.arcLengthDivisions = 200, this.v1 = a, this.v2 = b
            }

            function kd() {
                this.arcLengthDivisions = 200, this.curves = [], this.autoClose = !1
            }

            function ld(a, b, c, d, e, f, g, h) {
                this.arcLengthDivisions = 200, this.aX = a, this.aY = b, this.xRadius = c, this.yRadius = d, this.aStartAngle = e, this.aEndAngle = f, this.aClockwise = g, this.aRotation = h || 0
            }

            function md(a) {
                this.arcLengthDivisions = 200, this.points = void 0 === a ? [] : a
            }

            function nd(a, b, c, d) {
                this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
            }

            function od(a, b, c) {
                this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c
            }

            function pd(a) {
                kd.call(this), this.currentPoint = new c, a && this.fromPoints(a)
            }

            function qd() {
                pd.apply(this, arguments), this.holes = []
            }

            function rd() {
                this.subPaths = [], this.currentPath = null
            }

            function sd(a) {
                this.data = a
            }

            function td(a) {
                this.manager = void 0 !== a ? a : Ne
            }

            function ud(a) {
                this.manager = void 0 !== a ? a : Ne
            }

            function vd() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Ea, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ea, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function wd(a, b, c) {
                fa.call(this), this.type = "CubeCamera";
                var d = new Ea(90, 1, a, b);
                d.up.set(0, -1, 0), d.lookAt(new i(1, 0, 0)), this.add(d);
                var e = new Ea(90, 1, a, b);
                e.up.set(0, -1, 0), e.lookAt(new i(-1, 0, 0)), this.add(e);
                var f = new Ea(90, 1, a, b);
                f.up.set(0, 0, 1), f.lookAt(new i(0, 1, 0)), this.add(f);
                var h = new Ea(90, 1, a, b);
                h.up.set(0, 0, -1), h.lookAt(new i(0, -1, 0)), this.add(h);
                var j = new Ea(90, 1, a, b);
                j.up.set(0, -1, 0), j.lookAt(new i(0, 0, 1)), this.add(j);
                var k = new Ea(90, 1, a, b);
                k.up.set(0, -1, 0), k.lookAt(new i(0, 0, -1)), this.add(k), this.renderTarget = new g(c, c, {
                    format: 1022,
                    magFilter: 1006,
                    minFilter: 1006
                }), this.renderTarget.texture.name = "CubeCamera", this.updateCubeMap = function(a, b) {
                    null === this.parent && this.updateMatrixWorld();
                    var c = this.renderTarget,
                        g = c.texture.generateMipmaps;
                    c.texture.generateMipmaps = !1, c.activeCubeFace = 0, a.render(b, d, c), c.activeCubeFace = 1, a.render(b, e, c), c.activeCubeFace = 2, a.render(b, f, c), c.activeCubeFace = 3, a.render(b, h, c), c.activeCubeFace = 4, a.render(b, j, c), c.texture.generateMipmaps = g, c.activeCubeFace = 5, a.render(b, k, c), a.setRenderTarget(null)
                }
            }

            function xd(a) {
                Ea.call(this), this.enabled = !1, this.cameras = a || []
            }

            function yd() {
                fa.call(this), this.type = "AudioListener", this.context = We.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
            }

            function zd(a) {
                fa.call(this), this.type = "Audio", this.context = a.context, this.gain = this.context.createGain(), this.gain.connect(a.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function Ad(a) {
                zd.call(this, a), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function Bd(a, b) {
                this.analyser = a.context.createAnalyser(), this.analyser.fftSize = void 0 !== b ? b : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), a.getOutput().connect(this.analyser)
            }

            function Cd(a, b, c) {
                switch (this.binding = a, this.valueSize = c, a = Float64Array, b) {
                    case "quaternion":
                        b = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        a = Array, b = this._select;
                        break;
                    default:
                        b = this._lerp
                }
                this.buffer = new a(4 * c), this._mixBufferRegion = b, this.referenceCount = this.useCount = this.cumulativeWeight = 0
            }

            function Dd(a, b, c) {
                c = c || Ed.parseTrackName(b), this._targetGroup = a, this._bindings = a.subscribe_(b, c)
            }

            function Ed(a, b, c) {
                this.path = b, this.parsedPath = c || Ed.parseTrackName(b), this.node = Ed.findNode(a, this.parsedPath.nodeName) || a, this.rootNode = a
            }

            function Fd(a) {
                this.uuid = re.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var b = {};
                this._indicesByUUID = b;
                for (var c = 0, d = arguments.length; c !== d; ++c) b[arguments[c].uuid] = c;
                this._paths = [], this._parsedPaths = [],
                    this._bindings = [], this._bindingsIndicesByPath = {};
                var e = this;
                this.stats = {
                    objects: {
                        get total() {
                            return e._objects.length
                        },
                        get inUse() {
                            return this.total - e.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return e._bindings.length
                    }
                }
            }

            function Gd(a, b, c) {
                this._mixer = a, this._clip = b, this._localRoot = c || null, a = b.tracks, b = a.length, c = Array(b);
                for (var d = {
                        endingStart: 2400,
                        endingEnd: 2400
                    }, e = 0; e !== b; ++e) {
                    var f = a[e].createInterpolant(null);
                    c[e] = f, f.settings = d
                }
                this._interpolantSettings = d, this._interpolants = c, this._propertyBindings = Array(b), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
            }

            function Hd(a) {
                this._root = a, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
            }

            function Id(a, b) {
                "string" == typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b), this.value = a
            }

            function Jd() {
                xa.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function Kd(a, b, c, d) {
                this.uuid = re.generateUUID(), this.data = a, this.itemSize = b, this.offset = c, this.normalized = !0 === d
            }

            function Ld(a, b) {
                this.uuid = re.generateUUID(), this.array = a, this.stride = b, this.count = void 0 !== a ? a.length / b : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.onUploadCallback = function() {}, this.version = 0
            }

            function Md(a, b, c) {
                Ld.call(this, a, b), this.meshPerAttribute = c || 1
            }

            function Nd(a, b, c) {
                ka.call(this, a, b), this.meshPerAttribute = c || 1
            }

            function Od(a, b, c, d) {
                this.ray = new ca(a, b), this.near = c || 0, this.far = d || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function Pd(a, b) {
                return a.distance - b.distance
            }

            function Qd(a, b, c, d) {
                if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
                    a = a.children, d = 0;
                    for (var e = a.length; d < e; d++) Qd(a[d], b, c, !0)
                }
            }

            function Rd(a) {
                this.autoStart = void 0 === a || a, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
            }

            function Sd(a, b, c) {
                return this.radius = void 0 !== a ? a : 1, this.phi = void 0 !== b ? b : 0, this.theta = void 0 !== c ? c : 0, this
            }

            function Td(a, b, c) {
                return this.radius = void 0 !== a ? a : 1, this.theta = void 0 !== b ? b : 0, this.y = void 0 !== c ? c : 0, this
            }

            function Ud(a, b) {
                ya.call(this, a, b), this.animationsMap = {}, this.animationsList = [];
                var c = this.geometry.morphTargets.length;
                this.createAnimation("__default", 0, c - 1, c / 1), this.setAnimationWeight("__default", 1)
            }

            function Vd(a) {
                fa.call(this), this.material = a, this.render = function(a) {}
            }

            function Wd(a, b, c, d) {
                this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16711680, d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count), c = new xa, b = new sa(6 * b, 3), c.addAttribute("position", b), vb.call(this, c, new tb({
                    color: a,
                    linewidth: d
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Xd(a) {
                fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, a = new xa;
                for (var b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], c = 0, d = 1; 32 > c; c++, d++) {
                    var e = c / 32 * Math.PI * 2,
                        f = d / 32 * Math.PI * 2;
                    b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
                }
                a.addAttribute("position", new sa(b, 3)), b = new tb({
                    fog: !1
                }), this.cone = new vb(a, b), this.add(this.cone), this.update()
            }

            function Yd(a) {
                this.bones = this.getBoneList(a);
                for (var b = new xa, c = [], d = [], e = new R(0, 0, 1), f = new R(0, 1, 0), g = 0; g < this.bones.length; g++) {
                    var h = this.bones[g];
                    h.parent && h.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), d.push(e.r, e.g, e.b), d.push(f.r, f.g, f.b))
                }
                b.addAttribute("position", new sa(c, 3)), b.addAttribute("color", new sa(d, 3)), c = new tb({
                    vertexColors: 2,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                }), vb.call(this, b, c), this.root = a, this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function Zd(a, b) {
                this.light = a, this.light.updateMatrixWorld();
                var c = new ac(b, 4, 2),
                    d = new ja({
                        wireframe: !0,
                        fog: !1
                    });
                d.color.copy(this.light.color), ya.call(this, c, d), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
            }

            function $d(a) {
                fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, a = new tb({
                    color: a.color
                });
                var b = new xa;
                b.addAttribute("position", new ka(new Float32Array(15), 3)), this.add(new ub(b, a)), this.update()
            }

            function _d(a, b) {
                fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
                var c = new Mb(b);
                c.rotateY(.5 * Math.PI);
                var d = new ja({
                        vertexColors: 2,
                        wireframe: !0
                    }),
                    e = c.getAttribute("position"),
                    e = new Float32Array(3 * e.count);
                c.addAttribute("color", new ka(e, 3)), this.add(new ya(c, d)), this.update()
            }

            function ae(a, b, c, d) {
                a = a || 10, b = b || 10, c = new R(void 0 !== c ? c : 4473924), d = new R(void 0 !== d ? d : 8947848);
                var e = b / 2,
                    f = a / b,
                    g = a / 2;
                a = [];
                for (var h = [], i = 0, j = 0, k = -g; i <= b; i++, k += f) {
                    a.push(-g, 0, k, g, 0, k), a.push(k, 0, -g, k, 0, g);
                    var l = i === e ? c : d;
                    l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), j += 3
                }
                b = new xa, b.addAttribute("position", new sa(a, 3)), b.addAttribute("color", new sa(h, 3)), c = new tb({
                    vertexColors: 2
                }), vb.call(this, b, c)
            }

            function be(a, b, c, d, e, f) {
                a = a || 10, b = b || 16, c = c || 8, d = d || 64, e = new R(void 0 !== e ? e : 4473924), f = new R(void 0 !== f ? f : 8947848);
                var g, h, i, j, k, l = [],
                    m = [];
                for (i = 0; i <= b; i++) h = i / b * 2 * Math.PI, g = Math.sin(h) * a, h = Math.cos(h) * a, l.push(0, 0, 0), l.push(g, 0, h), k = 1 & i ? e : f, m.push(k.r, k.g, k.b), m.push(k.r, k.g, k.b);
                for (i = 0; i <= c; i++)
                    for (k = 1 & i ? e : f, j = a - a / c * i, b = 0; b < d; b++) h = b / d * 2 * Math.PI, g = Math.sin(h) * j, h = Math.cos(h) * j, l.push(g, 0, h), m.push(k.r, k.g, k.b), h = (b + 1) / d * 2 * Math.PI, g = Math.sin(h) * j, h = Math.cos(h) * j, l.push(g, 0, h), m.push(k.r, k.g, k.b);
                a = new xa, a.addAttribute("position", new sa(l, 3)), a.addAttribute("color", new sa(m, 3)), l = new tb({
                    vertexColors: 2
                }), vb.call(this, a, l)
            }

            function ce(a, b, c, d) {
                this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16776960, d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), c = new xa, b = new sa(6 * b, 3), c.addAttribute("position", b), vb.call(this, c, new tb({
                    color: a,
                    linewidth: d
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function de(a, b) {
                fa.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, void 0 === b && (b = 1);
                var c = new xa;
                c.addAttribute("position", new sa([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
                var d = new tb({
                    fog: !1
                });
                this.add(new ub(c, d)), c = new xa, c.addAttribute("position", new sa([0, 0, 0, 0, 0, 1], 3)), this.add(new ub(c, d)), this.update()
            }

            function ee(a) {
                function b(a, b, d) {
                    c(a, d), c(b, d)
                }

                function c(a, b) {
                    f.push(0, 0, 0), g.push(b.r, b.g, b.b), void 0 === h[a] && (h[a] = []), h[a].push(f.length / 3 - 1)
                }
                var d = new xa,
                    e = new tb({
                        color: 16777215,
                        vertexColors: 1
                    }),
                    f = [],
                    g = [],
                    h = {},
                    i = new R(16755200),
                    j = new R(16711680),
                    k = new R(43775),
                    l = new R(16777215),
                    m = new R(3355443);
                b("n1", "n2", i), b("n2", "n4", i), b("n4", "n3", i), b("n3", "n1", i), b("f1", "f2", i), b("f2", "f4", i), b("f4", "f3", i), b("f3", "f1", i), b("n1", "f1", i), b("n2", "f2", i), b("n3", "f3", i), b("n4", "f4", i), b("p", "n1", j), b("p", "n2", j), b("p", "n3", j), b("p", "n4", j), b("u1", "u2", k), b("u2", "u3", k), b("u3", "u1", k), b("c", "t", l), b("p", "c", m), b("cn1", "cn2", m), b("cn3", "cn4", m), b("cf1", "cf2", m), b("cf3", "cf4", m), d.addAttribute("position", new sa(f, 3)), d.addAttribute("color", new sa(g, 3)), vb.call(this, d, e), this.camera = a, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = h, this.update()
            }

            function fe(a, b) {
                this.object = a, void 0 === b && (b = 16776960);
                var c = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    d = new Float32Array(24),
                    e = new xa;
                e.setIndex(new ka(c, 1)), e.addAttribute("position", new ka(d, 3)), vb.call(this, e, new tb({
                    color: b
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function ge(a, b, c, d, e, f) {
                fa.call(this), void 0 === d && (d = 16776960), void 0 === c && (c = 1), void 0 === e && (e = .2 * c), void 0 === f && (f = .2 * e), void 0 === Xe && (Xe = new xa, Xe.addAttribute("position", new sa([0, 0, 0, 0, 1, 0], 3)), Ye = new jc(0, .5, 1, 5, 1), Ye.translate(0, -.5, 0)), this.position.copy(b), this.line = new ub(Xe, new tb({
                    color: d
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ya(Ye, new ja({
                    color: d
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(a), this.setLength(c, e, f)
            }

            function he(a) {
                a = a || 1;
                var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
                a = new xa, a.addAttribute("position", new sa(b, 3)), a.addAttribute("color", new sa([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), b = new tb({
                    vertexColors: 2
                }), vb.call(this, a, b)
            }

            function ie() {
                var a = 0,
                    b = 0,
                    c = 0,
                    d = 0;
                return {
                    initCatmullRom: function(e, f, g, h, i) {
                        e = i * (g - e), h = i * (h - f), a = f, b = e, c = -3 * f + 3 * g - 2 * e - h, d = 2 * f - 2 * g + e + h
                    },
                    initNonuniformCatmullRom: function(e, f, g, h, i, j, k) {
                        e = ((f - e) / i - (g - e) / (i + j) + (g - f) / j) * j, h = ((g - f) / j - (h - f) / (j + k) + (h - g) / k) * j, a = f, b = e, c = -3 * f + 3 * g - 2 * e - h, d = 2 * f - 2 * g + e + h
                    },
                    calc: function(e) {
                        var f = e * e;
                        return a + b * e + c * f + d * f * e
                    }
                }
            }

            function je(a) {
                this.arcLengthDivisions = 200, this.points = a || [], this.closed = !1
            }

            function ke(a, b, c, d) {
                this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
            }

            function le(a, b, c) {
                this.arcLengthDivisions = 200, this.v0 = a, this.v1 = b, this.v2 = c
            }

            function me(a, b) {
                this.arcLengthDivisions = 200, this.v1 = a, this.v2 = b
            }

            function ne(a, b, c, d, e, f) {
                ld.call(this, a, b, c, c, d, e, f)
            }

            function oe(a) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), je.call(this, a), this.type = "catmullrom", this.closed = !0
            }

            function pe(a) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), je.call(this, a), this.type = "catmullrom"
            }

            function qe(a) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), je.call(this, a), this.type = "catmullrom"
            }
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(a) {
                return "number" == typeof a && isFinite(a) && Math.floor(a) === a
            }), void 0 === Math.sign && (Math.sign = function(a) {
                return 0 > a ? -1 : 0 < a ? 1 : +a
            }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && function() {
                Object.assign = function(a) {
                    if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
                    for (var b = Object(a), c = 1; c < arguments.length; c++) {
                        var d = arguments[c];
                        if (void 0 !== d && null !== d)
                            for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
                    }
                    return b
                }
            }(), Object.assign(b.prototype, {
                addEventListener: function(a, b) {
                    void 0 === this._listeners && (this._listeners = {});
                    var c = this._listeners;
                    void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b)
                },
                hasEventListener: function(a, b) {
                    if (void 0 === this._listeners) return !1;
                    var c = this._listeners;
                    return void 0 !== c[a] && -1 !== c[a].indexOf(b)
                },
                removeEventListener: function(a, b) {
                    if (void 0 !== this._listeners) {
                        var c = this._listeners[a];
                        if (void 0 !== c) {
                            var d = c.indexOf(b); - 1 !== d && c.splice(d, 1)
                        }
                    }
                },
                dispatchEvent: function(a) {
                    if (void 0 !== this._listeners) {
                        var b = this._listeners[a.type];
                        if (void 0 !== b) {
                            a.target = this;
                            var c, d = [],
                                e = b.length;
                            for (c = 0; c < e; c++) d[c] = b[c];
                            for (c = 0; c < e; c++) d[c].call(this, a)
                        }
                    }
                }
            });
            var re = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                        c = Array(36),
                        d = 0;
                    return function() {
                        for (var e = 0; 36 > e; e++) 8 === e || 13 === e || 18 === e || 23 === e ? c[e] = "-" : 14 === e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), a = 15 & d, d >>= 4, c[e] = b[19 === e ? 3 & a | 8 : a]);
                        return c.join("")
                    }
                }(),
                clamp: function(a, b, c) {
                    return Math.max(b, Math.min(c, a))
                },
                euclideanModulo: function(a, b) {
                    return (a % b + b) % b
                },
                mapLinear: function(a, b, c, d, e) {
                    return d + (a - b) * (e - d) / (c - b)
                },
                lerp: function(a, b, c) {
                    return (1 - c) * a + c * b
                },
                smoothstep: function(a, b, c) {
                    return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a))
                },
                smootherstep: function(a, b, c) {
                    return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10))
                },
                randInt: function(a, b) {
                    return a + Math.floor(Math.random() * (b - a + 1))
                },
                randFloat: function(a, b) {
                    return a + Math.random() * (b - a)
                },
                randFloatSpread: function(a) {
                    return a * (.5 - Math.random())
                },
                degToRad: function(a) {
                    return a * re.DEG2RAD
                },
                radToDeg: function(a) {
                    return a * re.RAD2DEG
                },
                isPowerOfTwo: function(a) {
                    return 0 === (a & a - 1) && 0 !== a
                },
                nearestPowerOfTwo: function(a) {
                    return Math.pow(2, Math.round(Math.log(a) / Math.LN2))
                },
                nextPowerOfTwo: function(a) {
                    return a--, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, a++, a
                }
            };
            Object.defineProperties(c.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(a) {
                        this.x = a
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(a) {
                        this.y = a
                    }
                }
            }), Object.assign(c.prototype, {
                isVector2: !0,
                set: function(a, b) {
                    return this.x = a, this.y = b, this
                },
                setScalar: function(a) {
                    return this.y = this.x = a, this
                },
                setX: function(a) {
                    return this.x = a, this
                },
                setY: function(a) {
                    return this.y = a, this
                },
                setComponent: function(a, b) {
                    switch (a) {
                        case 0:
                            this.x = b;
                            break;
                        case 1:
                            this.y = b;
                            break;
                        default:
                            throw Error("index is out of range: " + a)
                    }
                    return this
                },
                getComponent: function(a) {
                    switch (a) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw Error("index is out of range: " + a)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(a) {
                    return this.x = a.x, this.y = a.y, this
                },
                add: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this)
                },
                addScalar: function(a) {
                    return this.x += a, this.y += a, this
                },
                addVectors: function(a, b) {
                    return this.x = a.x + b.x, this.y = a.y + b.y, this
                },
                addScaledVector: function(a, b) {
                    return this.x += a.x * b, this.y += a.y * b, this
                },
                sub: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this)
                },
                subScalar: function(a) {
                    return this.x -= a, this.y -= a, this
                },
                subVectors: function(a, b) {
                    return this.x = a.x - b.x, this.y = a.y - b.y, this
                },
                multiply: function(a) {
                    return this.x *= a.x, this.y *= a.y, this
                },
                multiplyScalar: function(a) {
                    return this.x *= a, this.y *= a, this
                },
                divide: function(a) {
                    return this.x /= a.x, this.y /= a.y, this
                },
                divideScalar: function(a) {
                    return this.multiplyScalar(1 / a)
                },
                min: function(a) {
                    return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this
                },
                max: function(a) {
                    return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this
                },
                clamp: function(a, b) {
                    return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this
                },
                clampScalar: function() {
                    var a = new c,
                        b = new c;
                    return function(c, d) {
                        return a.set(c, c), b.set(d, d), this.clamp(a, b)
                    }
                }(),
                clampLength: function(a, b) {
                    var c = this.length();
                    return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(a) {
                    return this.x * a.x + this.y * a.y
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                angle: function() {
                    var a = Math.atan2(this.y, this.x);
                    return 0 > a && (a += 2 * Math.PI), a
                },
                distanceTo: function(a) {
                    return Math.sqrt(this.distanceToSquared(a))
                },
                distanceToSquared: function(a) {
                    var b = this.x - a.x;
                    return a = this.y - a.y, b * b + a * a
                },
                distanceToManhattan: function(a) {
                    return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
                },
                setLength: function(a) {
                    return this.multiplyScalar(a / this.length())
                },
                lerp: function(a, b) {
                    return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this
                },
                lerpVectors: function(a, b, c) {
                    return this.subVectors(b, a).multiplyScalar(c).add(a)
                },
                equals: function(a) {
                    return a.x === this.x && a.y === this.y
                },
                fromArray: function(a, b) {
                    return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this
                },
                toArray: function(a, b) {
                    return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a
                },
                fromBufferAttribute: function(a, b, c) {
                    return void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this
                },
                rotateAround: function(a, b) {
                    var c = Math.cos(b),
                        d = Math.sin(b),
                        e = this.x - a.x,
                        f = this.y - a.y;
                    return this.x = e * c - f * d + a.x, this.y = e * d + f * c + a.y, this
                }
            });
            var se = 0;
            d.DEFAULT_IMAGE = void 0, d.DEFAULT_MAPPING = 300, Object.defineProperty(d.prototype, "needsUpdate", {
                set: function(a) {
                    !0 === a && this.version++
                }
            }), Object.assign(d.prototype, b.prototype, {
                constructor: d,
                isTexture: !0,
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.name = a.name, this.image = a.image, this.mipmaps = a.mipmaps.slice(0), this.mapping = a.mapping, this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, this.minFilter = a.minFilter, this.anisotropy = a.anisotropy, this.format = a.format, this.type = a.type, this.offset.copy(a.offset), this.repeat.copy(a.repeat), this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this.encoding = a.encoding, this
                },
                toJSON: function(a) {
                    if (void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
                    var b = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        wrap: [this.wrapS, this.wrapT],
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var c = this.image;
                        if (void 0 === c.uuid && (c.uuid = re.generateUUID()), void 0 === a.images[c.uuid]) {
                            var d, e = a.images,
                                f = c.uuid,
                                g = c.uuid;
                            void 0 !== c.toDataURL ? d = c : (d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), d.width = c.width, d.height = c.height, d.getContext("2d").drawImage(c, 0, 0, c.width, c.height)), d = 2048 < d.width || 2048 < d.height ? d.toDataURL("image/jpeg", .6) : d.toDataURL("image/png"), e[f] = {
                                uuid: g,
                                url: d
                            }
                        }
                        b.image = c.uuid
                    }
                    return a.textures[this.uuid] = b
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(a) {
                    if (300 === this.mapping) {
                        if (a.multiply(this.repeat), a.add(this.offset), 0 > a.x || 1 < a.x) switch (this.wrapS) {
                            case 1e3:
                                a.x -= Math.floor(a.x);
                                break;
                            case 1001:
                                a.x = 0 > a.x ? 0 : 1;
                                break;
                            case 1002:
                                a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
                        }
                        if (0 > a.y || 1 < a.y) switch (this.wrapT) {
                            case 1e3:
                                a.y -= Math.floor(a.y);
                                break;
                            case 1001:
                                a.y = 0 > a.y ? 0 : 1;
                                break;
                            case 1002:
                                a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
                        }
                        this.flipY && (a.y = 1 - a.y)
                    }
                }
            }), Object.assign(e.prototype, {
                isVector4: !0,
                set: function(a, b, c, d) {
                    return this.x = a, this.y = b, this.z = c, this.w = d, this
                },
                setScalar: function(a) {
                    return this.w = this.z = this.y = this.x = a, this
                },
                setX: function(a) {
                    return this.x = a, this
                },
                setY: function(a) {
                    return this.y = a, this
                },
                setZ: function(a) {
                    return this.z = a, this
                },
                setW: function(a) {
                    return this.w = a, this
                },
                setComponent: function(a, b) {
                    switch (a) {
                        case 0:
                            this.x = b;
                            break;
                        case 1:
                            this.y = b;
                            break;
                        case 2:
                            this.z = b;
                            break;
                        case 3:
                            this.w = b;
                            break;
                        default:
                            throw Error("index is out of range: " + a)
                    }
                    return this
                },
                getComponent: function(a) {
                    switch (a) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw Error("index is out of range: " + a)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(a) {
                    return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, this
                },
                add: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this)
                },
                addScalar: function(a) {
                    return this.x += a, this.y += a, this.z += a, this.w += a, this
                },
                addVectors: function(a, b) {
                    return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
                },
                addScaledVector: function(a, b) {
                    return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, this
                },
                sub: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this)
                },
                subScalar: function(a) {
                    return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this
                },
                subVectors: function(a, b) {
                    return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
                },
                multiplyScalar: function(a) {
                    return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this
                },
                applyMatrix4: function(a) {
                    var b = this.x,
                        c = this.y,
                        d = this.z,
                        e = this.w;
                    return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e, this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e, this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e, this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e, this
                },
                divideScalar: function(a) {
                    return this.multiplyScalar(1 / a)
                },
                setAxisAngleFromQuaternion: function(a) {
                    this.w = 2 * Math.acos(a.w);
                    var b = Math.sqrt(1 - a.w * a.w);
                    return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b), this
                },
                setAxisAngleFromRotationMatrix: function(a) {
                    var b, c, d;
                    a = a.elements;
                    var e = a[0];
                    d = a[4];
                    var f = a[8],
                        g = a[1],
                        h = a[5],
                        i = a[9];
                    c = a[2], b = a[6];
                    var j = a[10];
                    return .01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(i - b) ? .1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(i + b) && .1 > Math.abs(e + h + j - 3) ? (this.set(1, 0, 0, 0), this) : (a = Math.PI, e = (e + 1) / 2, h = (h + 1) / 2, j = (j + 1) / 2, d = (d + g) / 4, f = (f + c) / 4, i = (i + b) / 4, e > h && e > j ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > j ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = i / c) : .01 > j ? (c = b = .707106781, d = 0) : (d = Math.sqrt(j), b = f / d, c = i / d), this.set(b, c, d, a), this) : (a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (g - d) * (g - d)), .001 > Math.abs(a) && (a = 1), this.x = (b - i) / a, this.y = (f - c) / a, this.z = (g - d) / a, this.w = Math.acos((e + h + j - 1) / 2), this)
                },
                min: function(a) {
                    return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this.w = Math.min(this.w, a.w), this
                },
                max: function(a) {
                    return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this.w = Math.max(this.w, a.w), this
                },
                clamp: function(a, b) {
                    return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), this
                },
                clampScalar: function() {
                    var a = new e,
                        b = new e;
                    return function(c, d) {
                        return a.set(c, c, c, c), b.set(d, d, d, d), this.clamp(a, b)
                    }
                }(),
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(a) {
                    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(a) {
                    return this.multiplyScalar(a / this.length())
                },
                lerp: function(a, b) {
                    return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this.w += (a.w - this.w) * b, this
                },
                lerpVectors: function(a, b, c) {
                    return this.subVectors(b, a).multiplyScalar(c).add(a)
                },
                equals: function(a) {
                    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
                },
                fromArray: function(a, b) {
                    return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this
                },
                toArray: function(a, b) {
                    return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a
                },
                fromBufferAttribute: function(a, b, c) {
                    return void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this.w = a.getW(b), this
                }
            }), Object.assign(f.prototype, b.prototype, {
                isWebGLRenderTarget: !0,
                setSize: function(a, b) {
                    this.width === a && this.height === b || (this.width = a, this.height = b, this.dispose()), this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, this.depthTexture = a.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), g.prototype = Object.create(f.prototype), g.prototype.constructor = g, g.prototype.isWebGLRenderTargetCube = !0, Object.assign(h, {
                slerp: function(a, b, c, d) {
                    return c.copy(a).slerp(b, d)
                },
                slerpFlat: function(a, b, c, d, e, f, g) {
                    var h = c[d + 0],
                        i = c[d + 1],
                        j = c[d + 2];
                    c = c[d + 3], d = e[f + 0];
                    var k = e[f + 1],
                        l = e[f + 2];
                    if (e = e[f + 3], c !== e || h !== d || i !== k || j !== l) {
                        f = 1 - g;
                        var m = h * d + i * k + j * l + c * e,
                            n = 0 <= m ? 1 : -1,
                            o = 1 - m * m;
                        o > Number.EPSILON && (o = Math.sqrt(o), m = Math.atan2(o, m * n), f = Math.sin(f * m) / o, g = Math.sin(g * m) / o), n *= g, h = h * f + d * n, i = i * f + k * n, j = j * f + l * n, c = c * f + e * n, f === 1 - g && (g = 1 / Math.sqrt(h * h + i * i + j * j + c * c), h *= g, i *= g, j *= g, c *= g)
                    }
                    a[b] = h, a[b + 1] = i, a[b + 2] = j, a[b + 3] = c
                }
            }), Object.defineProperties(h.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(a) {
                        this._x = a, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(a) {
                        this._y = a, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(a) {
                        this._z = a, this.onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(a) {
                        this._w = a, this.onChangeCallback()
                    }
                }
            }), Object.assign(h.prototype, {
                set: function(a, b, c, d) {
                    return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(a) {
                    return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), this
                },
                setFromEuler: function(a, b) {
                    if (!1 === (a && a.isEuler)) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var c = a._x,
                        d = a._y,
                        e = a._z,
                        f = a.order,
                        g = Math.cos,
                        h = Math.sin,
                        i = g(c / 2),
                        j = g(d / 2),
                        g = g(e / 2),
                        c = h(c / 2),
                        d = h(d / 2),
                        e = h(e / 2);
                    return "XYZ" === f ? (this._x = c * j * g + i * d * e, this._y = i * d * g - c * j * e, this._z = i * j * e + c * d * g, this._w = i * j * g - c * d * e) : "YXZ" === f ? (this._x = c * j * g + i * d * e, this._y = i * d * g - c * j * e, this._z = i * j * e - c * d * g, this._w = i * j * g + c * d * e) : "ZXY" === f ? (this._x = c * j * g - i * d * e, this._y = i * d * g + c * j * e, this._z = i * j * e + c * d * g, this._w = i * j * g - c * d * e) : "ZYX" === f ? (this._x = c * j * g - i * d * e, this._y = i * d * g + c * j * e, this._z = i * j * e - c * d * g, this._w = i * j * g + c * d * e) : "YZX" === f ? (this._x = c * j * g + i * d * e, this._y = i * d * g + c * j * e, this._z = i * j * e - c * d * g, this._w = i * j * g - c * d * e) : "XZY" === f && (this._x = c * j * g - i * d * e, this._y = i * d * g - c * j * e, this._z = i * j * e + c * d * g, this._w = i * j * g + c * d * e), !1 !== b && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(a, b) {
                    var c = b / 2,
                        d = Math.sin(c);
                    return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(a) {
                    var b = a.elements,
                        c = b[0];
                    a = b[4];
                    var d = b[8],
                        e = b[1],
                        f = b[5],
                        g = b[9],
                        h = b[2],
                        i = b[6],
                        b = b[10],
                        j = c + f + b;
                    return 0 < j ? (c = .5 / Math.sqrt(j + 1), this._w = .25 / c, this._x = (i - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (i - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + i) / c, this._z = .25 * c), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() {
                    var a, b = new i;
                    return function(c, d) {
                        return void 0 === b && (b = new i), a = c.dot(d) + 1, 1e-6 > a ? (a = 0, Math.abs(c.x) > Math.abs(c.z) ? b.set(-c.y, c.x, 0) : b.set(0, -c.z, c.y)) : b.crossVectors(c, d), this._x = b.x, this._y = b.y, this._z = b.z, this._w = a, this.normalize()
                    }
                }(),
                inverse: function() {
                    return this.conjugate().normalize()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(a) {
                    return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var a = this.length();
                    return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a), this.onChangeCallback(), this
                },
                multiply: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
                },
                premultiply: function(a) {
                    return this.multiplyQuaternions(a, this)
                },
                multiplyQuaternions: function(a, b) {
                    var c = a._x,
                        d = a._y,
                        e = a._z,
                        f = a._w,
                        g = b._x,
                        h = b._y,
                        i = b._z,
                        j = b._w;
                    return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, this.onChangeCallback(), this
                },
                slerp: function(a, b) {
                    if (0 === b) return this;
                    if (1 === b) return this.copy(a);
                    var c = this._x,
                        d = this._y,
                        e = this._z,
                        f = this._w,
                        g = f * a._w + c * a._x + d * a._y + e * a._z;
                    if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a), 1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
                    var h = Math.sqrt(1 - g * g);
                    if (.001 > Math.abs(h)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
                    var i = Math.atan2(h, g),
                        g = Math.sin((1 - b) * i) / h,
                        h = Math.sin(b * i) / h;
                    return this._w = f * g + this._w * h, this._x = c * g + this._x * h, this._y = d * g + this._y * h, this._z = e * g + this._z * h, this.onChangeCallback(), this
                },
                equals: function(a) {
                    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
                },
                fromArray: function(a, b) {
                    return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], this._w = a[b + 3], this.onChangeCallback(), this
                },
                toArray: function(a, b) {
                    return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._w, a
                },
                onChange: function(a) {
                    return this.onChangeCallback = a, this
                },
                onChangeCallback: function() {}
            }), Object.assign(i.prototype, {
                isVector3: !0,
                set: function(a, b, c) {
                    return this.x = a, this.y = b, this.z = c, this
                },
                setScalar: function(a) {
                    return this.z = this.y = this.x = a, this
                },
                setX: function(a) {
                    return this.x = a, this
                },
                setY: function(a) {
                    return this.y = a, this
                },
                setZ: function(a) {
                    return this.z = a, this
                },
                setComponent: function(a, b) {
                    switch (a) {
                        case 0:
                            this.x = b;
                            break;
                        case 1:
                            this.y = b;
                            break;
                        case 2:
                            this.z = b;
                            break;
                        default:
                            throw Error("index is out of range: " + a)
                    }
                    return this
                },
                getComponent: function(a) {
                    switch (a) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw Error("index is out of range: " + a)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(a) {
                    return this.x = a.x, this.y = a.y, this.z = a.z, this
                },
                add: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this)
                },
                addScalar: function(a) {
                    return this.x += a, this.y += a, this.z += a, this
                },
                addVectors: function(a, b) {
                    return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
                },
                addScaledVector: function(a, b) {
                    return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this
                },
                sub: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this)
                },
                subScalar: function(a) {
                    return this.x -= a, this.y -= a, this.z -= a, this
                },
                subVectors: function(a, b) {
                    return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
                },
                multiply: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this)
                },
                multiplyScalar: function(a) {
                    return this.x *= a, this.y *= a, this.z *= a, this
                },
                multiplyVectors: function(a, b) {
                    return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
                },
                applyEuler: function() {
                    var a = new h;
                    return function(b) {
                        return !1 === (b && b.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(a.setFromEuler(b))
                    }
                }(),
                applyAxisAngle: function() {
                    var a = new h;
                    return function(b, c) {
                        return this.applyQuaternion(a.setFromAxisAngle(b, c))
                    }
                }(),
                applyMatrix3: function(a) {
                    var b = this.x,
                        c = this.y,
                        d = this.z;
                    return a = a.elements, this.x = a[0] * b + a[3] * c + a[6] * d, this.y = a[1] * b + a[4] * c + a[7] * d, this.z = a[2] * b + a[5] * c + a[8] * d, this
                },
                applyMatrix4: function(a) {
                    var b = this.x,
                        c = this.y,
                        d = this.z;
                    return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12], this.y = a[1] * b + a[5] * c + a[9] * d + a[13], this.z = a[2] * b + a[6] * c + a[10] * d + a[14], this.divideScalar(a[3] * b + a[7] * c + a[11] * d + a[15])
                },
                applyQuaternion: function(a) {
                    var b = this.x,
                        c = this.y,
                        d = this.z,
                        e = a.x,
                        f = a.y,
                        g = a.z;
                    a = a.w;
                    var h = a * b + f * d - g * c,
                        i = a * c + g * b - e * d,
                        j = a * d + e * c - f * b,
                        b = -e * b - f * c - g * d;
                    return this.x = h * a + b * -e + i * -g - j * -f, this.y = i * a + b * -f + j * -e - h * -g, this.z = j * a + b * -g + h * -f - i * -e, this
                },
                project: function() {
                    var a = new j;
                    return function(b) {
                        return a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), this.applyMatrix4(a)
                    }
                }(),
                unproject: function() {
                    var a = new j;
                    return function(b) {
                        return a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), this.applyMatrix4(a)
                    }
                }(),
                transformDirection: function(a) {
                    var b = this.x,
                        c = this.y,
                        d = this.z;
                    return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d, this.y = a[1] * b + a[5] * c + a[9] * d, this.z = a[2] * b + a[6] * c + a[10] * d, this.normalize()
                },
                divide: function(a) {
                    return this.x /= a.x, this.y /= a.y, this.z /= a.z, this
                },
                divideScalar: function(a) {
                    return this.multiplyScalar(1 / a)
                },
                min: function(a) {
                    return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this
                },
                max: function(a) {
                    return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this
                },
                clamp: function(a, b) {
                    return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this
                },
                clampScalar: function() {
                    var a = new i,
                        b = new i;
                    return function(c, d) {
                        return a.set(c, c, c), b.set(d, d, d), this.clamp(a, b)
                    }
                }(),
                clampLength: function(a, b) {
                    var c = this.length();
                    return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(a) {
                    return this.x * a.x + this.y * a.y + this.z * a.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(a) {
                    return this.multiplyScalar(a / this.length())
                },
                lerp: function(a, b) {
                    return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this
                },
                lerpVectors: function(a, b, c) {
                    return this.subVectors(b, a).multiplyScalar(c).add(a)
                },
                cross: function(a, b) {
                    if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
                    var c = this.x,
                        d = this.y,
                        e = this.z;
                    return this.x = d * a.z - e * a.y, this.y = e * a.x - c * a.z, this.z = c * a.y - d * a.x, this
                },
                crossVectors: function(a, b) {
                    var c = a.x,
                        d = a.y,
                        e = a.z,
                        f = b.x,
                        g = b.y,
                        h = b.z;
                    return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this
                },
                projectOnVector: function(a) {
                    var b = a.dot(this) / a.lengthSq();
                    return this.copy(a).multiplyScalar(b)
                },
                projectOnPlane: function() {
                    var a = new i;
                    return function(b) {
                        return a.copy(this).projectOnVector(b), this.sub(a)
                    }
                }(),
                reflect: function() {
                    var a = new i;
                    return function(b) {
                        return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
                    }
                }(),
                angleTo: function(a) {
                    return a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq()), Math.acos(re.clamp(a, -1, 1))
                },
                distanceTo: function(a) {
                    return Math.sqrt(this.distanceToSquared(a))
                },
                distanceToSquared: function(a) {
                    var b = this.x - a.x,
                        c = this.y - a.y;
                    return a = this.z - a.z, b * b + c * c + a * a
                },
                distanceToManhattan: function(a) {
                    return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
                },
                setFromSpherical: function(a) {
                    var b = Math.sin(a.phi) * a.radius;
                    return this.x = b * Math.sin(a.theta), this.y = Math.cos(a.phi) * a.radius, this.z = b * Math.cos(a.theta), this
                },
                setFromCylindrical: function(a) {
                    return this.x = a.radius * Math.sin(a.theta), this.y = a.y, this.z = a.radius * Math.cos(a.theta), this
                },
                setFromMatrixPosition: function(a) {
                    return this.setFromMatrixColumn(a, 3)
                },
                setFromMatrixScale: function(a) {
                    var b = this.setFromMatrixColumn(a, 0).length(),
                        c = this.setFromMatrixColumn(a, 1).length();
                    return a = this.setFromMatrixColumn(a, 2).length(), this.x = b, this.y = c, this.z = a, this
                },
                setFromMatrixColumn: function(a, b) {
                    return this.fromArray(a.elements, 4 * b)
                },
                equals: function(a) {
                    return a.x === this.x && a.y === this.y && a.z === this.z
                },
                fromArray: function(a, b) {
                    return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this
                },
                toArray: function(a, b) {
                    return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a
                },
                fromBufferAttribute: function(a, b, c) {
                    return void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this
                }
            }), Object.assign(j.prototype, {
                isMatrix4: !0,
                set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                    var q = this.elements;
                    return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new j).fromArray(this.elements)
                },
                copy: function(a) {
                    var b = this.elements;
                    return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], this
                },
                copyPosition: function(a) {
                    var b = this.elements;
                    return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this
                },
                extractBasis: function(a, b, c) {
                    return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(a, b, c) {
                    return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function() {
                    var a = new i;
                    return function(b) {
                        var c = this.elements,
                            d = b.elements,
                            e = 1 / a.setFromMatrixColumn(b, 0).length(),
                            f = 1 / a.setFromMatrixColumn(b, 1).length();
                        return b = 1 / a.setFromMatrixColumn(b, 2).length(), c[0] = d[0] * e, c[1] = d[1] * e, c[2] = d[2] * e, c[4] = d[4] * f, c[5] = d[5] * f, c[6] = d[6] * f, c[8] = d[8] * b, c[9] = d[9] * b, c[10] = d[10] * b, this
                    }
                }(),
                makeRotationFromEuler: function(a) {
                    !1 === (a && a.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var b = this.elements,
                        c = a.x,
                        d = a.y,
                        e = a.z,
                        f = Math.cos(c),
                        c = Math.sin(c),
                        g = Math.cos(d),
                        d = Math.sin(d),
                        h = Math.cos(e),
                        e = Math.sin(e);
                    if ("XYZ" === a.order) {
                        a = f * h;
                        var i = f * e,
                            j = c * h,
                            k = c * e;
                        b[0] = g * h, b[4] = -g * e, b[8] = d, b[1] = i + j * d, b[5] = a - k * d, b[9] = -c * g, b[2] = k - a * d, b[6] = j + i * d, b[10] = f * g
                    } else "YXZ" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a + k * c, b[4] = j * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = i * c - j, b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = j + i * c, b[1] = i + j * c, b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, i = f * e, j = c * h, k = c * e, b[0] = g * h, b[4] = j * d - i, b[8] = a * d + k, b[1] = g * e, b[5] = k * d + a, b[9] = i * d - j, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = j * e + i, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = i * e + j, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, b[5] = f * h, b[9] = i * e - j, b[2] = j * e - i, b[6] = c * h, b[10] = k * e + a);
                    return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
                },
                makeRotationFromQuaternion: function(a) {
                    var b = this.elements,
                        c = a._x,
                        d = a._y,
                        e = a._z,
                        f = a._w,
                        g = c + c,
                        h = d + d,
                        i = e + e;
                    a = c * g;
                    var j = c * h,
                        c = c * i,
                        k = d * h,
                        d = d * i,
                        e = e * i,
                        g = f * g,
                        h = f * h,
                        f = f * i;
                    return b[0] = 1 - (k + e), b[4] = j - f, b[8] = c + h, b[1] = j + f, b[5] = 1 - (a + e), b[9] = d - g, b[2] = c - h, b[6] = d + g, b[10] = 1 - (a + k), b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
                },
                lookAt: function() {
                    var a = new i,
                        b = new i,
                        c = new i;
                    return function(d, e, f) {
                        var g = this.elements;
                        return c.subVectors(d, e), 0 === c.lengthSq() && (c.z = 1), c.normalize(), a.crossVectors(f, c), 0 === a.lengthSq() && (c.z += 1e-4, a.crossVectors(f, c)), a.normalize(), b.crossVectors(c, a), g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, g[6] = b.z, g[10] = c.z, this
                    }
                }(),
                multiply: function(a, b) {
                    return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
                },
                premultiply: function(a) {
                    return this.multiplyMatrices(a, this)
                },
                multiplyMatrices: function(a, b) {
                    var c = a.elements,
                        d = b.elements,
                        e = this.elements,
                        f = c[0],
                        g = c[4],
                        h = c[8],
                        i = c[12],
                        j = c[1],
                        k = c[5],
                        l = c[9],
                        m = c[13],
                        n = c[2],
                        o = c[6],
                        p = c[10],
                        q = c[14],
                        r = c[3],
                        s = c[7],
                        t = c[11],
                        c = c[15],
                        u = d[0],
                        v = d[4],
                        w = d[8],
                        x = d[12],
                        y = d[1],
                        z = d[5],
                        A = d[9],
                        B = d[13],
                        C = d[2],
                        D = d[6],
                        E = d[10],
                        F = d[14],
                        G = d[3],
                        H = d[7],
                        I = d[11],
                        d = d[15];
                    return e[0] = f * u + g * y + h * C + i * G, e[4] = f * v + g * z + h * D + i * H, e[8] = f * w + g * A + h * E + i * I, e[12] = f * x + g * B + h * F + i * d, e[1] = j * u + k * y + l * C + m * G, e[5] = j * v + k * z + l * D + m * H, e[9] = j * w + k * A + l * E + m * I, e[13] = j * x + k * B + l * F + m * d, e[2] = n * u + o * y + p * C + q * G, e[6] = n * v + o * z + p * D + q * H, e[10] = n * w + o * A + p * E + q * I, e[14] = n * x + o * B + p * F + q * d, e[3] = r * u + s * y + t * C + c * G, e[7] = r * v + s * z + t * D + c * H, e[11] = r * w + s * A + t * E + c * I, e[15] = r * x + s * B + t * F + c * d, this
                },
                multiplyScalar: function(a) {
                    var b = this.elements;
                    return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, b[11] *= a, b[15] *= a, this
                },
                applyToBufferAttribute: function() {
                    var a = new i;
                    return function(b) {
                        for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);
                        return b
                    }
                }(),
                determinant: function() {
                    var a = this.elements,
                        b = a[0],
                        c = a[4],
                        d = a[8],
                        e = a[12],
                        f = a[1],
                        g = a[5],
                        h = a[9],
                        i = a[13],
                        j = a[2],
                        k = a[6],
                        l = a[10],
                        m = a[14];
                    return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j)
                },
                transpose: function() {
                    var a, b = this.elements;
                    return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this
                },
                setPosition: function(a) {
                    var b = this.elements;
                    return b[12] = a.x, b[13] = a.y, b[14] = a.z, this
                },
                getInverse: function(a, b) {
                    var c = this.elements,
                        d = a.elements,
                        e = d[0],
                        f = d[1],
                        g = d[2],
                        h = d[3],
                        i = d[4],
                        j = d[5],
                        k = d[6],
                        l = d[7],
                        m = d[8],
                        n = d[9],
                        o = d[10],
                        p = d[11],
                        q = d[12],
                        r = d[13],
                        s = d[14],
                        d = d[15],
                        t = n * s * l - r * o * l + r * k * p - j * s * p - n * k * d + j * o * d,
                        u = q * o * l - m * s * l - q * k * p + i * s * p + m * k * d - i * o * d,
                        v = m * r * l - q * n * l + q * j * p - i * r * p - m * j * d + i * n * d,
                        w = q * n * k - m * r * k - q * j * o + i * r * o + m * j * s - i * n * s,
                        x = e * t + f * u + g * v + h * w;
                    if (0 === x) {
                        if (!0 === b) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                        return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity()
                    }
                    return x = 1 / x, c[0] = t * x, c[1] = (r * o * h - n * s * h - r * g * p + f * s * p + n * g * d - f * o * d) * x, c[2] = (j * s * h - r * k * h + r * g * l - f * s * l - j * g * d + f * k * d) * x, c[3] = (n * k * h - j * o * h - n * g * l + f * o * l + j * g * p - f * k * p) * x, c[4] = u * x, c[5] = (m * s * h - q * o * h + q * g * p - e * s * p - m * g * d + e * o * d) * x, c[6] = (q * k * h - i * s * h - q * g * l + e * s * l + i * g * d - e * k * d) * x, c[7] = (i * o * h - m * k * h + m * g * l - e * o * l - i * g * p + e * k * p) * x, c[8] = v * x, c[9] = (q * n * h - m * r * h - q * f * p + e * r * p + m * f * d - e * n * d) * x, c[10] = (i * r * h - q * j * h + q * f * l - e * r * l - i * f * d + e * j * d) * x, c[11] = (m * j * h - i * n * h - m * f * l + e * n * l + i * f * p - e * j * p) * x, c[12] = w * x, c[13] = (m * r * g - q * n * g + q * f * o - e * r * o - m * f * s + e * n * s) * x, c[14] = (q * j * g - i * r * g - q * f * k + e * r * k + i * f * s - e * j * s) * x, c[15] = (i * n * g - m * j * g + m * f * k - e * n * k - i * f * o + e * j * o) * x, this
                },
                scale: function(a) {
                    var b = this.elements,
                        c = a.x,
                        d = a.y;
                    return a = a.z, b[0] *= c, b[4] *= d, b[8] *= a, b[1] *= c, b[5] *= d, b[9] *= a, b[2] *= c, b[6] *= d, b[10] *= a, b[3] *= c, b[7] *= d, b[11] *= a, this
                },
                getMaxScaleOnAxis: function() {
                    var a = this.elements;
                    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
                },
                makeTranslation: function(a, b, c) {
                    return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this
                },
                makeRotationX: function(a) {
                    var b = Math.cos(a);
                    return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(a) {
                    var b = Math.cos(a);
                    return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(a) {
                    var b = Math.cos(a);
                    return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(a, b) {
                    var c = Math.cos(b),
                        d = Math.sin(b),
                        e = 1 - c,
                        f = a.x,
                        g = a.y,
                        h = a.z,
                        i = e * f,
                        j = e * g;
                    return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), this
                },
                makeScale: function(a, b, c) {
                    return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this
                },
                makeShear: function(a, b, c) {
                    return this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(a, b, c) {
                    return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this
                },
                decompose: function() {
                    var a = new i,
                        b = new j;
                    return function(c, d, e) {
                        var f = this.elements,
                            g = a.set(f[0], f[1], f[2]).length(),
                            h = a.set(f[4], f[5], f[6]).length(),
                            i = a.set(f[8], f[9], f[10]).length();
                        0 > this.determinant() && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.copy(this), c = 1 / g;
                        var f = 1 / h,
                            j = 1 / i;
                        return b.elements[0] *= c, b.elements[1] *= c, b.elements[2] *= c, b.elements[4] *= f, b.elements[5] *= f, b.elements[6] *= f, b.elements[8] *= j, b.elements[9] *= j, b.elements[10] *= j, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this
                    }
                }(),
                makePerspective: function(a, b, c, d, e, f) {
                    void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var g = this.elements;
                    return g[0] = 2 * e / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, g[5] = 2 * e / (c - d), g[9] = (c + d) / (c - d), g[13] = 0, g[2] = 0, g[6] = 0, g[10] = -(f + e) / (f - e), g[14] = -2 * f * e / (f - e), g[3] = 0, g[7] = 0, g[11] = -1, g[15] = 0, this
                },
                makeOrthographic: function(a, b, c, d, e, f) {
                    var g = this.elements,
                        h = 1 / (b - a),
                        i = 1 / (c - d),
                        j = 1 / (f - e);
                    return g[0] = 2 * h, g[4] = 0, g[8] = 0, g[12] = -((b + a) * h), g[1] = 0, g[5] = 2 * i, g[9] = 0, g[13] = -((c + d) * i), g[2] = 0, g[6] = 0, g[10] = -2 * j, g[14] = -((f + e) * j), g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this
                },
                equals: function(a) {
                    var b = this.elements;
                    a = a.elements;
                    for (var c = 0; 16 > c; c++)
                        if (b[c] !== a[c]) return !1;
                    return !0
                },
                fromArray: function(a, b) {
                    void 0 === b && (b = 0);
                    for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
                    return this
                },
                toArray: function(a, b) {
                    void 0 === a && (a = []), void 0 === b && (b = 0);
                    var c = this.elements;
                    return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], a[b + 15] = c[15], a
                }
            }), k.prototype = Object.create(d.prototype), k.prototype.constructor = k, k.prototype.isDataTexture = !0, l.prototype = Object.create(d.prototype), l.prototype.constructor = l, l.prototype.isCubeTexture = !0, Object.defineProperty(l.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(a) {
                    this.image = a
                }
            });
            var te = new d,
                ue = new l,
                ve = [],
                we = [],
                xe = new Float32Array(16),
                ye = new Float32Array(9);
            P.prototype.setValue = function(a, b) {
                for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
                    var f = c[d];
                    f.setValue(a, b[f.id])
                }
            };
            var ze = /([\w\d_]+)(\])?(\[|\.)?/g;
            Q.prototype.setValue = function(a, b, c) {
                b = this.map[b], void 0 !== b && b.setValue(a, c, this.renderer)
            }, Q.prototype.setOptional = function(a, b, c) {
                b = b[c], void 0 !== b && this.setValue(a, c, b)
            }, Q.upload = function(a, b, c, d) {
                for (var e = 0, f = b.length; e !== f; ++e) {
                    var g = b[e],
                        h = c[g.id];
                    !1 !== h.needsUpdate && g.setValue(a, h.value, d)
                }
            }, Q.seqWithValue = function(a, b) {
                for (var c = [], d = 0, e = a.length; d !== e; ++d) {
                    var f = a[d];
                    f.id in b && c.push(f)
                }
                return c
            };
            var Ae = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            };
            Object.assign(R.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(a) {
                    return a && a.isColor ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), this
                },
                setScalar: function(a) {
                    return this.b = this.g = this.r = a, this
                },
                setHex: function(a) {
                    return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, this.b = (255 & a) / 255, this
                },
                setRGB: function(a, b, c) {
                    return this.r = a, this.g = b, this.b = c, this
                },
                setHSL: function() {
                    function a(a, b, c) {
                        return 0 > c && (c += 1), 1 < c && --c, c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
                    }
                    return function(b, c, d) {
                        return b = re.euclideanModulo(b, 1), c = re.clamp(c, 0, 1), d = re.clamp(d, 0, 1), 0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3)), this
                    }
                }(),
                setStyle: function(a) {
                    function b(b) {
                        void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
                    }
                    var c;
                    if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                        var d = c[2];
                        switch (c[1]) {
                            case "rgb":
                            case "rgba":
                                if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
                                if (c = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                                    var d = parseFloat(c[1]) / 360,
                                        e = parseInt(c[2], 10) / 100,
                                        f = parseInt(c[3], 10) / 100;
                                    return b(c[5]), this.setHSL(d, e, f)
                                }
                        }
                    } else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
                        if (c = c[1], d = c.length, 3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                        if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
                    }
                    return a && 0 < a.length && (c = Ae[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a)), this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(a) {
                    return this.r = a.r, this.g = a.g, this.b = a.b, this
                },
                copyGammaToLinear: function(a, b) {
                    return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this
                },
                copyLinearToGamma: function(a, b) {
                    void 0 === b && (b = 2);
                    var c = 0 < b ? 1 / b : 1;
                    return this.r = Math.pow(a.r, c), this.g = Math.pow(a.g, c), this.b = Math.pow(a.b, c), this
                },
                convertGammaToLinear: function() {
                    var a = this.r,
                        b = this.g,
                        c = this.b;
                    return this.r = a * a, this.g = b * b, this.b = c * c, this
                },
                convertLinearToGamma: function() {
                    return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(a) {
                    a = a || {
                        h: 0,
                        s: 0,
                        l: 0
                    };
                    var b, c = this.r,
                        d = this.g,
                        e = this.b,
                        f = Math.max(c, d, e),
                        g = Math.min(c, d, e),
                        h = (g + f) / 2;
                    if (g === f) g = b = 0;
                    else {
                        var i = f - g,
                            g = .5 >= h ? i / (f + g) : i / (2 - f - g);
                        switch (f) {
                            case c:
                                b = (d - e) / i + (d < e ? 6 : 0);
                                break;
                            case d:
                                b = (e - c) / i + 2;
                                break;
                            case e:
                                b = (c - d) / i + 4
                        }
                        b /= 6
                    }
                    return a.h = b, a.s = g, a.l = h, a
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(a, b, c) {
                    var d = this.getHSL();
                    return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this
                },
                add: function(a) {
                    return this.r += a.r, this.g += a.g, this.b += a.b, this
                },
                addColors: function(a, b) {
                    return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this
                },
                addScalar: function(a) {
                    return this.r += a, this.g += a, this.b += a, this
                },
                sub: function(a) {
                    return this.r = Math.max(0, this.r - a.r), this.g = Math.max(0, this.g - a.g), this.b = Math.max(0, this.b - a.b), this
                },
                multiply: function(a) {
                    return this.r *= a.r, this.g *= a.g, this.b *= a.b, this
                },
                multiplyScalar: function(a) {
                    return this.r *= a, this.g *= a, this.b *= a, this
                },
                lerp: function(a, b) {
                    return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, this
                },
                equals: function(a) {
                    return a.r === this.r && a.g === this.g && a.b === this.b
                },
                fromArray: function(a, b) {
                    return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], this
                },
                toArray: function(a, b) {
                    return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b, a
                },
                toJSON: function() {
                    return this.getHex()
                }
            });
            var Be = {
                    common: {
                        diffuse: {
                            value: new R(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        offsetRepeat: {
                            value: new e(0, 0, 1, 1)
                        },
                        specularMap: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new c(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new R(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new R(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        offsetRepeat: {
                            value: new e(0, 0, 1, 1)
                        }
                    }
                },
                Ce = {
                    merge: function(a) {
                        for (var b = {}, c = 0; c < a.length; c++) {
                            var d, e = this.clone(a[c]);
                            for (d in e) b[d] = e[d]
                        }
                        return b
                    },
                    clone: function(a) {
                        var b, c = {};
                        for (b in a) {
                            c[b] = {};
                            for (var d in a[b]) {
                                var e = a[b][d];
                                e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? c[b][d] = e.clone() : Array.isArray(e) ? c[b][d] = e.slice() : c[b][d] = e
                            }
                        }
                        return c
                    }
                },
                De = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "\nvec3 transformed = vec3( position );\n",
                    beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                    bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                    color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                    common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                    defaultnormal_vertex: "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                    encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                    envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                    fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                    gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                    lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                    lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                    logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                    map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                    map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                    normal_flip: "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
                    normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                    project_vertex: "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
                    dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                    dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                    tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                    uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
                    uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                    cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                    distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
                    distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
                    equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                    equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
                    shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
                },
                Ee = {
                    basic: {
                        uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.fog]),
                        vertexShader: De.meshbasic_vert,
                        fragmentShader: De.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.emissivemap, Be.fog, Be.lights, {
                            emissive: {
                                value: new R(0)
                            }
                        }]),
                        vertexShader: De.meshlambert_vert,
                        fragmentShader: De.meshlambert_frag
                    },
                    phong: {
                        uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.gradientmap, Be.fog, Be.lights, {
                            emissive: {
                                value: new R(0)
                            },
                            specular: {
                                value: new R(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: De.meshphong_vert,
                        fragmentShader: De.meshphong_frag
                    },
                    standard: {
                        uniforms: Ce.merge([Be.common, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.roughnessmap, Be.metalnessmap, Be.fog, Be.lights, {
                            emissive: {
                                value: new R(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: De.meshphysical_vert,
                        fragmentShader: De.meshphysical_frag
                    },
                    points: {
                        uniforms: Ce.merge([Be.points, Be.fog]),
                        vertexShader: De.points_vert,
                        fragmentShader: De.points_frag
                    },
                    dashed: {
                        uniforms: Ce.merge([Be.common, Be.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: De.linedashed_vert,
                        fragmentShader: De.linedashed_frag
                    },
                    depth: {
                        uniforms: Ce.merge([Be.common, Be.displacementmap]),
                        vertexShader: De.depth_vert,
                        fragmentShader: De.depth_frag
                    },
                    normal: {
                        uniforms: Ce.merge([Be.common, Be.bumpmap, Be.normalmap, Be.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: De.normal_vert,
                        fragmentShader: De.normal_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: De.cube_vert,
                        fragmentShader: De.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            }
                        },
                        vertexShader: De.equirect_vert,
                        fragmentShader: De.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: {
                            lightPos: {
                                value: new i
                            }
                        },
                        vertexShader: De.distanceRGBA_vert,
                        fragmentShader: De.distanceRGBA_frag
                    }
                };
            Ee.physical = {
                uniforms: Ce.merge([Ee.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: De.meshphysical_vert,
                fragmentShader: De.meshphysical_frag
            }, Object.assign(S.prototype, {
                set: function(a, b) {
                    return this.min.copy(a), this.max.copy(b), this
                },
                setFromPoints: function(a) {
                    this.makeEmpty();
                    for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var a = new c;
                    return function(b, c) {
                        var d = a.copy(c).multiplyScalar(.5);
                        return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.min.copy(a.min), this.max.copy(a.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function(a) {
                    return a = a || new c, this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(a) {
                    return a = a || new c, this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
                },
                expandByPoint: function(a) {
                    return this.min.min(a), this.max.max(a), this
                },
                expandByVector: function(a) {
                    return this.min.sub(a), this.max.add(a), this
                },
                expandByScalar: function(a) {
                    return this.min.addScalar(-a), this.max.addScalar(a), this
                },
                containsPoint: function(a) {
                    return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y)
                },
                containsBox: function(a) {
                    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
                },
                getParameter: function(a, b) {
                    return (b || new c).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(a) {
                    return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y)
                },
                clampPoint: function(a, b) {
                    return (b || new c).copy(a).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var a = new c;
                    return function(b) {
                        return a.copy(b).clamp(this.min, this.max).sub(b).length()
                    }
                }(),
                intersect: function(a) {
                    return this.min.max(a.min), this.max.min(a.max), this
                },
                union: function(a) {
                    return this.min.min(a.min), this.max.max(a.max), this
                },
                translate: function(a) {
                    return this.min.add(a), this.max.add(a), this
                },
                equals: function(a) {
                    return a.min.equals(this.min) && a.max.equals(this.max)
                }
            });
            var Fe = 0;
            Object.assign(V.prototype, b.prototype, {
                isMaterial: !0,
                setValues: function(a) {
                    if (void 0 !== a)
                        for (var b in a) {
                            var c = a[b];
                            if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                            else {
                                var d = this[b];
                                void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c
                            }
                        }
                },
                toJSON: function(a) {
                    function b(a) {
                        var b, c = [];
                        for (b in a) {
                            var d = a[b];
                            delete d.metadata, c.push(d)
                        }
                        return c
                    }
                    var c = void 0 === a;
                    c && (a = {
                        textures: {},
                        images: {}
                    });
                    var d = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    return d.uuid = this.uuid, d.type = this.type, "" !== this.name && (d.name = this.name), this.color && this.color.isColor && (d.color = this.color.getHex()), void 0 !== this.roughness && (d.roughness = this.roughness), void 0 !== this.metalness && (d.metalness = this.metalness), this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (d.specular = this.specular.getHex()), void 0 !== this.shininess && (d.shininess = this.shininess), void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid), this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid), this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid), this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid), this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid), this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid), this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid), this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid), void 0 !== this.size && (d.size = this.size), void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (d.blending = this.blending), 2 !== this.shading && (d.shading = this.shading), 0 !== this.side && (d.side = this.side), 0 !== this.vertexColors && (d.vertexColors = this.vertexColors), 1 > this.opacity && (d.opacity = this.opacity), !0 === this.transparent && (d.transparent = this.transparent), d.depthFunc = this.depthFunc, d.depthTest = this.depthTest, d.depthWrite = this.depthWrite, 0 < this.alphaTest && (d.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (d.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin), d.skinning = this.skinning, d.morphTargets = this.morphTargets, d.dithering = this.dithering, c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)), d
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    this.name = a.name, this.fog = a.fog, this.lights = a.lights, this.blending = a.blending, this.side = a.side, this.shading = a.shading, this.vertexColors = a.vertexColors, this.opacity = a.opacity, this.transparent = a.transparent, this.blendSrc = a.blendSrc, this.blendDst = a.blendDst, this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, this.blendDstAlpha = a.blendDstAlpha, this.blendEquationAlpha = a.blendEquationAlpha, this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, this.depthWrite = a.depthWrite, this.colorWrite = a.colorWrite, this.precision = a.precision, this.polygonOffset = a.polygonOffset, this.polygonOffsetFactor = a.polygonOffsetFactor, this.polygonOffsetUnits = a.polygonOffsetUnits, this.dithering = a.dithering, this.alphaTest = a.alphaTest, this.premultipliedAlpha = a.premultipliedAlpha, this.overdraw = a.overdraw, this.visible = a.visible, this.clipShadows = a.clipShadows, this.clipIntersection = a.clipIntersection, a = a.clippingPlanes;
                    var b = null;
                    if (null !== a)
                        for (var c = a.length, b = Array(c), d = 0; d !== c; ++d) b[d] = a[d].clone();
                    return this.clippingPlanes = b, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.fragmentShader = a.fragmentShader, this.vertexShader = a.vertexShader, this.uniforms = Ce.clone(a.uniforms), this.defines = a.defines, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.lights = a.lights, this.clipping = a.clipping, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this.extensions = a.extensions, this
            }, W.prototype.toJSON = function(a) {
                return a = V.prototype.toJSON.call(this, a), a.uniforms = this.uniforms, a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader, a
            }, X.prototype = Object.create(V.prototype), X.prototype.constructor = X, X.prototype.isMeshDepthMaterial = !0, X.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.depthPacking = a.depthPacking, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this
            }, Object.assign(Y.prototype, {
                isBox3: !0,
                set: function(a, b) {
                    return this.min.copy(a), this.max.copy(b), this
                },
                setFromArray: function(a) {
                    for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.length; h < i; h += 3) {
                        var j = a[h],
                            k = a[h + 1],
                            l = a[h + 2];
                        j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), l > g && (g = l)
                    }
                    return this.min.set(b, c, d), this.max.set(e, f, g), this
                },
                setFromBufferAttribute: function(a) {
                    for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.count; h < i; h++) {
                        var j = a.getX(h),
                            k = a.getY(h),
                            l = a.getZ(h);
                        j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), l > g && (g = l)
                    }
                    return this.min.set(b, c, d), this.max.set(e, f, g), this
                },
                setFromPoints: function(a) {
                    this.makeEmpty();
                    for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var a = new i;
                    return function(b, c) {
                        var d = a.copy(c).multiplyScalar(.5);
                        return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
                    }
                }(),
                setFromObject: function(a) {
                    return this.makeEmpty(), this.expandByObject(a)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.min.copy(a.min), this.max.copy(a.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(a) {
                    return a = a || new i, this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(a) {
                    return a = a || new i, this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
                },
                expandByPoint: function(a) {
                    return this.min.min(a), this.max.max(a), this
                },
                expandByVector: function(a) {
                    return this.min.sub(a), this.max.add(a), this
                },
                expandByScalar: function(a) {
                    return this.min.addScalar(-a), this.max.addScalar(a), this
                },
                expandByObject: function() {
                    var a = new i;
                    return function(b) {
                        var c = this;
                        return b.updateMatrixWorld(!0), b.traverse(function(b) {
                            var d, e;
                            if (d = b.geometry, void 0 !== d)
                                if (d.isGeometry) {
                                    var f = d.vertices;
                                    for (d = 0, e = f.length; d < e; d++) a.copy(f[d]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
                                } else if (d.isBufferGeometry && (f = d.attributes.position, void 0 !== f))
                                for (d = 0, e = f.count; d < e; d++) a.fromBufferAttribute(f, d).applyMatrix4(b.matrixWorld), c.expandByPoint(a)
                        }), this
                    }
                }(),
                containsPoint: function(a) {
                    return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z)
                },
                containsBox: function(a) {
                    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
                },
                getParameter: function(a, b) {
                    return (b || new i).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(a) {
                    return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var a = new i;
                    return function(b) {
                        return this.clampPoint(b.center, a), a.distanceToSquared(b.center) <= b.radius * b.radius
                    }
                }(),
                intersectsPlane: function(a) {
                    var b, c;
                    return 0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x), 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y), 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z), b <= a.constant && c >= a.constant
                },
                clampPoint: function(a, b) {
                    return (b || new i).copy(a).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var a = new i;
                    return function(b) {
                        return a.copy(b).clamp(this.min, this.max).sub(b).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var a = new i;
                    return function(b) {
                        return b = b || new Z, this.getCenter(b.center), b.radius = .5 * this.getSize(a).length(), b
                    }
                }(),
                intersect: function(a) {
                    return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(a) {
                    return this.min.min(a.min), this.max.max(a.max), this
                },
                applyMatrix4: function() {
                    var a = [new i, new i, new i, new i, new i, new i, new i, new i];
                    return function(b) {
                        return this.isEmpty() ? this : (a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), this.setFromPoints(a), this)
                    }
                }(),
                translate: function(a) {
                    return this.min.add(a), this.max.add(a), this
                },
                equals: function(a) {
                    return a.min.equals(this.min) && a.max.equals(this.max)
                }
            }), Object.assign(Z.prototype, {
                set: function(a, b) {
                    return this.center.copy(a), this.radius = b, this
                },
                setFromPoints: function() {
                    var a = new Y;
                    return function(b, c) {
                        var d = this.center;
                        void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
                        for (var e = 0, f = 0, g = b.length; f < g; f++) e = Math.max(e, d.distanceToSquared(b[f]));
                        return this.radius = Math.sqrt(e), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.center.copy(a.center), this.radius = a.radius, this
                },
                empty: function() {
                    return 0 >= this.radius
                },
                containsPoint: function(a) {
                    return a.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(a) {
                    return a.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(a) {
                    var b = this.radius + a.radius;
                    return a.center.distanceToSquared(this.center) <= b * b
                },
                intersectsBox: function(a) {
                    return a.intersectsSphere(this)
                },
                intersectsPlane: function(a) {
                    return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
                },
                clampPoint: function(a, b) {
                    var c = this.center.distanceToSquared(a),
                        d = b || new i;
                    return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center)), d
                },
                getBoundingBox: function(a) {
                    return a = a || new Y, a.set(this.center, this.center), a.expandByScalar(this.radius), a
                },
                applyMatrix4: function(a) {
                    return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this
                },
                translate: function(a) {
                    return this.center.add(a), this
                },
                equals: function(a) {
                    return a.center.equals(this.center) && a.radius === this.radius
                }
            }), Object.assign($.prototype, {
                isMatrix3: !0,
                set: function(a, b, c, d, e, f, g, h, i) {
                    var j = this.elements;
                    return j[0] = a, j[1] = d, j[2] = g, j[3] = b, j[4] = e, j[5] = h, j[6] = c, j[7] = f, j[8] = i, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(a) {
                    var b = this.elements;
                    return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], this
                },
                setFromMatrix4: function(a) {
                    return a = a.elements, this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), this
                },
                applyToBufferAttribute: function() {
                    var a = new i;
                    return function(b) {
                        for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);
                        return b
                    }
                }(),
                multiply: function(a) {
                    return this.multiplyMatrices(this, a)
                },
                premultiply: function(a) {
                    return this.multiplyMatrices(a, this)
                },
                multiplyMatrices: function(a, b) {
                    var c = a.elements,
                        d = b.elements,
                        e = this.elements,
                        f = c[0],
                        g = c[3],
                        h = c[6],
                        i = c[1],
                        j = c[4],
                        k = c[7],
                        l = c[2],
                        m = c[5],
                        c = c[8],
                        n = d[0],
                        o = d[3],
                        p = d[6],
                        q = d[1],
                        r = d[4],
                        s = d[7],
                        t = d[2],
                        u = d[5],
                        d = d[8];
                    return e[0] = f * n + g * q + h * t, e[3] = f * o + g * r + h * u, e[6] = f * p + g * s + h * d, e[1] = i * n + j * q + k * t, e[4] = i * o + j * r + k * u, e[7] = i * p + j * s + k * d, e[2] = l * n + m * q + c * t, e[5] = l * o + m * r + c * u, e[8] = l * p + m * s + c * d, this
                },
                multiplyScalar: function(a) {
                    var b = this.elements;
                    return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, b[5] *= a, b[8] *= a, this
                },
                determinant: function() {
                    var a = this.elements,
                        b = a[0],
                        c = a[1],
                        d = a[2],
                        e = a[3],
                        f = a[4],
                        g = a[5],
                        h = a[6],
                        i = a[7],
                        a = a[8];
                    return b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h
                },
                getInverse: function(a, b) {
                    a && a.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                    var c = a.elements,
                        d = this.elements,
                        e = c[0],
                        f = c[1],
                        g = c[2],
                        h = c[3],
                        i = c[4],
                        j = c[5],
                        k = c[6],
                        l = c[7],
                        c = c[8],
                        m = c * i - j * l,
                        n = j * k - c * h,
                        o = l * h - i * k,
                        p = e * m + f * n + g * o;
                    if (0 === p) {
                        if (!0 === b) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
                        return console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity()
                    }
                    return p = 1 / p, d[0] = m * p, d[1] = (g * l - c * f) * p, d[2] = (j * f - g * i) * p, d[3] = n * p, d[4] = (c * e - g * k) * p, d[5] = (g * h - j * e) * p, d[6] = o * p, d[7] = (f * k - l * e) * p, d[8] = (i * e - f * h) * p, this
                },
                transpose: function() {
                    var a, b = this.elements;
                    return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], b[5] = b[7], b[7] = a, this
                },
                getNormalMatrix: function(a) {
                    return this.setFromMatrix4(a).getInverse(this).transpose()
                },
                transposeIntoArray: function(a) {
                    var b = this.elements;
                    return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8], this
                },
                equals: function(a) {
                    var b = this.elements;
                    a = a.elements;
                    for (var c = 0; 9 > c; c++)
                        if (b[c] !== a[c]) return !1;
                    return !0
                },
                fromArray: function(a, b) {
                    void 0 === b && (b = 0);
                    for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
                    return this
                },
                toArray: function(a, b) {
                    void 0 === a && (a = []), void 0 === b && (b = 0);
                    var c = this.elements;
                    return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a
                }
            }), Object.assign(_.prototype, {
                set: function(a, b) {
                    return this.normal.copy(a), this.constant = b, this
                },
                setComponents: function(a, b, c, d) {
                    return this.normal.set(a, b, c), this.constant = d, this
                },
                setFromNormalAndCoplanarPoint: function(a, b) {
                    return this.normal.copy(a), this.constant = -b.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var a = new i,
                        b = new i;
                    return function(c, d, e) {
                        return d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(), this.setFromNormalAndCoplanarPoint(d, c), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.normal.copy(a.normal), this.constant = a.constant, this
                },
                normalize: function() {
                    var a = 1 / this.normal.length();
                    return this.normal.multiplyScalar(a), this.constant *= a, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(a) {
                    return this.normal.dot(a) + this.constant
                },
                distanceToSphere: function(a) {
                    return this.distanceToPoint(a.center) - a.radius
                },
                projectPoint: function(a, b) {
                    return this.orthoPoint(a, b).sub(a).negate()
                },
                orthoPoint: function(a, b) {
                    var c = this.distanceToPoint(a);
                    return (b || new i).copy(this.normal).multiplyScalar(c)
                },
                intersectLine: function() {
                    var a = new i;
                    return function(b, c) {
                        var d = c || new i,
                            e = b.delta(a),
                            f = this.normal.dot(e);
                        return 0 !== f ? (f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)) : 0 === this.distanceToPoint(b.start) ? d.copy(b.start) : void 0
                    }
                }(),
                intersectsLine: function(a) {
                    var b = this.distanceToPoint(a.start);
                    return a = this.distanceToPoint(a.end), 0 > b && 0 < a || 0 > a && 0 < b
                },
                intersectsBox: function(a) {
                    return a.intersectsPlane(this)
                },
                intersectsSphere: function(a) {
                    return a.intersectsPlane(this)
                },
                coplanarPoint: function(a) {
                    return (a || new i).copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var a = new i,
                        b = new $;
                    return function(c, d) {
                        var e = this.coplanarPoint(a).applyMatrix4(c),
                            f = d || b.getNormalMatrix(c),
                            f = this.normal.applyMatrix3(f).normalize();
                        return this.constant = -e.dot(f), this
                    }
                }(),
                translate: function(a) {
                    return this.constant -= a.dot(this.normal), this
                },
                equals: function(a) {
                    return a.normal.equals(this.normal) && a.constant === this.constant
                }
            }), Object.assign(aa.prototype, {
                set: function(a, b, c, d, e, f) {
                    var g = this.planes;
                    return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
                    return this
                },
                setFromMatrix: function(a) {
                    var b = this.planes,
                        c = a.elements;
                    a = c[0];
                    var d = c[1],
                        e = c[2],
                        f = c[3],
                        g = c[4],
                        h = c[5],
                        i = c[6],
                        j = c[7],
                        k = c[8],
                        l = c[9],
                        m = c[10],
                        n = c[11],
                        o = c[12],
                        p = c[13],
                        q = c[14],
                        c = c[15];
                    return b[0].setComponents(f - a, j - g, n - k, c - o).normalize(), b[1].setComponents(f + a, j + g, n + k, c + o).normalize(), b[2].setComponents(f + d, j + h, n + l, c + p).normalize(), b[3].setComponents(f - d, j - h, n - l, c - p).normalize(), b[4].setComponents(f - e, j - i, n - m, c - q).normalize(), b[5].setComponents(f + e, j + i, n + m, c + q).normalize(), this
                },
                intersectsObject: function() {
                    var a = new Z;
                    return function(b) {
                        var c = b.geometry;
                        return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld), this.intersectsSphere(a)
                    }
                }(),
                intersectsSprite: function() {
                    var a = new Z;
                    return function(b) {
                        return a.center.set(0, 0, 0), a.radius = .7071067811865476, a.applyMatrix4(b.matrixWorld), this.intersectsSphere(a)
                    }
                }(),
                intersectsSphere: function(a) {
                    var b = this.planes,
                        c = a.center;
                    a = -a.radius;
                    for (var d = 0; 6 > d; d++)
                        if (b[d].distanceToPoint(c) < a) return !1;
                    return !0
                },
                intersectsBox: function() {
                    var a = new i,
                        b = new i;
                    return function(c) {
                        for (var d = this.planes, e = 0; 6 > e; e++) {
                            var f = d[e];
                            a.x = 0 < f.normal.x ? c.min.x : c.max.x, b.x = 0 < f.normal.x ? c.max.x : c.min.x, a.y = 0 < f.normal.y ? c.min.y : c.max.y, b.y = 0 < f.normal.y ? c.max.y : c.min.y, a.z = 0 < f.normal.z ? c.min.z : c.max.z, b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                            var g = f.distanceToPoint(a),
                                f = f.distanceToPoint(b);
                            if (0 > g && 0 > f) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(a) {
                    for (var b = this.planes, c = 0; 6 > c; c++)
                        if (0 > b[c].distanceToPoint(a)) return !1;
                    return !0
                }
            }), Object.assign(ca.prototype, {
                set: function(a, b) {
                    return this.origin.copy(a), this.direction.copy(b), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.origin.copy(a.origin), this.direction.copy(a.direction), this
                },
                at: function(a, b) {
                    return (b || new i).copy(this.direction).multiplyScalar(a).add(this.origin)
                },
                lookAt: function(a) {
                    return this.direction.copy(a).sub(this.origin).normalize(), this
                },
                recast: function() {
                    var a = new i;
                    return function(b) {
                        return this.origin.copy(this.at(b, a)), this
                    }
                }(),
                closestPointToPoint: function(a, b) {
                    var c = b || new i;
                    c.subVectors(a, this.origin);
                    var d = c.dot(this.direction);
                    return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
                },
                distanceToPoint: function(a) {
                    return Math.sqrt(this.distanceSqToPoint(a))
                },
                distanceSqToPoint: function() {
                    var a = new i;
                    return function(b) {
                        var c = a.subVectors(b, this.origin).dot(this.direction);
                        return 0 > c ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), a.distanceToSquared(b))
                    }
                }(),
                distanceSqToSegment: function() {
                    var a = new i,
                        b = new i,
                        c = new i;
                    return function(d, e, f, g) {
                        a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
                        var h, i = .5 * d.distanceTo(e),
                            j = -this.direction.dot(b),
                            k = c.dot(this.direction),
                            l = -c.dot(b),
                            m = c.lengthSq(),
                            n = Math.abs(1 - j * j);
                        return 0 < n ? (d = j * l - k, e = j * k - l, h = i * n, 0 <= d ? e >= -h ? e <= h ? (i = 1 / n, d *= i, e *= i, j = d * (d + j * e + 2 * k) + e * (j * d + e + 2 * l) + m) : (e = i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : (e = -i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : e <= -h ? (d = Math.max(0, -(-j * i + k)), e = 0 < d ? -i : Math.min(Math.max(-i, -l), i), j = -d * d + e * (e + 2 * l) + m) : e <= h ? (d = 0, e = Math.min(Math.max(-i, -l), i), j = e * (e + 2 * l) + m) : (d = Math.max(0, -(j * i + k)), e = 0 < d ? i : Math.min(Math.max(-i, -l), i), j = -d * d + e * (e + 2 * l) + m)) : (e = 0 < j ? -i : i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m), f && f.copy(this.direction).multiplyScalar(d).add(this.origin), g && g.copy(b).multiplyScalar(e).add(a), j
                    }
                }(),
                intersectSphere: function() {
                    var a = new i;
                    return function(b, c) {
                        a.subVectors(b.center, this.origin);
                        var d = a.dot(this.direction),
                            e = a.dot(a) - d * d,
                            f = b.radius * b.radius;
                        return e > f ? null : (f = Math.sqrt(f - e), e = d - f, d += f, 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c))
                    }
                }(),
                intersectsSphere: function(a) {
                    return this.distanceToPoint(a.center) <= a.radius
                },
                distanceToPlane: function(a) {
                    var b = a.normal.dot(this.direction);
                    return 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b, 0 <= a ? a : null)
                },
                intersectPlane: function(a, b) {
                    var c = this.distanceToPlane(a);
                    return null === c ? null : this.at(c, b)
                },
                intersectsPlane: function(a) {
                    var b = a.distanceToPoint(this.origin);
                    return 0 === b || 0 > a.normal.dot(this.direction) * b
                },
                intersectBox: function(a, b) {
                    var c, d, e, f, g;
                    d = 1 / this.direction.x, f = 1 / this.direction.y, g = 1 / this.direction.z;
                    var h = this.origin;
                    return 0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x), 0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (f < d || d !== d) && (d = f), 0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z), c > g || e > d ? null : ((e > c || c !== c) && (c = e), (g < d || d !== d) && (d = g), 0 > d ? null : this.at(0 <= c ? c : d, b)))
                },
                intersectsBox: function() {
                    var a = new i;
                    return function(b) {
                        return null !== this.intersectBox(b, a)
                    }
                }(),
                intersectTriangle: function() {
                    var a = new i,
                        b = new i,
                        c = new i,
                        d = new i;
                    return function(e, f, g, h, i) {
                        if (b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c), f = this.direction.dot(d), 0 < f) {
                            if (h) return null;
                            h = 1
                        } else {
                            if (!(0 > f)) return null;
                            h = -1, f = -f
                        }
                        return a.subVectors(this.origin, e), e = h * this.direction.dot(c.crossVectors(a, c)), 0 > e ? null : (g = h * this.direction.dot(b.cross(a)), 0 > g || e + g > f ? null : (e = -h * a.dot(d), 0 > e ? null : this.at(e / f, i)))
                    }
                }(),
                applyMatrix4: function(a) {
                    return this.direction.add(this.origin).applyMatrix4(a), this.origin.applyMatrix4(a), this.direction.sub(this.origin), this.direction.normalize(), this
                },
                equals: function(a) {
                    return a.origin.equals(this.origin) && a.direction.equals(this.direction)
                }
            }), da.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), da.DefaultOrder = "XYZ", Object.defineProperties(da.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(a) {
                        this._x = a, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(a) {
                        this._y = a, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(a) {
                        this._z = a, this.onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(a) {
                        this._order = a, this.onChangeCallback()
                    }
                }
            }), Object.assign(da.prototype, {
                isEuler: !0,
                set: function(a, b, c, d) {
                    return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(a) {
                    return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(a, b, c) {
                    var d = re.clamp,
                        e = a.elements;
                    a = e[0];
                    var f = e[4],
                        g = e[8],
                        h = e[1],
                        i = e[5],
                        j = e[9],
                        k = e[2],
                        l = e[6],
                        e = e[10];
                    return b = b || this._order, "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-j, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(j, -1, 1)), .99999 > Math.abs(j) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(-k, e), this._z = Math.atan2(-f, i)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), .99999 > Math.abs(k) ? (this._x = Math.atan2(l, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-j, i), this._y = Math.atan2(-k, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-j, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), this._order = b, !1 !== c && this.onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var a = new j;
                    return function(b, c, d) {
                        return a.makeRotationFromQuaternion(b), this.setFromRotationMatrix(a, c, d)
                    }
                }(),
                setFromVector3: function(a, b) {
                    return this.set(a.x, a.y, a.z, b || this._order)
                },
                reorder: function() {
                    var a = new h;
                    return function(b) {
                        return a.setFromEuler(this), this.setFromQuaternion(a, b)
                    }
                }(),
                equals: function(a) {
                    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
                },
                fromArray: function(a) {
                    return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), this.onChangeCallback(), this
                },
                toArray: function(a, b) {
                    return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._order, a
                },
                toVector3: function(a) {
                    return a ? a.set(this._x, this._y, this._z) : new i(this._x, this._y, this._z)
                },
                onChange: function(a) {
                    return this.onChangeCallback = a, this
                },
                onChangeCallback: function() {}
            }), Object.assign(ea.prototype, {
                set: function(a) {
                    this.mask = 1 << a | 0
                },
                enable: function(a) {
                    this.mask = this.mask | 1 << a | 0
                },
                toggle: function(a) {
                    this.mask ^= 1 << a | 0
                },
                disable: function(a) {
                    this.mask &= ~(1 << a | 0)
                },
                test: function(a) {
                    return 0 !== (this.mask & a.mask)
                }
            });
            var Ge = 0;
            fa.DefaultUp = new i(0, 1, 0), fa.DefaultMatrixAutoUpdate = !0, Object.assign(fa.prototype, b.prototype, {
                isObject3D: !0,
                applyMatrix: function(a) {
                    this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                setRotationFromAxisAngle: function(a, b) {
                    this.quaternion.setFromAxisAngle(a, b)
                },
                setRotationFromEuler: function(a) {
                    this.quaternion.setFromEuler(a, !0)
                },
                setRotationFromMatrix: function(a) {
                    this.quaternion.setFromRotationMatrix(a)
                },
                setRotationFromQuaternion: function(a) {
                    this.quaternion.copy(a)
                },
                rotateOnAxis: function() {
                    var a = new h;
                    return function(b, c) {
                        return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this
                    }
                }(),
                rotateX: function() {
                    var a = new i(1, 0, 0);
                    return function(b) {
                        return this.rotateOnAxis(a, b)
                    }
                }(),
                rotateY: function() {
                    var a = new i(0, 1, 0);
                    return function(b) {
                        return this.rotateOnAxis(a, b)
                    }
                }(),
                rotateZ: function() {
                    var a = new i(0, 0, 1);
                    return function(b) {
                        return this.rotateOnAxis(a, b)
                    }
                }(),
                translateOnAxis: function() {
                    var a = new i;
                    return function(b, c) {
                        return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), this
                    }
                }(),
                translateX: function() {
                    var a = new i(1, 0, 0);
                    return function(b) {
                        return this.translateOnAxis(a, b)
                    }
                }(),
                translateY: function() {
                    var a = new i(0, 1, 0);
                    return function(b) {
                        return this.translateOnAxis(a, b)
                    }
                }(),
                translateZ: function() {
                    var a = new i(0, 0, 1);
                    return function(b) {
                        return this.translateOnAxis(a, b)
                    }
                }(),
                localToWorld: function(a) {
                    return a.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var a = new j;
                    return function(b) {
                        return b.applyMatrix4(a.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var a = new j;
                    return function(b) {
                        this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a)
                    }
                }(),
                add: function(a) {
                    if (1 < arguments.length) {
                        for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
                        return this
                    }
                    return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this) : (a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
                        type: "added"
                    }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), this)
                },
                remove: function(a) {
                    if (1 < arguments.length)
                        for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
                    b = this.children.indexOf(a), -1 !== b && (a.parent = null, a.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(b, 1))
                },
                getObjectById: function(a) {
                    return this.getObjectByProperty("id", a)
                },
                getObjectByName: function(a) {
                    return this.getObjectByProperty("name", a)
                },
                getObjectByProperty: function(a, b) {
                    if (this[a] === b) return this;
                    for (var c = 0, d = this.children.length; c < d; c++) {
                        var e = this.children[c].getObjectByProperty(a, b);
                        if (void 0 !== e) return e
                    }
                },
                getWorldPosition: function(a) {
                    return a = a || new i, this.updateMatrixWorld(!0), a.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var a = new i,
                        b = new i;
                    return function(c) {
                        return c = c || new h, this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, c, b), c
                    }
                }(),
                getWorldRotation: function() {
                    var a = new h;
                    return function(b) {
                        return b = b || new da, this.getWorldQuaternion(a), b.setFromQuaternion(a, this.rotation.order, !1)
                    }
                }(),
                getWorldScale: function() {
                    var a = new i,
                        b = new h;
                    return function(c) {
                        return c = c || new i, this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, c), c
                    }
                }(),
                getWorldDirection: function() {
                    var a = new h;
                    return function(b) {
                        return b = b || new i, this.getWorldQuaternion(a), b.set(0, 0, 1).applyQuaternion(a)
                    }
                }(),
                raycast: function() {},
                traverse: function(a) {
                    a(this);
                    for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
                },
                traverseVisible: function(a) {
                    if (!1 !== this.visible) {
                        a(this);
                        for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
                    }
                },
                traverseAncestors: function(a) {
                    var b = this.parent;
                    null !== b && (a(b), b.traverseAncestors(a))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(a) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || a) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0);
                    for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a)
                },
                toJSON: function(a) {
                    function b(b, c) {
                        return void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)), c.uuid
                    }

                    function c(a) {
                        var b, c = [];
                        for (b in a) {
                            var d = a[b];
                            delete d.metadata, c.push(d)
                        }
                        return c
                    }
                    var d = void 0 === a || "" === a,
                        e = {};
                    d && (a = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {}
                    }, e.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var f = {};
                    if (f.uuid = this.uuid, f.type = this.type, "" !== this.name && (f.name = this.name), "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData), !0 === this.castShadow && (f.castShadow = !0), !0 === this.receiveShadow && (f.receiveShadow = !0), !1 === this.visible && (f.visible = !1), f.matrix = this.matrix.toArray(), void 0 !== this.geometry && (f.geometry = b(a.geometries, this.geometry)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            for (var g = [], h = 0, i = this.material.length; h < i; h++) g.push(b(a.materials, this.material[h]));
                            f.material = g
                        } else f.material = b(a.materials, this.material);
                    if (0 < this.children.length)
                        for (f.children = [], h = 0; h < this.children.length; h++) f.children.push(this.children[h].toJSON(a).object);
                    return d && (d = c(a.geometries), g = c(a.materials), h = c(a.textures), i = c(a.images), 0 < d.length && (e.geometries = d), 0 < g.length && (e.materials = g), 0 < h.length && (e.textures = h), 0 < i.length && (e.images = i)), e.object = f, e
                },
                clone: function(a) {
                    return (new this.constructor).copy(this, a)
                },
                copy: function(a, b) {
                    if (void 0 === b && (b = !0), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.matrix.copy(a.matrix), this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.layers.mask = a.layers.mask, this.visible = a.visible, this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, this.frustumCulled = a.frustumCulled, this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), !0 === b)
                        for (var c = 0; c < a.children.length; c++) this.add(a.children[c].clone());
                    return this
                }
            }), Object.assign(ga.prototype, {
                set: function(a, b) {
                    return this.start.copy(a), this.end.copy(b), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.start.copy(a.start), this.end.copy(a.end), this
                },
                getCenter: function(a) {
                    return (a || new i).addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(a) {
                    return (a || new i).subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(a, b) {
                    var c = b || new i;
                    return this.delta(c).multiplyScalar(a).add(this.start)
                },
                closestPointToPointParameter: function() {
                    var a = new i,
                        b = new i;
                    return function(c, d) {
                        a.subVectors(c, this.start), b.subVectors(this.end, this.start);
                        var e = b.dot(b),
                            e = b.dot(a) / e;
                        return d && (e = re.clamp(e, 0, 1)), e
                    }
                }(),
                closestPointToPoint: function(a, b, c) {
                    return a = this.closestPointToPointParameter(a, b), c = c || new i, this.delta(c).multiplyScalar(a).add(this.start)
                },
                applyMatrix4: function(a) {
                    return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this
                },
                equals: function(a) {
                    return a.start.equals(this.start) && a.end.equals(this.end)
                }
            }), Object.assign(ha, {
                normal: function() {
                    var a = new i;
                    return function(b, c, d, e) {
                        return e = e || new i, e.subVectors(d, c), a.subVectors(b, c), e.cross(a), b = e.lengthSq(), 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
                    }
                }(),
                barycoordFromPoint: function() {
                    var a = new i,
                        b = new i,
                        c = new i;
                    return function(d, e, f, g, h) {
                        a.subVectors(g, e), b.subVectors(f, e), c.subVectors(d, e), d = a.dot(a), e = a.dot(b), f = a.dot(c);
                        var j = b.dot(b);
                        g = b.dot(c);
                        var k = d * j - e * e;
                        return h = h || new i, 0 === k ? h.set(-2, -1, -1) : (k = 1 / k, j = (j * f - e * g) * k, d = (d * g - e * f) * k, h.set(1 - j - d, d, j))
                    }
                }(),
                containsPoint: function() {
                    var a = new i;
                    return function(b, c, d, e) {
                        return b = ha.barycoordFromPoint(b, c, d, e, a), 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
                    }
                }()
            }), Object.assign(ha.prototype, {
                set: function(a, b, c) {
                    return this.a.copy(a), this.b.copy(b), this.c.copy(c), this
                },
                setFromPointsAndIndices: function(a, b, c, d) {
                    return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this
                },
                area: function() {
                    var a = new i,
                        b = new i;
                    return function() {
                        return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length()
                    }
                }(),
                midpoint: function(a) {
                    return (a || new i).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                normal: function(a) {
                    return ha.normal(this.a, this.b, this.c, a)
                },
                plane: function(a) {
                    return (a || new _).setFromCoplanarPoints(this.a, this.b, this.c)
                },
                barycoordFromPoint: function(a, b) {
                    return ha.barycoordFromPoint(a, this.a, this.b, this.c, b)
                },
                containsPoint: function(a) {
                    return ha.containsPoint(a, this.a, this.b, this.c)
                },
                closestPointToPoint: function() {
                    var a = new _,
                        b = [new ga, new ga, new ga],
                        c = new i,
                        d = new i;
                    return function(e, f) {
                        var g = f || new i,
                            h = 1 / 0;
                        if (a.setFromCoplanarPoints(this.a, this.b, this.c), a.projectPoint(e, c), !0 === this.containsPoint(c)) g.copy(c);
                        else {
                            b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a);
                            for (var j = 0; j < b.length; j++) {
                                b[j].closestPointToPoint(c, !0, d);
                                var k = c.distanceToSquared(d);
                                k < h && (h = k, g.copy(d))
                            }
                        }
                        return g
                    }
                }(),
                equals: function(a) {
                    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
                }
            }), Object.assign(ia.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), this.materialIndex = a.materialIndex;
                    for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
                    for (b = 0, c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
                    return this
                }
            }), ja.prototype = Object.create(V.prototype), ja.prototype.constructor = ja, ja.prototype.isMeshBasicMaterial = !0, ja.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this
            }, Object.defineProperty(ka.prototype, "needsUpdate", {
                set: function(a) {
                    !0 === a && this.version++
                }
            }), Object.assign(ka.prototype, {
                isBufferAttribute: !0,
                setArray: function(a) {
                    if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.count = void 0 !== a ? a.length / this.itemSize : 0, this.array = a
                },
                setDynamic: function(a) {
                    return this.dynamic = a, this
                },
                copy: function(a) {
                    return this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, this.count = a.count, this.normalized = a.normalized, this.dynamic = a.dynamic, this
                },
                copyAt: function(a, b, c) {
                    a *= this.itemSize, c *= b.itemSize;
                    for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
                    return this
                },
                copyArray: function(a) {
                    return this.array.set(a), this
                },
                copyColorsArray: function(a) {
                    for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                        var f = a[d];
                        void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new R), b[c++] = f.r, b[c++] = f.g, b[c++] = f.b
                    }
                    return this
                },
                copyIndicesArray: function(a) {
                    for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                        var f = a[d];
                        b[c++] = f.a, b[c++] = f.b, b[c++] = f.c
                    }
                    return this
                },
                copyVector2sArray: function(a) {
                    for (var b = this.array, d = 0, e = 0, f = a.length; e < f; e++) {
                        var g = a[e];
                        void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", e), g = new c), b[d++] = g.x, b[d++] = g.y
                    }
                    return this
                },
                copyVector3sArray: function(a) {
                    for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                        var f = a[d];
                        void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new i), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z
                    }
                    return this
                },
                copyVector4sArray: function(a) {
                    for (var b = this.array, c = 0, d = 0, f = a.length; d < f; d++) {
                        var g = a[d];
                        void 0 === g && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), g = new e), b[c++] = g.x, b[c++] = g.y, b[c++] = g.z, b[c++] = g.w
                    }
                    return this
                },
                set: function(a, b) {
                    return void 0 === b && (b = 0), this.array.set(a, b), this
                },
                getX: function(a) {
                    return this.array[a * this.itemSize]
                },
                setX: function(a, b) {
                    return this.array[a * this.itemSize] = b, this
                },
                getY: function(a) {
                    return this.array[a * this.itemSize + 1]
                },
                setY: function(a, b) {
                    return this.array[a * this.itemSize + 1] = b, this
                },
                getZ: function(a) {
                    return this.array[a * this.itemSize + 2]
                },
                setZ: function(a, b) {
                    return this.array[a * this.itemSize + 2] = b, this
                },
                getW: function(a) {
                    return this.array[a * this.itemSize + 3]
                },
                setW: function(a, b) {
                    return this.array[a * this.itemSize + 3] = b, this
                },
                setXY: function(a, b, c) {
                    return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this
                },
                setXYZ: function(a, b, c, d) {
                    return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this
                },
                setXYZW: function(a, b, c, d, e) {
                    return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this.array[a + 3] = e, this
                },
                onUpload: function(a) {
                    return this.onUploadCallback = a, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), la.prototype = Object.create(ka.prototype), la.prototype.constructor = la, ma.prototype = Object.create(ka.prototype), ma.prototype.constructor = ma, na.prototype = Object.create(ka.prototype), na.prototype.constructor = na, oa.prototype = Object.create(ka.prototype), oa.prototype.constructor = oa, pa.prototype = Object.create(ka.prototype), pa.prototype.constructor = pa, qa.prototype = Object.create(ka.prototype), qa.prototype.constructor = qa, ra.prototype = Object.create(ka.prototype), ra.prototype.constructor = ra, sa.prototype = Object.create(ka.prototype), sa.prototype.constructor = sa, ta.prototype = Object.create(ka.prototype), ta.prototype.constructor = ta, Object.assign(ua.prototype, {
                computeGroups: function(a) {
                    var b, c = [],
                        d = void 0;
                    a = a.faces;
                    for (var e = 0; e < a.length; e++) {
                        var f = a[e];
                        f.materialIndex !== d && (d = f.materialIndex, void 0 !== b && (b.count = 3 * e - b.start, c.push(b)), b = {
                            start: 3 * e,
                            materialIndex: d
                        })
                    }
                    void 0 !== b && (b.count = 3 * e - b.start, c.push(b)), this.groups = c
                },
                fromGeometry: function(a) {
                    var b, d = a.faces,
                        e = a.vertices,
                        f = a.faceVertexUvs,
                        g = f[0] && 0 < f[0].length,
                        h = f[1] && 0 < f[1].length,
                        i = a.morphTargets,
                        j = i.length;
                    if (0 < j) {
                        b = [];
                        for (var k = 0; k < j; k++) b[k] = [];
                        this.morphTargets.position = b
                    }
                    var l, m = a.morphNormals,
                        n = m.length;
                    if (0 < n) {
                        for (l = [], k = 0; k < n; k++) l[k] = [];
                        this.morphTargets.normal = l
                    }
                    for (var o = a.skinIndices, p = a.skinWeights, q = o.length === e.length, r = p.length === e.length, k = 0; k < d.length; k++) {
                        var s = d[k];
                        this.vertices.push(e[s.a], e[s.b], e[s.c]);
                        var t = s.vertexNormals;
                        for (3 === t.length ? this.normals.push(t[0], t[1], t[2]) : (t = s.normal, this.normals.push(t, t, t)), t = s.vertexColors, 3 === t.length ? this.colors.push(t[0], t[1], t[2]) : (t = s.color, this.colors.push(t, t, t)), !0 === g && (t = f[0][k], void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", k), this.uvs.push(new c, new c, new c))), !0 === h && (t = f[1][k], void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", k), this.uvs2.push(new c, new c, new c))), t = 0; t < j; t++) {
                            var u = i[t].vertices;
                            b[t].push(u[s.a], u[s.b], u[s.c])
                        }
                        for (t = 0; t < n; t++) u = m[t].vertexNormals[k], l[t].push(u.a, u.b, u.c);
                        q && this.skinIndices.push(o[s.a], o[s.b], o[s.c]), r && this.skinWeights.push(p[s.a], p[s.b], p[s.c])
                    }
                    return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this
                }
            });
            var He = 0;
            Object.assign(wa.prototype, b.prototype, {
                isGeometry: !0,
                applyMatrix: function(a) {
                    for (var b = (new $).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
                    for (c = 0, d = this.faces.length; c < d; c++) {
                        a = this.faces[c], a.normal.applyMatrix3(b).normalize();
                        for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
                },
                rotateX: function() {
                    var a = new j;
                    return function(b) {
                        return a.makeRotationX(b), this.applyMatrix(a), this
                    }
                }(),
                rotateY: function() {
                    var a = new j;
                    return function(b) {
                        return a.makeRotationY(b), this.applyMatrix(a), this
                    }
                }(),
                rotateZ: function() {
                    var a = new j;
                    return function(b) {
                        return a.makeRotationZ(b), this.applyMatrix(a), this
                    }
                }(),
                translate: function() {
                    var a = new j;
                    return function(b, c, d) {
                        return a.makeTranslation(b, c, d), this.applyMatrix(a), this
                    }
                }(),
                scale: function() {
                    var a = new j;
                    return function(b, c, d) {
                        return a.makeScale(b, c, d), this.applyMatrix(a), this
                    }
                }(),
                lookAt: function() {
                    var a = new fa;
                    return function(b) {
                        a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
                    }
                }(),
                fromBufferGeometry: function(a) {
                    function b(a, b, c, e) {
                        var f = void 0 !== h ? [m[a].clone(), m[b].clone(), m[c].clone()] : [],
                            g = void 0 !== j ? [d.colors[a].clone(), d.colors[b].clone(), d.colors[c].clone()] : [];
                        e = new ia(a, b, c, f, g, e), d.faces.push(e), void 0 !== k && d.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[c].clone()]), void 0 !== l && d.faceVertexUvs[1].push([o[a].clone(), o[b].clone(), o[c].clone()])
                    }
                    var d = this,
                        e = null !== a.index ? a.index.array : void 0,
                        f = a.attributes,
                        g = f.position.array,
                        h = void 0 !== f.normal ? f.normal.array : void 0,
                        j = void 0 !== f.color ? f.color.array : void 0,
                        k = void 0 !== f.uv ? f.uv.array : void 0,
                        l = void 0 !== f.uv2 ? f.uv2.array : void 0;
                    void 0 !== l && (this.faceVertexUvs[1] = []);
                    for (var m = [], n = [], o = [], p = f = 0; f < g.length; f += 3, p += 2) d.vertices.push(new i(g[f], g[f + 1], g[f + 2])), void 0 !== h && m.push(new i(h[f], h[f + 1], h[f + 2])), void 0 !== j && d.colors.push(new R(j[f], j[f + 1], j[f + 2])), void 0 !== k && n.push(new c(k[p], k[p + 1])), void 0 !== l && o.push(new c(l[p], l[p + 1]));
                    var q = a.groups;
                    if (0 < q.length)
                        for (f = 0; f < q.length; f++)
                            for (var g = q[f], r = g.start, s = g.count, p = r, r = r + s; p < r; p += 3) void 0 !== e ? b(e[p], e[p + 1], e[p + 2], g.materialIndex) : b(p, p + 1, p + 2, g.materialIndex);
                    else if (void 0 !== e)
                        for (f = 0; f < e.length; f += 3) b(e[f], e[f + 1], e[f + 2]);
                    else
                        for (f = 0; f < g.length / 3; f += 3) b(f, f + 1, f + 2);
                    return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this
                },
                center: function() {
                    this.computeBoundingBox();
                    var a = this.boundingBox.getCenter().negate();
                    return this.translate(a.x, a.y, a.z), a
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var a = this.boundingSphere.center,
                        b = this.boundingSphere.radius,
                        b = 0 === b ? 1 : 1 / b,
                        c = new j;
                    return c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1), this.applyMatrix(c), this
                },
                computeFaceNormals: function() {
                    for (var a = new i, b = new i, c = 0, d = this.faces.length; c < d; c++) {
                        var e = this.faces[c],
                            f = this.vertices[e.a],
                            g = this.vertices[e.b];
                        a.subVectors(this.vertices[e.c], g), b.subVectors(f, g), a.cross(b), a.normalize(), e.normal.copy(a)
                    }
                },
                computeVertexNormals: function(a) {
                    void 0 === a && (a = !0);
                    var b, c, d;
                    for (d = Array(this.vertices.length), b = 0, c = this.vertices.length; b < c; b++) d[b] = new i;
                    if (a) {
                        var e, f, g, h = new i,
                            j = new i;
                        for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), j.subVectors(e, f), h.cross(j), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
                    } else
                        for (this.computeFaceNormals(), a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
                    for (b = 0, c = this.vertices.length; b < c; b++) d[b].normalize();
                    for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = c.vertexNormals, 3 === e.length ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c])) : (e[0] = d[c.a].clone(), e[1] = d[c.b].clone(), e[2] = d[c.c].clone());
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var a, b, c;
                    for (this.computeFaceNormals(), a = 0, b = this.faces.length; a < b; a++) {
                        c = this.faces[a];
                        var d = c.vertexNormals;
                        3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone())
                    }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var a, b, c, d, e;
                    for (c = 0, d = this.faces.length; c < d; c++)
                        for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
                    var f = new wa;
                    for (f.faces = this.faces, a = 0, b = this.morphTargets.length; a < b; a++) {
                        if (!this.morphNormals[a]) {
                            this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [], e = this.morphNormals[a].faceNormals;
                            var g, h, j = this.morphNormals[a].vertexNormals;
                            for (c = 0, d = this.faces.length; c < d; c++) g = new i, h = {
                                a: new i,
                                b: new i,
                                c: new i
                            }, e.push(g), j.push(h)
                        }
                        for (j = this.morphNormals[a], f.vertices = this.morphTargets[a].vertices, f.computeFaceNormals(), f.computeVertexNormals(), c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], g = j.faceNormals[c], h = j.vertexNormals[c], g.copy(e.normal), h.a.copy(e.vertexNormals[0]), h.b.copy(e.vertexNormals[1]), h.c.copy(e.vertexNormals[2])
                    }
                    for (c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
                },
                computeLineDistances: function() {
                    for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Y), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Z), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(a, b, c) {
                    if (!1 === (a && a.isGeometry)) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
                    else {
                        var d, e = this.vertices.length,
                            f = this.vertices,
                            g = a.vertices,
                            h = this.faces,
                            i = a.faces,
                            j = this.faceVertexUvs[0],
                            k = a.faceVertexUvs[0],
                            l = this.colors,
                            m = a.colors;
                        void 0 === c && (c = 0), void 0 !== b && (d = (new $).getNormalMatrix(b)), a = 0;
                        for (var n = g.length; a < n; a++) {
                            var o = g[a].clone();
                            void 0 !== b && o.applyMatrix4(b), f.push(o)
                        }
                        for (a = 0, n = m.length; a < n; a++) l.push(m[a].clone());
                        for (a = 0, n = i.length; a < n; a++) {
                            var g = i[a],
                                p = g.vertexNormals,
                                m = g.vertexColors,
                                l = new ia(g.a + e, g.b + e, g.c + e);
                            for (l.normal.copy(g.normal), void 0 !== d && l.normal.applyMatrix3(d).normalize(), b = 0, f = p.length; b < f; b++) o = p[b].clone(), void 0 !== d && o.applyMatrix3(d).normalize(), l.vertexNormals.push(o);
                            for (l.color.copy(g.color), b = 0, f = m.length; b < f; b++) o = m[b], l.vertexColors.push(o.clone());
                            l.materialIndex = g.materialIndex + c, h.push(l)
                        }
                        for (a = 0, n = k.length; a < n; a++)
                            if (c = k[a], d = [], void 0 !== c) {
                                for (b = 0, f = c.length; b < f; b++) d.push(c[b].clone());
                                j.push(d)
                            }
                    }
                },
                mergeMesh: function(a) {
                    !1 === (a && a.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(),
                        this.merge(a.geometry, a.matrix))
                },
                mergeVertices: function() {
                    var a, b, c, d = {},
                        e = [],
                        f = [],
                        g = Math.pow(10, 4);
                    for (b = 0, c = this.vertices.length; b < c; b++) a = this.vertices[b], a = Math.round(a.x * g) + "_" + Math.round(a.y * g) + "_" + Math.round(a.z * g), void 0 === d[a] ? (d[a] = b, e.push(this.vertices[b]), f[b] = e.length - 1) : f[b] = f[d[a]];
                    for (d = [], b = 0, c = this.faces.length; b < c; b++)
                        for (g = this.faces[b], g.a = f[g.a], g.b = f[g.b], g.c = f[g.c], g = [g.a, g.b, g.c], a = 0; 3 > a; a++)
                            if (g[a] === g[(a + 1) % 3]) {
                                d.push(b);
                                break
                            }
                    for (b = d.length - 1; 0 <= b; b--)
                        for (g = d[b], this.faces.splice(g, 1), f = 0, c = this.faceVertexUvs.length; f < c; f++) this.faceVertexUvs[f].splice(g, 1);
                    return b = this.vertices.length - e.length, this.vertices = e, b
                },
                sortFacesByMaterialIndex: function() {
                    for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
                    a.sort(function(a, b) {
                        return a.materialIndex - b.materialIndex
                    });
                    var d, e, f = this.faceVertexUvs[0],
                        g = this.faceVertexUvs[1];
                    for (f && f.length === b && (d = []), g && g.length === b && (e = []), c = 0; c < b; c++) {
                        var h = a[c]._id;
                        d && d.push(f[h]), e && e.push(g[h])
                    }
                    d && (this.faceVertexUvs[0] = d), e && (this.faceVertexUvs[1] = e)
                },
                toJSON: function() {
                    function a(a, b, c) {
                        return c ? a | 1 << b : a & ~(1 << b)
                    }

                    function b(a) {
                        var b = a.x.toString() + a.y.toString() + a.z.toString();
                        return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3, i.push(a.x, a.y, a.z), j[b])
                    }

                    function c(a) {
                        var b = a.r.toString() + a.g.toString() + a.b.toString();
                        return void 0 !== l[b] ? l[b] : (l[b] = k.length, k.push(a.getHex()), l[b])
                    }

                    function d(a) {
                        var b = a.x.toString() + a.y.toString();
                        return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2, m.push(a.x, a.y), n[b])
                    }
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                        var f, g = this.parameters;
                        for (f in g) void 0 !== g[f] && (e[f] = g[f]);
                        return e
                    }
                    for (g = [], f = 0; f < this.vertices.length; f++) {
                        var h = this.vertices[f];
                        g.push(h.x, h.y, h.z)
                    }
                    var h = [],
                        i = [],
                        j = {},
                        k = [],
                        l = {},
                        m = [],
                        n = {};
                    for (f = 0; f < this.faces.length; f++) {
                        var o = this.faces[f],
                            p = void 0 !== this.faceVertexUvs[0][f],
                            q = 0 < o.normal.length(),
                            r = 0 < o.vertexNormals.length,
                            s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b,
                            t = 0 < o.vertexColors.length,
                            u = 0,
                            u = a(u, 0, 0),
                            u = a(u, 1, !0),
                            u = a(u, 2, !1),
                            u = a(u, 3, p),
                            u = a(u, 4, q),
                            u = a(u, 5, r),
                            u = a(u, 6, s),
                            u = a(u, 7, t);
                        h.push(u), h.push(o.a, o.b, o.c), h.push(o.materialIndex), p && (p = this.faceVertexUvs[0][f], h.push(d(p[0]), d(p[1]), d(p[2]))), q && h.push(b(o.normal)), r && (q = o.vertexNormals, h.push(b(q[0]), b(q[1]), b(q[2]))), s && h.push(c(o.color)), t && (o = o.vertexColors, h.push(c(o[0]), c(o[1]), c(o[2])))
                    }
                    return e.data = {}, e.data.vertices = g, e.data.normals = i, 0 < k.length && (e.data.colors = k), 0 < m.length && (e.data.uvs = [m]), e.data.faces = h, e
                },
                clone: function() {
                    return (new wa).copy(this)
                },
                copy: function(a) {
                    var b, c, d, e, f, g;
                    for (this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = a.name, d = a.vertices, b = 0, c = d.length; b < c; b++) this.vertices.push(d[b].clone());
                    for (d = a.colors, b = 0, c = d.length; b < c; b++) this.colors.push(d[b].clone());
                    for (d = a.faces, b = 0, c = d.length; b < c; b++) this.faces.push(d[b].clone());
                    for (b = 0, c = a.faceVertexUvs.length; b < c; b++) {
                        var h = a.faceVertexUvs[b];
                        for (void 0 === this.faceVertexUvs[b] && (this.faceVertexUvs[b] = []), d = 0, e = h.length; d < e; d++) {
                            var i = h[d],
                                j = [];
                            for (f = 0, g = i.length; f < g; f++) j.push(i[f].clone());
                            this.faceVertexUvs[b].push(j)
                        }
                    }
                    for (f = a.morphTargets, b = 0, c = f.length; b < c; b++) {
                        if (g = {}, g.name = f[b].name, void 0 !== f[b].vertices)
                            for (g.vertices = [], d = 0, e = f[b].vertices.length; d < e; d++) g.vertices.push(f[b].vertices[d].clone());
                        if (void 0 !== f[b].normals)
                            for (g.normals = [], d = 0, e = f[b].normals.length; d < e; d++) g.normals.push(f[b].normals[d].clone());
                        this.morphTargets.push(g)
                    }
                    for (f = a.morphNormals, b = 0, c = f.length; b < c; b++) {
                        if (g = {}, void 0 !== f[b].vertexNormals)
                            for (g.vertexNormals = [], d = 0, e = f[b].vertexNormals.length; d < e; d++) h = f[b].vertexNormals[d], i = {}, i.a = h.a.clone(), i.b = h.b.clone(), i.c = h.c.clone(), g.vertexNormals.push(i);
                        if (void 0 !== f[b].faceNormals)
                            for (g.faceNormals = [], d = 0, e = f[b].faceNormals.length; d < e; d++) g.faceNormals.push(f[b].faceNormals[d].clone());
                        this.morphNormals.push(g)
                    }
                    for (d = a.skinWeights, b = 0, c = d.length; b < c; b++) this.skinWeights.push(d[b].clone());
                    for (d = a.skinIndices, b = 0, c = d.length; b < c; b++) this.skinIndices.push(d[b].clone());
                    for (d = a.lineDistances, b = 0, c = d.length; b < c; b++) this.lineDistances.push(d[b]);
                    return b = a.boundingBox, null !== b && (this.boundingBox = b.clone()), b = a.boundingSphere, null !== b && (this.boundingSphere = b.clone()), this.elementsNeedUpdate = a.elementsNeedUpdate, this.verticesNeedUpdate = a.verticesNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), xa.MaxIndex = 65535, Object.assign(xa.prototype, b.prototype, {
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(a) {
                    Array.isArray(a) ? this.index = new(65535 < va(a) ? ra : pa)(a, 1) : this.index = a
                },
                addAttribute: function(a, b, c) {
                    if (!1 === (b && b.isBufferAttribute) && !1 === (b && b.isInterleavedBufferAttribute)) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new ka(b, c));
                    else {
                        if ("index" !== a) return this.attributes[a] = b, this;
                        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b)
                    }
                },
                getAttribute: function(a) {
                    return this.attributes[a]
                },
                removeAttribute: function(a) {
                    return delete this.attributes[a], this
                },
                addGroup: function(a, b, c) {
                    this.groups.push({
                        start: a,
                        count: b,
                        materialIndex: void 0 !== c ? c : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(a, b) {
                    this.drawRange.start = a, this.drawRange.count = b
                },
                applyMatrix: function(a) {
                    var b = this.attributes.position;
                    return void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0), b = this.attributes.normal, void 0 !== b && ((new $).getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() {
                    var a = new j;
                    return function(b) {
                        return a.makeRotationX(b), this.applyMatrix(a), this
                    }
                }(),
                rotateY: function() {
                    var a = new j;
                    return function(b) {
                        return a.makeRotationY(b), this.applyMatrix(a), this
                    }
                }(),
                rotateZ: function() {
                    var a = new j;
                    return function(b) {
                        return a.makeRotationZ(b), this.applyMatrix(a), this
                    }
                }(),
                translate: function() {
                    var a = new j;
                    return function(b, c, d) {
                        return a.makeTranslation(b, c, d), this.applyMatrix(a), this
                    }
                }(),
                scale: function() {
                    var a = new j;
                    return function(b, c, d) {
                        return a.makeScale(b, c, d), this.applyMatrix(a), this
                    }
                }(),
                lookAt: function() {
                    var a = new fa;
                    return function(b) {
                        a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
                    }
                }(),
                center: function() {
                    this.computeBoundingBox();
                    var a = this.boundingBox.getCenter().negate();
                    return this.translate(a.x, a.y, a.z), a
                },
                setFromObject: function(a) {
                    var b = a.geometry;
                    if (a.isPoints || a.isLine) {
                        a = new sa(3 * b.vertices.length, 3);
                        var c = new sa(3 * b.colors.length, 3);
                        this.addAttribute("position", a.copyVector3sArray(b.vertices)), this.addAttribute("color", c.copyColorsArray(b.colors)), b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new sa(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances))), null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
                    } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
                    return this
                },
                updateFromObject: function(a) {
                    var b = a.geometry;
                    if (a.isMesh) {
                        var c = b.__directGeometry;
                        if (!0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1), void 0 === c) return this.fromGeometry(b);
                        c.verticesNeedUpdate = b.verticesNeedUpdate, c.normalsNeedUpdate = b.normalsNeedUpdate, c.colorsNeedUpdate = b.colorsNeedUpdate, c.uvsNeedUpdate = b.uvsNeedUpdate, c.groupsNeedUpdate = b.groupsNeedUpdate, b.verticesNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.uvsNeedUpdate = !1, b.groupsNeedUpdate = !1, b = c
                    }
                    return !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1), !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1), !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1), b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1), b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1), b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(a) {
                    return a.__directGeometry = (new ua).fromGeometry(a), this.fromDirectGeometry(a.__directGeometry)
                },
                fromDirectGeometry: function(a) {
                    var b = new Float32Array(3 * a.vertices.length);
                    this.addAttribute("position", new ka(b, 3).copyVector3sArray(a.vertices)), 0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", new ka(b, 3).copyVector3sArray(a.normals))), 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", new ka(b, 3).copyColorsArray(a.colors))), 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", new ka(b, 2).copyVector2sArray(a.uvs))), 0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", new ka(b, 2).copyVector2sArray(a.uvs2))), 0 < a.indices.length && (b = new(65535 < va(a.indices) ? Uint32Array : Uint16Array)(3 * a.indices.length), this.setIndex(new ka(b, 1).copyIndicesArray(a.indices))), this.groups = a.groups;
                    for (var c in a.morphTargets) {
                        for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                            var g = d[e],
                                h = new sa(3 * g.length, 3);
                            b.push(h.copyVector3sArray(g))
                        }
                        this.morphAttributes[c] = b
                    }
                    return 0 < a.skinIndices.length && (c = new sa(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))), 0 < a.skinWeights.length && (c = new sa(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Y);
                    var a = this.attributes.position;
                    void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    var a = new Y,
                        b = new i;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new Z);
                        var c = this.attributes.position;
                        if (c) {
                            var d = this.boundingSphere.center;
                            a.setFromBufferAttribute(c), a.getCenter(d);
                            for (var e = 0, f = 0, g = c.count; f < g; f++) b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));
                            this.boundingSphere.radius = Math.sqrt(e), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var a = this.index,
                        b = this.attributes,
                        c = this.groups;
                    if (b.position) {
                        var d = b.position.array;
                        if (void 0 === b.normal) this.addAttribute("normal", new ka(new Float32Array(d.length), 3));
                        else
                            for (var e = b.normal.array, f = 0, g = e.length; f < g; f++) e[f] = 0;
                        var h, j, k, e = b.normal.array,
                            l = new i,
                            m = new i,
                            n = new i,
                            o = new i,
                            p = new i;
                        if (a) {
                            a = a.array, 0 === c.length && this.addGroup(0, a.length);
                            for (var q = 0, r = c.length; q < r; ++q)
                                for (f = c[q], g = f.start, h = f.count, f = g, g += h; f < g; f += 3) h = 3 * a[f + 0], j = 3 * a[f + 1], k = 3 * a[f + 2], l.fromArray(d, h), m.fromArray(d, j), n.fromArray(d, k), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), e[h] += o.x, e[h + 1] += o.y, e[h + 2] += o.z, e[j] += o.x, e[j + 1] += o.y, e[j + 2] += o.z, e[k] += o.x, e[k + 1] += o.y, e[k + 2] += o.z
                        } else
                            for (f = 0, g = d.length; f < g; f += 9) l.fromArray(d, f), m.fromArray(d, f + 3), n.fromArray(d, f + 6), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), e[f] = o.x, e[f + 1] = o.y, e[f + 2] = o.z, e[f + 3] = o.x, e[f + 4] = o.y, e[f + 5] = o.z, e[f + 6] = o.x, e[f + 7] = o.y, e[f + 8] = o.z;
                        this.normalizeNormals(), b.normal.needsUpdate = !0
                    }
                },
                merge: function(a, b) {
                    if (!1 !== (a && a.isBufferGeometry)) {
                        void 0 === b && (b = 0);
                        var c, d = this.attributes;
                        for (c in d)
                            if (void 0 !== a.attributes[c])
                                for (var e = d[c].array, f = a.attributes[c], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
                },
                normalizeNormals: function() {
                    for (var a, b, c, d, e = this.attributes.normal, f = 0, g = e.count; f < g; f++) a = e.getX(f), b = e.getY(f), c = e.getZ(f), d = 1 / Math.sqrt(a * a + b * b + c * c), e.setXYZ(f, a * d, b * d, c * d)
                },
                toNonIndexed: function() {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var a, b = new xa,
                        c = this.index.array,
                        d = this.attributes;
                    for (a in d) {
                        for (var e, f = d[a], g = f.array, f = f.itemSize, h = new g.constructor(c.length * f), i = 0, j = 0, k = c.length; j < k; j++) {
                            e = c[j] * f;
                            for (var l = 0; l < f; l++) h[i++] = g[e++]
                        }
                        b.addAttribute(a, new ka(h, f))
                    }
                    return b
                },
                toJSON: function() {
                    var a = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), void 0 !== this.parameters) {
                        var b, c = this.parameters;
                        for (b in c) void 0 !== c[b] && (a[b] = c[b]);
                        return a
                    }
                    a.data = {
                        attributes: {}
                    };
                    var d = this.index;
                    null !== d && (c = Array.prototype.slice.call(d.array), a.data.index = {
                        type: d.array.constructor.name,
                        array: c
                    }), d = this.attributes;
                    for (b in d) {
                        var e = d[b],
                            c = Array.prototype.slice.call(e.array);
                        a.data.attributes[b] = {
                            itemSize: e.itemSize,
                            type: e.array.constructor.name,
                            array: c,
                            normalized: e.normalized
                        }
                    }
                    return b = this.groups, 0 < b.length && (a.data.groups = JSON.parse(JSON.stringify(b))), b = this.boundingSphere, null !== b && (a.data.boundingSphere = {
                        center: b.center.toArray(),
                        radius: b.radius
                    }), a
                },
                clone: function() {
                    return (new xa).copy(this)
                },
                copy: function(a) {
                    var b, c, d;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = a.name, c = a.index, null !== c && this.setIndex(c.clone()), c = a.attributes;
                    for (b in c) this.addAttribute(b, c[b].clone());
                    var e = a.morphAttributes;
                    for (b in e) {
                        var f = [],
                            g = e[b];
                        for (c = 0, d = g.length; c < d; c++) f.push(g[c].clone());
                        this.morphAttributes[b] = f
                    }
                    for (b = a.groups, c = 0, d = b.length; c < d; c++) e = b[c], this.addGroup(e.start, e.count, e.materialIndex);
                    return b = a.boundingBox, null !== b && (this.boundingBox = b.clone()), b = a.boundingSphere, null !== b && (this.boundingSphere = b.clone()), this.drawRange.start = a.drawRange.start, this.drawRange.count = a.drawRange.count, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), ya.prototype = Object.assign(Object.create(fa.prototype), {
                constructor: ya,
                isMesh: !0,
                setDrawMode: function(a) {
                    this.drawMode = a
                },
                copy: function(a) {
                    return fa.prototype.copy.call(this, a), this.drawMode = a.drawMode, this
                },
                updateMorphTargets: function() {
                    var a = this.geometry.morphTargets;
                    if (void 0 !== a && 0 < a.length) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (var b = 0, c = a.length; b < c; b++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[a[b].name] = b
                    }
                },
                raycast: function() {
                    function a(a, b, c, d, e, f, g) {
                        return ha.barycoordFromPoint(a, b, c, d, s), e.multiplyScalar(s.x), f.multiplyScalar(s.y), g.multiplyScalar(s.z), e.add(f).add(g), e.clone()
                    }

                    function b(a, b, c, d, e, f, g) {
                        var h = a.material;
                        return null === (1 === h.side ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, 2 !== h.side, g)) ? null : (u.copy(g), u.applyMatrix4(a.matrixWorld), c = b.ray.origin.distanceTo(u), c < b.near || c > b.far ? null : {
                            distance: c,
                            point: u.clone(),
                            object: a
                        })
                    }

                    function d(c, d, e, f, g, i, j, m) {
                        return h.fromBufferAttribute(f, i), k.fromBufferAttribute(f, j), l.fromBufferAttribute(f, m), (c = b(c, d, e, h, k, l, t)) && (g && (p.fromBufferAttribute(g, i), q.fromBufferAttribute(g, j), r.fromBufferAttribute(g, m), c.uv = a(t, h, k, l, p, q, r)), c.face = new ia(i, j, m, ha.normal(h, k, l)), c.faceIndex = i), c
                    }
                    var e = new j,
                        f = new ca,
                        g = new Z,
                        h = new i,
                        k = new i,
                        l = new i,
                        m = new i,
                        n = new i,
                        o = new i,
                        p = new c,
                        q = new c,
                        r = new c,
                        s = new i,
                        t = new i,
                        u = new i;
                    return function(c, i) {
                        var j = this.geometry,
                            s = this.material,
                            u = this.matrixWorld;
                        if (void 0 !== s && (null === j.boundingSphere && j.computeBoundingSphere(), g.copy(j.boundingSphere), g.applyMatrix4(u), !1 !== c.ray.intersectsSphere(g) && (e.getInverse(u), f.copy(c.ray).applyMatrix4(e), null === j.boundingBox || !1 !== f.intersectsBox(j.boundingBox)))) {
                            var v;
                            if (j.isBufferGeometry) {
                                var w, x, y, z, s = j.index,
                                    A = j.attributes.position,
                                    u = j.attributes.uv;
                                if (null !== s)
                                    for (y = 0, z = s.count; y < z; y += 3) j = s.getX(y), w = s.getX(y + 1), x = s.getX(y + 2), (v = d(this, c, f, A, u, j, w, x)) && (v.faceIndex = Math.floor(y / 3), i.push(v));
                                else
                                    for (y = 0, z = A.count; y < z; y += 3) j = y, w = y + 1, x = y + 2, (v = d(this, c, f, A, u, j, w, x)) && (v.index = j, i.push(v))
                            } else if (j.isGeometry) {
                                var B, u = Array.isArray(s);
                                y = j.vertices, z = j.faces, w = j.faceVertexUvs[0], 0 < w.length && (A = w);
                                for (var C = 0, D = z.length; C < D; C++) {
                                    var E = z[C];
                                    if (v = u ? s[E.materialIndex] : s, void 0 !== v) {
                                        if (w = y[E.a], x = y[E.b], B = y[E.c], !0 === v.morphTargets) {
                                            v = j.morphTargets;
                                            var F = this.morphTargetInfluences;
                                            h.set(0, 0, 0), k.set(0, 0, 0), l.set(0, 0, 0);
                                            for (var G = 0, H = v.length; G < H; G++) {
                                                var I = F[G];
                                                if (0 !== I) {
                                                    var J = v[G].vertices;
                                                    h.addScaledVector(m.subVectors(J[E.a], w), I), k.addScaledVector(n.subVectors(J[E.b], x), I), l.addScaledVector(o.subVectors(J[E.c], B), I)
                                                }
                                            }
                                            h.add(w), k.add(x), l.add(B), w = h, x = k, B = l
                                        }(v = b(this, c, f, w, x, B, t)) && (A && A[C] && (F = A[C], p.copy(F[0]), q.copy(F[1]), r.copy(F[2]), v.uv = a(t, w, x, B, p, q, r)), v.face = E, v.faceIndex = C, i.push(v))
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), za.prototype = Object.create(wa.prototype), za.prototype.constructor = za, Aa.prototype = Object.create(xa.prototype), Aa.prototype.constructor = Aa, Ba.prototype = Object.create(wa.prototype), Ba.prototype.constructor = Ba, Ca.prototype = Object.create(xa.prototype), Ca.prototype.constructor = Ca, Da.prototype = Object.assign(Object.create(fa.prototype), {
                constructor: Da,
                isCamera: !0,
                copy: function(a) {
                    return fa.prototype.copy.call(this, a), this.matrixWorldInverse.copy(a.matrixWorldInverse), this.projectionMatrix.copy(a.projectionMatrix), this
                },
                getWorldDirection: function() {
                    var a = new h;
                    return function(b) {
                        return b = b || new i, this.getWorldQuaternion(a), b.set(0, 0, -1).applyQuaternion(a)
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Ea.prototype = Object.assign(Object.create(Da.prototype), {
                constructor: Ea,
                isPerspectiveCamera: !0,
                copy: function(a) {
                    return Da.prototype.copy.call(this, a), this.fov = a.fov, this.zoom = a.zoom, this.near = a.near, this.far = a.far, this.focus = a.focus, this.aspect = a.aspect, this.view = null === a.view ? null : Object.assign({}, a.view), this.filmGauge = a.filmGauge, this.filmOffset = a.filmOffset, this
                },
                setFocalLength: function(a) {
                    a = .5 * this.getFilmHeight() / a, this.fov = 2 * re.RAD2DEG * Math.atan(a), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var a = Math.tan(.5 * re.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / a
                },
                getEffectiveFOV: function() {
                    return 2 * re.RAD2DEG * Math.atan(Math.tan(.5 * re.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(a, b, c, d, e, f) {
                    this.aspect = a / b, this.view = {
                        fullWidth: a,
                        fullHeight: b,
                        offsetX: c,
                        offsetY: d,
                        width: e,
                        height: f
                    }, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    this.view = null, this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var a = this.near,
                        b = a * Math.tan(.5 * re.DEG2RAD * this.fov) / this.zoom,
                        c = 2 * b,
                        d = this.aspect * c,
                        e = -.5 * d,
                        f = this.view;
                    if (null !== f) var g = f.fullWidth,
                        h = f.fullHeight,
                        e = e + f.offsetX * d / g,
                        b = b - f.offsetY * c / h,
                        d = f.width / g * d,
                        c = f.height / h * c;
                    f = this.filmOffset, 0 !== f && (e += a * f / this.getFilmWidth()), this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far)
                },
                toJSON: function(a) {
                    return a = fa.prototype.toJSON.call(this, a), a.object.fov = this.fov, a.object.zoom = this.zoom, a.object.near = this.near, a.object.far = this.far, a.object.focus = this.focus, a.object.aspect = this.aspect, null !== this.view && (a.object.view = Object.assign({}, this.view)), a.object.filmGauge = this.filmGauge, a.object.filmOffset = this.filmOffset, a
                }
            }), Fa.prototype = Object.assign(Object.create(Da.prototype), {
                constructor: Fa,
                isOrthographicCamera: !0,
                copy: function(a) {
                    return Da.prototype.copy.call(this, a), this.left = a.left, this.right = a.right, this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, this.zoom = a.zoom, this.view = null === a.view ? null : Object.assign({}, a.view), this
                },
                setViewOffset: function(a, b, c, d, e, f) {
                    this.view = {
                        fullWidth: a,
                        fullHeight: b,
                        offsetX: c,
                        offsetY: d,
                        width: e,
                        height: f
                    }, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    this.view = null, this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var a = (this.right - this.left) / (2 * this.zoom),
                        b = (this.top - this.bottom) / (2 * this.zoom),
                        c = (this.right + this.left) / 2,
                        d = (this.top + this.bottom) / 2,
                        e = c - a,
                        c = c + a,
                        a = d + b,
                        b = d - b;
                    if (null !== this.view) var c = this.zoom / (this.view.width / this.view.fullWidth),
                        b = this.zoom / (this.view.height / this.view.fullHeight),
                        f = (this.right - this.left) / this.view.width,
                        d = (this.top - this.bottom) / this.view.height,
                        e = e + this.view.offsetX / c * f,
                        c = e + this.view.width / c * f,
                        a = a - this.view.offsetY / b * d,
                        b = a - this.view.height / b * d;
                    this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far)
                },
                toJSON: function(a) {
                    return a = fa.prototype.toJSON.call(this, a), a.object.zoom = this.zoom, a.object.left = this.left, a.object.right = this.right, a.object.top = this.top, a.object.bottom = this.bottom, a.object.near = this.near, a.object.far = this.far, null !== this.view && (a.object.view = Object.assign({}, this.view)), a
                }
            });
            var Ie = 0;
            jb.prototype.isFogExp2 = !0, jb.prototype.clone = function() {
                    return new jb(this.color.getHex(), this.density)
                }, jb.prototype.toJSON = function(a) {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }, kb.prototype.isFog = !0, kb.prototype.clone = function() {
                    return new kb(this.color.getHex(), this.near, this.far)
                }, kb.prototype.toJSON = function(a) {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }, lb.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: lb,
                    copy: function(a, b) {
                        return fa.prototype.copy.call(this, a, b), null !== a.background && (this.background = a.background.clone()), null !== a.fog && (this.fog = a.fog.clone()), null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this
                    },
                    toJSON: function(a) {
                        var b = fa.prototype.toJSON.call(this, a);
                        return null !== this.background && (b.object.background = this.background.toJSON(a)), null !== this.fog && (b.object.fog = this.fog.toJSON()), b
                    }
                }), mb.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: mb,
                    isLensFlare: !0,
                    copy: function(a) {
                        fa.prototype.copy.call(this, a), this.positionScreen.copy(a.positionScreen), this.customUpdateCallback = a.customUpdateCallback;
                        for (var b = 0, c = a.lensFlares.length; b < c; b++) this.lensFlares.push(a.lensFlares[b]);
                        return this
                    },
                    add: function(a, b, c, d, e, f) {
                        void 0 === b && (b = -1), void 0 === c && (c = 0), void 0 === f && (f = 1), void 0 === e && (e = new R(16777215)), void 0 === d && (d = 1), c = Math.min(c, Math.max(0, c)), this.lensFlares.push({
                            texture: a,
                            size: b,
                            distance: c,
                            x: 0,
                            y: 0,
                            z: 0,
                            scale: 1,
                            rotation: 0,
                            opacity: f,
                            color: e,
                            blending: d
                        })
                    },
                    updateLensFlares: function() {
                        var a, b, c = this.lensFlares.length,
                            d = 2 * -this.positionScreen.x,
                            e = 2 * -this.positionScreen.y;
                        for (a = 0; a < c; a++) b = this.lensFlares[a], b.x = this.positionScreen.x + d * b.distance, b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, b.rotation += .25 * (b.wantedRotation - b.rotation)
                    }
                }), nb.prototype = Object.create(V.prototype), nb.prototype.constructor = nb, nb.prototype.isSpriteMaterial = !0, nb.prototype.copy = function(a) {
                    return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.rotation = a.rotation, this
                }, ob.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ob,
                    isSprite: !0,
                    raycast: function() {
                        var a = new i,
                            b = new i,
                            c = new i;
                        return function(d, e) {
                            b.setFromMatrixPosition(this.matrixWorld), d.ray.closestPointToPoint(b, a), c.setFromMatrixScale(this.matrixWorld);
                            var f = c.x * c.y / 4;
                            b.distanceToSquared(a) > f || (f = d.ray.origin.distanceTo(a), f < d.near || f > d.far || e.push({
                                distance: f,
                                point: a.clone(),
                                face: null,
                                object: this
                            }))
                        }
                    }(),
                    clone: function() {
                        return new this.constructor(this.material).copy(this)
                    }
                }), pb.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: pb,
                    copy: function(a) {
                        fa.prototype.copy.call(this, a, !1), a = a.levels;
                        for (var b = 0, c = a.length; b < c; b++) {
                            var d = a[b];
                            this.addLevel(d.object.clone(), d.distance)
                        }
                        return this
                    },
                    addLevel: function(a, b) {
                        void 0 === b && (b = 0), b = Math.abs(b);
                        for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
                        c.splice(d, 0, {
                            distance: b,
                            object: a
                        }), this.add(a)
                    },
                    getObjectForDistance: function(a) {
                        for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
                        return b[c - 1].object
                    },
                    raycast: function() {
                        var a = new i;
                        return function(b, c) {
                            a.setFromMatrixPosition(this.matrixWorld);
                            var d = b.ray.origin.distanceTo(a);
                            this.getObjectForDistance(d).raycast(b, c)
                        }
                    }(),
                    update: function() {
                        var a = new i,
                            b = new i;
                        return function(c) {
                            var d = this.levels;
                            if (1 < d.length) {
                                a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld), c = a.distanceTo(b), d[0].object.visible = !0;
                                for (var e = 1, f = d.length; e < f && c >= d[e].distance; e++) d[e - 1].object.visible = !1, d[e].object.visible = !0;
                                for (; e < f; e++) d[e].object.visible = !1
                            }
                        }
                    }(),
                    toJSON: function(a) {
                        a = fa.prototype.toJSON.call(this, a), a.object.levels = [];
                        for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
                            var e = b[c];
                            a.object.levels.push({
                                object: e.object.uuid,
                                distance: e.distance
                            })
                        }
                        return a
                    }
                }), Object.assign(qb.prototype, {
                    calculateInverses: function() {
                        this.boneInverses = [];
                        for (var a = 0, b = this.bones.length; a < b; a++) {
                            var c = new j;
                            this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c)
                        }
                    },
                    pose: function() {
                        var a, b, c;
                        for (b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
                        for (b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                    },
                    update: function() {
                        var a = new j,
                            b = new j;
                        return function() {
                            for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++) a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), a.toArray(e, 16 * g);
                            void 0 !== f && (f.needsUpdate = !0)
                        }
                    }(),
                    clone: function() {
                        return new qb(this.bones, this.boneInverses)
                    }
                }), rb.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: rb,
                    isBone: !0
                }), sb.prototype = Object.assign(Object.create(ya.prototype), {
                    constructor: sb,
                    isSkinnedMesh: !0,
                    initBones: function() {
                        var a, b, c, d, e = [];
                        if (this.geometry && void 0 !== this.geometry.bones) {
                            for (c = 0, d = this.geometry.bones.length; c < d; c++) b = this.geometry.bones[c], a = new rb, e.push(a), a.name = b.name, a.position.fromArray(b.pos), a.quaternion.fromArray(b.rotq), void 0 !== b.scl && a.scale.fromArray(b.scl);
                            for (c = 0, d = this.geometry.bones.length; c < d; c++) b = this.geometry.bones[c], -1 !== b.parent && null !== b.parent && void 0 !== e[b.parent] ? e[b.parent].add(e[c]) : this.add(e[c])
                        }
                        return this.updateMatrixWorld(!0), e
                    },
                    bind: function(a, b) {
                        this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b)
                    },
                    pose: function() {
                        this.skeleton.pose()
                    },
                    normalizeSkinWeights: function() {
                        var a, b;
                        if (this.geometry && this.geometry.isGeometry)
                            for (b = 0; b < this.geometry.skinWeights.length; b++) {
                                var c = this.geometry.skinWeights[b];
                                a = 1 / c.lengthManhattan(), 1 / 0 !== a ? c.multiplyScalar(a) : c.set(1, 0, 0, 0)
                            } else if (this.geometry && this.geometry.isBufferGeometry) {
                                var c = new e,
                                    d = this.geometry.attributes.skinWeight;
                                for (b = 0; b < d.count; b++) c.x = d.getX(b), c.y = d.getY(b), c.z = d.getZ(b), c.w = d.getW(b), a = 1 / c.lengthManhattan(), 1 / 0 !== a ? c.multiplyScalar(a) : c.set(1, 0, 0, 0), d.setXYZW(b, c.x, c.y, c.z, c.w)
                            }
                    },
                    updateMatrixWorld: function(a) {
                        ya.prototype.updateMatrixWorld.call(this, a), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    },
                    clone: function() {
                        return new this.constructor(this.geometry, this.material).copy(this)
                    }
                }), tb.prototype = Object.create(V.prototype), tb.prototype.constructor = tb, tb.prototype.isLineBasicMaterial = !0, tb.prototype.copy = function(a) {
                    return V.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.linecap = a.linecap, this.linejoin = a.linejoin, this
                }, ub.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ub,
                    isLine: !0,
                    raycast: function() {
                        var a = new j,
                            b = new ca,
                            c = new Z;
                        return function(d, e) {
                            var f = d.linePrecision,
                                f = f * f,
                                g = this.geometry,
                                h = this.matrixWorld;
                            if (null === g.boundingSphere && g.computeBoundingSphere(), c.copy(g.boundingSphere), c.applyMatrix4(h), !1 !== d.ray.intersectsSphere(c)) {
                                a.getInverse(h), b.copy(d.ray).applyMatrix4(a);
                                var j = new i,
                                    k = new i,
                                    h = new i,
                                    l = new i,
                                    m = this && this.isLineSegments ? 2 : 1;
                                if (g.isBufferGeometry) {
                                    var n = g.index,
                                        o = g.attributes.position.array;
                                    if (null !== n)
                                        for (var n = n.array, g = 0, p = n.length - 1; g < p; g += m) {
                                            var q = n[g + 1];
                                            j.fromArray(o, 3 * n[g]), k.fromArray(o, 3 * q), q = b.distanceSqToSegment(j, k, l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
                                                distance: q,
                                                point: h.clone().applyMatrix4(this.matrixWorld),
                                                index: g,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            }))
                                        } else
                                            for (g = 0, p = o.length / 3 - 1; g < p; g += m) j.fromArray(o, 3 * g), k.fromArray(o, 3 * g + 3), q = b.distanceSqToSegment(j, k, l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
                                                distance: q,
                                                point: h.clone().applyMatrix4(this.matrixWorld),
                                                index: g,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            }))
                                } else if (g.isGeometry)
                                    for (j = g.vertices, k = j.length, g = 0; g < k - 1; g += m) q = b.distanceSqToSegment(j[g], j[g + 1], l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
                                        distance: q,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: g,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                            }
                        }
                    }(),
                    clone: function() {
                        return new this.constructor(this.geometry, this.material).copy(this)
                    }
                }), vb.prototype = Object.assign(Object.create(ub.prototype), {
                    constructor: vb,
                    isLineSegments: !0
                }), wb.prototype = Object.assign(Object.create(ub.prototype), {
                    constructor: wb,
                    isLineLoop: !0
                }), xb.prototype = Object.create(V.prototype), xb.prototype.constructor = xb, xb.prototype.isPointsMaterial = !0, xb.prototype.copy = function(a) {
                    return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.size = a.size, this.sizeAttenuation = a.sizeAttenuation, this
                }, yb.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: yb,
                    isPoints: !0,
                    raycast: function() {
                        var a = new j,
                            b = new ca,
                            c = new Z;
                        return function(d, e) {
                            function f(a, c) {
                                var f = b.distanceSqToPoint(a);
                                if (f < l) {
                                    var h = b.closestPointToPoint(a);
                                    h.applyMatrix4(j);
                                    var i = d.ray.origin.distanceTo(h);
                                    i < d.near || i > d.far || e.push({
                                        distance: i,
                                        distanceToRay: Math.sqrt(f),
                                        point: h.clone(),
                                        index: c,
                                        face: null,
                                        object: g
                                    })
                                }
                            }
                            var g = this,
                                h = this.geometry,
                                j = this.matrixWorld,
                                k = d.params.Points.threshold;
                            if (null === h.boundingSphere && h.computeBoundingSphere(), c.copy(h.boundingSphere), c.applyMatrix4(j), c.radius += k, !1 !== d.ray.intersectsSphere(c)) {
                                a.getInverse(j), b.copy(d.ray).applyMatrix4(a);
                                var k = k / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                    l = k * k,
                                    k = new i;
                                if (h.isBufferGeometry) {
                                    var m = h.index,
                                        h = h.attributes.position.array;
                                    if (null !== m)
                                        for (var n = m.array, m = 0, o = n.length; m < o; m++) {
                                            var p = n[m];
                                            k.fromArray(h, 3 * p), f(k, p)
                                        } else
                                            for (m = 0, n = h.length / 3; m < n; m++) k.fromArray(h, 3 * m), f(k, m)
                                } else
                                    for (k = h.vertices, m = 0, n = k.length; m < n; m++) f(k[m], m)
                            }
                        }
                    }(),
                    clone: function() {
                        return new this.constructor(this.geometry, this.material).copy(this)
                    }
                }), zb.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: zb
                }), Ab.prototype = Object.create(d.prototype), Ab.prototype.constructor = Ab, Bb.prototype = Object.create(d.prototype), Bb.prototype.constructor = Bb, Bb.prototype.isCompressedTexture = !0, Cb.prototype = Object.create(d.prototype), Cb.prototype.constructor = Cb, Db.prototype = Object.create(d.prototype), Db.prototype.constructor = Db, Db.prototype.isDepthTexture = !0, Eb.prototype = Object.create(xa.prototype), Eb.prototype.constructor = Eb, Fb.prototype = Object.create(wa.prototype), Fb.prototype.constructor = Fb, Gb.prototype = Object.create(xa.prototype),
                Gb.prototype.constructor = Gb, Hb.prototype = Object.create(wa.prototype), Hb.prototype.constructor = Hb, Ib.prototype = Object.create(xa.prototype), Ib.prototype.constructor = Ib, Jb.prototype = Object.create(wa.prototype), Jb.prototype.constructor = Jb, Kb.prototype = Object.create(Ib.prototype), Kb.prototype.constructor = Kb, Lb.prototype = Object.create(wa.prototype), Lb.prototype.constructor = Lb, Mb.prototype = Object.create(Ib.prototype), Mb.prototype.constructor = Mb, Nb.prototype = Object.create(wa.prototype), Nb.prototype.constructor = Nb, Ob.prototype = Object.create(Ib.prototype), Ob.prototype.constructor = Ob, Pb.prototype = Object.create(wa.prototype), Pb.prototype.constructor = Pb, Qb.prototype = Object.create(Ib.prototype), Qb.prototype.constructor = Qb, Rb.prototype = Object.create(wa.prototype), Rb.prototype.constructor = Rb, Sb.prototype = Object.create(xa.prototype), Sb.prototype.constructor = Sb, Tb.prototype = Object.create(wa.prototype), Tb.prototype.constructor = Tb, Ub.prototype = Object.create(xa.prototype), Ub.prototype.constructor = Ub, Vb.prototype = Object.create(wa.prototype), Vb.prototype.constructor = Vb, Wb.prototype = Object.create(xa.prototype), Wb.prototype.constructor = Wb;
            var Je = {
                area: function(a) {
                    for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
                    return .5 * c
                },
                triangulate: function() {
                    return function(a, b) {
                        var c = a.length;
                        if (3 > c) return null;
                        var d, e, f, g = [],
                            h = [],
                            i = [];
                        if (0 < Je.area(a))
                            for (e = 0; e < c; e++) h[e] = e;
                        else
                            for (e = 0; e < c; e++) h[e] = c - 1 - e;
                        var j = 2 * c;
                        for (e = c - 1; 2 < c;) {
                            if (0 >= j--) {
                                console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                                break
                            }
                            d = e, c <= d && (d = 0), e = d + 1, c <= e && (e = 0), f = e + 1, c <= f && (f = 0);
                            var k;
                            a: {
                                var l, m, n, o, p, q, r, s;
                                if (l = a[h[d]].x, m = a[h[d]].y, n = a[h[e]].x, o = a[h[e]].y, p = a[h[f]].x, q = a[h[f]].y, 0 >= (n - l) * (q - m) - (o - m) * (p - l)) k = !1;
                                else {
                                    var t, u, v, w, x, y, z, A, B, C;
                                    for (t = p - n, u = q - o, v = l - p, w = m - q, x = n - l, y = o - m, k = 0; k < c; k++)
                                        if (r = a[h[k]].x, s = a[h[k]].y, !(r === l && s === m || r === n && s === o || r === p && s === q) && (z = r - l, A = s - m, B = r - n, C = s - o, r -= p, s -= q, B = t * C - u * B, z = x * A - y * z, A = v * s - w * r, B >= -Number.EPSILON && A >= -Number.EPSILON && z >= -Number.EPSILON)) {
                                            k = !1;
                                            break a
                                        }
                                    k = !0
                                }
                            }
                            if (k) {
                                for (g.push([a[h[d]], a[h[e]], a[h[f]]]), i.push([h[d], h[e], h[f]]), d = e, f = e + 1; f < c; d++, f++) h[d] = h[f];
                                c--, j = 2 * c
                            }
                        }
                        return b ? i : g
                    }
                }(),
                triangulateShape: function(a, b) {
                    function c(a) {
                        var b = a.length;
                        2 < b && a[b - 1].equals(a[0]) && a.pop()
                    }

                    function d(a, b, c) {
                        return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
                    }

                    function e(a, b, c, e, f) {
                        var g = b.x - a.x,
                            h = b.y - a.y,
                            i = e.x - c.x,
                            j = e.y - c.y,
                            k = a.x - c.x,
                            l = a.y - c.y,
                            m = h * i - g * j,
                            n = h * k - g * l;
                        if (Math.abs(m) > Number.EPSILON) {
                            if (0 < m) {
                                if (0 > n || n > m) return [];
                                if (i = j * k - i * l, 0 > i || i > m) return []
                            } else {
                                if (0 < n || n < m) return [];
                                if (i = j * k - i * l, 0 < i || i < m) return []
                            }
                            return 0 === i ? !f || 0 !== n && n !== m ? [a] : [] : i === m ? !f || 0 !== n && n !== m ? [b] : [] : 0 === n ? [c] : n === m ? [e] : (f = i / m, [{
                                x: a.x + f * g,
                                y: a.y + f * h
                            }])
                        }
                        return 0 !== n || j * k !== i * l ? [] : (h = 0 === g && 0 === h, i = 0 === i && 0 === j, h && i ? a.x !== c.x || a.y !== c.y ? [] : [a] : h ? d(c, e, a) ? [a] : [] : i ? d(a, b, c) ? [c] : [] : (0 !== g ? (a.x < b.x ? (g = a, i = a.x, h = b, a = b.x) : (g = b, i = b.x, h = a, a = a.x), c.x < e.x ? (b = c, m = c.x, j = e, c = e.x) : (b = e, m = e.x, j = c, c = c.x)) : (a.y < b.y ? (g = a, i = a.y, h = b, a = b.y) : (g = b, i = b.y, h = a, a = a.y), c.y < e.y ? (b = c, m = c.y, j = e, c = e.y) : (b = e, m = e.y, j = c, c = c.y)), i <= m ? a < m ? [] : a === m ? f ? [] : [b] : a <= c ? [b, h] : [b, j] : i > c ? [] : i === c ? f ? [] : [g] : a <= c ? [g, h] : [g, j]))
                    }

                    function f(a, b, c, d) {
                        var e = b.x - a.x,
                            f = b.y - a.y;
                        b = c.x - a.x, c = c.y - a.y;
                        var g = d.x - a.x;
                        return d = d.y - a.y, a = e * c - f * b, e = e * d - f * g, Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
                    }
                    c(a), b.forEach(c);
                    var g, h, i, j, k, l = {};
                    for (i = a.concat(), g = 0, h = b.length; g < h; g++) Array.prototype.push.apply(i, b[g]);
                    for (g = 0, h = i.length; g < h; g++) k = i[g].x + ":" + i[g].y, void 0 !== l[k] && console.warn("THREE.ShapeUtils: Duplicate point", k, g), l[k] = g;
                    g = function(a, b) {
                        function c(a, b) {
                            var c = q.length - 1,
                                d = a - 1;
                            0 > d && (d = c);
                            var e = a + 1;
                            return e > c && (e = 0), !!(c = f(q[a], q[d], q[e], h[b])) && (c = h.length - 1, d = b - 1, 0 > d && (d = c), e = b + 1, e > c && (e = 0), !!(c = f(h[b], h[d], h[e], q[a])))
                        }

                        function d(a, b) {
                            var c, d;
                            for (c = 0; c < q.length; c++)
                                if (d = c + 1, d %= q.length, d = e(a, b, q[c], q[d], !0), 0 < d.length) return !0;
                            return !1
                        }

                        function g(a, c) {
                            var d, f, g, h;
                            for (d = 0; d < r.length; d++)
                                for (f = b[r[d]], g = 0; g < f.length; g++)
                                    if (h = g + 1, h %= f.length, h = e(a, c, f[g], f[h], !0), 0 < h.length) return !0;
                            return !1
                        }
                        var h, i, j, k, l, m, n, o, p, q = a.concat(),
                            r = [],
                            s = [],
                            t = 0;
                        for (i = b.length; t < i; t++) r.push(t);
                        n = 0;
                        for (var u = 2 * r.length; 0 < r.length;) {
                            if (u--, 0 > u) {
                                console.log("Infinite Loop! Holes left:" + r.length + ", Probably Hole outside Shape!");
                                break
                            }
                            for (j = n; j < q.length; j++) {
                                for (k = q[j], i = -1, t = 0; t < r.length; t++)
                                    if (l = r[t], m = k.x + ":" + k.y + ":" + l, void 0 === s[m]) {
                                        for (h = b[l], o = 0; o < h.length; o++)
                                            if (l = h[o], c(j, o) && !d(k, l) && !g(k, l)) {
                                                i = o, r.splice(t, 1), n = q.slice(0, j + 1), l = q.slice(j), o = h.slice(i), p = h.slice(0, i + 1), q = n.concat(o).concat(p).concat(l), n = j;
                                                break
                                            }
                                        if (0 <= i) break;
                                        s[m] = !0
                                    }
                                if (0 <= i) break
                            }
                        }
                        return q
                    }(a, b);
                    var m = Je.triangulate(g, !1);
                    for (g = 0, h = m.length; g < h; g++)
                        for (j = m[g], i = 0; 3 > i; i++) k = j[i].x + ":" + j[i].y, k = l[k], void 0 !== k && (j[i] = k);
                    return m.concat()
                },
                isClockWise: function(a) {
                    return 0 > Je.area(a)
                }
            };
            Xb.prototype = Object.create(wa.prototype), Xb.prototype.constructor = Xb, Yb.prototype = Object.create(xa.prototype), Yb.prototype.constructor = Yb, Yb.prototype.getArrays = function() {
                var a = this.getAttribute("position"),
                    a = a ? Array.prototype.slice.call(a.array) : [],
                    b = this.getAttribute("uv"),
                    b = b ? Array.prototype.slice.call(b.array) : [],
                    c = this.index,
                    c = c ? Array.prototype.slice.call(c.array) : [];
                return {
                    position: a,
                    uv: b,
                    index: c
                }
            }, Yb.prototype.addShapeList = function(a, b) {
                var c = a.length;
                b.arrays = this.getArrays();
                for (var d = 0; d < c; d++) this.addShape(a[d], b);
                this.setIndex(b.arrays.index), this.addAttribute("position", new sa(b.arrays.position, 3)), this.addAttribute("uv", new sa(b.arrays.uv, 2))
            }, Yb.prototype.addShape = function(a, b) {
                function d(a, b, c) {
                    return b || console.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(c).add(a)
                }

                function e(a, b, d) {
                    var e, f, g;
                    f = a.x - b.x, g = a.y - b.y, e = d.x - a.x;
                    var h = d.y - a.y,
                        i = f * f + g * g;
                    if (Math.abs(f * h - g * e) > Number.EPSILON) {
                        var j = Math.sqrt(i),
                            k = Math.sqrt(e * e + h * h),
                            i = b.x - g / j;
                        if (b = b.y + f / j, h = ((d.x - h / k - i) * h - (d.y + e / k - b) * e) / (f * h - g * e), e = i + f * h - a.x, f = b + g * h - a.y, g = e * e + f * f, 2 >= g) return new c(e, f);
                        g = Math.sqrt(g / 2)
                    } else a = !1, f > Number.EPSILON ? e > Number.EPSILON && (a = !0) : f < -Number.EPSILON ? e < -Number.EPSILON && (a = !0) : Math.sign(g) === Math.sign(h) && (a = !0), a ? (e = -g, g = Math.sqrt(i)) : (e = f, f = g, g = Math.sqrt(i / 2));
                    return new c(e / g, f / g)
                }

                function f(a, b) {
                    var c, d;
                    for (T = a.length; 0 <= --T;) {
                        c = T, d = T - 1, 0 > d && (d = a.length - 1);
                        var e, f = A + 2 * x;
                        for (e = 0; e < f; e++) {
                            var g = R * e,
                                h = R * (e + 1),
                                i = b + d + g,
                                l = b + d + h,
                                h = b + c + h;
                            j(b + c + g), j(i), j(h), j(i), j(l), j(h), g = r.length / 3, g = D.generateSideWallUV(H, r, g - 6, g - 3, g - 2, g - 1), k(g[0]), k(g[1]), k(g[3]), k(g[1]), k(g[2]), k(g[3])
                        }
                    }
                }

                function g(a, b, c) {
                    u.push(a), u.push(b), u.push(c)
                }

                function h(a, b, c) {
                    j(a), j(b), j(c), a = r.length / 3, a = D.generateTopUV(H, r, a - 3, a - 2, a - 1), k(a[0]), k(a[1]), k(a[2])
                }

                function j(a) {
                    s.push(r.length / 3), r.push(u[3 * a + 0]), r.push(u[3 * a + 1]), r.push(u[3 * a + 2])
                }

                function k(a) {
                    t.push(a.x), t.push(a.y)
                }
                var l, m, n, o, p, q = b.arrays ? b.arrays : this.getArrays(),
                    r = q.position,
                    s = q.index,
                    t = q.uv,
                    u = [],
                    q = void 0 !== b.amount ? b.amount : 100,
                    v = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
                    w = void 0 !== b.bevelSize ? b.bevelSize : v - 2,
                    x = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
                    y = void 0 === b.bevelEnabled || b.bevelEnabled,
                    z = void 0 !== b.curveSegments ? b.curveSegments : 12,
                    A = void 0 !== b.steps ? b.steps : 1,
                    B = b.extrudePath,
                    C = !1,
                    D = void 0 !== b.UVGenerator ? b.UVGenerator : Xb.WorldUVGenerator;
                B && (l = B.getSpacedPoints(A), C = !0, y = !1, m = void 0 !== b.frames ? b.frames : B.computeFrenetFrames(A, !1), n = new i, o = new i, p = new i), y || (w = v = x = 0);
                var E, F, G, H = this,
                    B = a.extractPoints(z),
                    z = B.shape,
                    I = B.holes;
                if (B = !Je.isClockWise(z)) {
                    for (z = z.reverse(), F = 0, G = I.length; F < G; F++) E = I[F], Je.isClockWise(E) && (I[F] = E.reverse());
                    B = !1
                }
                var J = Je.triangulateShape(z, I),
                    K = z;
                for (F = 0, G = I.length; F < G; F++) E = I[F], z = z.concat(E);
                var L, M, N, O, P, Q, R = z.length,
                    S = J.length,
                    B = [],
                    T = 0;
                for (N = K.length, L = N - 1, M = T + 1; T < N; T++, L++, M++) L === N && (L = 0), M === N && (M = 0), B[T] = e(K[T], K[L], K[M]);
                var U, V = [],
                    W = B.concat();
                for (F = 0, G = I.length; F < G; F++) {
                    for (E = I[F], U = [], T = 0, N = E.length, L = N - 1, M = T + 1; T < N; T++, L++, M++) L === N && (L = 0), M === N && (M = 0), U[T] = e(E[T], E[L], E[M]);
                    V.push(U), W = W.concat(U)
                }
                for (L = 0; L < x; L++) {
                    for (N = L / x, O = v * Math.cos(N * Math.PI / 2), M = w * Math.sin(N * Math.PI / 2), T = 0, N = K.length; T < N; T++) P = d(K[T], B[T], M), g(P.x, P.y, -O);
                    for (F = 0, G = I.length; F < G; F++)
                        for (E = I[F], U = V[F], T = 0, N = E.length; T < N; T++) P = d(E[T], U[T], M), g(P.x, P.y, -O)
                }
                for (M = w, T = 0; T < R; T++) P = y ? d(z[T], W[T], M) : z[T], C ? (o.copy(m.normals[0]).multiplyScalar(P.x), n.copy(m.binormals[0]).multiplyScalar(P.y), p.copy(l[0]).add(o).add(n), g(p.x, p.y, p.z)) : g(P.x, P.y, 0);
                for (N = 1; N <= A; N++)
                    for (T = 0; T < R; T++) P = y ? d(z[T], W[T], M) : z[T], C ? (o.copy(m.normals[N]).multiplyScalar(P.x), n.copy(m.binormals[N]).multiplyScalar(P.y), p.copy(l[N]).add(o).add(n), g(p.x, p.y, p.z)) : g(P.x, P.y, q / A * N);
                for (L = x - 1; 0 <= L; L--) {
                    for (N = L / x, O = v * Math.cos(N * Math.PI / 2), M = w * Math.sin(N * Math.PI / 2), T = 0, N = K.length; T < N; T++) P = d(K[T], B[T], M), g(P.x, P.y, q + O);
                    for (F = 0, G = I.length; F < G; F++)
                        for (E = I[F], U = V[F], T = 0, N = E.length; T < N; T++) P = d(E[T], U[T], M), C ? g(P.x, P.y + l[A - 1].y, l[A - 1].x + O) : g(P.x, P.y, q + O)
                }! function() {
                    var a = r.length / 3;
                    if (y) {
                        var c = 0 * R;
                        for (T = 0; T < S; T++) Q = J[T], h(Q[2] + c, Q[1] + c, Q[0] + c);
                        for (c = R * (A + 2 * x), T = 0; T < S; T++) Q = J[T], h(Q[0] + c, Q[1] + c, Q[2] + c)
                    } else {
                        for (T = 0; T < S; T++) Q = J[T], h(Q[2], Q[1], Q[0]);
                        for (T = 0; T < S; T++) Q = J[T], h(Q[0] + R * A, Q[1] + R * A, Q[2] + R * A)
                    }
                    H.addGroup(a, r.length / 3 - a, void 0 !== b.material ? b.material : 0)
                }(),
                function() {
                    var a = r.length / 3,
                        c = 0;
                    for (f(K, c), c += K.length, F = 0, G = I.length; F < G; F++) E = I[F], f(E, c), c += E.length;
                    H.addGroup(a, r.length / 3 - a, void 0 !== b.extrudeMaterial ? b.extrudeMaterial : 1)
                }(), b.arrays || (this.setIndex(s), this.addAttribute("position", new sa(r, 3)), this.addAttribute("uv", new sa(b.arrays.uv, 2)))
            }, Xb.WorldUVGenerator = {
                generateTopUV: function(a, b, d, e, f) {
                    a = b[3 * e], e = b[3 * e + 1];
                    var g = b[3 * f];
                    return f = b[3 * f + 1], [new c(b[3 * d], b[3 * d + 1]), new c(a, e), new c(g, f)]
                },
                generateSideWallUV: function(a, b, d, e, f, g) {
                    a = b[3 * d];
                    var h = b[3 * d + 1];
                    d = b[3 * d + 2];
                    var i = b[3 * e],
                        j = b[3 * e + 1];
                    e = b[3 * e + 2];
                    var k = b[3 * f],
                        l = b[3 * f + 1];
                    f = b[3 * f + 2];
                    var m = b[3 * g],
                        n = b[3 * g + 1];
                    return b = b[3 * g + 2], .01 > Math.abs(h - j) ? [new c(a, 1 - d), new c(i, 1 - e), new c(k, 1 - f), new c(m, 1 - b)] : [new c(h, 1 - d), new c(j, 1 - e), new c(l, 1 - f), new c(n, 1 - b)]
                }
            }, Zb.prototype = Object.create(wa.prototype), Zb.prototype.constructor = Zb, $b.prototype = Object.create(Yb.prototype), $b.prototype.constructor = $b, _b.prototype = Object.create(wa.prototype), _b.prototype.constructor = _b, ac.prototype = Object.create(xa.prototype), ac.prototype.constructor = ac, bc.prototype = Object.create(wa.prototype), bc.prototype.constructor = bc, cc.prototype = Object.create(xa.prototype), cc.prototype.constructor = cc, dc.prototype = Object.create(wa.prototype), dc.prototype.constructor = dc, ec.prototype = Object.create(xa.prototype), ec.prototype.constructor = ec, fc.prototype = Object.create(wa.prototype), fc.prototype.constructor = fc, gc.prototype = Object.create(xa.prototype), gc.prototype.constructor = gc, hc.prototype = Object.create(xa.prototype), hc.prototype.constructor = hc, ic.prototype = Object.create(wa.prototype), ic.prototype.constructor = ic, jc.prototype = Object.create(xa.prototype), jc.prototype.constructor = jc, kc.prototype = Object.create(ic.prototype), kc.prototype.constructor = kc, lc.prototype = Object.create(jc.prototype), lc.prototype.constructor = lc, mc.prototype = Object.create(wa.prototype), mc.prototype.constructor = mc, nc.prototype = Object.create(xa.prototype), nc.prototype.constructor = nc;
            var Ke = Object.freeze({
                WireframeGeometry: Eb,
                ParametricGeometry: Fb,
                ParametricBufferGeometry: Gb,
                TetrahedronGeometry: Jb,
                TetrahedronBufferGeometry: Kb,
                OctahedronGeometry: Lb,
                OctahedronBufferGeometry: Mb,
                IcosahedronGeometry: Nb,
                IcosahedronBufferGeometry: Ob,
                DodecahedronGeometry: Pb,
                DodecahedronBufferGeometry: Qb,
                PolyhedronGeometry: Hb,
                PolyhedronBufferGeometry: Ib,
                TubeGeometry: Rb,
                TubeBufferGeometry: Sb,
                TorusKnotGeometry: Tb,
                TorusKnotBufferGeometry: Ub,
                TorusGeometry: Vb,
                TorusBufferGeometry: Wb,
                TextGeometry: Zb,
                TextBufferGeometry: $b,
                SphereGeometry: _b,
                SphereBufferGeometry: ac,
                RingGeometry: bc,
                RingBufferGeometry: cc,
                PlaneGeometry: Ba,
                PlaneBufferGeometry: Ca,
                LatheGeometry: dc,
                LatheBufferGeometry: ec,
                ShapeGeometry: fc,
                ShapeBufferGeometry: gc,
                ExtrudeGeometry: Xb,
                ExtrudeBufferGeometry: Yb,
                EdgesGeometry: hc,
                ConeGeometry: kc,
                ConeBufferGeometry: lc,
                CylinderGeometry: ic,
                CylinderBufferGeometry: jc,
                CircleGeometry: mc,
                CircleBufferGeometry: nc,
                BoxGeometry: za,
                BoxBufferGeometry: Aa
            });
            oc.prototype = Object.create(W.prototype), oc.prototype.constructor = oc, oc.prototype.isShadowMaterial = !0, pc.prototype = Object.create(W.prototype), pc.prototype.constructor = pc, pc.prototype.isRawShaderMaterial = !0, qc.prototype = Object.create(V.prototype), qc.prototype.constructor = qc, qc.prototype.isMeshStandardMaterial = !0, qc.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.defines = {
                    STANDARD: ""
                }, this.color.copy(a.color), this.roughness = a.roughness, this.metalness = a.metalness, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.roughnessMap = a.roughnessMap, this.metalnessMap = a.metalnessMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.envMapIntensity = a.envMapIntensity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
            }, rc.prototype = Object.create(qc.prototype), rc.prototype.constructor = rc, rc.prototype.isMeshPhysicalMaterial = !0, rc.prototype.copy = function(a) {
                return qc.prototype.copy.call(this, a), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = a.reflectivity, this.clearCoat = a.clearCoat, this.clearCoatRoughness = a.clearCoatRoughness, this
            }, sc.prototype = Object.create(V.prototype), sc.prototype.constructor = sc, sc.prototype.isMeshPhongMaterial = !0, sc.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), this.shininess = a.shininess, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
            }, tc.prototype = Object.create(sc.prototype), tc.prototype.constructor = tc, tc.prototype.isMeshToonMaterial = !0, tc.prototype.copy = function(a) {
                return sc.prototype.copy.call(this, a), this.gradientMap = a.gradientMap, this
            }, uc.prototype = Object.create(V.prototype), uc.prototype.constructor = uc, uc.prototype.isMeshNormalMaterial = !0, uc.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
            }, vc.prototype = Object.create(V.prototype), vc.prototype.constructor = vc, vc.prototype.isMeshLambertMaterial = !0, vc.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
            }, wc.prototype = Object.create(V.prototype), wc.prototype.constructor = wc, wc.prototype.isLineDashedMaterial = !0, wc.prototype.copy = function(a) {
                return V.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.scale = a.scale, this.dashSize = a.dashSize, this.gapSize = a.gapSize, this
            };
            var Le = Object.freeze({
                    ShadowMaterial: oc,
                    SpriteMaterial: nb,
                    RawShaderMaterial: pc,
                    ShaderMaterial: W,
                    PointsMaterial: xb,
                    MeshPhysicalMaterial: rc,
                    MeshStandardMaterial: qc,
                    MeshPhongMaterial: sc,
                    MeshToonMaterial: tc,
                    MeshNormalMaterial: uc,
                    MeshLambertMaterial: vc,
                    MeshDepthMaterial: X,
                    MeshBasicMaterial: ja,
                    LineDashedMaterial: wc,
                    LineBasicMaterial: tb,
                    Material: V
                }),
                Me = {
                    enabled: !1,
                    files: {},
                    add: function(a, b) {
                        !1 !== this.enabled && (this.files[a] = b)
                    },
                    get: function(a) {
                        if (!1 !== this.enabled) return this.files[a]
                    },
                    remove: function(a) {
                        delete this.files[a]
                    },
                    clear: function() {
                        this.files = {}
                    }
                },
                Ne = new xc;
            Object.assign(yc.prototype, {
                load: function(a, b, c, d) {
                    void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a);
                    var e = this,
                        f = Me.get(a);
                    if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
                        b && b(f), e.manager.itemEnd(a)
                    }, 0), f;
                    var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
                    if (g) {
                        var h = g[1],
                            i = !!g[2],
                            g = g[3],
                            g = window.decodeURIComponent(g);
                        i && (g = window.atob(g));
                        try {
                            var j, k = (this.responseType || "").toLowerCase();
                            switch (k) {
                                case "arraybuffer":
                                case "blob":
                                    j = new ArrayBuffer(g.length);
                                    for (var l = new Uint8Array(j), i = 0; i < g.length; i++) l[i] = g.charCodeAt(i);
                                    "blob" === k && (j = new Blob([j], {
                                        type: h
                                    }));
                                    break;
                                case "document":
                                    j = (new DOMParser).parseFromString(g, h);
                                    break;
                                case "json":
                                    j = JSON.parse(g);
                                    break;
                                default:
                                    j = g
                            }
                            window.setTimeout(function() {
                                b && b(j), e.manager.itemEnd(a)
                            }, 0)
                        } catch (b) {
                            window.setTimeout(function() {
                                d && d(b), e.manager.itemEnd(a), e.manager.itemError(a)
                            }, 0)
                        }
                    } else {
                        var m = new XMLHttpRequest;
                        m.open("GET", a, !0), m.addEventListener("load", function(c) {
                            var f = c.target.response;
                            Me.add(a, f), 200 === this.status ? (b && b(f), e.manager.itemEnd(a)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), b && b(f), e.manager.itemEnd(a)) : (d && d(c), e.manager.itemEnd(a), e.manager.itemError(a))
                        }, !1), void 0 !== c && m.addEventListener("progress", function(a) {
                            c(a)
                        }, !1), m.addEventListener("error", function(b) {
                            d && d(b), e.manager.itemEnd(a), e.manager.itemError(a)
                        }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (h in this.requestHeader) m.setRequestHeader(h, this.requestHeader[h]);
                        m.send(null)
                    }
                    return e.manager.itemStart(a), m
                },
                setPath: function(a) {
                    return this.path = a, this
                },
                setResponseType: function(a) {
                    return this.responseType = a, this
                },
                setWithCredentials: function(a) {
                    return this.withCredentials = a, this
                },
                setMimeType: function(a) {
                    return this.mimeType = a, this
                },
                setRequestHeader: function(a) {
                    return this.requestHeader = a, this
                }
            }), Object.assign(zc.prototype, {
                load: function(a, b, c, d) {
                    function e(e) {
                        i.load(a[e], function(a) {
                            a = f._parser(a, !0), g[e] = {
                                width: a.width,
                                height: a.height,
                                format: a.format,
                                mipmaps: a.mipmaps
                            }, j += 1, 6 === j && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h))
                        }, c, d)
                    }
                    var f = this,
                        g = [],
                        h = new Bb;
                    h.image = g;
                    var i = new yc(this.manager);
                    if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(a))
                        for (var j = 0, k = 0, l = a.length; k < l; ++k) e(k);
                    else i.load(a, function(a) {
                        if (a = f._parser(a, !0), a.isCubemap)
                            for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                                g[d] = {
                                    mipmaps: []
                                };
                                for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
                            } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
                        1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h)
                    }, c, d);
                    return h
                },
                setPath: function(a) {
                    return this.path = a, this
                }
            }), Object.assign(Ac.prototype, {
                load: function(a, b, c, d) {
                    var e = this,
                        f = new k,
                        g = new yc(this.manager);
                    return g.setResponseType("arraybuffer"), g.load(a, function(a) {
                        (a = e._parser(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a))
                    }, c, d), f
                }
            }), Object.assign(Bc.prototype, {
                load: function(a, b, c, d) {
                    void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a);
                    var e = this,
                        f = Me.get(a);
                    return void 0 !== f ? (e.manager.itemStart(a), setTimeout(function() {
                        b && b(f), e.manager.itemEnd(a)
                    }, 0), f) : (c = document.createElementNS("http://www.w3.org/1999/xhtml", "img"), c.addEventListener("load", function() {
                        Me.add(a, this), b && b(this), e.manager.itemEnd(a)
                    }, !1), c.addEventListener("error", function(b) {
                        d && d(b), e.manager.itemEnd(a), e.manager.itemError(a)
                    }, !1), "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin), e.manager.itemStart(a), c.src = a, c)
                },
                setCrossOrigin: function(a) {
                    return this.crossOrigin = a, this
                },
                setPath: function(a) {
                    return this.path = a, this
                }
            }), Object.assign(Cc.prototype, {
                load: function(a, b, c, d) {
                    function e(c) {
                        g.load(a[c], function(a) {
                            f.images[c] = a, h++, 6 === h && (f.needsUpdate = !0, b && b(f))
                        }, void 0, d)
                    }
                    var f = new l,
                        g = new Bc(this.manager);
                    g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
                    var h = 0;
                    for (c = 0; c < a.length; ++c) e(c);
                    return f
                },
                setCrossOrigin: function(a) {
                    return this.crossOrigin = a, this
                },
                setPath: function(a) {
                    return this.path = a, this
                }
            }), Object.assign(Dc.prototype, {
                load: function(a, b, c, e) {
                    var f = new Bc(this.manager);
                    f.setCrossOrigin(this.crossOrigin), f.setPath(this.path);
                    var g = new d;
                    return g.image = f.load(a, function() {
                        var c = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data\:image\/jpeg/);
                        g.format = c ? 1022 : 1023, g.needsUpdate = !0, void 0 !== b && b(g)
                    }, c, e), g
                },
                setCrossOrigin: function(a) {
                    return this.crossOrigin = a, this
                },
                setPath: function(a) {
                    return this.path = a, this
                }
            }), Ec.prototype = Object.assign(Object.create(fa.prototype), {
                constructor: Ec,
                isLight: !0,
                copy: function(a) {
                    return fa.prototype.copy.call(this, a), this.color.copy(a.color), this.intensity = a.intensity, this
                },
                toJSON: function(a) {
                    return a = fa.prototype.toJSON.call(this, a), a.object.color = this.color.getHex(), a.object.intensity = this.intensity, void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (a.object.distance = this.distance), void 0 !== this.angle && (a.object.angle = this.angle), void 0 !== this.decay && (a.object.decay = this.decay), void 0 !== this.penumbra && (a.object.penumbra = this.penumbra), void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()), a
                }
            }), Fc.prototype = Object.assign(Object.create(Ec.prototype), {
                constructor: Fc,
                isHemisphereLight: !0,
                copy: function(a) {
                    return Ec.prototype.copy.call(this, a), this.groundColor.copy(a.groundColor), this
                }
            }), Object.assign(Gc.prototype, {
                copy: function(a) {
                    return this.camera = a.camera.clone(), this.bias = a.bias, this.radius = a.radius, this.mapSize.copy(a.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var a = {};
                    return 0 !== this.bias && (a.bias = this.bias), 1 !== this.radius && (a.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (a.mapSize = this.mapSize.toArray()), a.camera = this.camera.toJSON(!1).object, delete a.camera.matrix, a
                }
            }), Hc.prototype = Object.assign(Object.create(Gc.prototype), {
                constructor: Hc,
                isSpotLightShadow: !0,
                update: function(a) {
                    var b = this.camera,
                        c = 2 * re.RAD2DEG * a.angle,
                        d = this.mapSize.width / this.mapSize.height;
                    a = a.distance || b.far, c === b.fov && d === b.aspect && a === b.far || (b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix())
                }
            }), Ic.prototype = Object.assign(Object.create(Ec.prototype), {
                constructor: Ic,
                isSpotLight: !0,
                copy: function(a) {
                    return Ec.prototype.copy.call(this, a), this.distance = a.distance, this.angle = a.angle, this.penumbra = a.penumbra, this.decay = a.decay, this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
                }
            }), Jc.prototype = Object.assign(Object.create(Ec.prototype), {
                constructor: Jc,
                isPointLight: !0,
                copy: function(a) {
                    return Ec.prototype.copy.call(this, a), this.distance = a.distance, this.decay = a.decay, this.shadow = a.shadow.clone(), this
                }
            }), Kc.prototype = Object.assign(Object.create(Gc.prototype), {
                constructor: Kc
            }), Lc.prototype = Object.assign(Object.create(Ec.prototype), {
                constructor: Lc,
                isDirectionalLight: !0,
                copy: function(a) {
                    return Ec.prototype.copy.call(this, a), this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
                }
            }), Mc.prototype = Object.assign(Object.create(Ec.prototype), {
                constructor: Mc,
                isAmbientLight: !0
            }), Nc.prototype = Object.assign(Object.create(Ec.prototype), {
                constructor: Nc,
                isRectAreaLight: !0,
                copy: function(a) {
                    return Ec.prototype.copy.call(this, a), this.width = a.width, this.height = a.height, this
                },
                toJSON: function(a) {
                    return a = Ec.prototype.toJSON.call(this, a), a.object.width = this.width, a.object.height = this.height, a
                }
            });
            var Oe = {
                arraySlice: function(a, b, c) {
                    return Oe.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
                },
                convertArray: function(a, b, c) {
                    return !a || !c && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
                },
                isTypedArray: function(a) {
                    return ArrayBuffer.isView(a) && !(a instanceof DataView)
                },
                getKeyframeOrder: function(a) {
                    for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
                    return c.sort(function(b, c) {
                        return a[b] - a[c]
                    }), c
                },
                sortedArray: function(a, b, c) {
                    for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)
                        for (var h = c[f] * b, i = 0; i !== b; ++i) e[g++] = a[h + i];
                    return e
                },
                flattenJSON: function(a, b, c, d) {
                    for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
                    if (void 0 !== f) {
                        var g = f[d];
                        if (void 0 !== g)
                            if (Array.isArray(g)) {
                                do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
                            } else if (void 0 !== g.toArray) {
                            do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
                        } else
                            do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f)
                    }
                }
            };
            Object.assign(Oc.prototype, {
                evaluate: function(a) {
                    var b = this.parameterPositions,
                        c = this._cachedIndex,
                        d = b[c],
                        e = b[c - 1];
                    a: {
                        b: {
                            c: {
                                d: if (!(a < d)) {
                                    for (var f = c + 2;;) {
                                        if (void 0 === d) {
                                            if (a < e) break d;
                                            return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, a, e)
                                        }
                                        if (c === f) break;
                                        if (e = d, d = b[++c], a < d) break b
                                    }
                                    d = b.length;
                                    break c
                                }if (a >= e) break a;
                                for (f = b[1], a < f && (c = 2, e = f), f = c - 2;;) {
                                    if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                                    if (c === f) break;
                                    if (d = e, e = b[--c - 1], a >= e) break b
                                }
                                d = c,
                                c = 0
                            }
                            for (; c < d;) e = c + d >>> 1,
                            a < b[e] ? d = e : c = e + 1;
                            if (d = b[c], e = b[c - 1], void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                            if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
                        }
                        this._cachedIndex = c,
                        this.intervalChanged_(c, e, d)
                    }
                    return this.interpolate_(c, e, a, d)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(a) {
                    var b = this.resultBuffer,
                        c = this.sampleValues,
                        d = this.valueSize;
                    a *= d;
                    for (var e = 0; e !== d; ++e) b[e] = c[a + e];
                    return b
                },
                interpolate_: function(a, b, c, d) {
                    throw Error("call to abstract method")
                },
                intervalChanged_: function(a, b, c) {}
            }), Object.assign(Oc.prototype, {
                beforeStart_: Oc.prototype.copySampleValue_,
                afterEnd_: Oc.prototype.copySampleValue_
            }), Pc.prototype = Object.assign(Object.create(Oc.prototype), {
                constructor: Pc,
                DefaultSettings_: {
                    endingStart: 2400,
                    endingEnd: 2400
                },
                intervalChanged_: function(a, b, c) {
                    var d = this.parameterPositions,
                        e = a - 2,
                        f = a + 1,
                        g = d[e],
                        h = d[f];
                    if (void 0 === g) switch (this.getSettings_().endingStart) {
                        case 2401:
                            e = a, g = 2 * b - c;
                            break;
                        case 2402:
                            e = d.length - 2, g = b + d[e] - d[e + 1];
                            break;
                        default:
                            e = a, g = c
                    }
                    if (void 0 === h) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            f = a, h = 2 * c - b;
                            break;
                        case 2402:
                            f = 1, h = c + d[1] - d[0];
                            break;
                        default:
                            f = a - 1, h = b
                    }
                    a = .5 * (c - b), d = this.valueSize, this._weightPrev = a / (b - g), this._weightNext = a / (h - c), this._offsetPrev = e * d, this._offsetNext = f * d
                },
                interpolate_: function(a, b, c, d) {
                    var e = this.resultBuffer,
                        f = this.sampleValues,
                        g = this.valueSize;
                    a *= g;
                    var h = a - g,
                        i = this._offsetPrev,
                        j = this._offsetNext,
                        k = this._weightPrev,
                        l = this._weightNext,
                        m = (c - b) / (d - b);
                    for (c = m * m, d = c * m, b = -k * d + 2 * k * c - k * m, k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * m + 1, m = (-1 - l) * d + (1.5 + l) * c + .5 * m, l = l * d - l * c, c = 0; c !== g; ++c) e[c] = b * f[i + c] + k * f[h + c] + m * f[a + c] + l * f[j + c];
                    return e
                }
            }), Qc.prototype = Object.assign(Object.create(Oc.prototype), {
                constructor: Qc,
                interpolate_: function(a, b, c, d) {
                    var e = this.resultBuffer,
                        f = this.sampleValues,
                        g = this.valueSize;
                    a *= g;
                    var h = a - g;
                    for (b = (c - b) / (d - b), c = 1 - b, d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
                    return e
                }
            }), Rc.prototype = Object.assign(Object.create(Oc.prototype), {
                constructor: Rc,
                interpolate_: function(a, b, c, d) {
                    return this.copySampleValue_(a - 1)
                }
            });
            var Pe;
            Pe = {
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodDiscrete: function(a) {
                    return new Rc(this.times, this.values, this.getValueSize(), a)
                },
                InterpolantFactoryMethodLinear: function(a) {
                    return new Qc(this.times, this.values, this.getValueSize(), a)
                },
                InterpolantFactoryMethodSmooth: function(a) {
                    return new Pc(this.times, this.values, this.getValueSize(), a)
                },
                setInterpolation: function(a) {
                    var b;
                    switch (a) {
                        case 2300:
                            b = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case 2301:
                            b = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            b = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === b) {
                        if (b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                            if (a === this.DefaultInterpolation) throw Error(b);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        console.warn(b)
                    } else this.createInterpolant = b
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return 2300;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(a) {
                    if (0 !== a)
                        for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
                    return this
                },
                scale: function(a) {
                    if (1 !== a)
                        for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
                    return this
                },
                trim: function(a, b) {
                    for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;) ++e;
                    for (; - 1 !== f && c[f] > b;) --f;
                    return ++f, 0 === e && f === d || (e >= f && (f = Math.max(f, 1), e = f - 1), d = this.getValueSize(), this.times = Oe.arraySlice(c, e, f), this.values = Oe.arraySlice(this.values, e * d, f * d)), this
                },
                validate: function() {
                    var a = !0,
                        b = this.getValueSize();
                    0 !== b - Math.floor(b) && (console.error("invalid value size in track", this), a = !1);
                    var c = this.times,
                        b = this.values,
                        d = c.length;
                    0 === d && (console.error("track is empty", this), a = !1);
                    for (var e = null, f = 0; f !== d; f++) {
                        var g = c[f];
                        if ("number" == typeof g && isNaN(g)) {
                            console.error("time is not a valid number", this, f, g), a = !1;
                            break
                        }
                        if (null !== e && e > g) {
                            console.error("out of order keys", this, f, g, e), a = !1;
                            break
                        }
                        e = g
                    }
                    if (void 0 !== b && Oe.isTypedArray(b))
                        for (f = 0, c = b.length; f !== c; ++f)
                            if (d = b[f], isNaN(d)) {
                                console.error("value is not a valid number", this, f, d), a = !1;
                                break
                            }
                    return a
                },
                optimize: function() {
                    for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) {
                        var h = !1,
                            i = a[g];
                        if (i !== a[g + 1] && (1 !== g || i !== i[0]))
                            if (d) h = !0;
                            else
                                for (var j = g * c, k = j - c, l = j + c, i = 0; i !== c; ++i) {
                                    var m = b[j + i];
                                    if (m !== b[k + i] || m !== b[l + i]) {
                                        h = !0;
                                        break
                                    }
                                }
                        if (h) {
                            if (g !== e)
                                for (a[e] = a[g], h = g * c, j = e * c, i = 0; i !== c; ++i) b[j + i] = b[h + i];
                            ++e
                        }
                    }
                    if (0 < f) {
                        for (a[e] = a[f], h = f * c, j = e * c, i = 0; i !== c; ++i) b[j + i] = b[h + i];
                        ++e
                    }
                    return e !== a.length && (this.times = Oe.arraySlice(a, 0, e), this.values = Oe.arraySlice(b, 0, e * c)), this
                }
            }, Tc.prototype = Object.assign(Object.create(Pe), {
                constructor: Tc,
                ValueTypeName: "vector"
            }), Uc.prototype = Object.assign(Object.create(Oc.prototype), {
                constructor: Uc,
                interpolate_: function(a, b, c, d) {
                    var e = this.resultBuffer,
                        f = this.sampleValues,
                        g = this.valueSize;
                    for (a *= g, b = (c - b) / (d - b), c = a + g; a !== c; a += 4) h.slerpFlat(e, 0, f, a - g, f, a, b);
                    return e
                }
            }), Vc.prototype = Object.assign(Object.create(Pe), {
                constructor: Vc,
                ValueTypeName: "quaternion",
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodLinear: function(a) {
                    return new Uc(this.times, this.values, this.getValueSize(), a)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), Wc.prototype = Object.assign(Object.create(Pe), {
                constructor: Wc,
                ValueTypeName: "number"
            }), Xc.prototype = Object.assign(Object.create(Pe), {
                constructor: Xc,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Yc.prototype = Object.assign(Object.create(Pe), {
                constructor: Yc,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Zc.prototype = Object.assign(Object.create(Pe), {
                constructor: Zc,
                ValueTypeName: "color"
            }), $c.prototype = Pe, Pe.constructor = $c, Object.assign($c, {
                parse: function(a) {
                    if (void 0 === a.type) throw Error("track type undefined, can not parse");
                    var b = $c._getTrackTypeForValueTypeName(a.type);
                    if (void 0 === a.times) {
                        var c = [],
                            d = [];
                        Oe.flattenJSON(a.keys, c, d, "value"), a.times = c, a.values = d
                    }
                    return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
                },
                toJSON: function(a) {
                    var b = a.constructor;
                    if (void 0 !== b.toJSON) b = b.toJSON(a);
                    else {
                        var b = {
                                name: a.name,
                                times: Oe.convertArray(a.times, Array),
                                values: Oe.convertArray(a.values, Array)
                            },
                            c = a.getInterpolation();
                        c !== a.DefaultInterpolation && (b.interpolation = c)
                    }
                    return b.type = a.ValueTypeName, b
                },
                _getTrackTypeForValueTypeName: function(a) {
                    switch (a.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Wc;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Tc;
                        case "color":
                            return Zc;
                        case "quaternion":
                            return Vc;
                        case "bool":
                        case "boolean":
                            return Yc;
                        case "string":
                            return Xc
                    }
                    throw Error("Unsupported typeName: " + a)
                }
            }), Object.assign(_c, {
                parse: function(a) {
                    for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push($c.parse(c[e]).scale(d));
                    return new _c(a.name, a.duration, b)
                },
                toJSON: function(a) {
                    var b = [],
                        c = a.tracks;
                    a = {
                        name: a.name,
                        duration: a.duration,
                        tracks: b
                    };
                    for (var d = 0, e = c.length; d !== e; ++d) b.push($c.toJSON(c[d]));
                    return a
                },
                CreateFromMorphTargetSequence: function(a, b, c, d) {
                    for (var e = b.length, f = [], g = 0; g < e; g++) {
                        var h = [],
                            i = [];
                        h.push((g + e - 1) % e, g, (g + 1) % e), i.push(0, 1, 0);
                        var j = Oe.getKeyframeOrder(h),
                            h = Oe.sortedArray(h, 1, j),
                            i = Oe.sortedArray(i, 1, j);
                        d || 0 !== h[0] || (h.push(e), i.push(i[0])), f.push(new Wc(".morphTargetInfluences[" + b[g].name + "]", h, i).scale(1 / c))
                    }
                    return new _c(a, -1, f)
                },
                findByName: function(a, b) {
                    var c = a;
                    Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
                    for (var d = 0; d < c.length; d++)
                        if (c[d].name === b) return c[d];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(a, b, c) {
                    for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
                        var h = a[f],
                            i = h.name.match(e);
                        if (i && 1 < i.length) {
                            var j = i[1];
                            (i = d[j]) || (d[j] = i = []), i.push(h)
                        }
                    }
                    a = [];
                    for (j in d) a.push(_c.CreateFromMorphTargetSequence(j, d[j], b, c));
                    return a
                },
                parseAnimation: function(a, b) {
                    if (!a) return console.error("  no animation in JSONLoader data"), null;
                    for (var c = function(a, b, c, d, e) {
                            if (0 !== c.length) {
                                var f = [],
                                    g = [];
                                Oe.flattenJSON(c, f, g, d), 0 !== f.length && e.push(new a(b, f, g))
                            }
                        }, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30, h = a.hierarchy || [], i = 0; i < h.length; i++) {
                        var j = h[i].keys;
                        if (j && 0 !== j.length)
                            if (j[0].morphTargets) {
                                for (var f = {}, k = 0; k < j.length; k++)
                                    if (j[k].morphTargets)
                                        for (var l = 0; l < j[k].morphTargets.length; l++) f[j[k].morphTargets[l]] = -1;
                                for (var m in f) {
                                    for (var n = [], o = [], l = 0; l !== j[k].morphTargets.length; ++l) {
                                        var p = j[k];
                                        n.push(p.time), o.push(p.morphTarget === m ? 1 : 0)
                                    }
                                    d.push(new Wc(".morphTargetInfluence[" + m + "]", n, o))
                                }
                                f = f.length * (g || 1)
                            } else k = ".bones[" + b[i].name + "]", c(Tc, k + ".position", j, "pos", d), c(Vc, k + ".quaternion", j, "rot", d), c(Tc, k + ".scale", j, "scl", d)
                    }
                    return 0 === d.length ? null : new _c(e, f, d)
                }
            }), Object.assign(_c.prototype, {
                resetDuration: function() {
                    for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) var d = this.tracks[b],
                        a = Math.max(a, d.times[d.times.length - 1]);
                    this.duration = a
                },
                trim: function() {
                    for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
                    return this
                },
                optimize: function() {
                    for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
                    return this
                }
            }), Object.assign(ad.prototype, {
                load: function(a, b, c, d) {
                    var e = this,
                        f = new yc(e.manager);
                    f.setResponseType("json"), f.load(a, function(a) {
                        b(e.parse(a))
                    }, c, d)
                },
                setTextures: function(a) {
                    this.textures = a
                },
                parse: function(a) {
                    function b(a) {
                        return void 0 === d[a] && console.warn("THREE.MaterialLoader: Undefined texture", a), d[a]
                    }
                    var d = this.textures,
                        e = new Le[a.type];
                    if (void 0 !== a.uuid && (e.uuid = a.uuid), void 0 !== a.name && (e.name = a.name), void 0 !== a.color && e.color.setHex(a.color), void 0 !== a.roughness && (e.roughness = a.roughness), void 0 !== a.metalness && (e.metalness = a.metalness), void 0 !== a.emissive && e.emissive.setHex(a.emissive), void 0 !== a.specular && e.specular.setHex(a.specular), void 0 !== a.shininess && (e.shininess = a.shininess), void 0 !== a.clearCoat && (e.clearCoat = a.clearCoat), void 0 !== a.clearCoatRoughness && (e.clearCoatRoughness = a.clearCoatRoughness), void 0 !== a.uniforms && (e.uniforms = a.uniforms), void 0 !== a.vertexShader && (e.vertexShader = a.vertexShader), void 0 !== a.fragmentShader && (e.fragmentShader = a.fragmentShader), void 0 !== a.vertexColors && (e.vertexColors = a.vertexColors), void 0 !== a.fog && (e.fog = a.fog), void 0 !== a.shading && (e.shading = a.shading), void 0 !== a.blending && (e.blending = a.blending), void 0 !== a.side && (e.side = a.side), void 0 !== a.opacity && (e.opacity = a.opacity), void 0 !== a.transparent && (e.transparent = a.transparent), void 0 !== a.alphaTest && (e.alphaTest = a.alphaTest), void 0 !== a.depthTest && (e.depthTest = a.depthTest), void 0 !== a.depthWrite && (e.depthWrite = a.depthWrite), void 0 !== a.colorWrite && (e.colorWrite = a.colorWrite), void 0 !== a.wireframe && (e.wireframe = a.wireframe), void 0 !== a.wireframeLinewidth && (e.wireframeLinewidth = a.wireframeLinewidth), void 0 !== a.wireframeLinecap && (e.wireframeLinecap = a.wireframeLinecap), void 0 !== a.wireframeLinejoin && (e.wireframeLinejoin = a.wireframeLinejoin), void 0 !== a.skinning && (e.skinning = a.skinning), void 0 !== a.morphTargets && (e.morphTargets = a.morphTargets), void 0 !== a.size && (e.size = a.size), void 0 !== a.sizeAttenuation && (e.sizeAttenuation = a.sizeAttenuation), void 0 !== a.map && (e.map = b(a.map)), void 0 !== a.alphaMap && (e.alphaMap = b(a.alphaMap), e.transparent = !0), void 0 !== a.bumpMap && (e.bumpMap = b(a.bumpMap)), void 0 !== a.bumpScale && (e.bumpScale = a.bumpScale), void 0 !== a.normalMap && (e.normalMap = b(a.normalMap)), void 0 !== a.normalScale) {
                        var f = a.normalScale;
                        !1 === Array.isArray(f) && (f = [f, f]), e.normalScale = (new c).fromArray(f)
                    }
                    return void 0 !== a.displacementMap && (e.displacementMap = b(a.displacementMap)), void 0 !== a.displacementScale && (e.displacementScale = a.displacementScale), void 0 !== a.displacementBias && (e.displacementBias = a.displacementBias), void 0 !== a.roughnessMap && (e.roughnessMap = b(a.roughnessMap)), void 0 !== a.metalnessMap && (e.metalnessMap = b(a.metalnessMap)), void 0 !== a.emissiveMap && (e.emissiveMap = b(a.emissiveMap)), void 0 !== a.emissiveIntensity && (e.emissiveIntensity = a.emissiveIntensity), void 0 !== a.specularMap && (e.specularMap = b(a.specularMap)), void 0 !== a.envMap && (e.envMap = b(a.envMap)), void 0 !== a.reflectivity && (e.reflectivity = a.reflectivity), void 0 !== a.lightMap && (e.lightMap = b(a.lightMap)), void 0 !== a.lightMapIntensity && (e.lightMapIntensity = a.lightMapIntensity), void 0 !== a.aoMap && (e.aoMap = b(a.aoMap)), void 0 !== a.aoMapIntensity && (e.aoMapIntensity = a.aoMapIntensity), void 0 !== a.gradientMap && (e.gradientMap = b(a.gradientMap)), e
                }
            }), Object.assign(bd.prototype, {
                load: function(a, b, c, d) {
                    var e = this,
                        f = new yc(e.manager);
                    f.setResponseType("json"), f.load(a, function(a) {
                        b(e.parse(a))
                    }, c, d)
                },
                parse: function(a) {
                    var b = new xa,
                        c = a.data.index;
                    void 0 !== c && (c = new Qe[c.type](c.array), b.setIndex(new ka(c, 1)));
                    var d, e = a.data.attributes;
                    for (d in e) {
                        var f = e[d],
                            c = new Qe[f.type](f.array);
                        b.addAttribute(d, new ka(c, f.itemSize, f.normalized))
                    }
                    if (d = a.data.groups || a.data.drawcalls || a.data.offsets, void 0 !== d)
                        for (c = 0, e = d.length; c !== e; ++c) f = d[c], b.addGroup(f.start, f.count, f.materialIndex);
                    return a = a.data.boundingSphere, void 0 !== a && (d = new i, void 0 !== a.center && d.fromArray(a.center), b.boundingSphere = new Z(d, a.radius)), b
                }
            });
            var Qe = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            cd.Handlers = {
                handlers: [],
                add: function(a, b) {
                    this.handlers.push(a, b)
                },
                get: function(a) {
                    for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
                        var e = b[c + 1];
                        if (b[c].test(a)) return e
                    }
                    return null
                }
            }, Object.assign(cd.prototype, {
                crossOrigin: void 0,
                extractUrlBase: function(a) {
                    return a = a.split("/"), 1 === a.length ? "./" : (a.pop(), a.join("/") + "/")
                },
                initMaterials: function(a, b, c) {
                    for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
                    return d
                },
                createMaterial: function() {
                    var a = {
                            NoBlending: 0,
                            NormalBlending: 1,
                            AdditiveBlending: 2,
                            SubtractiveBlending: 3,
                            MultiplyBlending: 4,
                            CustomBlending: 5
                        },
                        b = new R,
                        c = new Dc,
                        d = new ad;
                    return function(e, f, g) {
                        function h(a, b, d, e, h) {
                            a = f + a;
                            var i = cd.Handlers.get(a);
                            return null !== i ? a = i.load(a) : (c.setCrossOrigin(g), a = c.load(a)), void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1e3), 1 !== b[1] && (a.wrapT = 1e3)), void 0 !== d && a.offset.fromArray(d), void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1e3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1e3), "mirror" === e[1] && (a.wrapT = 1002)), void 0 !== h && (a.anisotropy = h), b = re.generateUUID(), j[b] = a, b
                        }
                        var i, j = {},
                            k = {
                                uuid: re.generateUUID(),
                                type: "MeshLambertMaterial"
                            };
                        for (i in e) {
                            var l = e[i];
                            switch (i) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    k.name = l;
                                    break;
                                case "blending":
                                    k.blending = a[l];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", i, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    k.color = b.fromArray(l).getHex();
                                    break;
                                case "colorSpecular":
                                    k.specular = b.fromArray(l).getHex();
                                    break;
                                case "colorEmissive":
                                    k.emissive = b.fromArray(l).getHex();
                                    break;
                                case "specularCoef":
                                    k.shininess = l;
                                    break;
                                case "shading":
                                    "basic" === l.toLowerCase() && (k.type = "MeshBasicMaterial"), "phong" === l.toLowerCase() && (k.type = "MeshPhongMaterial"), "standard" === l.toLowerCase() && (k.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    k.map = h(l, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    k.emissiveMap = h(l, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    k.lightMap = h(l, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    k.aoMap = h(l, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    k.bumpMap = h(l, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    k.bumpScale = l;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    k.normalMap = h(l, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    k.normalScale = [l, l];
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    k.specularMap = h(l, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    k.metalnessMap = h(l, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    k.roughnessMap = h(l, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    k.alphaMap = h(l, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    k.side = 1;
                                    break;
                                case "doubleSided":
                                    k.side = 2;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), k.opacity = l;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    k[i] = l;
                                    break;
                                case "vertexColors":
                                    !0 === l && (k.vertexColors = 2), "face" === l && (k.vertexColors = 1);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", i, l)
                            }
                        }
                        return "MeshBasicMaterial" === k.type && delete k.emissive, "MeshPhongMaterial" !== k.type && delete k.specular, 1 > k.opacity && (k.transparent = !0), d.setTextures(j), d.parse(k)
                    }
                }()
            }), Object.assign(dd.prototype, {
                load: function(a, b, c, d) {
                    var e = this,
                        f = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : cd.prototype.extractUrlBase(a),
                        g = new yc(this.manager);
                    g.setResponseType("json"), g.setWithCredentials(this.withCredentials), g.load(a, function(c) {
                        var d = c.metadata;
                        if (void 0 !== d && (d = d.type, void 0 !== d)) {
                            if ("object" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                            if ("scene" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.")
                        }
                        c = e.parse(c, f), b(c.geometry, c.materials)
                    }, c, d)
                },
                setTexturePath: function(a) {
                    this.texturePath = a
                },
                parse: function() {
                    return function(a, b) {
                        void 0 !== a.data && (a = a.data), a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
                        var d, f, g, h, j, k, l, m, n, o, p, q, r, s, t = new wa,
                            u = a,
                            v = u.faces;
                        n = u.vertices;
                        var w = u.normals,
                            x = u.colors;
                        k = u.scale;
                        var y = 0;
                        if (void 0 !== u.uvs) {
                            for (d = 0; d < u.uvs.length; d++) u.uvs[d].length && y++;
                            for (d = 0; d < y; d++) t.faceVertexUvs[d] = []
                        }
                        for (h = 0, j = n.length; h < j;) d = new i, d.x = n[h++] * k, d.y = n[h++] * k, d.z = n[h++] * k, t.vertices.push(d);
                        for (h = 0, j = v.length; h < j;)
                            if (n = v[h++], o = 1 & n, g = 2 & n, d = 8 & n, l = 16 & n, p = 32 & n, k = 64 & n, n &= 128, o) {
                                if (o = new ia, o.a = v[h], o.b = v[h + 1], o.c = v[h + 3], q = new ia, q.a = v[h + 1], q.b = v[h + 2], q.c = v[h + 3], h += 4, g && (g = v[h++], o.materialIndex = g, q.materialIndex = g), g = t.faces.length, d)
                                    for (d = 0; d < y; d++)
                                        for (r = u.uvs[d], t.faceVertexUvs[d][g] = [], t.faceVertexUvs[d][g + 1] = [], f = 0; 4 > f; f++) m = v[h++], s = r[2 * m], m = r[2 * m + 1], s = new c(s, m), 2 !== f && t.faceVertexUvs[d][g].push(s), 0 !== f && t.faceVertexUvs[d][g + 1].push(s);
                                if (l && (l = 3 * v[h++], o.normal.set(w[l++], w[l++], w[l]), q.normal.copy(o.normal)), p)
                                    for (d = 0; 4 > d; d++) l = 3 * v[h++], p = new i(w[l++], w[l++], w[l]), 2 !== d && o.vertexNormals.push(p), 0 !== d && q.vertexNormals.push(p);
                                if (k && (k = v[h++], k = x[k], o.color.setHex(k), q.color.setHex(k)), n)
                                    for (d = 0; 4 > d; d++) k = v[h++], k = x[k], 2 !== d && o.vertexColors.push(new R(k)), 0 !== d && q.vertexColors.push(new R(k));
                                t.faces.push(o), t.faces.push(q)
                            } else {
                                if (o = new ia, o.a = v[h++], o.b = v[h++], o.c = v[h++], g && (g = v[h++], o.materialIndex = g), g = t.faces.length, d)
                                    for (d = 0; d < y; d++)
                                        for (r = u.uvs[d], t.faceVertexUvs[d][g] = [], f = 0; 3 > f; f++) m = v[h++], s = r[2 * m], m = r[2 * m + 1], s = new c(s, m), t.faceVertexUvs[d][g].push(s);
                                if (l && (l = 3 * v[h++], o.normal.set(w[l++], w[l++], w[l])), p)
                                    for (d = 0; 3 > d; d++) l = 3 * v[h++], p = new i(w[l++], w[l++], w[l]), o.vertexNormals.push(p);
                                if (k && (k = v[h++], o.color.setHex(x[k])), n)
                                    for (d = 0; 3 > d; d++) k = v[h++], o.vertexColors.push(new R(x[k]));
                                t.faces.push(o)
                            }
                        if (u = a, h = void 0 !== u.influencesPerVertex ? u.influencesPerVertex : 2, u.skinWeights)
                            for (j = 0, v = u.skinWeights.length; j < v; j += h) t.skinWeights.push(new e(u.skinWeights[j], 1 < h ? u.skinWeights[j + 1] : 0, 2 < h ? u.skinWeights[j + 2] : 0, 3 < h ? u.skinWeights[j + 3] : 0));
                        if (u.skinIndices)
                            for (j = 0, v = u.skinIndices.length; j < v; j += h) t.skinIndices.push(new e(u.skinIndices[j], 1 < h ? u.skinIndices[j + 1] : 0, 2 < h ? u.skinIndices[j + 2] : 0, 3 < h ? u.skinIndices[j + 3] : 0));
                        if (t.bones = u.bones, t.bones && 0 < t.bones.length && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match."), j = a, v = j.scale, void 0 !== j.morphTargets)
                            for (u = 0, h = j.morphTargets.length; u < h; u++)
                                for (t.morphTargets[u] = {}, t.morphTargets[u].name = j.morphTargets[u].name, t.morphTargets[u].vertices = [], w = t.morphTargets[u].vertices, x = j.morphTargets[u].vertices, y = 0, n = x.length; y < n; y += 3) k = new i, k.x = x[y] * v, k.y = x[y + 1] * v, k.z = x[y + 2] * v, w.push(k);
                        if (void 0 !== j.morphColors && 0 < j.morphColors.length)
                            for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), v = t.faces, j = j.morphColors[0].colors, u = 0, h = v.length; u < h; u++) v[u].color.fromArray(j, 3 * u);
                        for (j = a, u = [], h = [], void 0 !== j.animation && h.push(j.animation), void 0 !== j.animations && (j.animations.length ? h = h.concat(j.animations) : h.push(j.animations)), j = 0; j < h.length; j++)(v = _c.parseAnimation(h[j], t.bones)) && u.push(v);
                        return t.morphTargets && (h = _c.CreateClipsFromMorphTargetSequences(t.morphTargets, 10), u = u.concat(h)), 0 < u.length && (t.animations = u), t.computeFaceNormals(), t.computeBoundingSphere(), void 0 === a.materials || 0 === a.materials.length ? {
                            geometry: t
                        } : (u = cd.prototype.initMaterials(a.materials, b, this.crossOrigin), {
                            geometry: t,
                            materials: u
                        })
                    }
                }()
            }), Object.assign(ed.prototype, {
                load: function(a, b, c, d) {
                    "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
                    var e = this;
                    new yc(e.manager).load(a, function(c) {
                        var f = null;
                        try {
                            f = JSON.parse(c)
                        } catch (b) {
                            return void 0 !== d && d(b), void console.error("THREE:ObjectLoader: Can't parse " + a + ".", b.message)
                        }
                        c = f.metadata, void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(f, b)
                    }, c, d)
                },
                setTexturePath: function(a) {
                    this.texturePath = a
                },
                setCrossOrigin: function(a) {
                    this.crossOrigin = a
                },
                parse: function(a, b) {
                    var c = this.parseGeometries(a.geometries),
                        d = this.parseImages(a.images, function() {
                            void 0 !== b && b(e)
                        }),
                        d = this.parseTextures(a.textures, d),
                        d = this.parseMaterials(a.materials, d),
                        e = this.parseObject(a.object, c, d);
                    return a.animations && (e.animations = this.parseAnimations(a.animations)), void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e), e
                },
                parseGeometries: function(a) {
                    var b = {};
                    if (void 0 !== a)
                        for (var c = new dd, d = new bd, e = 0, f = a.length; e < f; e++) {
                            var g, h = a[e];
                            switch (h.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    g = new Ke[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    g = new Ke[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    g = new Ke[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    g = new Ke[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    g = new Ke[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    g = new Ke[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "IcosahedronGeometry":
                                case "OctahedronGeometry":
                                case "TetrahedronGeometry":
                                    g = new Ke[h.type](h.radius, h.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    g = new Ke[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    g = new Ke[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    g = new Ke[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    g = new Ke[h.type](h.points, h.segments, h.phiStart, h.phiLength);
                                    break;
                                case "BufferGeometry":
                                    g = d.parse(h);
                                    break;
                                case "Geometry":
                                    g = c.parse(h, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                                    continue
                            }
                            g.uuid = h.uuid, void 0 !== h.name && (g.name = h.name), b[h.uuid] = g
                        }
                    return b
                },
                parseMaterials: function(a, b) {
                    var c = {};
                    if (void 0 !== a) {
                        var d = new ad;
                        d.setTextures(b);
                        for (var e = 0, f = a.length; e < f; e++) {
                            var g = a[e];
                            if ("MultiMaterial" === g.type) {
                                for (var h = [], i = 0; i < g.materials.length; i++) h.push(d.parse(g.materials[i]));
                                c[g.uuid] = h
                            } else c[g.uuid] = d.parse(g)
                        }
                    }
                    return c
                },
                parseAnimations: function(a) {
                    for (var b = [], c = 0; c < a.length; c++) {
                        var d = _c.parse(a[c]);
                        b.push(d)
                    }
                    return b
                },
                parseImages: function(a, b) {
                    function c(a) {
                        return d.manager.itemStart(a), g.load(a, function() {
                            d.manager.itemEnd(a)
                        }, void 0, function() {
                            d.manager.itemEnd(a), d.manager.itemError(a)
                        })
                    }
                    var d = this,
                        e = {};
                    if (void 0 !== a && 0 < a.length) {
                        var f = new xc(b),
                            g = new Bc(f);
                        g.setCrossOrigin(this.crossOrigin);
                        for (var f = 0, h = a.length; f < h; f++) {
                            var i = a[f],
                                j = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i.url) ? i.url : d.texturePath + i.url;
                            e[i.uuid] = c(j)
                        }
                    }
                    return e
                },
                parseTextures: function(a, b) {
                    function c(a, b) {
                        return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), b[a])
                    }
                    var e = {};
                    if (void 0 !== a)
                        for (var f = 0, g = a.length; f < g; f++) {
                            var h = a[f];
                            void 0 === h.image && console.warn('THREE.ObjectLoader: No "image" specified for', h.uuid), void 0 === b[h.image] && console.warn("THREE.ObjectLoader: Undefined image", h.image);
                            var i = new d(b[h.image]);
                            i.needsUpdate = !0, i.uuid = h.uuid, void 0 !== h.name && (i.name = h.name), void 0 !== h.mapping && (i.mapping = c(h.mapping, Re)), void 0 !== h.offset && i.offset.fromArray(h.offset), void 0 !== h.repeat && i.repeat.fromArray(h.repeat), void 0 !== h.wrap && (i.wrapS = c(h.wrap[0], Se), i.wrapT = c(h.wrap[1], Se)), void 0 !== h.minFilter && (i.minFilter = c(h.minFilter, Te)), void 0 !== h.magFilter && (i.magFilter = c(h.magFilter, Te)), void 0 !== h.anisotropy && (i.anisotropy = h.anisotropy), void 0 !== h.flipY && (i.flipY = h.flipY), e[h.uuid] = i
                        }
                    return e
                },
                parseObject: function() {
                    var a = new j;
                    return function(b, c, d) {
                        function e(a) {
                            return void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a), c[a]
                        }

                        function f(a) {
                            if (void 0 !== a) {
                                if (Array.isArray(a)) {
                                    for (var b = [], c = 0, e = a.length; c < e; c++) {
                                        var f = a[c];
                                        void 0 === d[f] && console.warn("THREE.ObjectLoader: Undefined material", f), b.push(d[f])
                                    }
                                    return b
                                }
                                return void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a), d[a]
                            }
                        }
                        var g;
                        switch (b.type) {
                            case "Scene":
                                g = new lb, void 0 !== b.background && Number.isInteger(b.background) && (g.background = new R(b.background)), void 0 !== b.fog && ("Fog" === b.fog.type ? g.fog = new kb(b.fog.color, b.fog.near, b.fog.far) : "FogExp2" === b.fog.type && (g.fog = new jb(b.fog.color, b.fog.density)));
                                break;
                            case "PerspectiveCamera":
                                g = new Ea(b.fov, b.aspect, b.near, b.far), void 0 !== b.focus && (g.focus = b.focus), void 0 !== b.zoom && (g.zoom = b.zoom), void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge), void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset), void 0 !== b.view && (g.view = Object.assign({}, b.view));
                                break;
                            case "OrthographicCamera":
                                g = new Fa(b.left, b.right, b.top, b.bottom, b.near, b.far);
                                break;
                            case "AmbientLight":
                                g = new Mc(b.color, b.intensity);
                                break;
                            case "DirectionalLight":
                                g = new Lc(b.color, b.intensity);
                                break;
                            case "PointLight":
                                g = new Jc(b.color, b.intensity, b.distance, b.decay);
                                break;
                            case "RectAreaLight":
                                g = new Nc(b.color, b.intensity, b.width, b.height);
                                break;
                            case "SpotLight":
                                g = new Ic(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay);
                                break;
                            case "HemisphereLight":
                                g = new Fc(b.color, b.groundColor, b.intensity);
                                break;
                            case "SkinnedMesh":
                                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                            case "Mesh":
                                g = e(b.geometry);
                                var h = f(b.material);
                                g = g.bones && 0 < g.bones.length ? new sb(g, h) : new ya(g, h);
                                break;
                            case "LOD":
                                g = new pb;
                                break;
                            case "Line":
                                g = new ub(e(b.geometry), f(b.material), b.mode);
                                break;
                            case "LineLoop":
                                g = new wb(e(b.geometry), f(b.material));
                                break;
                            case "LineSegments":
                                g = new vb(e(b.geometry), f(b.material));
                                break;
                            case "PointCloud":
                            case "Points":
                                g = new yb(e(b.geometry), f(b.material));
                                break;
                            case "Sprite":
                                g = new ob(f(b.material));
                                break;
                            case "Group":
                                g = new zb;
                                break;
                            default:
                                g = new fa
                        }
                        if (g.uuid = b.uuid, void 0 !== b.name && (g.name = b.name), void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position), void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.quaternion && g.quaternion.fromArray(b.quaternion), void 0 !== b.scale && g.scale.fromArray(b.scale)), void 0 !== b.castShadow && (g.castShadow = b.castShadow), void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow), b.shadow && (void 0 !== b.shadow.bias && (g.shadow.bias = b.shadow.bias), void 0 !== b.shadow.radius && (g.shadow.radius = b.shadow.radius), void 0 !== b.shadow.mapSize && g.shadow.mapSize.fromArray(b.shadow.mapSize), void 0 !== b.shadow.camera && (g.shadow.camera = this.parseObject(b.shadow.camera))), void 0 !== b.visible && (g.visible = b.visible), void 0 !== b.userData && (g.userData = b.userData), void 0 !== b.children)
                            for (var i in b.children) g.add(this.parseObject(b.children[i], c, d));
                        if ("LOD" === b.type)
                            for (b = b.levels, h = 0; h < b.length; h++) {
                                var j = b[h];
                                i = g.getObjectByProperty("uuid", j.object), void 0 !== i && g.addLevel(i, j.distance)
                            }
                        return g
                    }
                }()
            });
            var Re = {
                    UVMapping: 300,
                    CubeReflectionMapping: 301,
                    CubeRefractionMapping: 302,
                    EquirectangularReflectionMapping: 303,
                    EquirectangularRefractionMapping: 304,
                    SphericalReflectionMapping: 305,
                    CubeUVReflectionMapping: 306,
                    CubeUVRefractionMapping: 307
                },
                Se = {
                    RepeatWrapping: 1e3,
                    ClampToEdgeWrapping: 1001,
                    MirroredRepeatWrapping: 1002
                },
                Te = {
                    NearestFilter: 1003,
                    NearestMipMapNearestFilter: 1004,
                    NearestMipMapLinearFilter: 1005,
                    LinearFilter: 1006,
                    LinearMipMapNearestFilter: 1007,
                    LinearMipMapLinearFilter: 1008
                };
            Object.assign(id.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(a) {
                    return a = this.getUtoTmapping(a), this.getPoint(a)
                },
                getPoints: function(a) {
                    void 0 === a && (a = 5);
                    for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
                    return b
                },
                getSpacedPoints: function(a) {
                    void 0 === a && (a = 5);
                    for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
                    return b
                },
                getLength: function() {
                    var a = this.getLengths();
                    return a[a.length - 1]
                },
                getLengths: function(a) {
                    if (void 0 === a && (a = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var b, c, d = [],
                        e = this.getPoint(0),
                        f = 0;
                    for (d.push(0), c = 1; c <= a; c++) b = this.getPoint(c / a), f += b.distanceTo(e), d.push(f), e = b;
                    return this.cacheArcLengths = d
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(a, b) {
                    var c, d, e = this.getLengths(),
                        f = e.length;
                    d = b ? b : a * e[f - 1];
                    for (var g, h = 0, i = f - 1; h <= i;)
                        if (c = Math.floor(h + (i - h) / 2), g = e[c] - d, 0 > g) h = c + 1;
                        else {
                            if (!(0 < g)) {
                                i = c;
                                break
                            }
                            i = c - 1
                        }
                    return c = i, e[c] === d ? c / (f - 1) : (h = e[c], (c + (d - h) / (e[c + 1] - h)) / (f - 1))
                },
                getTangent: function(a) {
                    var b = a - 1e-4;
                    return a += 1e-4, 0 > b && (b = 0), 1 < a && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize()
                },
                getTangentAt: function(a) {
                    return a = this.getUtoTmapping(a), this.getTangent(a)
                },
                computeFrenetFrames: function(a, b) {
                    var c, d, e = new i,
                        f = [],
                        g = [],
                        h = [],
                        k = new i,
                        l = new j;
                    for (c = 0; c <= a; c++) d = c / a, f[c] = this.getTangentAt(d), f[c].normalize();
                    g[0] = new i, h[0] = new i, c = Number.MAX_VALUE, d = Math.abs(f[0].x);
                    var m = Math.abs(f[0].y),
                        n = Math.abs(f[0].z);
                    for (d <= c && (c = d, e.set(1, 0, 0)), m <= c && (c = m, e.set(0, 1, 0)), n <= c && e.set(0, 0, 1), k.crossVectors(f[0], e).normalize(), g[0].crossVectors(f[0], k), h[0].crossVectors(f[0], g[0]), c = 1; c <= a; c++) g[c] = g[c - 1].clone(), h[c] = h[c - 1].clone(), k.crossVectors(f[c - 1], f[c]), k.length() > Number.EPSILON && (k.normalize(), e = Math.acos(re.clamp(f[c - 1].dot(f[c]), -1, 1)), g[c].applyMatrix4(l.makeRotationAxis(k, e))), h[c].crossVectors(f[c], g[c]);
                    if (!0 === b)
                        for (e = Math.acos(re.clamp(g[0].dot(g[a]), -1, 1)), e /= a, 0 < f[0].dot(k.crossVectors(g[0], g[a])) && (e = -e), c = 1; c <= a; c++) g[c].applyMatrix4(l.makeRotationAxis(f[c], e * c)), h[c].crossVectors(f[c], g[c]);
                    return {
                        tangents: f,
                        normals: g,
                        binormals: h
                    }
                }
            }), jd.prototype = Object.create(id.prototype), jd.prototype.constructor = jd, jd.prototype.isLineCurve = !0, jd.prototype.getPoint = function(a) {
                if (1 === a) return this.v2.clone();
                var b = this.v2.clone().sub(this.v1);
                return b.multiplyScalar(a).add(this.v1), b
            }, jd.prototype.getPointAt = function(a) {
                return this.getPoint(a)
            }, jd.prototype.getTangent = function(a) {
                return this.v2.clone().sub(this.v1).normalize()
            }, kd.prototype = Object.assign(Object.create(id.prototype), {
                constructor: kd,
                add: function(a) {
                    this.curves.push(a)
                },
                closePath: function() {
                    var a = this.curves[0].getPoint(0),
                        b = this.curves[this.curves.length - 1].getPoint(1);
                    a.equals(b) || this.curves.push(new jd(b, a))
                },
                getPoint: function(a) {
                    var b = a * this.getLength(),
                        c = this.getCurveLengths();
                    for (a = 0; a < c.length;) {
                        if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
                        a++
                    }
                    return null
                },
                getLength: function() {
                    var a = this.getCurveLengths();
                    return a[a.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
                    return this.cacheLengths = a
                },
                getSpacedPoints: function(a) {
                    void 0 === a && (a = 40);
                    for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
                    return this.autoClose && b.push(b[0]), b
                },
                getPoints: function(a) {
                    a = a || 12;
                    for (var b, c = [], d = 0, e = this.curves; d < e.length; d++)
                        for (var f = e[d], f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && f.isLineCurve ? 1 : f && f.isSplineCurve ? a * f.points.length : a), g = 0; g < f.length; g++) {
                            var h = f[g];
                            b && b.equals(h) || (c.push(h), b = h)
                        }
                    return this.autoClose && 1 < c.length && !c[c.length - 1].equals(c[0]) && c.push(c[0]), c
                },
                createPointsGeometry: function(a) {
                    return a = this.getPoints(a), this.createGeometry(a)
                },
                createSpacedPointsGeometry: function(a) {
                    return a = this.getSpacedPoints(a), this.createGeometry(a)
                },
                createGeometry: function(a) {
                    for (var b = new wa, c = 0, d = a.length; c < d; c++) {
                        var e = a[c];
                        b.vertices.push(new i(e.x, e.y, e.z || 0))
                    }
                    return b
                }
            }), ld.prototype = Object.create(id.prototype), ld.prototype.constructor = ld, ld.prototype.isEllipseCurve = !0, ld.prototype.getPoint = function(a) {
                for (var b = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;) d += b;
                for (; d > b;) d -= b;
                d < Number.EPSILON && (d = e ? 0 : b), !0 !== this.aClockwise || e || (d = d === b ? -b : d - b), b = this.aStartAngle + a * d, a = this.aX + this.xRadius * Math.cos(b);
                var f = this.aY + this.yRadius * Math.sin(b);
                return 0 !== this.aRotation && (b = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * b - f * d + this.aX, f = e * d + f * b + this.aY), new c(a, f)
            }, md.prototype = Object.create(id.prototype), md.prototype.constructor = md, md.prototype.isSplineCurve = !0, md.prototype.getPoint = function(a) {
                var b = this.points,
                    d = (b.length - 1) * a;
                a = Math.floor(d);
                var d = d - a,
                    e = b[0 === a ? a : a - 1],
                    f = b[a],
                    g = b[a > b.length - 2 ? b.length - 1 : a + 1],
                    b = b[a > b.length - 3 ? b.length - 1 : a + 2];
                return new c(fd(d, e.x, f.x, g.x, b.x), fd(d, e.y, f.y, g.y, b.y))
            }, nd.prototype = Object.create(id.prototype), nd.prototype.constructor = nd, nd.prototype.getPoint = function(a) {
                var b = this.v0,
                    d = this.v1,
                    e = this.v2,
                    f = this.v3;
                return new c(hd(a, b.x, d.x, e.x, f.x), hd(a, b.y, d.y, e.y, f.y))
            }, od.prototype = Object.create(id.prototype), od.prototype.constructor = od, od.prototype.getPoint = function(a) {
                var b = this.v0,
                    d = this.v1,
                    e = this.v2;
                return new c(gd(a, b.x, d.x, e.x), gd(a, b.y, d.y, e.y))
            };
            var Ue = Object.assign(Object.create(kd.prototype), {
                fromPoints: function(a) {
                    this.moveTo(a[0].x, a[0].y);
                    for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
                },
                moveTo: function(a, b) {
                    this.currentPoint.set(a, b)
                },
                lineTo: function(a, b) {
                    var d = new jd(this.currentPoint.clone(), new c(a, b));
                    this.curves.push(d), this.currentPoint.set(a, b)
                },
                quadraticCurveTo: function(a, b, d, e) {
                    a = new od(this.currentPoint.clone(), new c(a, b), new c(d, e)), this.curves.push(a), this.currentPoint.set(d, e)
                },
                bezierCurveTo: function(a, b, d, e, f, g) {
                    a = new nd(this.currentPoint.clone(), new c(a, b), new c(d, e), new c(f, g)), this.curves.push(a), this.currentPoint.set(f, g)
                },
                splineThru: function(a) {
                    var b = [this.currentPoint.clone()].concat(a),
                        b = new md(b);
                    this.curves.push(b), this.currentPoint.copy(a[a.length - 1])
                },
                arc: function(a, b, c, d, e, f) {
                    this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
                },
                absarc: function(a, b, c, d, e, f) {
                    this.absellipse(a, b, c, c, d, e, f)
                },
                ellipse: function(a, b, c, d, e, f, g, h) {
                    this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h)
                },
                absellipse: function(a, b, c, d, e, f, g, h) {
                    a = new ld(a, b, c, d, e, f, g, h), 0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y)), this.curves.push(a), a = a.getPoint(1), this.currentPoint.copy(a)
                }
            });
            pd.prototype = Ue, Ue.constructor = pd, qd.prototype = Object.assign(Object.create(Ue), {
                constructor: qd,
                getPointsHoles: function(a) {
                    for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
                    return b
                },
                extractAllPoints: function(a) {
                    return {
                        shape: this.getPoints(a),
                        holes: this.getPointsHoles(a)
                    }
                },
                extractPoints: function(a) {
                    return this.extractAllPoints(a)
                }
            }), Object.assign(rd.prototype, {
                moveTo: function(a, b) {
                    this.currentPath = new pd, this.subPaths.push(this.currentPath), this.currentPath.moveTo(a, b)
                },
                lineTo: function(a, b) {
                    this.currentPath.lineTo(a, b)
                },
                quadraticCurveTo: function(a, b, c, d) {
                    this.currentPath.quadraticCurveTo(a, b, c, d)
                },
                bezierCurveTo: function(a, b, c, d, e, f) {
                    this.currentPath.bezierCurveTo(a, b, c, d, e, f)
                },
                splineThru: function(a) {
                    this.currentPath.splineThru(a)
                },
                toShapes: function(a, b) {
                    function c(a) {
                        for (var b = [], c = 0, d = a.length; c < d; c++) {
                            var e = a[c],
                                f = new qd;
                            f.curves = e.curves, b.push(f)
                        }
                        return b
                    }

                    function d(a, b) {
                        for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                            var g = b[e],
                                h = b[f],
                                i = h.x - g.x,
                                j = h.y - g.y;
                            if (Math.abs(j) > Number.EPSILON) {
                                if (0 > j && (g = b[f], i = -i, h = b[e], j = -j), !(a.y < g.y || a.y > h.y))
                                    if (a.y === g.y) {
                                        if (a.x === g.x) return !0
                                    } else {
                                        if (e = j * (a.x - g.x) - i * (a.y - g.y), 0 === e) return !0;
                                        0 > e || (d = !d)
                                    }
                            } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0
                        }
                        return d
                    }
                    var e = Je.isClockWise,
                        f = this.subPaths;
                    if (0 === f.length) return [];
                    if (!0 === b) return c(f);
                    var g, h, i, j = [];
                    if (1 === f.length) return h = f[0], i = new qd, i.curves = h.curves, j.push(i), j;
                    var k = !e(f[0].getPoints()),
                        k = a ? !k : k;
                    i = [];
                    var l, m = [],
                        n = [],
                        o = 0;
                    m[o] = void 0, n[o] = [];
                    for (var p = 0, q = f.length; p < q; p++) h = f[p], l = h.getPoints(), g = e(l), (g = a ? !g : g) ? (!k && m[o] && o++, m[o] = {
                        s: new qd,
                        p: l
                    }, m[o].s.curves = h.curves, k && o++, n[o] = []) : n[o].push({
                        h: h,
                        p: l[0]
                    });
                    if (!m[0]) return c(f);
                    if (1 < m.length) {
                        for (p = !1, h = [], e = 0, f = m.length; e < f; e++) i[e] = [];
                        for (e = 0, f = m.length; e < f; e++)
                            for (g = n[e], k = 0; k < g.length; k++) {
                                for (o = g[k], l = !0, q = 0; q < m.length; q++) d(o.p, m[q].p) && (e !== q && h.push({
                                    froms: e,
                                    tos: q,
                                    hole: k
                                }), l ? (l = !1, i[q].push(o)) : p = !0);
                                l && i[e].push(o)
                            }
                        0 < h.length && (p || (n = i))
                    }
                    for (p = 0, e = m.length; p < e; p++)
                        for (i = m[p].s, j.push(i), h = n[p], f = 0, g = h.length; f < g; f++) i.holes.push(h[f].h);
                    return j
                }
            }), Object.assign(sd.prototype, {
                isFont: !0,
                generateShapes: function(a, b, c) {
                    void 0 === b && (b = 100), void 0 === c && (c = 4);
                    var d = this.data;
                    a = String(a).split("");
                    var e = b / d.resolution,
                        f = (d.boundingBox.yMax - d.boundingBox.yMin + d.underlineThickness) * e,
                        g = 0,
                        h = 0;
                    b = [];
                    for (var i = 0; i < a.length; i++) {
                        var j = a[i];
                        if ("\n" === j) g = 0, h -= f;
                        else {
                            var k;
                            k = e;
                            var l = g,
                                m = h;
                            if (j = d.glyphs[j] || d.glyphs["?"]) {
                                var n, o, p, q, r, s, t, u, v = new rd,
                                    w = [];
                                if (j.o)
                                    for (var x = j._cachedOutline || (j._cachedOutline = j.o.split(" ")), y = 0, z = x.length; y < z;) switch (x[y++]) {
                                        case "m":
                                            n = x[y++] * k + l, o = x[y++] * k + m, v.moveTo(n, o);
                                            break;
                                        case "l":
                                            n = x[y++] * k + l, o = x[y++] * k + m, v.lineTo(n, o);
                                            break;
                                        case "q":
                                            if (n = x[y++] * k + l, o = x[y++] * k + m, r = x[y++] * k + l, s = x[y++] * k + m, v.quadraticCurveTo(r, s, n, o), q = w[w.length - 1]) {
                                                p = q.x, q = q.y;
                                                for (var A = 1; A <= c; A++) {
                                                    var B = A / c;
                                                    gd(B, p, r, n), gd(B, q, s, o)
                                                }
                                            }
                                            break;
                                        case "b":
                                            if (n = x[y++] * k + l, o = x[y++] * k + m, r = x[y++] * k + l, s = x[y++] * k + m, t = x[y++] * k + l, u = x[y++] * k + m, v.bezierCurveTo(r, s, t, u, n, o), q = w[w.length - 1])
                                                for (p = q.x, q = q.y, A = 1; A <= c; A++) B = A / c, hd(B, p, r, t, n), hd(B, q, s, u, o)
                                    }
                                k = {
                                    offsetX: j.ha * k,
                                    path: v
                                }
                            } else k = void 0;
                            g += k.offsetX, b.push(k.path)
                        }
                    }
                    for (c = [], d = 0, a = b.length; d < a; d++) Array.prototype.push.apply(c, b[d].toShapes());
                    return c
                }
            }), Object.assign(td.prototype, {
                load: function(a, b, c, d) {
                    var e = this;
                    new yc(this.manager).load(a, function(a) {
                        var c;
                        try {
                            c = JSON.parse(a)
                        } catch (b) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2))
                        }
                        a = e.parse(c), b && b(a)
                    }, c, d)
                },
                parse: function(a) {
                    return new sd(a)
                }
            });
            var Ve, We = {
                getContext: function() {
                    return void 0 === Ve && (Ve = new(window.AudioContext || window.webkitAudioContext)), Ve
                },
                setContext: function(a) {
                    Ve = a
                }
            };
            Object.assign(ud.prototype, {
                load: function(a, b, c, d) {
                    var e = new yc(this.manager);
                    e.setResponseType("arraybuffer"), e.load(a, function(a) {
                        We.getContext().decodeAudioData(a, function(a) {
                            b(a)
                        })
                    }, c, d)
                }
            }), Object.assign(vd.prototype, {
                update: function() {
                    var a, b, c, d, e, f, g, h, i = new j,
                        k = new j;
                    return function(j) {
                        if (a !== this || b !== j.focus || c !== j.fov || d !== j.aspect * this.aspect || e !== j.near || f !== j.far || g !== j.zoom || h !== this.eyeSep) {
                            a = this, b = j.focus, c = j.fov, d = j.aspect * this.aspect, e = j.near, f = j.far, g = j.zoom;
                            var l = j.projectionMatrix.clone();
                            h = this.eyeSep / 2;
                            var m, n, o = h * e / b,
                                p = e * Math.tan(re.DEG2RAD * c * .5) / g;
                            k.elements[12] = -h, i.elements[12] = h, m = -p * d + o, n = p * d + o, l.elements[0] = 2 * e / (n - m), l.elements[8] = (n + m) / (n - m), this.cameraL.projectionMatrix.copy(l), m = -p * d - o, n = p * d - o, l.elements[0] = 2 * e / (n - m), l.elements[8] = (n + m) / (n - m), this.cameraR.projectionMatrix.copy(l)
                        }
                        this.cameraL.matrixWorld.copy(j.matrixWorld).multiply(k), this.cameraR.matrixWorld.copy(j.matrixWorld).multiply(i)
                    }
                }()
            }), wd.prototype = Object.create(fa.prototype), wd.prototype.constructor = wd, xd.prototype = Object.assign(Object.create(Ea.prototype), {
                constructor: xd,
                isArrayCamera: !0
            }), yd.prototype = Object.assign(Object.create(fa.prototype), {
                constructor: yd,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(a) {
                    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = a, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(a) {
                    this.gain.gain.value = a
                },
                updateMatrixWorld: function() {
                    var a = new i,
                        b = new h,
                        c = new i,
                        d = new i;
                    return function(e) {
                        fa.prototype.updateMatrixWorld.call(this, e), e = this.context.listener;
                        var f = this.up;
                        this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z))
                    }
                }()
            }), zd.prototype = Object.assign(Object.create(fa.prototype), {
                constructor: zd,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(a) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = a, this.connect(), this
                },
                setBuffer: function(a) {
                    return this.buffer = a, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function() {
                    if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
                    else {
                        if (!1 !== this.hasPlaybackControl) {
                            var a = this.context.createBufferSource();
                            return a.buffer = this.buffer, a.loop = this.loop, a.onended = this.onEnded.bind(this), a.playbackRate.setValueAtTime(this.playbackRate, this.startTime), a.start(0, this.startTime), this.isPlaying = !0, this.source = a, this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                },
                pause: function() {
                    return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = 0, this.isPlaying = !1, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (0 < this.filters.length) {
                        this.source.connect(this.filters[0]);
                        for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (0 < this.filters.length) {
                        this.source.disconnect(this.filters[0]);
                        for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(a) {
                    return a || (a = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a, this
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(a) {
                    return this.setFilters(a ? [a] : [])
                },
                setPlaybackRate: function(a) {
                    return !1 !== this.hasPlaybackControl ? (this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this) : void console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(a) {
                    return !1 !== this.hasPlaybackControl ? (this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this) : void console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(a) {
                    return this.gain.gain.value = a, this
                }
            }), Ad.prototype = Object.assign(Object.create(zd.prototype), {
                constructor: Ad,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(a) {
                    this.panner.refDistance = a
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(a) {
                    this.panner.rolloffFactor = a
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(a) {
                    this.panner.distanceModel = a
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(a) {
                    this.panner.maxDistance = a
                },
                updateMatrixWorld: function() {
                    var a = new i;
                    return function(b) {
                        fa.prototype.updateMatrixWorld.call(this, b), a.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(a.x, a.y, a.z)
                    }
                }()
            }), Object.assign(Bd.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
                    return a / b.length
                }
            }), Object.assign(Cd.prototype, {
                accumulate: function(a, b) {
                    var c = this.buffer,
                        d = this.valueSize,
                        e = a * d + d,
                        f = this.cumulativeWeight;
                    if (0 === f) {
                        for (f = 0; f !== d; ++f) c[e + f] = c[f];
                        f = b
                    } else f += b, this._mixBufferRegion(c, e, 0, b / f, d);
                    this.cumulativeWeight = f
                },
                apply: function(a) {
                    var b = this.valueSize,
                        c = this.buffer;
                    a = a * b + b;
                    var d = this.cumulativeWeight,
                        e = this.binding;
                    this.cumulativeWeight = 0, 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
                    for (var d = b, f = b + b; d !== f; ++d)
                        if (c[d] !== c[d + b]) {
                            e.setValue(c, a);
                            break
                        }
                },
                saveOriginalState: function() {
                    var a = this.buffer,
                        b = this.valueSize,
                        c = 3 * b;
                    this.binding.getValue(a, c);
                    for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    this.binding.setValue(this.buffer, 3 * this.valueSize)
                },
                _select: function(a, b, c, d, e) {
                    if (.5 <= d)
                        for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
                },
                _slerp: function(a, b, c, d) {
                    h.slerpFlat(a, b, a, b, a, c, d)
                },
                _lerp: function(a, b, c, d, e) {
                    for (var f = 1 - d, g = 0; g !== e; ++g) {
                        var h = b + g;
                        a[h] = a[h] * f + a[c + g] * d
                    }
                }
            }), Object.assign(Dd.prototype, {
                getValue: function(a, b) {
                    this.bind();
                    var c = this._bindings[this._targetGroup.nCachedObjects_];
                    void 0 !== c && c.getValue(a, b)
                },
                setValue: function(a, b) {
                    for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
                },
                bind: function() {
                    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
                },
                unbind: function() {
                    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
                }
            }), Object.assign(Ed, {
                Composite: Dd,
                create: function(a, b, c) {
                    return a && a.isAnimationObjectGroup ? new Ed.Composite(a, b, c) : new Ed(a, b, c)
                },
                parseTrackName: function() {
                    var a = new RegExp("^" + /((?:[\w-]+[\/:])*)/.source + /([\w-\.]+)?/.source + /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source + /\.([\w-]+)(?:\[(.+)\])?/.source + "$"),
                        b = ["material", "materials", "bones"];
                    return function(c) {
                        var d = a.exec(c);
                        if (!d) throw Error("PropertyBinding: Cannot parse trackName: " + c);
                        var d = {
                                nodeName: d[2],
                                objectName: d[3],
                                objectIndex: d[4],
                                propertyName: d[5],
                                propertyIndex: d[6]
                            },
                            e = d.nodeName && d.nodeName.lastIndexOf(".");
                        if (void 0 !== e && -1 !== e) {
                            var f = d.nodeName.substring(e + 1); - 1 !== b.indexOf(f) && (d.nodeName = d.nodeName.substring(0, e), d.objectName = f)
                        }
                        if (null === d.propertyName || 0 === d.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + c);
                        return d
                    }
                }(),
                findNode: function(a, b) {
                    if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
                    if (a.skeleton) {
                        var c = function(a) {
                            for (var c = 0; c < a.bones.length; c++) {
                                var d = a.bones[c];
                                if (d.name === b) return d
                            }
                            return null
                        }(a.skeleton);
                        if (c) return c
                    }
                    if (a.children) {
                        var d = function(a) {
                            for (var c = 0; c < a.length; c++) {
                                var e = a[c];
                                if (e.name === b || e.uuid === b || (e = d(e.children))) return e
                            }
                            return null
                        };
                        if (c = d(a.children)) return c
                    }
                    return null
                }
            }), Object.assign(Ed.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(a, b) {
                    a[b] = this.node[this.propertyName]
                }, function(a, b) {
                    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
                }, function(a, b) {
                    a[b] = this.resolvedProperty[this.propertyIndex]
                }, function(a, b) {
                    this.resolvedProperty.toArray(a, b)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(a, b) {
                        this.node[this.propertyName] = a[b]
                    }, function(a, b) {
                        this.node[this.propertyName] = a[b], this.targetObject.needsUpdate = !0
                    }, function(a, b) {
                        this.node[this.propertyName] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(a, b) {
                        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
                    }, function(a, b) {
                        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                        this.targetObject.needsUpdate = !0
                    }, function(a, b) {
                        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(a, b) {
                        this.resolvedProperty[this.propertyIndex] = a[b]
                    }, function(a, b) {
                        this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.needsUpdate = !0
                    }, function(a, b) {
                        this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(a, b) {
                        this.resolvedProperty.fromArray(a, b)
                    }, function(a, b) {
                        this.resolvedProperty.fromArray(a, b), this.targetObject.needsUpdate = !0
                    }, function(a, b) {
                        this.resolvedProperty.fromArray(a, b), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(a, b) {
                    this.bind(), this.getValue(a, b)
                },
                setValue: function(a, b) {
                    this.bind(), this.setValue(a, b)
                },
                bind: function() {
                    var a = this.node,
                        b = this.parsedPath,
                        c = b.objectName,
                        d = b.propertyName,
                        e = b.propertyIndex;
                    if (a || (this.node = a = Ed.findNode(this.rootNode, b.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, a) {
                        if (c) {
                            var f = b.objectIndex;
                            switch (c) {
                                case "materials":
                                    if (!a.material) return void console.error("  can not bind to material as node does not have a material", this);
                                    if (!a.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                                    a = a.material.materials;
                                    break;
                                case "bones":
                                    if (!a.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                                    for (a = a.skeleton.bones, c = 0; c < a.length; c++)
                                        if (a[c].name === f) {
                                            f = c;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === a[c]) return void console.error("  can not bind to objectName of node, undefined", this);
                                    a = a[c]
                            }
                            if (void 0 !== f) {
                                if (void 0 === a[f]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
                                a = a[f]
                            }
                        }
                        if (f = a[d], void 0 === f) console.error("  trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
                        else {
                            if (b = this.Versioning.None, void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a), c = this.BindingType.Direct, void 0 !== e) {
                                if ("morphTargetInfluences" === d) {
                                    if (!a.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                                    if (!a.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                                    for (c = 0; c < this.node.geometry.morphTargets.length; c++)
                                        if (a.geometry.morphTargets[c].name === e) {
                                            e = c;
                                            break
                                        }
                                }
                                c = this.BindingType.ArrayElement, this.resolvedProperty = f, this.propertyIndex = e
                            } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
                            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
                        }
                    } else console.error("  trying to update node for track: " + this.path + " but it wasn't found.")
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Ed.prototype, {
                _getValue_unbound: Ed.prototype.getValue,
                _setValue_unbound: Ed.prototype.setValue
            }), Object.assign(Fd.prototype, {
                isAnimationObjectGroup: !0,
                add: function(a) {
                    for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._paths, g = this._parsedPaths, h = this._bindings, i = h.length, j = 0, k = arguments.length; j !== k; ++j) {
                        var l = arguments[j],
                            m = l.uuid,
                            n = e[m];
                        if (void 0 === n) {
                            n = c++, e[m] = n, b.push(l);
                            for (var m = 0, o = i; m !== o; ++m) h[m].push(new Ed(l, f[m], g[m]))
                        } else if (n < d) {
                            var p = --d,
                                o = b[p];
                            for (e[o.uuid] = n, b[n] = o, e[m] = p, b[p] = l, m = 0, o = i; m !== o; ++m) {
                                var q = h[m],
                                    r = q[n];
                                q[n] = q[p], void 0 === r && (r = new Ed(l, f[m], g[m])), q[p] = r
                            }
                        } else void 0 !== b[n] && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                    }
                    this.nCachedObjects_ = d
                },
                remove: function(a) {
                    for (var b = this._objects, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
                        var i = arguments[g],
                            j = i.uuid,
                            k = d[j];
                        if (void 0 !== k && k >= c) {
                            var l = c++,
                                m = b[l];
                            for (d[m.uuid] = k, b[k] = m, d[j] = l, b[l] = i, i = 0, j = f; i !== j; ++i) {
                                var m = e[i],
                                    n = m[k];
                                m[k] = m[l], m[l] = n
                            }
                        }
                    }
                    this.nCachedObjects_ = c
                },
                uncache: function(a) {
                    for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._bindings, g = f.length, h = 0, i = arguments.length; h !== i; ++h) {
                        var j = arguments[h].uuid,
                            k = e[j];
                        if (void 0 !== k)
                            if (delete e[j], k < d) {
                                var j = --d,
                                    l = b[j],
                                    m = --c,
                                    n = b[m];
                                for (e[l.uuid] = k, b[k] = l, e[n.uuid] = j, b[j] = n, b.pop(), l = 0, n = g; l !== n; ++l) {
                                    var o = f[l],
                                        p = o[m];
                                    o[k] = o[j], o[j] = p, o.pop()
                                }
                            } else
                                for (m = --c, n = b[m], e[n.uuid] = k, b[k] = n, b.pop(), l = 0, n = g; l !== n; ++l) o = f[l], o[k] = o[m], o.pop()
                    }
                    this.nCachedObjects_ = d
                },
                subscribe_: function(a, b) {
                    var c = this._bindingsIndicesByPath,
                        d = c[a],
                        e = this._bindings;
                    if (void 0 !== d) return e[d];
                    var f = this._paths,
                        g = this._parsedPaths,
                        h = this._objects,
                        i = this.nCachedObjects_,
                        j = Array(h.length),
                        d = e.length;
                    for (c[a] = d, f.push(a), g.push(b), e.push(j), c = i, d = h.length; c !== d; ++c) j[c] = new Ed(h[c], a, b);
                    return j
                },
                unsubscribe_: function(a) {
                    var b = this._bindingsIndicesByPath,
                        c = b[a];
                    if (void 0 !== c) {
                        var d = this._paths,
                            e = this._parsedPaths,
                            f = this._bindings,
                            g = f.length - 1,
                            h = f[g];
                        b[a[g]] = c, f[c] = h, f.pop(), e[c] = e[g], e.pop(), d[c] = d[g], d.pop()
                    }
                }
            }), Object.assign(Gd.prototype, {
                play: function() {
                    return this._mixer._activateAction(this), this
                },
                stop: function() {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function() {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function(a) {
                    return this._startTime = a, this
                },
                setLoop: function(a, b) {
                    return this.loop = a, this.repetitions = b, this
                },
                setEffectiveWeight: function(a) {
                    return this.weight = a, this._effectiveWeight = this.enabled ? a : 0, this.stopFading()
                },
                getEffectiveWeight: function() {
                    return this._effectiveWeight
                },
                fadeIn: function(a) {
                    return this._scheduleFading(a, 0, 1)
                },
                fadeOut: function(a) {
                    return this._scheduleFading(a, 1, 0)
                },
                crossFadeFrom: function(a, b, c) {
                    if (a.fadeOut(b), this.fadeIn(b), c) {
                        c = this._clip.duration;
                        var d = a._clip.duration,
                            e = c / d;
                        a.warp(1, d / c, b), this.warp(e, 1, b)
                    }
                    return this
                },
                crossFadeTo: function(a, b, c) {
                    return a.crossFadeFrom(this, b, c)
                },
                stopFading: function() {
                    var a = this._weightInterpolant;
                    return null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
                },
                setEffectiveTimeScale: function(a) {
                    return this.timeScale = a, this._effectiveTimeScale = this.paused ? 0 : a, this.stopWarping()
                },
                getEffectiveTimeScale: function() {
                    return this._effectiveTimeScale
                },
                setDuration: function(a) {
                    return this.timeScale = this._clip.duration / a, this.stopWarping()
                },
                syncWith: function(a) {
                    return this.time = a.time, this.timeScale = a.timeScale, this.stopWarping()
                },
                halt: function(a) {
                    return this.warp(this._effectiveTimeScale, 0, a)
                },
                warp: function(a, b, c) {
                    var d = this._mixer,
                        e = d.time,
                        f = this._timeScaleInterpolant,
                        g = this.timeScale;
                    return null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()), d = f.parameterPositions, f = f.sampleValues, d[0] = e, d[1] = e + c, f[0] = a / g, f[1] = b / g, this
                },
                stopWarping: function() {
                    var a = this._timeScaleInterpolant;
                    return null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
                },
                getMixer: function() {
                    return this._mixer
                },
                getClip: function() {
                    return this._clip
                },
                getRoot: function() {
                    return this._localRoot || this._mixer._root
                },
                _update: function(a, b, c, d) {
                    if (this.enabled) {
                        var e = this._startTime;
                        if (null !== e) {
                            if (b = (a - e) * c, 0 > b || 0 === c) return;
                            this._startTime = null, b *= c
                        }
                        if (b *= this._updateTimeScale(a), c = this._updateTime(b), a = this._updateWeight(a), 0 < a) {
                            b = this._interpolants;
                            for (var e = this._propertyBindings, f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
                        }
                    } else this._updateWeight(a)
                },
                _updateWeight: function(a) {
                    var b = 0;
                    if (this.enabled) {
                        var b = this.weight,
                            c = this._weightInterpolant;
                        if (null !== c) {
                            var d = c.evaluate(a)[0],
                                b = b * d;
                            a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = b
                },
                _updateTimeScale: function(a) {
                    var b = 0;
                    if (!this.paused) {
                        var b = this.timeScale,
                            c = this._timeScaleInterpolant;
                        if (null !== c) {
                            var d = c.evaluate(a)[0],
                                b = b * d;
                            a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
                        }
                    }
                    return this._effectiveTimeScale = b
                },
                _updateTime: function(a) {
                    var b = this.time + a;
                    if (0 === a) return b;
                    var c = this._clip.duration,
                        d = this.loop,
                        e = this._loopCount;
                    if (2200 === d) a: {
                        if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
                        else {
                            if (!(0 > b)) break a;
                            b = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 > a ? -1 : 1
                        })
                    }
                    else {
                        if (d = 2202 === d, -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d)), b >= c || 0 > b) {
                            var f = Math.floor(b / c),
                                b = b - c * f,
                                e = e + Math.abs(f),
                                g = this.repetitions - e;
                            0 > g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: 0 < a ? 1 : -1
                            })) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), this._loopCount = e, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: f
                            }))
                        }
                        if (d && 1 === (1 & e)) return this.time = b, c - b
                    }
                    return this.time = b
                },
                _setEndings: function(a, b, c) {
                    var d = this._interpolantSettings;
                    c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
                },
                _scheduleFading: function(a, b, c) {
                    var d = this._mixer,
                        e = d.time,
                        f = this._weightInterpolant;
                    return null === f && (this._weightInterpolant = f = d._lendControlInterpolant()), d = f.parameterPositions, f = f.sampleValues, d[0] = e, f[0] = b, d[1] = e + a, f[1] = c, this
                }
            }), Object.assign(Hd.prototype, b.prototype, {
                _bindAction: function(a, b) {
                    var c = a._localRoot || this._root,
                        d = a._clip.tracks,
                        e = d.length,
                        f = a._propertyBindings,
                        g = a._interpolants,
                        h = c.uuid,
                        i = this._bindingsByRootAndName,
                        j = i[h];
                    for (void 0 === j && (j = {}, i[h] = j), i = 0; i !== e; ++i) {
                        var k = d[i],
                            l = k.name,
                            m = j[l];
                        if (void 0 === m) {
                            if (m = f[i], void 0 !== m) {
                                null === m._cacheIndex && (++m.referenceCount, this._addInactiveBinding(m, h, l));
                                continue
                            }
                            m = new Cd(Ed.create(c, l, b && b._propertyBindings[i].binding.parsedPath), k.ValueTypeName, k.getValueSize()), ++m.referenceCount, this._addInactiveBinding(m, h, l)
                        }
                        f[i] = m, g[i].resultBuffer = m.buffer
                    }
                },
                _activateAction: function(a) {
                    if (!this._isActiveAction(a)) {
                        if (null === a._cacheIndex) {
                            var b = (a._localRoot || this._root).uuid,
                                c = a._clip.uuid,
                                d = this._actionsByClip[c];
                            this._bindAction(a, d && d.knownActions[0]), this._addInactiveAction(a, c, b)
                        }
                        for (b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                            var e = b[c];
                            0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
                        }
                        this._lendAction(a)
                    }
                },
                _deactivateAction: function(a) {
                    if (this._isActiveAction(a)) {
                        for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                            var e = b[c];
                            0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
                        }
                        this._takeBackAction(a)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var a = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return a._actions.length
                            },
                            get inUse() {
                                return a._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return a._bindings.length
                            },
                            get inUse() {
                                return a._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return a._controlInterpolants.length
                            },
                            get inUse() {
                                return a._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(a) {
                    return a = a._cacheIndex, null !== a && a < this._nActiveActions
                },
                _addInactiveAction: function(a, b, c) {
                    var d = this._actions,
                        e = this._actionsByClip,
                        f = e[b];
                    void 0 === f ? (f = {
                        knownActions: [a],
                        actionByRoot: {}
                    }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a)), a._cacheIndex = d.length, d.push(a), f.actionByRoot[c] = a
                },
                _removeInactiveAction: function(a) {
                    var b = this._actions,
                        c = b[b.length - 1],
                        d = a._cacheIndex;
                    c._cacheIndex = d, b[d] = c, b.pop(), a._cacheIndex = null;
                    var b = a._clip.uuid,
                        c = this._actionsByClip,
                        d = c[b],
                        e = d.knownActions,
                        f = e[e.length - 1],
                        g = a._byClipCacheIndex;
                    f._byClipCacheIndex = g, e[g] = f, e.pop(), a._byClipCacheIndex = null, delete d.actionByRoot[(a._localRoot || this._root).uuid], 0 === e.length && delete c[b], this._removeInactiveBindingsForAction(a)
                },
                _removeInactiveBindingsForAction: function(a) {
                    a = a._propertyBindings;
                    for (var b = 0, c = a.length; b !== c; ++b) {
                        var d = a[b];
                        0 === --d.referenceCount && this._removeInactiveBinding(d)
                    }
                },
                _lendAction: function(a) {
                    var b = this._actions,
                        c = a._cacheIndex,
                        d = this._nActiveActions++,
                        e = b[d];
                    a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
                },
                _takeBackAction: function(a) {
                    var b = this._actions,
                        c = a._cacheIndex,
                        d = --this._nActiveActions,
                        e = b[d];
                    a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
                },
                _addInactiveBinding: function(a, b, c) {
                    var d = this._bindingsByRootAndName,
                        e = d[b],
                        f = this._bindings;
                    void 0 === e && (e = {}, d[b] = e), e[c] = a, a._cacheIndex = f.length, f.push(a)
                },
                _removeInactiveBinding: function(a) {
                    var b = this._bindings,
                        c = a.binding,
                        d = c.rootNode.uuid,
                        c = c.path,
                        e = this._bindingsByRootAndName,
                        f = e[d],
                        g = b[b.length - 1];
                    a = a._cacheIndex, g._cacheIndex = a, b[a] = g, b.pop(), delete f[c];
                    a: {
                        for (var h in f) break a;delete e[d]
                    }
                },
                _lendBinding: function(a) {
                    var b = this._bindings,
                        c = a._cacheIndex,
                        d = this._nActiveBindings++,
                        e = b[d];
                    a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
                },
                _takeBackBinding: function(a) {
                    var b = this._bindings,
                        c = a._cacheIndex,
                        d = --this._nActiveBindings,
                        e = b[d];
                    a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
                },
                _lendControlInterpolant: function() {
                    var a = this._controlInterpolants,
                        b = this._nActiveControlInterpolants++,
                        c = a[b];
                    return void 0 === c && (c = new Qc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c), c
                },
                _takeBackControlInterpolant: function(a) {
                    var b = this._controlInterpolants,
                        c = a.__cacheIndex,
                        d = --this._nActiveControlInterpolants,
                        e = b[d];
                    a.__cacheIndex = d, b[d] = a, e.__cacheIndex = c, b[c] = e
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(a, b) {
                    var c = b || this._root,
                        d = c.uuid,
                        e = "string" == typeof a ? _c.findByName(c, a) : a,
                        c = null !== e ? e.uuid : a,
                        f = this._actionsByClip[c],
                        g = null;
                    if (void 0 !== f) {
                        if (g = f.actionByRoot[d], void 0 !== g) return g;
                        g = f.knownActions[0], null === e && (e = g._clip)
                    }
                    return null === e ? null : (e = new Gd(this, e, b), this._bindAction(e, g), this._addInactiveAction(e, c, d), e)
                },
                existingAction: function(a, b) {
                    var c = b || this._root,
                        d = c.uuid,
                        c = "string" == typeof a ? _c.findByName(c, a) : a,
                        c = this._actionsByClip[c ? c.uuid : a];
                    return void 0 !== c ? c.actionByRoot[d] || null : null
                },
                stopAllAction: function() {
                    for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
                    for (e = 0; e !== d; ++e) c[e].useCount = 0;
                    return this
                },
                update: function(a) {
                    a *= this.timeScale;
                    for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) b[g]._update(d, a, e, f);
                    for (a = this._bindings, b = this._nActiveBindings, g = 0; g !== b; ++g) a[g].apply(f);
                    return this
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(a) {
                    var b = this._actions;
                    a = a.uuid;
                    var c = this._actionsByClip,
                        d = c[a];
                    if (void 0 !== d) {
                        for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
                            var g = d[e];
                            this._deactivateAction(g);
                            var h = g._cacheIndex,
                                i = b[b.length - 1];
                            g._cacheIndex = null, g._byClipCacheIndex = null, i._cacheIndex = h, b[h] = i, b.pop(), this._removeInactiveBindingsForAction(g)
                        }
                        delete c[a]
                    }
                },
                uncacheRoot: function(a) {
                    a = a.uuid;
                    var b, c = this._actionsByClip;
                    for (b in c) {
                        var d = c[b].actionByRoot[a];
                        void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d))
                    }
                    if (b = this._bindingsByRootAndName[a], void 0 !== b)
                        for (var e in b) a = b[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
                },
                uncacheAction: function(a, b) {
                    var c = this.existingAction(a, b);
                    null !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
                }
            }), Id.prototype.clone = function() {
                return new Id(void 0 === this.value.clone ? this.value : this.value.clone())
            }, Jd.prototype = Object.assign(Object.create(xa.prototype), {
                constructor: Jd,
                isInstancedBufferGeometry: !0,
                addGroup: function(a, b, c) {
                    this.groups.push({
                        start: a,
                        count: b,
                        materialIndex: c
                    })
                },
                copy: function(a) {
                    var b = a.index;
                    null !== b && this.setIndex(b.clone());
                    var c, b = a.attributes;
                    for (c in b) this.addAttribute(c, b[c].clone());
                    for (a = a.groups, c = 0, b = a.length; c < b; c++) {
                        var d = a[c];
                        this.addGroup(d.start, d.count, d.materialIndex)
                    }
                    return this
                }
            }), Object.defineProperties(Kd.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(Kd.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(a, b) {
                    return this.data.array[a * this.data.stride + this.offset] = b, this
                },
                setY: function(a, b) {
                    return this.data.array[a * this.data.stride + this.offset + 1] = b, this
                },
                setZ: function(a, b) {
                    return this.data.array[a * this.data.stride + this.offset + 2] = b, this
                },
                setW: function(a, b) {
                    return this.data.array[a * this.data.stride + this.offset + 3] = b, this
                },
                getX: function(a) {
                    return this.data.array[a * this.data.stride + this.offset]
                },
                getY: function(a) {
                    return this.data.array[a * this.data.stride + this.offset + 1]
                },
                getZ: function(a) {
                    return this.data.array[a * this.data.stride + this.offset + 2]
                },
                getW: function(a) {
                    return this.data.array[a * this.data.stride + this.offset + 3]
                },
                setXY: function(a, b, c) {
                    return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this
                },
                setXYZ: function(a, b, c, d) {
                    return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this
                },
                setXYZW: function(a, b, c, d, e) {
                    return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this.data.array[a + 3] = e, this
                }
            }), Object.defineProperty(Ld.prototype, "needsUpdate", {
                set: function(a) {
                    !0 === a && this.version++
                }
            }), Object.assign(Ld.prototype, {
                isInterleavedBuffer: !0,
                setArray: function(a) {
                    if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.count = void 0 !== a ? a.length / this.stride : 0, this.array = a
                },
                setDynamic: function(a) {
                    return this.dynamic = a, this
                },
                copy: function(a) {
                    return this.array = new a.array.constructor(a.array), this.count = a.count, this.stride = a.stride, this.dynamic = a.dynamic, this
                },
                copyAt: function(a, b, c) {
                    a *= this.stride, c *= b.stride;
                    for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
                    return this
                },
                set: function(a, b) {
                    return void 0 === b && (b = 0), this.array.set(a, b), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(a) {
                    return this.onUploadCallback = a, this
                }
            }), Md.prototype = Object.assign(Object.create(Ld.prototype), {
                constructor: Md,
                isInstancedInterleavedBuffer: !0,
                copy: function(a) {
                    return Ld.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
                }
            }), Nd.prototype = Object.assign(Object.create(ka.prototype), {
                constructor: Nd,
                isInstancedBufferAttribute: !0,
                copy: function(a) {
                    return ka.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
                }
            }), Object.assign(Od.prototype, {
                linePrecision: 1,
                set: function(a, b) {
                    this.ray.set(a, b)
                },
                setFromCamera: function(a, b) {
                    b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(a, b) {
                    var c = [];
                    return Qd(a, this, c, b), c.sort(Pd), c
                },
                intersectObjects: function(a, b) {
                    var c = [];
                    if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
                    for (var d = 0, e = a.length; d < e; d++) Qd(a[d], this, c, b);
                    return c.sort(Pd), c
                }
            }), Object.assign(Rd.prototype, {
                start: function() {
                    this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var a = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var b = ("undefined" == typeof performance ? Date : performance).now(),
                            a = (b - this.oldTime) / 1e3;
                        this.oldTime = b, this.elapsedTime += a
                    }
                    return a
                }
            }), Object.assign(Sd.prototype, {
                set: function(a, b, c) {
                    return this.radius = a, this.phi = b, this.theta = c, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.radius = a.radius, this.phi = a.phi, this.theta = a.theta, this
                },
                makeSafe: function() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                },
                setFromVector3: function(a) {
                    return this.radius = a.length(), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(re.clamp(a.y / this.radius, -1, 1))), this
                }
            }), Object.assign(Td.prototype, {
                set: function(a, b, c) {
                    return this.radius = a, this.theta = b, this.y = c, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(a) {
                    return this.radius = a.radius, this.theta = a.theta, this.y = a.y, this
                },
                setFromVector3: function(a) {
                    return this.radius = Math.sqrt(a.x * a.x + a.z * a.z), this.theta = Math.atan2(a.x, a.z), this.y = a.y, this
                }
            }), Ud.prototype = Object.create(ya.prototype), Ud.prototype.constructor = Ud, Ud.prototype.createAnimation = function(a, b, c, d) {
                b = {
                    start: b,
                    end: c,
                    length: c - b + 1,
                    fps: d,
                    duration: (c - b) / d,
                    lastFrame: 0,
                    currentFrame: 0,
                    active: !1,
                    time: 0,
                    direction: 1,
                    weight: 1,
                    directionBackwards: !1,
                    mirroredLoop: !1
                }, this.animationsMap[a] = b, this.animationsList.push(b)
            }, Ud.prototype.autoCreateAnimations = function(a) {
                for (var b, c = /([a-z]+)_?(\d+)/i, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
                    var h = e.morphTargets[f].name.match(c);
                    if (h && 1 < h.length) {
                        var i = h[1];
                        d[i] || (d[i] = {
                            start: 1 / 0,
                            end: -(1 / 0)
                        }), h = d[i], f < h.start && (h.start = f), f > h.end && (h.end = f), b || (b = i)
                    }
                }
                for (i in d) h = d[i], this.createAnimation(i, h.start, h.end, a);
                this.firstAnimation = b
            }, Ud.prototype.setAnimationDirectionForward = function(a) {
                (a = this.animationsMap[a]) && (a.direction = 1, a.directionBackwards = !1)
            }, Ud.prototype.setAnimationDirectionBackward = function(a) {
                (a = this.animationsMap[a]) && (a.direction = -1, a.directionBackwards = !0)
            }, Ud.prototype.setAnimationFPS = function(a, b) {
                var c = this.animationsMap[a];
                c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
            }, Ud.prototype.setAnimationDuration = function(a, b) {
                var c = this.animationsMap[a];
                c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
            }, Ud.prototype.setAnimationWeight = function(a, b) {
                var c = this.animationsMap[a];
                c && (c.weight = b)
            }, Ud.prototype.setAnimationTime = function(a, b) {
                var c = this.animationsMap[a];
                c && (c.time = b)
            }, Ud.prototype.getAnimationTime = function(a) {
                var b = 0;
                return (a = this.animationsMap[a]) && (b = a.time), b
            }, Ud.prototype.getAnimationDuration = function(a) {
                var b = -1;
                return (a = this.animationsMap[a]) && (b = a.duration), b
            }, Ud.prototype.playAnimation = function(a) {
                var b = this.animationsMap[a];
                b ? (b.time = 0, b.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
            }, Ud.prototype.stopAnimation = function(a) {
                (a = this.animationsMap[a]) && (a.active = !1)
            }, Ud.prototype.update = function(a) {
                for (var b = 0, c = this.animationsList.length; b < c; b++) {
                    var d = this.animationsList[b];
                    if (d.active) {
                        var e = d.duration / d.length;
                        d.time += d.direction * a, d.mirroredLoop ? (d.time > d.duration || 0 > d.time) && (d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1)) : (d.time %= d.duration, 0 > d.time && (d.time += d.duration));
                        var f = d.start + re.clamp(Math.floor(d.time / e), 0, d.length - 1),
                            g = d.weight;
                        f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f), e = d.time % e / e, d.directionBackwards && (e = 1 - e), d.currentFrame !== d.lastFrame ? (this.morphTargetInfluences[d.currentFrame] = e * g, this.morphTargetInfluences[d.lastFrame] = (1 - e) * g) : this.morphTargetInfluences[d.currentFrame] = g
                    }
                }
            }, Vd.prototype = Object.create(fa.prototype), Vd.prototype.constructor = Vd, Vd.prototype.isImmediateRenderObject = !0, Wd.prototype = Object.create(vb.prototype), Wd.prototype.constructor = Wd, Wd.prototype.update = function() {
                var a = new i,
                    b = new i,
                    c = new $;
                return function() {
                    var d = ["a", "b", "c"];
                    this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
                    var e = this.object.matrixWorld,
                        f = this.geometry.attributes.position,
                        g = this.object.geometry;
                    if (g && g.isGeometry)
                        for (var h = g.vertices, i = g.faces, j = g = 0, k = i.length; j < k; j++)
                            for (var l = i[j], m = 0, n = l.vertexNormals.length; m < n; m++) {
                                var o = l.vertexNormals[m];
                                a.copy(h[l[d[m]]]).applyMatrix4(e), b.copy(o).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1
                            } else if (g && g.isBufferGeometry)
                                for (d = g.attributes.position, h = g.attributes.normal, m = g = 0, n = d.count; m < n; m++) a.set(d.getX(m), d.getY(m), d.getZ(m)).applyMatrix4(e), b.set(h.getX(m), h.getY(m), h.getZ(m)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
                    f.needsUpdate = !0
                }
            }(), Xd.prototype = Object.create(fa.prototype), Xd.prototype.constructor = Xd, Xd.prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, Xd.prototype.update = function() {
                var a = new i,
                    b = new i;
                return function() {
                    var c = this.light.distance ? this.light.distance : 1e3,
                        d = c * Math.tan(this.light.angle);
                    this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(b.sub(a)), this.cone.material.color.copy(this.light.color)
                }
            }(), Yd.prototype = Object.create(vb.prototype), Yd.prototype.constructor = Yd, Yd.prototype.getBoneList = function(a) {
                var b = [];
                a && a.isBone && b.push(a);
                for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
                return b
            }, Yd.prototype.update = function() {
                var a = new i,
                    b = new j,
                    c = new j;
                return function() {
                    var d = this.geometry,
                        e = d.getAttribute("position");
                    c.getInverse(this.root.matrixWorld);
                    for (var f = 0, g = 0; f < this.bones.length; f++) {
                        var h = this.bones[f];
                        h.parent && h.parent.isBone && (b.multiplyMatrices(c, h.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g, a.x, a.y, a.z), b.multiplyMatrices(c, h.parent.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g + 1, a.x, a.y, a.z), g += 2)
                    }
                    d.getAttribute("position").needsUpdate = !0
                }
            }(), Zd.prototype = Object.create(ya.prototype), Zd.prototype.constructor = Zd, Zd.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, Zd.prototype.update = function() {
                this.material.color.copy(this.light.color)
            }, $d.prototype = Object.create(fa.prototype), $d.prototype.constructor = $d, $d.prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, $d.prototype.update = function() {
                var a = this.children[0];
                a.material.color.copy(this.light.color);
                var b = .5 * this.light.width,
                    c = .5 * this.light.height,
                    a = a.geometry.attributes.position,
                    d = a.array;
                d[0] = b, d[1] = -c, d[2] = 0, d[3] = b, d[4] = c, d[5] = 0, d[6] = -b, d[7] = c, d[8] = 0, d[9] = -b, d[10] = -c, d[11] = 0, d[12] = b, d[13] = -c, d[14] = 0, a.needsUpdate = !0
            }, _d.prototype = Object.create(fa.prototype), _d.prototype.constructor = _d, _d.prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, _d.prototype.update = function() {
                var a = new i,
                    b = new R,
                    c = new R;
                return function() {
                    var d = this.children[0],
                        e = d.geometry.getAttribute("color");
                    b.copy(this.light.color), c.copy(this.light.groundColor);
                    for (var f = 0, g = e.count; f < g; f++) {
                        var h = f < g / 2 ? b : c;
                        e.setXYZ(f, h.r, h.g, h.b)
                    }
                    d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()), e.needsUpdate = !0
                }
            }(), ae.prototype = Object.create(vb.prototype), ae.prototype.constructor = ae, be.prototype = Object.create(vb.prototype), be.prototype.constructor = be, ce.prototype = Object.create(vb.prototype), ce.prototype.constructor = ce, ce.prototype.update = function() {
                var a = new i,
                    b = new i,
                    c = new $;
                return function() {
                    this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
                    for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices, f = f.faces, h = 0, i = 0, j = f.length; i < j; i++) {
                        var k = f[i],
                            l = k.normal;
                        a.copy(g[k.a]).add(g[k.b]).add(g[k.c]).divideScalar(3).applyMatrix4(d), b.copy(l).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), e.setXYZ(h, a.x, a.y, a.z), h += 1, e.setXYZ(h, b.x, b.y, b.z), h += 1
                    }
                    e.needsUpdate = !0
                }
            }(), de.prototype = Object.create(fa.prototype), de.prototype.constructor = de, de.prototype.dispose = function() {
                var a = this.children[0],
                    b = this.children[1];
                a.geometry.dispose(), a.material.dispose(), b.geometry.dispose(), b.material.dispose()
            }, de.prototype.update = function() {
                var a = new i,
                    b = new i,
                    c = new i;
                return function() {
                    a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), c.subVectors(b, a);
                    var d = this.children[0],
                        e = this.children[1];
                    d.lookAt(c), d.material.color.copy(this.light.color), e.lookAt(c), e.scale.z = c.length()
                }
            }(), ee.prototype = Object.create(vb.prototype), ee.prototype.constructor = ee, ee.prototype.update = function() {
                function a(a, f, g, h) {
                    if (d.set(f, g, h).unproject(e), a = c[a], void 0 !== a)
                        for (f = b.getAttribute("position"), g = 0, h = a.length; g < h; g++) f.setXYZ(a[g], d.x, d.y, d.z)
                }
                var b, c, d = new i,
                    e = new Da;
                return function() {
                    b = this.geometry, c = this.pointMap, e.projectionMatrix.copy(this.camera.projectionMatrix), a("c", 0, 0, -1), a("t", 0, 0, 1), a("n1", -1, -1, -1), a("n2", 1, -1, -1), a("n3", -1, 1, -1), a("n4", 1, 1, -1), a("f1", -1, -1, 1), a("f2", 1, -1, 1), a("f3", -1, 1, 1), a("f4", 1, 1, 1), a("u1", .7, 1.1, -1), a("u2", -.7, 1.1, -1), a("u3", 0, 2, -1), a("cf1", -1, 0, 1), a("cf2", 1, 0, 1), a("cf3", 0, -1, 1), a("cf4", 0, 1, 1), a("cn1", -1, 0, -1), a("cn2", 1, 0, -1), a("cn3", 0, -1, -1), a("cn4", 0, 1, -1), b.getAttribute("position").needsUpdate = !0
                }
            }(), fe.prototype = Object.create(vb.prototype), fe.prototype.constructor = fe, fe.prototype.update = function() {
                var a = new Y;
                return function(b) {
                    if (void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && a.setFromObject(this.object), !a.isEmpty()) {
                        b = a.min;
                        var c = a.max,
                            d = this.geometry.attributes.position,
                            e = d.array;
                        e[0] = c.x, e[1] = c.y, e[2] = c.z, e[3] = b.x, e[4] = c.y, e[5] = c.z, e[6] = b.x, e[7] = b.y, e[8] = c.z, e[9] = c.x, e[10] = b.y, e[11] = c.z, e[12] = c.x, e[13] = c.y, e[14] = b.z, e[15] = b.x, e[16] = c.y, e[17] = b.z, e[18] = b.x, e[19] = b.y, e[20] = b.z, e[21] = c.x, e[22] = b.y, e[23] = b.z, d.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                }
            }(), fe.prototype.setFromObject = function(a) {
                return this.object = a, this.update(), this
            };
            var Xe, Ye;
            ge.prototype = Object.create(fa.prototype), ge.prototype.constructor = ge, ge.prototype.setDirection = function() {
                var a, b = new i;
                return function(c) {
                    .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a))
                }
            }(), ge.prototype.setLength = function(a, b, c) {
                void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, Math.max(0, a - b), 1), this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, this.cone.updateMatrix()
            }, ge.prototype.setColor = function(a) {
                this.line.material.color.copy(a), this.cone.material.color.copy(a)
            }, he.prototype = Object.create(vb.prototype), he.prototype.constructor = he;
            var Ze = new i,
                $e = new ie,
                _e = new ie,
                af = new ie;
            je.prototype = Object.create(id.prototype), je.prototype.constructor = je, je.prototype.getPoint = function(a) {
                var b = this.points,
                    c = b.length;
                2 > c && console.log("duh, you need at least 2 points"), a *= c - (this.closed ? 0 : 1);
                var d = Math.floor(a);
                a -= d, this.closed ? d += 0 < d ? 0 : (Math.floor(Math.abs(d) / b.length) + 1) * b.length : 0 === a && d === c - 1 && (d = c - 2, a = 1);
                var e, f, g;
                if (this.closed || 0 < d ? e = b[(d - 1) % c] : (Ze.subVectors(b[0], b[1]).add(b[0]), e = Ze), f = b[d % c], g = b[(d + 1) % c], this.closed || d + 2 < c ? b = b[(d + 2) % c] : (Ze.subVectors(b[c - 1], b[c - 2]).add(b[c - 1]), b = Ze), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                    var h = "chordal" === this.type ? .5 : .25,
                        c = Math.pow(e.distanceToSquared(f), h),
                        d = Math.pow(f.distanceToSquared(g), h),
                        h = Math.pow(g.distanceToSquared(b), h);
                    1e-4 > d && (d = 1), 1e-4 > c && (c = d), 1e-4 > h && (h = d), $e.initNonuniformCatmullRom(e.x, f.x, g.x, b.x, c, d, h), _e.initNonuniformCatmullRom(e.y, f.y, g.y, b.y, c, d, h), af.initNonuniformCatmullRom(e.z, f.z, g.z, b.z, c, d, h)
                } else "catmullrom" === this.type && (c = void 0 !== this.tension ? this.tension : .5, $e.initCatmullRom(e.x, f.x, g.x, b.x, c), _e.initCatmullRom(e.y, f.y, g.y, b.y, c), af.initCatmullRom(e.z, f.z, g.z, b.z, c));
                return new i($e.calc(a), _e.calc(a), af.calc(a))
            }, ke.prototype = Object.create(id.prototype), ke.prototype.constructor = ke, ke.prototype.getPoint = function(a) {
                var b = this.v0,
                    c = this.v1,
                    d = this.v2,
                    e = this.v3;
                return new i(hd(a, b.x, c.x, d.x, e.x), hd(a, b.y, c.y, d.y, e.y), hd(a, b.z, c.z, d.z, e.z))
            }, le.prototype = Object.create(id.prototype), le.prototype.constructor = le, le.prototype.getPoint = function(a) {
                var b = this.v0,
                    c = this.v1,
                    d = this.v2;
                return new i(gd(a, b.x, c.x, d.x), gd(a, b.y, c.y, d.y), gd(a, b.z, c.z, d.z))
            }, me.prototype = Object.create(id.prototype), me.prototype.constructor = me, me.prototype.getPoint = function(a) {
                if (1 === a) return this.v2.clone();
                var b = new i;
                return b.subVectors(this.v2, this.v1), b.multiplyScalar(a), b.add(this.v1), b
            }, ne.prototype = Object.create(ld.prototype), ne.prototype.constructor = ne, id.create = function(a, b) {
                return console.log("THREE.Curve.create() has been deprecated"), a.prototype = Object.create(id.prototype), a.prototype.constructor = a, a.prototype.getPoint = b, a
            }, oe.prototype = Object.create(je.prototype), pe.prototype = Object.create(je.prototype), qe.prototype = Object.create(je.prototype), Object.assign(qe.prototype, {
                initFromArray: function(a) {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function(a) {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function(a) {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), ae.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, Object.assign(S.prototype, {
                center: function(a) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(a)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(a) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
                },
                size: function(a) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(a)
                }
            }), Object.assign(Y.prototype, {
                center: function(a) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(a)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(a) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
                },
                isIntersectionSphere: function(a) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
                },
                size: function(a) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(a)
                }
            }), ga.prototype.center = function(a) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(a)
            }, re.random16 = function() {
                return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
            }, Object.assign($.prototype, {
                flattenToArrayOffset: function(a, b) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, b)
                },
                multiplyVector3: function(a) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), a.applyMatrix3(this)
                },
                multiplyVector3Array: function(a) {
                    return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
                },
                applyToBuffer: function(a, b, c) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(a)
                },
                applyToVector3Array: function(a, b, c) {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(j.prototype, {
                extractPosition: function(a) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(a)
                },
                flattenToArrayOffset: function(a, b) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, b)
                },
                getPosition: function() {
                    var a;
                    return function() {
                        return void 0 === a && (a = new i), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), a.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function(a) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(a)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(a) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
                },
                multiplyVector4: function(a) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
                },
                multiplyVector3Array: function(a) {
                    return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
                },
                rotateAxis: function(a) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), a.transformDirection(this)
                },
                crossVector: function(a) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(a, b, c) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(a)
                },
                applyToVector3Array: function(a, b, c) {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(a, b, c, d, e, f) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(a, b, d, c, e, f)
                }
            }), _.prototype.isIntersectionLine = function(a) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(a)
            }, h.prototype.multiplyVector3 = function(a) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), a.applyQuaternion(this)
            }, Object.assign(ca.prototype, {
                isIntersectionBox: function(a) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
                },
                isIntersectionPlane: function(a) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(a)
                },
                isIntersectionSphere: function(a) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
                }
            }), Object.assign(qd.prototype, {
                extrude: function(a) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Xb(this, a)
                },
                makeGeometry: function(a) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new fc(this, a)
                }
            }), Object.assign(c.prototype, {
                fromAttribute: function(a, b, c) {
                    return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, c)
                }
            }), Object.assign(i.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(a) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(a)
                },
                getScaleFromMatrix: function(a) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(a)
                },
                getColumnFromMatrix: function(a, b) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(b, a)
                },
                applyProjection: function(a) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(a)
                },
                fromAttribute: function(a, b, c) {
                    return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, c)
                }
            }), Object.assign(e.prototype, {
                fromAttribute: function(a, b, c) {
                    return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, c)
                }
            }), wa.prototype.computeTangents = function() {
                console.warn("THREE.Geometry: .computeTangents() has been removed.")
            }, Object.assign(fa.prototype, {
                getChildByName: function(a) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(a)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(a, b) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(b, a)
                }
            }), Object.defineProperties(fa.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(a) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(pb.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(qb.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Object.defineProperty(id.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(a) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = a
                }
            }), Ea.prototype.setLens = function(a, b) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== b && (this.filmGauge = b), this.setFocalLength(a)
            }, Object.defineProperties(Ec.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a
                    }
                },
                shadowCameraLeft: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a
                    }
                },
                shadowCameraRight: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a
                    }
                },
                shadowCameraTop: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a
                    }
                },
                shadowCameraBottom: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = a
                    }
                },
                shadowCameraNear: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a
                    }
                },
                shadowCameraFar: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a
                    }
                },
                shadowMapHeight: {
                    set: function(a) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a
                    }
                }
            }), Object.defineProperties(ka.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                }
            }), Object.assign(xa.prototype, {
                addIndex: function(a) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(a)
                },
                addDrawCall: function(a, b, c) {
                    void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, b)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(xa.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.defineProperties(Id.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(V.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new R
                    }
                }
            }), Object.defineProperties(sc.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(W.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(a) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = a
                    }
                }
            }), Object.assign(ib.prototype, {
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(a) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(a)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }
            }), Object.defineProperties(ib.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = a;
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        return this.shadowMap.cullFace
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = a
                    }
                }
            }), Object.defineProperties(ba.prototype, {
                cullFace: {
                    get: function() {
                        return this.renderReverseSided ? 2 : 1
                    },
                    set: function(a) {
                        a = 1 !== a, console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + "."), this.renderReverseSided = a
                    }
                }
            }), Object.defineProperties(f.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = a
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = a
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = a
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(a) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = a
                    }
                }
            }), zd.prototype.load = function(a) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var b = this;
                return (new ud).load(a, function(a) {
                    b.setBuffer(a)
                }), this
            }, Bd.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, a.WebGLRenderTargetCube = g, a.WebGLRenderTarget = f, a.WebGLRenderer = ib, a.ShaderLib = Ee, a.UniformsLib = Be, a.UniformsUtils = Ce, a.ShaderChunk = De, a.FogExp2 = jb, a.Fog = kb, a.Scene = lb, a.LensFlare = mb, a.Sprite = ob, a.LOD = pb, a.SkinnedMesh = sb, a.Skeleton = qb, a.Bone = rb, a.Mesh = ya, a.LineSegments = vb, a.LineLoop = wb, a.Line = ub, a.Points = yb, a.Group = zb, a.VideoTexture = Ab, a.DataTexture = k, a.CompressedTexture = Bb, a.CubeTexture = l, a.CanvasTexture = Cb, a.DepthTexture = Db, a.Texture = d, a.CompressedTextureLoader = zc, a.DataTextureLoader = Ac, a.CubeTextureLoader = Cc, a.TextureLoader = Dc, a.ObjectLoader = ed, a.MaterialLoader = ad, a.BufferGeometryLoader = bd, a.DefaultLoadingManager = Ne, a.LoadingManager = xc, a.JSONLoader = dd, a.ImageLoader = Bc, a.FontLoader = td, a.FileLoader = yc, a.Loader = cd, a.Cache = Me, a.AudioLoader = ud, a.SpotLightShadow = Hc, a.SpotLight = Ic, a.PointLight = Jc, a.RectAreaLight = Nc, a.HemisphereLight = Fc, a.DirectionalLightShadow = Kc, a.DirectionalLight = Lc, a.AmbientLight = Mc, a.LightShadow = Gc, a.Light = Ec, a.StereoCamera = vd, a.PerspectiveCamera = Ea, a.OrthographicCamera = Fa, a.CubeCamera = wd, a.ArrayCamera = xd, a.Camera = Da, a.AudioListener = yd, a.PositionalAudio = Ad, a.AudioContext = We, a.AudioAnalyser = Bd, a.Audio = zd, a.VectorKeyframeTrack = Tc, a.StringKeyframeTrack = Xc, a.QuaternionKeyframeTrack = Vc, a.NumberKeyframeTrack = Wc, a.ColorKeyframeTrack = Zc, a.BooleanKeyframeTrack = Yc, a.PropertyMixer = Cd, a.PropertyBinding = Ed, a.KeyframeTrack = $c, a.AnimationUtils = Oe, a.AnimationObjectGroup = Fd, a.AnimationMixer = Hd, a.AnimationClip = _c, a.Uniform = Id, a.InstancedBufferGeometry = Jd, a.BufferGeometry = xa, a.GeometryIdCount = function() {
                return He++
            }, a.Geometry = wa, a.InterleavedBufferAttribute = Kd, a.InstancedInterleavedBuffer = Md, a.InterleavedBuffer = Ld, a.InstancedBufferAttribute = Nd, a.Face3 = ia, a.Object3D = fa, a.Raycaster = Od, a.Layers = ea, a.EventDispatcher = b, a.Clock = Rd, a.QuaternionLinearInterpolant = Uc, a.LinearInterpolant = Qc, a.DiscreteInterpolant = Rc, a.CubicInterpolant = Pc, a.Interpolant = Oc, a.Triangle = ha, a.Math = re, a.Spherical = Sd, a.Cylindrical = Td, a.Plane = _, a.Frustum = aa, a.Sphere = Z, a.Ray = ca, a.Matrix4 = j, a.Matrix3 = $, a.Box3 = Y, a.Box2 = S, a.Line3 = ga, a.Euler = da, a.Vector4 = e, a.Vector3 = i, a.Vector2 = c, a.Quaternion = h, a.Color = R, a.MorphBlendMesh = Ud, a.ImmediateRenderObject = Vd, a.VertexNormalsHelper = Wd, a.SpotLightHelper = Xd, a.SkeletonHelper = Yd, a.PointLightHelper = Zd, a.RectAreaLightHelper = $d, a.HemisphereLightHelper = _d, a.GridHelper = ae, a.PolarGridHelper = be, a.FaceNormalsHelper = ce, a.DirectionalLightHelper = de, a.CameraHelper = ee, a.BoxHelper = fe, a.ArrowHelper = ge, a.AxisHelper = he, a.CatmullRomCurve3 = je, a.CubicBezierCurve3 = ke, a.QuadraticBezierCurve3 = le, a.LineCurve3 = me, a.ArcCurve = ne, a.EllipseCurve = ld, a.SplineCurve = md, a.CubicBezierCurve = nd, a.QuadraticBezierCurve = od, a.LineCurve = jd, a.Shape = qd, a.Path = pd;
            a.ShapePath = rd;
            a.Font = sd, a.CurvePath = kd, a.Curve = id, a.ShapeUtils = Je, a.SceneUtils = {
                createMultiMaterialObject: function(a, b) {
                    for (var c = new zb, d = 0, e = b.length; d < e; d++) c.add(new ya(a, b[d]));
                    return c
                },
                detach: function(a, b, c) {
                    a.applyMatrix(b.matrixWorld), b.remove(a), c.add(a)
                },
                attach: function(a, b, c) {
                    var d = new j;
                    d.getInverse(c.matrixWorld), a.applyMatrix(d), b.remove(a), c.add(a)
                }
            }, a.WireframeGeometry = Eb, a.ParametricGeometry = Fb, a.ParametricBufferGeometry = Gb, a.TetrahedronGeometry = Jb, a.TetrahedronBufferGeometry = Kb, a.OctahedronGeometry = Lb, a.OctahedronBufferGeometry = Mb, a.IcosahedronGeometry = Nb, a.IcosahedronBufferGeometry = Ob, a.DodecahedronGeometry = Pb, a.DodecahedronBufferGeometry = Qb, a.PolyhedronGeometry = Hb, a.PolyhedronBufferGeometry = Ib, a.TubeGeometry = Rb, a.TubeBufferGeometry = Sb, a.TorusKnotGeometry = Tb, a.TorusKnotBufferGeometry = Ub, a.TorusGeometry = Vb, a.TorusBufferGeometry = Wb, a.TextGeometry = Zb, a.TextBufferGeometry = $b, a.SphereGeometry = _b, a.SphereBufferGeometry = ac, a.RingGeometry = bc, a.RingBufferGeometry = cc, a.PlaneGeometry = Ba, a.PlaneBufferGeometry = Ca, a.LatheGeometry = dc, a.LatheBufferGeometry = ec, a.ShapeGeometry = fc, a.ShapeBufferGeometry = gc, a.ExtrudeGeometry = Xb, a.ExtrudeBufferGeometry = Yb, a.EdgesGeometry = hc, a.ConeGeometry = kc, a.ConeBufferGeometry = lc, a.CylinderGeometry = ic, a.CylinderBufferGeometry = jc, a.CircleGeometry = mc, a.CircleBufferGeometry = nc, a.BoxGeometry = za, a.BoxBufferGeometry = Aa, a.ShadowMaterial = oc, a.SpriteMaterial = nb, a.RawShaderMaterial = pc, a.ShaderMaterial = W, a.PointsMaterial = xb, a.MeshPhysicalMaterial = rc, a.MeshStandardMaterial = qc, a.MeshPhongMaterial = sc, a.MeshToonMaterial = tc, a.MeshNormalMaterial = uc, a.MeshLambertMaterial = vc, a.MeshDepthMaterial = X, a.MeshBasicMaterial = ja, a.LineDashedMaterial = wc, a.LineBasicMaterial = tb, a.Material = V, a.Float64BufferAttribute = ta, a.Float32BufferAttribute = sa, a.Uint32BufferAttribute = ra, a.Int32BufferAttribute = qa, a.Uint16BufferAttribute = pa, a.Int16BufferAttribute = oa, a.Uint8ClampedBufferAttribute = na, a.Uint8BufferAttribute = ma, a.Int8BufferAttribute = la, a.BufferAttribute = ka, a.REVISION = "85", a.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            }, a.CullFaceNone = 0, a.CullFaceBack = 1, a.CullFaceFront = 2, a.CullFaceFrontBack = 3, a.FrontFaceDirectionCW = 0, a.FrontFaceDirectionCCW = 1, a.BasicShadowMap = 0, a.PCFShadowMap = 1, a.PCFSoftShadowMap = 2, a.FrontSide = 0, a.BackSide = 1, a.DoubleSide = 2, a.FlatShading = 1, a.SmoothShading = 2, a.NoColors = 0, a.FaceColors = 1, a.VertexColors = 2, a.NoBlending = 0, a.NormalBlending = 1, a.AdditiveBlending = 2, a.SubtractiveBlending = 3, a.MultiplyBlending = 4, a.CustomBlending = 5, a.AddEquation = 100, a.SubtractEquation = 101, a.ReverseSubtractEquation = 102, a.MinEquation = 103, a.MaxEquation = 104, a.ZeroFactor = 200, a.OneFactor = 201, a.SrcColorFactor = 202, a.OneMinusSrcColorFactor = 203, a.SrcAlphaFactor = 204, a.OneMinusSrcAlphaFactor = 205, a.DstAlphaFactor = 206, a.OneMinusDstAlphaFactor = 207, a.DstColorFactor = 208, a.OneMinusDstColorFactor = 209, a.SrcAlphaSaturateFactor = 210, a.NeverDepth = 0, a.AlwaysDepth = 1, a.LessDepth = 2, a.LessEqualDepth = 3, a.EqualDepth = 4, a.GreaterEqualDepth = 5, a.GreaterDepth = 6, a.NotEqualDepth = 7, a.MultiplyOperation = 0, a.MixOperation = 1, a.AddOperation = 2, a.NoToneMapping = 0, a.LinearToneMapping = 1, a.ReinhardToneMapping = 2, a.Uncharted2ToneMapping = 3, a.CineonToneMapping = 4, a.UVMapping = 300, a.CubeReflectionMapping = 301, a.CubeRefractionMapping = 302, a.EquirectangularReflectionMapping = 303, a.EquirectangularRefractionMapping = 304, a.SphericalReflectionMapping = 305, a.CubeUVReflectionMapping = 306, a.CubeUVRefractionMapping = 307, a.RepeatWrapping = 1e3, a.ClampToEdgeWrapping = 1001, a.MirroredRepeatWrapping = 1002, a.NearestFilter = 1003, a.NearestMipMapNearestFilter = 1004, a.NearestMipMapLinearFilter = 1005, a.LinearFilter = 1006, a.LinearMipMapNearestFilter = 1007, a.LinearMipMapLinearFilter = 1008, a.UnsignedByteType = 1009, a.ByteType = 1010, a.ShortType = 1011, a.UnsignedShortType = 1012, a.IntType = 1013, a.UnsignedIntType = 1014, a.FloatType = 1015, a.HalfFloatType = 1016, a.UnsignedShort4444Type = 1017, a.UnsignedShort5551Type = 1018, a.UnsignedShort565Type = 1019, a.UnsignedInt248Type = 1020, a.AlphaFormat = 1021, a.RGBFormat = 1022, a.RGBAFormat = 1023, a.LuminanceFormat = 1024, a.LuminanceAlphaFormat = 1025, a.RGBEFormat = 1023, a.DepthFormat = 1026, a.DepthStencilFormat = 1027, a.RGB_S3TC_DXT1_Format = 2001, a.RGBA_S3TC_DXT1_Format = 2002, a.RGBA_S3TC_DXT3_Format = 2003, a.RGBA_S3TC_DXT5_Format = 2004, a.RGB_PVRTC_4BPPV1_Format = 2100, a.RGB_PVRTC_2BPPV1_Format = 2101, a.RGBA_PVRTC_4BPPV1_Format = 2102, a.RGBA_PVRTC_2BPPV1_Format = 2103, a.RGB_ETC1_Format = 2151, a.LoopOnce = 2200, a.LoopRepeat = 2201, a.LoopPingPong = 2202, a.InterpolateDiscrete = 2300, a.InterpolateLinear = 2301, a.InterpolateSmooth = 2302, a.ZeroCurvatureEnding = 2400, a.ZeroSlopeEnding = 2401, a.WrapAroundEnding = 2402, a.TrianglesDrawMode = 0, a.TriangleStripDrawMode = 1, a.TriangleFanDrawMode = 2, a.LinearEncoding = 3e3, a.sRGBEncoding = 3001, a.GammaEncoding = 3007, a.RGBEEncoding = 3002, a.LogLuvEncoding = 3003, a.RGBM7Encoding = 3004, a.RGBM16Encoding = 3005, a.RGBDEncoding = 3006, a.BasicDepthPacking = 3200, a.RGBADepthPacking = 3201, a.CubeGeometry = za, a.Face4 = function(a, b, c, d, e, f, g) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ia(a, b, c, e, f, g)
            };
            a.LineStrip = 0;
            a.LinePieces = 1, a.MeshFaceMaterial = function(a) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), a
            }, a.MultiMaterial = function(a) {
                return void 0 === a && (a = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), a.isMultiMaterial = !0, a.materials = a, a.clone = function() {
                    return a.slice()
                }, a
            }, a.PointCloud = function(a, b) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new yb(a, b)
            }, a.Particle = function(a) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new ob(a)
            }, a.ParticleSystem = function(a, b) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new yb(a, b)
            }, a.PointCloudMaterial = function(a) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new xb(a)
            }, a.ParticleBasicMaterial = function(a) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new xb(a)
            }, a.ParticleSystemMaterial = function(a) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new xb(a)
            }, a.Vertex = function(a, b, c) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new i(a, b, c)
            }, a.DynamicBufferAttribute = function(a, b) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ka(a, b).setDynamic(!0)
            }, a.Int8Attribute = function(a, b) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new la(a, b)
            }, a.Uint8Attribute = function(a, b) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ma(a, b)
            }, a.Uint8ClampedAttribute = function(a, b) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new na(a, b)
            }, a.Int16Attribute = function(a, b) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new oa(a, b)
            }, a.Uint16Attribute = function(a, b) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new pa(a, b)
            }, a.Int32Attribute = function(a, b) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new qa(a, b)
            }, a.Uint32Attribute = function(a, b) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new ra(a, b)
            }, a.Float32Attribute = function(a, b) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new sa(a, b)
            }, a.Float64Attribute = function(a, b) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ta(a, b)
            }, a.ClosedSplineCurve3 = oe, a.SplineCurve3 = pe, a.Spline = qe, a.BoundingBoxHelper = function(a, b) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new fe(a, b)
            }, a.EdgesHelper = function(a, b) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new vb(new hc(a.geometry), new tb({
                    color: void 0 !== b ? b : 16777215
                }))
            }, a.WireframeHelper = function(a, b) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new vb(new Eb(a.geometry), new tb({
                    color: void 0 !== b ? b : 16777215
                }))
            }, a.XHRLoader = function(a) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new yc(a)
            }, a.BinaryTextureLoader = function(a) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ac(a)
            }, a.GeometryUtils = {
                merge: function(a, b, c) {
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var d;
                    b.isMesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry), a.merge(b, d, c)
                },
                center: function(a) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), a.center()
                }
            }, a.ImageUtils = {
                crossOrigin: void 0,
                loadTexture: function(a, b, c, d) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    var e = new Dc;
                    return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), a
                },
                loadTextureCube: function(a, b, c, d) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    var e = new Cc;
                    return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), a
                },
                loadCompressedTexture: function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                },
                loadCompressedTextureCube: function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }
            }, a.Projector = function() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(a, b) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b)
                }, this.unprojectVector = function(a, b) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), a.unproject(b)
                }, this.pickingRay = function() {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }, a.CanvasRenderer = function() {
                console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
            }, Object.defineProperty(a, "__esModule", {
                value: !0
            })
        }), ! function(a, b) {
            "object" == typeof exports && "object" == typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define([], b) : "object" == typeof exports ? exports.io = b() : a.io = b()
        }(this, function() {
            return function(a) {
                function b(d) {
                    if (c[d]) return c[d].exports;
                    var e = c[d] = {
                        exports: {},
                        id: d,
                        loaded: !1
                    };
                    return a[d].call(e.exports, e, e.exports, b), e.loaded = !0, e.exports
                }
                var c = {};
                return b.m = a, b.c = c, b.p = "", b(0)
            }([function(a, b, c) {
                "use strict";

                function d(a, b) {
                    "object" === ("undefined" == typeof a ? "undefined" : e(a)) && (b = a, a = void 0), b = b || {};
                    var c, d = f(a),
                        g = d.source,
                        j = d.id,
                        k = d.path,
                        l = i[j] && k in i[j].nsps,
                        m = b.forceNew || b["force new connection"] || !1 === b.multiplex || l;
                    return m ? c = h(g, b) : (i[j] || (i[j] = h(g, b)), c = i[j]), d.query && !b.query && (b.query = d.query), c.socket(d.path, b)
                }
                var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
                        return typeof a
                    } : function(a) {
                        return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
                    },
                    f = c(1),
                    g = c(4),
                    h = c(10);
                c(3)("socket.io-client"), a.exports = b = d;
                var i = b.managers = {};
                b.protocol = g.protocol, b.connect = d, b.Manager = c(10), b.Socket = c(36)
            }, function(a, b, c) {
                (function(b) {
                    "use strict";

                    function d(a, c) {
                        var d = a;
                        c = c || b.location, null == a && (a = c.protocol + "//" + c.host), "string" == typeof a && ("/" === a.charAt(0) && (a = "/" === a.charAt(1) ? c.protocol + a : c.host + a), /^(https?|wss?):\/\//.test(a) || (a = "undefined" != typeof c ? c.protocol + "//" + a : "https://" + a), d = e(a)), d.port || (/^(http|ws)$/.test(d.protocol) ? d.port = "80" : /^(http|ws)s$/.test(d.protocol) && (d.port = "443")), d.path = d.path || "/";
                        var f = d.host.indexOf(":") !== -1,
                            g = f ? "[" + d.host + "]" : d.host;
                        return d.id = d.protocol + "://" + g + ":" + d.port, d.href = d.protocol + "://" + g + (c && c.port === d.port ? "" : ":" + d.port), d
                    }
                    var e = c(2);
                    c(3)("socket.io-client:url"), a.exports = d
                }).call(b, function() {
                    return this
                }())
            }, function(a, b) {
                var c = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
                    d = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
                a.exports = function(a) {
                    var b = a,
                        e = a.indexOf("["),
                        f = a.indexOf("]");
                    e != -1 && f != -1 && (a = a.substring(0, e) + a.substring(e, f).replace(/:/g, ";") + a.substring(f, a.length));
                    for (var g = c.exec(a || ""), h = {}, i = 14; i--;) h[d[i]] = g[i] || "";
                    return e != -1 && f != -1 && (h.source = b, h.host = h.host.substring(1, h.host.length - 1).replace(/;/g, ":"), h.authority = h.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), h.ipv6uri = !0), h
                }
            }, function(a, b) {
                "use strict";
                a.exports = function() {
                    return function() {}
                }
            }, function(a, b, c) {
                function d() {}

                function e(a) {
                    var c = "" + a.type;
                    return b.BINARY_EVENT !== a.type && b.BINARY_ACK !== a.type || (c += a.attachments + "-"), a.nsp && "/" !== a.nsp && (c += a.nsp + ","), null != a.id && (c += a.id), null != a.data && (c += JSON.stringify(a.data)), c
                }

                function f(a, b) {
                    function c(a) {
                        var c = n.deconstructPacket(a),
                            d = e(c.packet),
                            f = c.buffers;
                        f.unshift(d), b(f)
                    }
                    n.removeBlobs(a, c)
                }

                function g() {
                    this.reconstructor = null
                }

                function h(a) {
                    var c = 0,
                        d = {
                            type: Number(a.charAt(0))
                        };
                    if (null == b.types[d.type]) return k();
                    if (b.BINARY_EVENT === d.type || b.BINARY_ACK === d.type) {
                        for (var e = "";
                            "-" !== a.charAt(++c) && (e += a.charAt(c), c != a.length););
                        if (e != Number(e) || "-" !== a.charAt(c)) throw new Error("Illegal attachments");
                        d.attachments = Number(e)
                    }
                    if ("/" === a.charAt(c + 1))
                        for (d.nsp = ""; ++c;) {
                            var f = a.charAt(c);
                            if ("," === f) break;
                            if (d.nsp += f, c === a.length) break
                        } else d.nsp = "/";
                    var g = a.charAt(c + 1);
                    if ("" !== g && Number(g) == g) {
                        for (d.id = ""; ++c;) {
                            var f = a.charAt(c);
                            if (null == f || Number(f) != f) {
                                --c;
                                break
                            }
                            if (d.id += a.charAt(c), c === a.length) break
                        }
                        d.id = Number(d.id)
                    }
                    return a.charAt(++c) && (d = i(d, a.substr(c))), d
                }

                function i(a, b) {
                    try {
                        a.data = JSON.parse(b)
                    } catch (a) {
                        return k()
                    }
                    return a
                }

                function j(a) {
                    this.reconPack = a, this.buffers = []
                }

                function k() {
                    return {
                        type: b.ERROR,
                        data: "parser error"
                    }
                }
                var l = (c(3)("socket.io-parser"), c(5)),
                    m = c(6),
                    n = c(8),
                    o = c(9);
                b.protocol = 4, b.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], b.CONNECT = 0, b.DISCONNECT = 1, b.EVENT = 2, b.ACK = 3, b.ERROR = 4, b.BINARY_EVENT = 5, b.BINARY_ACK = 6, b.Encoder = d, b.Decoder = g, d.prototype.encode = function(a, c) {
                    if (a.type !== b.EVENT && a.type !== b.ACK || !m(a.data) || (a.type = a.type === b.EVENT ? b.BINARY_EVENT : b.BINARY_ACK), b.BINARY_EVENT === a.type || b.BINARY_ACK === a.type) f(a, c);
                    else {
                        var d = e(a);
                        c([d])
                    }
                }, l(g.prototype), g.prototype.add = function(a) {
                    var c;
                    if ("string" == typeof a) c = h(a), b.BINARY_EVENT === c.type || b.BINARY_ACK === c.type ? (this.reconstructor = new j(c), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", c)) : this.emit("decoded", c);
                    else {
                        if (!o(a) && !a.base64) throw new Error("Unknown type: " + a);
                        if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
                        c = this.reconstructor.takeBinaryData(a), c && (this.reconstructor = null, this.emit("decoded", c))
                    }
                }, g.prototype.destroy = function() {
                    this.reconstructor && this.reconstructor.finishedReconstruction()
                }, j.prototype.takeBinaryData = function(a) {
                    if (this.buffers.push(a), this.buffers.length === this.reconPack.attachments) {
                        var b = n.reconstructPacket(this.reconPack, this.buffers);
                        return this.finishedReconstruction(), b
                    }
                    return null
                }, j.prototype.finishedReconstruction = function() {
                    this.reconPack = null, this.buffers = []
                }
            }, function(a, b, c) {
                function d(a) {
                    if (a) return e(a)
                }

                function e(a) {
                    for (var b in d.prototype) a[b] = d.prototype[b];
                    return a
                }
                a.exports = d, d.prototype.on = d.prototype.addEventListener = function(a, b) {
                    return this._callbacks = this._callbacks || {}, (this._callbacks["$" + a] = this._callbacks["$" + a] || []).push(b), this
                }, d.prototype.once = function(a, b) {
                    function c() {
                        this.off(a, c), b.apply(this, arguments)
                    }
                    return c.fn = b, this.on(a, c), this
                }, d.prototype.off = d.prototype.removeListener = d.prototype.removeAllListeners = d.prototype.removeEventListener = function(a, b) {
                    if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
                    var c = this._callbacks["$" + a];
                    if (!c) return this;
                    if (1 == arguments.length) return delete this._callbacks["$" + a], this;
                    for (var d, e = 0; e < c.length; e++)
                        if (d = c[e], d === b || d.fn === b) {
                            c.splice(e, 1);
                            break
                        }
                    return this
                }, d.prototype.emit = function(a) {
                    this._callbacks = this._callbacks || {};
                    var b = [].slice.call(arguments, 1),
                        c = this._callbacks["$" + a];
                    if (c) {
                        c = c.slice(0);
                        for (var d = 0, e = c.length; d < e; ++d) c[d].apply(this, b)
                    }
                    return this
                }, d.prototype.listeners = function(a) {
                    return this._callbacks = this._callbacks || {}, this._callbacks["$" + a] || []
                }, d.prototype.hasListeners = function(a) {
                    return !!this.listeners(a).length
                }
            }, function(a, b, c) {
                (function(b) {
                    function d(a) {
                        if (!a || "object" != typeof a) return !1;
                        if (e(a)) {
                            for (var c = 0, f = a.length; c < f; c++)
                                if (d(a[c])) return !0;
                            return !1
                        }
                        if ("function" == typeof b.Buffer && b.Buffer.isBuffer && b.Buffer.isBuffer(a) || "function" == typeof b.ArrayBuffer && a instanceof ArrayBuffer || g && a instanceof Blob || h && a instanceof File) return !0;
                        if (a.toJSON && "function" == typeof a.toJSON && 1 === arguments.length) return d(a.toJSON(), !0);
                        for (var i in a)
                            if (Object.prototype.hasOwnProperty.call(a, i) && d(a[i])) return !0;
                        return !1
                    }
                    var e = c(7),
                        f = Object.prototype.toString,
                        g = "function" == typeof b.Blob || "[object BlobConstructor]" === f.call(b.Blob),
                        h = "function" == typeof b.File || "[object FileConstructor]" === f.call(b.File);
                    a.exports = d
                }).call(b, function() {
                    return this
                }())
            }, function(a, b) {
                var c = {}.toString;
                a.exports = Array.isArray || function(a) {
                    return "[object Array]" == c.call(a)
                }
            }, function(a, b, c) {
                (function(a) {
                    function d(a, b) {
                        if (!a) return a;
                        if (g(a)) {
                            var c = {
                                _placeholder: !0,
                                num: b.length
                            };
                            return b.push(a), c
                        }
                        if (f(a)) {
                            for (var e = new Array(a.length), h = 0; h < a.length; h++) e[h] = d(a[h], b);
                            return e
                        }
                        if ("object" == typeof a && !(a instanceof Date)) {
                            var e = {};
                            for (var i in a) e[i] = d(a[i], b);
                            return e
                        }
                        return a
                    }

                    function e(a, b) {
                        if (!a) return a;
                        if (a && a._placeholder) return b[a.num];
                        if (f(a))
                            for (var c = 0; c < a.length; c++) a[c] = e(a[c], b);
                        else if ("object" == typeof a)
                            for (var d in a) a[d] = e(a[d], b);
                        return a
                    }
                    var f = c(7),
                        g = c(9),
                        h = Object.prototype.toString,
                        i = "function" == typeof a.Blob || "[object BlobConstructor]" === h.call(a.Blob),
                        j = "function" == typeof a.File || "[object FileConstructor]" === h.call(a.File);
                    b.deconstructPacket = function(a) {
                        var b = [],
                            c = a.data,
                            e = a;
                        return e.data = d(c, b), e.attachments = b.length, {
                            packet: e,
                            buffers: b
                        }
                    }, b.reconstructPacket = function(a, b) {
                        return a.data = e(a.data, b), a.attachments = void 0, a
                    }, b.removeBlobs = function(a, b) {
                        function c(a, h, k) {
                            if (!a) return a;
                            if (i && a instanceof Blob || j && a instanceof File) {
                                d++;
                                var l = new FileReader;
                                l.onload = function() {
                                    k ? k[h] = this.result : e = this.result, --d || b(e)
                                }, l.readAsArrayBuffer(a)
                            } else if (f(a))
                                for (var m = 0; m < a.length; m++) c(a[m], m, a);
                            else if ("object" == typeof a && !g(a))
                                for (var n in a) c(a[n], n, a)
                        }
                        var d = 0,
                            e = a;
                        c(e), d || b(e)
                    }
                }).call(b, function() {
                    return this
                }())
            }, function(a, b) {
                (function(b) {
                    function c(a) {
                        return b.Buffer && b.Buffer.isBuffer(a) || b.ArrayBuffer && a instanceof ArrayBuffer
                    }
                    a.exports = c
                }).call(b, function() {
                    return this
                }())
            }, function(a, b, c) {
                "use strict";

                function d(a, b) {
                    if (!(this instanceof d)) return new d(a, b);
                    a && "object" === ("undefined" == typeof a ? "undefined" : e(a)) && (b = a, a = void 0), b = b || {}, b.path = b.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = b, this.reconnection(b.reconnection !== !1), this.reconnectionAttempts(b.reconnectionAttempts || 1 / 0), this.reconnectionDelay(b.reconnectionDelay || 1e3), this.reconnectionDelayMax(b.reconnectionDelayMax || 5e3), this.randomizationFactor(b.randomizationFactor || .5), this.backoff = new m({
                        min: this.reconnectionDelay(),
                        max: this.reconnectionDelayMax(),
                        jitter: this.randomizationFactor()
                    }), this.timeout(null == b.timeout ? 2e4 : b.timeout), this.readyState = "closed", this.uri = a, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = [];
                    var c = b.parser || i;
                    this.encoder = new c.Encoder, this.decoder = new c.Decoder, this.autoConnect = b.autoConnect !== !1, this.autoConnect && this.open()
                }
                var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
                        return typeof a
                    } : function(a) {
                        return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
                    },
                    f = c(11),
                    g = c(36),
                    h = c(5),
                    i = c(4),
                    j = c(38),
                    k = c(39),
                    l = (c(3)("socket.io-client:manager"), c(34)),
                    m = c(40),
                    n = Object.prototype.hasOwnProperty;
                a.exports = d, d.prototype.emitAll = function() {
                    this.emit.apply(this, arguments);
                    for (var a in this.nsps) n.call(this.nsps, a) && this.nsps[a].emit.apply(this.nsps[a], arguments)
                }, d.prototype.updateSocketIds = function() {
                    for (var a in this.nsps) n.call(this.nsps, a) && (this.nsps[a].id = this.generateId(a))
                }, d.prototype.generateId = function(a) {
                    return ("/" === a ? "" : a + "#") + this.engine.id
                }, h(d.prototype), d.prototype.reconnection = function(a) {
                    return arguments.length ? (this._reconnection = !!a, this) : this._reconnection
                }, d.prototype.reconnectionAttempts = function(a) {
                    return arguments.length ? (this._reconnectionAttempts = a, this) : this._reconnectionAttempts
                }, d.prototype.reconnectionDelay = function(a) {
                    return arguments.length ? (this._reconnectionDelay = a, this.backoff && this.backoff.setMin(a), this) : this._reconnectionDelay
                }, d.prototype.randomizationFactor = function(a) {
                    return arguments.length ? (this._randomizationFactor = a, this.backoff && this.backoff.setJitter(a), this) : this._randomizationFactor
                }, d.prototype.reconnectionDelayMax = function(a) {
                    return arguments.length ? (this._reconnectionDelayMax = a, this.backoff && this.backoff.setMax(a), this) : this._reconnectionDelayMax
                }, d.prototype.timeout = function(a) {
                    return arguments.length ? (this._timeout = a, this) : this._timeout
                }, d.prototype.maybeReconnectOnOpen = function() {
                    !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
                }, d.prototype.open = d.prototype.connect = function(a, b) {
                    if (~this.readyState.indexOf("open")) return this;
                    this.engine = f(this.uri, this.opts);
                    var c = this.engine,
                        d = this;
                    this.readyState = "opening", this.skipReconnect = !1;
                    var e = j(c, "open", function() {
                            d.onopen(), a && a()
                        }),
                        g = j(c, "error", function(b) {
                            if (d.cleanup(), d.readyState = "closed", d.emitAll("connect_error", b), a) {
                                var c = new Error("Connection error");
                                c.data = b, a(c)
                            } else d.maybeReconnectOnOpen()
                        });
                    if (!1 !== this._timeout) {
                        var h = this._timeout,
                            i = setTimeout(function() {
                                e.destroy(), c.close(), c.emit("error", "timeout"), d.emitAll("connect_timeout", h)
                            }, h);
                        this.subs.push({
                            destroy: function() {
                                clearTimeout(i)
                            }
                        })
                    }
                    return this.subs.push(e), this.subs.push(g), this
                }, d.prototype.onopen = function() {
                    this.cleanup(), this.readyState = "open", this.emit("open");
                    var a = this.engine;
                    this.subs.push(j(a, "data", k(this, "ondata"))), this.subs.push(j(a, "ping", k(this, "onping"))), this.subs.push(j(a, "pong", k(this, "onpong"))), this.subs.push(j(a, "error", k(this, "onerror"))), this.subs.push(j(a, "close", k(this, "onclose"))), this.subs.push(j(this.decoder, "decoded", k(this, "ondecoded")))
                }, d.prototype.onping = function() {
                    this.lastPing = new Date, this.emitAll("ping")
                }, d.prototype.onpong = function() {
                    this.emitAll("pong", new Date - this.lastPing)
                }, d.prototype.ondata = function(a) {
                    this.decoder.add(a)
                }, d.prototype.ondecoded = function(a) {
                    this.emit("packet", a)
                }, d.prototype.onerror = function(a) {
                    this.emitAll("error", a)
                }, d.prototype.socket = function(a, b) {
                    function c() {
                        ~l(e.connecting, d) || e.connecting.push(d)
                    }
                    var d = this.nsps[a];
                    if (!d) {
                        d = new g(this, a, b), this.nsps[a] = d;
                        var e = this;
                        d.on("connecting", c), d.on("connect", function() {
                            d.id = e.generateId(a)
                        }), this.autoConnect && c()
                    }
                    return d
                }, d.prototype.destroy = function(a) {
                    var b = l(this.connecting, a);
                    ~b && this.connecting.splice(b, 1), this.connecting.length || this.close()
                }, d.prototype.packet = function(a) {
                    var b = this;
                    a.query && 0 === a.type && (a.nsp += "?" + a.query), b.encoding ? b.packetBuffer.push(a) : (b.encoding = !0, this.encoder.encode(a, function(c) {
                        for (var d = 0; d < c.length; d++) b.engine.write(c[d], a.options);
                        b.encoding = !1, b.processPacketQueue()
                    }))
                }, d.prototype.processPacketQueue = function() {
                    if (this.packetBuffer.length > 0 && !this.encoding) {
                        var a = this.packetBuffer.shift();
                        this.packet(a)
                    }
                }, d.prototype.cleanup = function() {
                    for (var a = this.subs.length, b = 0; b < a; b++) {
                        var c = this.subs.shift();
                        c.destroy()
                    }
                    this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy()
                }, d.prototype.close = d.prototype.disconnect = function() {
                    this.skipReconnect = !0, this.reconnecting = !1, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close()
                }, d.prototype.onclose = function(a) {
                    this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", a), this._reconnection && !this.skipReconnect && this.reconnect()
                }, d.prototype.reconnect = function() {
                    if (this.reconnecting || this.skipReconnect) return this;
                    var a = this;
                    if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;
                    else {
                        var b = this.backoff.duration();
                        this.reconnecting = !0;
                        var c = setTimeout(function() {
                            a.skipReconnect || (a.emitAll("reconnect_attempt", a.backoff.attempts), a.emitAll("reconnecting", a.backoff.attempts), a.skipReconnect || a.open(function(b) {
                                b ? (a.reconnecting = !1, a.reconnect(), a.emitAll("reconnect_error", b.data)) : a.onreconnect()
                            }))
                        }, b);
                        this.subs.push({
                            destroy: function() {
                                clearTimeout(c)
                            }
                        })
                    }
                }, d.prototype.onreconnect = function() {
                    var a = this.backoff.attempts;
                    this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", a)
                }
            }, function(a, b, c) {
                a.exports = c(12)
            }, function(a, b, c) {
                a.exports = c(13), a.exports.parser = c(20)
            }, function(a, b, c) {
                (function(b) {
                    function d(a, c) {
                        if (!(this instanceof d)) return new d(a, c);
                        c = c || {}, a && "object" == typeof a && (c = a, a = null), a ? (a = j(a), c.hostname = a.host, c.secure = "https" === a.protocol || "wss" === a.protocol, c.port = a.port, a.query && (c.query = a.query)) : c.host && (c.hostname = j(c.host).host),
                            this.secure = null != c.secure ? c.secure : b.location && "https:" === location.protocol, c.hostname && !c.port && (c.port = this.secure ? "443" : "80"), this.agent = c.agent || !1, this.hostname = c.hostname || (b.location ? location.hostname : "localhost"), this.port = c.port || (b.location && location.port ? location.port : this.secure ? 443 : 80), this.query = c.query || {}, "string" == typeof this.query && (this.query = l.decode(this.query)), this.upgrade = !1 !== c.upgrade, this.path = (c.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!c.forceJSONP, this.jsonp = !1 !== c.jsonp, this.forceBase64 = !!c.forceBase64, this.enablesXDR = !!c.enablesXDR, this.timestampParam = c.timestampParam || "t", this.timestampRequests = c.timestampRequests, this.transports = c.transports || ["polling", "websocket"], this.transportOptions = c.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = c.policyPort || 843, this.rememberUpgrade = c.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = c.onlyBinaryUpgrades, this.perMessageDeflate = !1 !== c.perMessageDeflate && (c.perMessageDeflate || {}), !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = c.pfx || null, this.key = c.key || null, this.passphrase = c.passphrase || null, this.cert = c.cert || null, this.ca = c.ca || null, this.ciphers = c.ciphers || null, this.rejectUnauthorized = void 0 === c.rejectUnauthorized || c.rejectUnauthorized, this.forceNode = !!c.forceNode;
                        var e = "object" == typeof b && b;
                        e.global === e && (c.extraHeaders && Object.keys(c.extraHeaders).length > 0 && (this.extraHeaders = c.extraHeaders), c.localAddress && (this.localAddress = c.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open()
                    }

                    function e(a) {
                        var b = {};
                        for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
                        return b
                    }
                    var f = c(14),
                        g = c(5),
                        h = (c(3)("engine.io-client:socket"), c(34)),
                        i = c(20),
                        j = c(2),
                        k = c(35),
                        l = c(28);
                    a.exports = d, d.priorWebsocketSuccess = !1, g(d.prototype), d.protocol = i.protocol, d.Socket = d, d.Transport = c(19), d.transports = c(14), d.parser = c(20), d.prototype.createTransport = function(a) {
                        var b = e(this.query);
                        b.EIO = i.protocol, b.transport = a;
                        var c = this.transportOptions[a] || {};
                        this.id && (b.sid = this.id);
                        var d = new f[a]({
                            query: b,
                            socket: this,
                            agent: c.agent || this.agent,
                            hostname: c.hostname || this.hostname,
                            port: c.port || this.port,
                            secure: c.secure || this.secure,
                            path: c.path || this.path,
                            forceJSONP: c.forceJSONP || this.forceJSONP,
                            jsonp: c.jsonp || this.jsonp,
                            forceBase64: c.forceBase64 || this.forceBase64,
                            enablesXDR: c.enablesXDR || this.enablesXDR,
                            timestampRequests: c.timestampRequests || this.timestampRequests,
                            timestampParam: c.timestampParam || this.timestampParam,
                            policyPort: c.policyPort || this.policyPort,
                            pfx: c.pfx || this.pfx,
                            key: c.key || this.key,
                            passphrase: c.passphrase || this.passphrase,
                            cert: c.cert || this.cert,
                            ca: c.ca || this.ca,
                            ciphers: c.ciphers || this.ciphers,
                            rejectUnauthorized: c.rejectUnauthorized || this.rejectUnauthorized,
                            perMessageDeflate: c.perMessageDeflate || this.perMessageDeflate,
                            extraHeaders: c.extraHeaders || this.extraHeaders,
                            forceNode: c.forceNode || this.forceNode,
                            localAddress: c.localAddress || this.localAddress,
                            requestTimeout: c.requestTimeout || this.requestTimeout,
                            protocols: c.protocols || void 0
                        });
                        return d
                    }, d.prototype.open = function() {
                        var a;
                        if (this.rememberUpgrade && d.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) a = "websocket";
                        else {
                            if (0 === this.transports.length) {
                                var b = this;
                                return void setTimeout(function() {
                                    b.emit("error", "No transports available")
                                }, 0)
                            }
                            a = this.transports[0]
                        }
                        this.readyState = "opening";
                        try {
                            a = this.createTransport(a)
                        } catch (a) {
                            return this.transports.shift(), void this.open()
                        }
                        a.open(), this.setTransport(a)
                    }, d.prototype.setTransport = function(a) {
                        var b = this;
                        this.transport && this.transport.removeAllListeners(), this.transport = a, a.on("drain", function() {
                            b.onDrain()
                        }).on("packet", function(a) {
                            b.onPacket(a)
                        }).on("error", function(a) {
                            b.onError(a)
                        }).on("close", function() {
                            b.onClose("transport close")
                        })
                    }, d.prototype.probe = function(a) {
                        function b() {
                            if (l.onlyBinaryUpgrades) {
                                var a = !this.supportsBinary && l.transport.supportsBinary;
                                k = k || a
                            }
                            k || (j.send([{
                                type: "ping",
                                data: "probe"
                            }]), j.once("packet", function(a) {
                                if (!k)
                                    if ("pong" === a.type && "probe" === a.data) {
                                        if (l.upgrading = !0, l.emit("upgrading", j), !j) return;
                                        d.priorWebsocketSuccess = "websocket" === j.name, l.transport.pause(function() {
                                            k || "closed" !== l.readyState && (i(), l.setTransport(j), j.send([{
                                                type: "upgrade"
                                            }]), l.emit("upgrade", j), j = null, l.upgrading = !1, l.flush())
                                        })
                                    } else {
                                        var b = new Error("probe error");
                                        b.transport = j.name, l.emit("upgradeError", b)
                                    }
                            }))
                        }

                        function c() {
                            k || (k = !0, i(), j.close(), j = null)
                        }

                        function e(a) {
                            var b = new Error("probe error: " + a);
                            b.transport = j.name, c(), l.emit("upgradeError", b)
                        }

                        function f() {
                            e("transport closed")
                        }

                        function g() {
                            e("socket closed")
                        }

                        function h(a) {
                            j && a.name !== j.name && c()
                        }

                        function i() {
                            j.removeListener("open", b), j.removeListener("error", e), j.removeListener("close", f), l.removeListener("close", g), l.removeListener("upgrading", h)
                        }
                        var j = this.createTransport(a, {
                                probe: 1
                            }),
                            k = !1,
                            l = this;
                        d.priorWebsocketSuccess = !1, j.once("open", b), j.once("error", e), j.once("close", f), this.once("close", g), this.once("upgrading", h), j.open()
                    }, d.prototype.onOpen = function() {
                        if (this.readyState = "open", d.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause)
                            for (var a = 0, b = this.upgrades.length; a < b; a++) this.probe(this.upgrades[a])
                    }, d.prototype.onPacket = function(a) {
                        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (this.emit("packet", a), this.emit("heartbeat"), a.type) {
                            case "open":
                                this.onHandshake(k(a.data));
                                break;
                            case "pong":
                                this.setPing(), this.emit("pong");
                                break;
                            case "error":
                                var b = new Error("server error");
                                b.code = a.data, this.onError(b);
                                break;
                            case "message":
                                this.emit("data", a.data), this.emit("message", a.data)
                        }
                    }, d.prototype.onHandshake = function(a) {
                        this.emit("handshake", a), this.id = a.sid, this.transport.query.sid = a.sid, this.upgrades = this.filterUpgrades(a.upgrades), this.pingInterval = a.pingInterval, this.pingTimeout = a.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat))
                    }, d.prototype.onHeartbeat = function(a) {
                        clearTimeout(this.pingTimeoutTimer);
                        var b = this;
                        b.pingTimeoutTimer = setTimeout(function() {
                            "closed" !== b.readyState && b.onClose("ping timeout")
                        }, a || b.pingInterval + b.pingTimeout)
                    }, d.prototype.setPing = function() {
                        var a = this;
                        clearTimeout(a.pingIntervalTimer), a.pingIntervalTimer = setTimeout(function() {
                            a.ping(), a.onHeartbeat(a.pingTimeout)
                        }, a.pingInterval)
                    }, d.prototype.ping = function() {
                        var a = this;
                        this.sendPacket("ping", function() {
                            a.emit("ping")
                        })
                    }, d.prototype.onDrain = function() {
                        this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush()
                    }, d.prototype.flush = function() {
                        "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"))
                    }, d.prototype.write = d.prototype.send = function(a, b, c) {
                        return this.sendPacket("message", a, b, c), this
                    }, d.prototype.sendPacket = function(a, b, c, d) {
                        if ("function" == typeof b && (d = b, b = void 0), "function" == typeof c && (d = c, c = null), "closing" !== this.readyState && "closed" !== this.readyState) {
                            c = c || {}, c.compress = !1 !== c.compress;
                            var e = {
                                type: a,
                                data: b,
                                options: c
                            };
                            this.emit("packetCreate", e), this.writeBuffer.push(e), d && this.once("flush", d), this.flush()
                        }
                    }, d.prototype.close = function() {
                        function a() {
                            d.onClose("forced close"), d.transport.close()
                        }

                        function b() {
                            d.removeListener("upgrade", b), d.removeListener("upgradeError", b), a()
                        }

                        function c() {
                            d.once("upgrade", b), d.once("upgradeError", b)
                        }
                        if ("opening" === this.readyState || "open" === this.readyState) {
                            this.readyState = "closing";
                            var d = this;
                            this.writeBuffer.length ? this.once("drain", function() {
                                this.upgrading ? c() : a()
                            }) : this.upgrading ? c() : a()
                        }
                        return this
                    }, d.prototype.onError = function(a) {
                        d.priorWebsocketSuccess = !1, this.emit("error", a), this.onClose("transport error", a)
                    }, d.prototype.onClose = function(a, b) {
                        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                            var c = this;
                            clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", a, b), c.writeBuffer = [], c.prevBufferLen = 0
                        }
                    }, d.prototype.filterUpgrades = function(a) {
                        for (var b = [], c = 0, d = a.length; c < d; c++) ~h(this.transports, a[c]) && b.push(a[c]);
                        return b
                    }
                }).call(b, function() {
                    return this
                }())
            }, function(a, b, c) {
                (function(a) {
                    function d(b) {
                        var c, d = !1,
                            h = !1,
                            i = !1 !== b.jsonp;
                        if (a.location) {
                            var j = "https:" === location.protocol,
                                k = location.port;
                            k || (k = j ? 443 : 80), d = b.hostname !== location.hostname || k !== b.port, h = b.secure !== j
                        }
                        if (b.xdomain = d, b.xscheme = h, c = new e(b), "open" in c && !b.forceJSONP) return new f(b);
                        if (!i) throw new Error("JSONP disabled");
                        return new g(b)
                    }
                    var e = c(15),
                        f = c(17),
                        g = c(31),
                        h = c(32);
                    b.polling = d, b.websocket = h
                }).call(b, function() {
                    return this
                }())
            }, function(a, b, c) {
                (function(b) {
                    var d = c(16);
                    a.exports = function(a) {
                        var c = a.xdomain,
                            e = a.xscheme,
                            f = a.enablesXDR;
                        try {
                            if ("undefined" != typeof XMLHttpRequest && (!c || d)) return new XMLHttpRequest
                        } catch (a) {}
                        try {
                            if ("undefined" != typeof XDomainRequest && !e && f) return new XDomainRequest
                        } catch (a) {}
                        if (!c) try {
                            return new(b[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
                        } catch (a) {}
                    }
                }).call(b, function() {
                    return this
                }())
            }, function(a, b) {
                try {
                    a.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest
                } catch (b) {
                    a.exports = !1
                }
            }, function(a, b, c) {
                (function(b) {
                    function d() {}

                    function e(a) {
                        if (i.call(this, a), this.requestTimeout = a.requestTimeout, this.extraHeaders = a.extraHeaders, b.location) {
                            var c = "https:" === location.protocol,
                                d = location.port;
                            d || (d = c ? 443 : 80), this.xd = a.hostname !== b.location.hostname || d !== a.port, this.xs = a.secure !== c
                        }
                    }

                    function f(a) {
                        this.method = a.method || "GET", this.uri = a.uri, this.xd = !!a.xd, this.xs = !!a.xs, this.async = !1 !== a.async, this.data = void 0 !== a.data ? a.data : null, this.agent = a.agent, this.isBinary = a.isBinary, this.supportsBinary = a.supportsBinary, this.enablesXDR = a.enablesXDR, this.requestTimeout = a.requestTimeout, this.pfx = a.pfx, this.key = a.key, this.passphrase = a.passphrase, this.cert = a.cert, this.ca = a.ca, this.ciphers = a.ciphers, this.rejectUnauthorized = a.rejectUnauthorized, this.extraHeaders = a.extraHeaders, this.create()
                    }

                    function g() {
                        for (var a in f.requests) f.requests.hasOwnProperty(a) && f.requests[a].abort()
                    }
                    var h = c(15),
                        i = c(18),
                        j = c(5),
                        k = c(29);
                    c(3)("engine.io-client:polling-xhr"), a.exports = e, a.exports.Request = f, k(e, i), e.prototype.supportsBinary = !0, e.prototype.request = function(a) {
                        return a = a || {}, a.uri = this.uri(), a.xd = this.xd, a.xs = this.xs, a.agent = this.agent || !1, a.supportsBinary = this.supportsBinary, a.enablesXDR = this.enablesXDR, a.pfx = this.pfx, a.key = this.key, a.passphrase = this.passphrase, a.cert = this.cert, a.ca = this.ca, a.ciphers = this.ciphers, a.rejectUnauthorized = this.rejectUnauthorized, a.requestTimeout = this.requestTimeout, a.extraHeaders = this.extraHeaders, new f(a)
                    }, e.prototype.doWrite = function(a, b) {
                        var c = "string" != typeof a && void 0 !== a,
                            d = this.request({
                                method: "POST",
                                data: a,
                                isBinary: c
                            }),
                            e = this;
                        d.on("success", b), d.on("error", function(a) {
                            e.onError("xhr post error", a)
                        }), this.sendXhr = d
                    }, e.prototype.doPoll = function() {
                        var a = this.request(),
                            b = this;
                        a.on("data", function(a) {
                            b.onData(a)
                        }), a.on("error", function(a) {
                            b.onError("xhr poll error", a)
                        }), this.pollXhr = a
                    }, j(f.prototype), f.prototype.create = function() {
                        var a = {
                            agent: this.agent,
                            xdomain: this.xd,
                            xscheme: this.xs,
                            enablesXDR: this.enablesXDR
                        };
                        a.pfx = this.pfx, a.key = this.key, a.passphrase = this.passphrase, a.cert = this.cert, a.ca = this.ca, a.ciphers = this.ciphers, a.rejectUnauthorized = this.rejectUnauthorized;
                        var c = this.xhr = new h(a),
                            d = this;
                        try {
                            c.open(this.method, this.uri, this.async);
                            try {
                                if (this.extraHeaders) {
                                    c.setDisableHeaderCheck && c.setDisableHeaderCheck(!0);
                                    for (var e in this.extraHeaders) this.extraHeaders.hasOwnProperty(e) && c.setRequestHeader(e, this.extraHeaders[e])
                                }
                            } catch (a) {}
                            if ("POST" === this.method) try {
                                this.isBinary ? c.setRequestHeader("Content-type", "application/octet-stream") : c.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                            } catch (a) {}
                            try {
                                c.setRequestHeader("Accept", "*/*")
                            } catch (a) {}
                            "withCredentials" in c && (c.withCredentials = !0), this.requestTimeout && (c.timeout = this.requestTimeout), this.hasXDR() ? (c.onload = function() {
                                d.onLoad()
                            }, c.onerror = function() {
                                d.onError(c.responseText)
                            }) : c.onreadystatechange = function() {
                                if (2 === c.readyState) {
                                    var a;
                                    try {
                                        a = c.getResponseHeader("Content-Type")
                                    } catch (a) {}
                                    "application/octet-stream" === a && (c.responseType = "arraybuffer")
                                }
                                4 === c.readyState && (200 === c.status || 1223 === c.status ? d.onLoad() : setTimeout(function() {
                                    d.onError(c.status)
                                }, 0))
                            }, c.send(this.data)
                        } catch (a) {
                            return void setTimeout(function() {
                                d.onError(a)
                            }, 0)
                        }
                        b.document && (this.index = f.requestsCount++, f.requests[this.index] = this)
                    }, f.prototype.onSuccess = function() {
                        this.emit("success"), this.cleanup()
                    }, f.prototype.onData = function(a) {
                        this.emit("data", a), this.onSuccess()
                    }, f.prototype.onError = function(a) {
                        this.emit("error", a), this.cleanup(!0)
                    }, f.prototype.cleanup = function(a) {
                        if ("undefined" != typeof this.xhr && null !== this.xhr) {
                            if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = d : this.xhr.onreadystatechange = d, a) try {
                                this.xhr.abort()
                            } catch (a) {}
                            b.document && delete f.requests[this.index], this.xhr = null
                        }
                    }, f.prototype.onLoad = function() {
                        var a;
                        try {
                            var b;
                            try {
                                b = this.xhr.getResponseHeader("Content-Type")
                            } catch (a) {}
                            a = "application/octet-stream" === b ? this.xhr.response || this.xhr.responseText : this.xhr.responseText
                        } catch (a) {
                            this.onError(a)
                        }
                        null != a && this.onData(a)
                    }, f.prototype.hasXDR = function() {
                        return "undefined" != typeof b.XDomainRequest && !this.xs && this.enablesXDR
                    }, f.prototype.abort = function() {
                        this.cleanup()
                    }, f.requestsCount = 0, f.requests = {}, b.document && (b.attachEvent ? b.attachEvent("onunload", g) : b.addEventListener && b.addEventListener("beforeunload", g, !1))
                }).call(b, function() {
                    return this
                }())
            }, function(a, b, c) {
                function d(a) {
                    var b = a && a.forceBase64;
                    j && !b || (this.supportsBinary = !1), e.call(this, a)
                }
                var e = c(19),
                    f = c(28),
                    g = c(20),
                    h = c(29),
                    i = c(30);
                c(3)("engine.io-client:polling"), a.exports = d;
                var j = function() {
                    var a = c(15),
                        b = new a({
                            xdomain: !1
                        });
                    return null != b.responseType
                }();
                h(d, e), d.prototype.name = "polling", d.prototype.doOpen = function() {
                    this.poll()
                }, d.prototype.pause = function(a) {
                    function b() {
                        c.readyState = "paused", a()
                    }
                    var c = this;
                    if (this.readyState = "pausing", this.polling || !this.writable) {
                        var d = 0;
                        this.polling && (d++, this.once("pollComplete", function() {
                            --d || b()
                        })), this.writable || (d++, this.once("drain", function() {
                            --d || b()
                        }))
                    } else b()
                }, d.prototype.poll = function() {
                    this.polling = !0, this.doPoll(), this.emit("poll")
                }, d.prototype.onData = function(a) {
                    var b = this,
                        c = function(a, c, d) {
                            return "opening" === b.readyState && b.onOpen(), "close" === a.type ? (b.onClose(), !1) : void b.onPacket(a)
                        };
                    g.decodePayload(a, this.socket.binaryType, c), "closed" !== this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" === this.readyState && this.poll())
                }, d.prototype.doClose = function() {
                    function a() {
                        b.write([{
                            type: "close"
                        }])
                    }
                    var b = this;
                    "open" === this.readyState ? a() : this.once("open", a)
                }, d.prototype.write = function(a) {
                    var b = this;
                    this.writable = !1;
                    var c = function() {
                        b.writable = !0, b.emit("drain")
                    };
                    g.encodePayload(a, this.supportsBinary, function(a) {
                        b.doWrite(a, c)
                    })
                }, d.prototype.uri = function() {
                    var a = this.query || {},
                        b = this.secure ? "https" : "http",
                        c = "";
                    !1 !== this.timestampRequests && (a[this.timestampParam] = i()), this.supportsBinary || a.sid || (a.b64 = 1), a = f.encode(a), this.port && ("https" === b && 443 !== Number(this.port) || "http" === b && 80 !== Number(this.port)) && (c = ":" + this.port), a.length && (a = "?" + a);
                    var d = this.hostname.indexOf(":") !== -1;
                    return b + "://" + (d ? "[" + this.hostname + "]" : this.hostname) + c + this.path + a
                }
            }, function(a, b, c) {
                function d(a) {
                    this.path = a.path, this.hostname = a.hostname, this.port = a.port, this.secure = a.secure, this.query = a.query, this.timestampParam = a.timestampParam, this.timestampRequests = a.timestampRequests, this.readyState = "", this.agent = a.agent || !1, this.socket = a.socket, this.enablesXDR = a.enablesXDR, this.pfx = a.pfx, this.key = a.key, this.passphrase = a.passphrase, this.cert = a.cert, this.ca = a.ca, this.ciphers = a.ciphers, this.rejectUnauthorized = a.rejectUnauthorized, this.forceNode = a.forceNode, this.extraHeaders = a.extraHeaders, this.localAddress = a.localAddress
                }
                var e = c(20),
                    f = c(5);
                a.exports = d, f(d.prototype), d.prototype.onError = function(a, b) {
                    var c = new Error(a);
                    return c.type = "TransportError", c.description = b, this.emit("error", c), this
                }, d.prototype.open = function() {
                    return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this
                }, d.prototype.close = function() {
                    return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this
                }, d.prototype.send = function(a) {
                    if ("open" !== this.readyState) throw new Error("Transport not open");
                    this.write(a)
                }, d.prototype.onOpen = function() {
                    this.readyState = "open", this.writable = !0, this.emit("open")
                }, d.prototype.onData = function(a) {
                    var b = e.decodePacket(a, this.socket.binaryType);
                    this.onPacket(b)
                }, d.prototype.onPacket = function(a) {
                    this.emit("packet", a)
                }, d.prototype.onClose = function() {
                    this.readyState = "closed", this.emit("close")
                }
            }, function(a, b, c) {
                (function(a) {
                    function d(a, c) {
                        var d = "b" + b.packets[a.type] + a.data.data;
                        return c(d)
                    }

                    function e(a, c, d) {
                        if (!c) return b.encodeBase64Packet(a, d);
                        var e = a.data,
                            f = new Uint8Array(e),
                            g = new Uint8Array(1 + e.byteLength);
                        g[0] = s[a.type];
                        for (var h = 0; h < f.length; h++) g[h + 1] = f[h];
                        return d(g.buffer)
                    }

                    function f(a, c, d) {
                        if (!c) return b.encodeBase64Packet(a, d);
                        var e = new FileReader;
                        return e.onload = function() {
                            a.data = e.result, b.encodePacket(a, c, !0, d)
                        }, e.readAsArrayBuffer(a.data)
                    }

                    function g(a, c, d) {
                        if (!c) return b.encodeBase64Packet(a, d);
                        if (r) return f(a, c, d);
                        var e = new Uint8Array(1);
                        e[0] = s[a.type];
                        var g = new v([e.buffer, a.data]);
                        return d(g)
                    }

                    function h(a) {
                        try {
                            a = o.decode(a, {
                                strict: !1
                            })
                        } catch (a) {
                            return !1
                        }
                        return a
                    }

                    function i(a, b, c) {
                        for (var d = new Array(a.length), e = n(a.length, c), f = function(a, c, e) {
                                b(c, function(b, c) {
                                    d[a] = c, e(b, d)
                                })
                            }, g = 0; g < a.length; g++) f(g, a[g], e)
                    }
                    var j, k = c(21),
                        l = c(6),
                        m = c(22),
                        n = c(23),
                        o = c(24);
                    a && a.ArrayBuffer && (j = c(26));
                    var p = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
                        q = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent),
                        r = p || q;
                    b.protocol = 3;
                    var s = b.packets = {
                            open: 0,
                            close: 1,
                            ping: 2,
                            pong: 3,
                            message: 4,
                            upgrade: 5,
                            noop: 6
                        },
                        t = k(s),
                        u = {
                            type: "error",
                            data: "parser error"
                        },
                        v = c(27);
                    b.encodePacket = function(b, c, f, h) {
                        "function" == typeof c && (h = c, c = !1), "function" == typeof f && (h = f, f = null);
                        var i = void 0 === b.data ? void 0 : b.data.buffer || b.data;
                        if (a.ArrayBuffer && i instanceof ArrayBuffer) return e(b, c, h);
                        if (v && i instanceof a.Blob) return g(b, c, h);
                        if (i && i.base64) return d(b, h);
                        var j = s[b.type];
                        return void 0 !== b.data && (j += f ? o.encode(String(b.data), {
                            strict: !1
                        }) : String(b.data)), h("" + j)
                    }, b.encodeBase64Packet = function(c, d) {
                        var e = "b" + b.packets[c.type];
                        if (v && c.data instanceof a.Blob) {
                            var f = new FileReader;
                            return f.onload = function() {
                                var a = f.result.split(",")[1];
                                d(e + a)
                            }, f.readAsDataURL(c.data)
                        }
                        var g;
                        try {
                            g = String.fromCharCode.apply(null, new Uint8Array(c.data))
                        } catch (a) {
                            for (var h = new Uint8Array(c.data), i = new Array(h.length), j = 0; j < h.length; j++) i[j] = h[j];
                            g = String.fromCharCode.apply(null, i)
                        }
                        return e += a.btoa(g), d(e)
                    }, b.decodePacket = function(a, c, d) {
                        if (void 0 === a) return u;
                        if ("string" == typeof a) {
                            if ("b" === a.charAt(0)) return b.decodeBase64Packet(a.substr(1), c);
                            if (d && (a = h(a), a === !1)) return u;
                            var e = a.charAt(0);
                            return Number(e) == e && t[e] ? a.length > 1 ? {
                                type: t[e],
                                data: a.substring(1)
                            } : {
                                type: t[e]
                            } : u
                        }
                        var f = new Uint8Array(a),
                            e = f[0],
                            g = m(a, 1);
                        return v && "blob" === c && (g = new v([g])), {
                            type: t[e],
                            data: g
                        }
                    }, b.decodeBase64Packet = function(a, b) {
                        var c = t[a.charAt(0)];
                        if (!j) return {
                            type: c,
                            data: {
                                base64: !0,
                                data: a.substr(1)
                            }
                        };
                        var d = j.decode(a.substr(1));
                        return "blob" === b && v && (d = new v([d])), {
                            type: c,
                            data: d
                        }
                    }, b.encodePayload = function(a, c, d) {
                        function e(a) {
                            return a.length + ":" + a
                        }

                        function f(a, d) {
                            b.encodePacket(a, !!g && c, !1, function(a) {
                                d(null, e(a))
                            })
                        }
                        "function" == typeof c && (d = c, c = null);
                        var g = l(a);
                        return c && g ? v && !r ? b.encodePayloadAsBlob(a, d) : b.encodePayloadAsArrayBuffer(a, d) : a.length ? void i(a, f, function(a, b) {
                            return d(b.join(""))
                        }) : d("0:")
                    }, b.decodePayload = function(a, c, d) {
                        if ("string" != typeof a) return b.decodePayloadAsBinary(a, c, d);
                        "function" == typeof c && (d = c, c = null);
                        var e;
                        if ("" === a) return d(u, 0, 1);
                        for (var f, g, h = "", i = 0, j = a.length; i < j; i++) {
                            var k = a.charAt(i);
                            if (":" === k) {
                                if ("" === h || h != (f = Number(h))) return d(u, 0, 1);
                                if (g = a.substr(i + 1, f), h != g.length) return d(u, 0, 1);
                                if (g.length) {
                                    if (e = b.decodePacket(g, c, !1), u.type === e.type && u.data === e.data) return d(u, 0, 1);
                                    var l = d(e, i + f, j);
                                    if (!1 === l) return
                                }
                                i += f, h = ""
                            } else h += k
                        }
                        return "" !== h ? d(u, 0, 1) : void 0
                    }, b.encodePayloadAsArrayBuffer = function(a, c) {
                        function d(a, c) {
                            b.encodePacket(a, !0, !0, function(a) {
                                return c(null, a)
                            })
                        }
                        return a.length ? void i(a, d, function(a, b) {
                            var d = b.reduce(function(a, b) {
                                    var c;
                                    return c = "string" == typeof b ? b.length : b.byteLength, a + c.toString().length + c + 2
                                }, 0),
                                e = new Uint8Array(d),
                                f = 0;
                            return b.forEach(function(a) {
                                var b = "string" == typeof a,
                                    c = a;
                                if (b) {
                                    for (var d = new Uint8Array(a.length), g = 0; g < a.length; g++) d[g] = a.charCodeAt(g);
                                    c = d.buffer
                                }
                                b ? e[f++] = 0 : e[f++] = 1;
                                for (var h = c.byteLength.toString(), g = 0; g < h.length; g++) e[f++] = parseInt(h[g]);
                                e[f++] = 255;
                                for (var d = new Uint8Array(c), g = 0; g < d.length; g++) e[f++] = d[g]
                            }), c(e.buffer)
                        }) : c(new ArrayBuffer(0))
                    }, b.encodePayloadAsBlob = function(a, c) {
                        function d(a, c) {
                            b.encodePacket(a, !0, !0, function(a) {
                                var b = new Uint8Array(1);
                                if (b[0] = 1, "string" == typeof a) {
                                    for (var d = new Uint8Array(a.length), e = 0; e < a.length; e++) d[e] = a.charCodeAt(e);
                                    a = d.buffer, b[0] = 0
                                }
                                for (var f = a instanceof ArrayBuffer ? a.byteLength : a.size, g = f.toString(), h = new Uint8Array(g.length + 1), e = 0; e < g.length; e++) h[e] = parseInt(g[e]);
                                if (h[g.length] = 255, v) {
                                    var i = new v([b.buffer, h.buffer, a]);
                                    c(null, i)
                                }
                            })
                        }
                        i(a, d, function(a, b) {
                            return c(new v(b))
                        })
                    }, b.decodePayloadAsBinary = function(a, c, d) {
                        "function" == typeof c && (d = c, c = null);
                        for (var e = a, f = []; e.byteLength > 0;) {
                            for (var g = new Uint8Array(e), h = 0 === g[0], i = "", j = 1; 255 !== g[j]; j++) {
                                if (i.length > 310) return d(u, 0, 1);
                                i += g[j]
                            }
                            e = m(e, 2 + i.length), i = parseInt(i);
                            var k = m(e, 0, i);
                            if (h) try {
                                k = String.fromCharCode.apply(null, new Uint8Array(k))
                            } catch (a) {
                                var l = new Uint8Array(k);
                                k = "";
                                for (var j = 0; j < l.length; j++) k += String.fromCharCode(l[j])
                            }
                            f.push(k), e = m(e, i)
                        }
                        var n = f.length;
                        f.forEach(function(a, e) {
                            d(b.decodePacket(a, c, !0), e, n)
                        })
                    }
                }).call(b, function() {
                    return this
                }())
            }, function(a, b) {
                a.exports = Object.keys || function(a) {
                    var b = [],
                        c = Object.prototype.hasOwnProperty;
                    for (var d in a) c.call(a, d) && b.push(d);
                    return b
                }
            }, function(a, b) {
                a.exports = function(a, b, c) {
                    var d = a.byteLength;
                    if (b = b || 0, c = c || d, a.slice) return a.slice(b, c);
                    if (b < 0 && (b += d), c < 0 && (c += d), c > d && (c = d), b >= d || b >= c || 0 === d) return new ArrayBuffer(0);
                    for (var e = new Uint8Array(a), f = new Uint8Array(c - b), g = b, h = 0; g < c; g++, h++) f[h] = e[g];
                    return f.buffer
                }
            }, function(a, b) {
                function c(a, b, c) {
                    function e(a, d) {
                        if (e.count <= 0) throw new Error("after called too many times");
                        --e.count, a ? (f = !0, b(a), b = c) : 0 !== e.count || f || b(null, d)
                    }
                    var f = !1;
                    return c = c || d, e.count = a, 0 === a ? b() : e
                }

                function d() {}
                a.exports = c
            }, function(a, b, c) {
                var d;
                (function(a, e) {
                    ! function(f) {
                        function g(a) {
                            for (var b, c, d = [], e = 0, f = a.length; e < f;) b = a.charCodeAt(e++), b >= 55296 && b <= 56319 && e < f ? (c = a.charCodeAt(e++), 56320 == (64512 & c) ? d.push(((1023 & b) << 10) + (1023 & c) + 65536) : (d.push(b), e--)) : d.push(b);
                            return d
                        }

                        function h(a) {
                            for (var b, c = a.length, d = -1, e = ""; ++d < c;) b = a[d], b > 65535 && (b -= 65536, e += u(b >>> 10 & 1023 | 55296), b = 56320 | 1023 & b), e += u(b);
                            return e
                        }

                        function i(a, b) {
                            if (a >= 55296 && a <= 57343) {
                                if (b) throw Error("Lone surrogate U+" + a.toString(16).toUpperCase() + " is not a scalar value");
                                return !1
                            }
                            return !0
                        }

                        function j(a, b) {
                            return u(a >> b & 63 | 128)
                        }

                        function k(a, b) {
                            if (0 == (4294967168 & a)) return u(a);
                            var c = "";
                            return 0 == (4294965248 & a) ? c = u(a >> 6 & 31 | 192) : 0 == (4294901760 & a) ? (i(a, b) || (a = 65533), c = u(a >> 12 & 15 | 224), c += j(a, 6)) : 0 == (4292870144 & a) && (c = u(a >> 18 & 7 | 240), c += j(a, 12), c += j(a, 6)), c += u(63 & a | 128)
                        }

                        function l(a, b) {
                            b = b || {};
                            for (var c, d = !1 !== b.strict, e = g(a), f = e.length, h = -1, i = ""; ++h < f;) c = e[h], i += k(c, d);
                            return i
                        }

                        function m() {
                            if (t >= s) throw Error("Invalid byte index");
                            var a = 255 & r[t];
                            if (t++, 128 == (192 & a)) return 63 & a;
                            throw Error("Invalid continuation byte")
                        }

                        function n(a) {
                            var b, c, d, e, f;
                            if (t > s) throw Error("Invalid byte index");
                            if (t == s) return !1;
                            if (b = 255 & r[t], t++, 0 == (128 & b)) return b;
                            if (192 == (224 & b)) {
                                if (c = m(), f = (31 & b) << 6 | c, f >= 128) return f;
                                throw Error("Invalid continuation byte")
                            }
                            if (224 == (240 & b)) {
                                if (c = m(), d = m(), f = (15 & b) << 12 | c << 6 | d, f >= 2048) return i(f, a) ? f : 65533;
                                throw Error("Invalid continuation byte")
                            }
                            if (240 == (248 & b) && (c = m(), d = m(), e = m(), f = (7 & b) << 18 | c << 12 | d << 6 | e, f >= 65536 && f <= 1114111)) return f;
                            throw Error("Invalid UTF-8 detected")
                        }

                        function o(a, b) {
                            b = b || {};
                            var c = !1 !== b.strict;
                            r = g(a), s = r.length, t = 0;
                            for (var d, e = [];
                                (d = n(c)) !== !1;) e.push(d);
                            return h(e)
                        }
                        var p = "object" == typeof b && b,
                            q = ("object" == typeof a && a && a.exports == p && a, "object" == typeof e && e);
                        q.global !== q && q.window !== q || (f = q);
                        var r, s, t, u = String.fromCharCode,
                            v = {
                                version: "2.1.2",
                                encode: l,
                                decode: o
                            };
                        d = function() {
                            return v
                        }.call(b, c, b, a), !(void 0 !== d && (a.exports = d))
                    }(this)
                }).call(b, c(25)(a), function() {
                    return this
                }())
            }, function(a, b) {
                a.exports = function(a) {
                    return a.webpackPolyfill || (a.deprecate = function() {}, a.paths = [], a.children = [], a.webpackPolyfill = 1), a
                }
            }, function(a, b) {
                ! function() {
                    "use strict";
                    for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = new Uint8Array(256), d = 0; d < a.length; d++) c[a.charCodeAt(d)] = d;
                    b.encode = function(b) {
                        var c, d = new Uint8Array(b),
                            e = d.length,
                            f = "";
                        for (c = 0; c < e; c += 3) f += a[d[c] >> 2], f += a[(3 & d[c]) << 4 | d[c + 1] >> 4], f += a[(15 & d[c + 1]) << 2 | d[c + 2] >> 6], f += a[63 & d[c + 2]];
                        return e % 3 === 2 ? f = f.substring(0, f.length - 1) + "=" : e % 3 === 1 && (f = f.substring(0, f.length - 2) + "=="), f
                    }, b.decode = function(a) {
                        var b, d, e, f, g, h = .75 * a.length,
                            i = a.length,
                            j = 0;
                        "=" === a[a.length - 1] && (h--, "=" === a[a.length - 2] && h--);
                        var k = new ArrayBuffer(h),
                            l = new Uint8Array(k);
                        for (b = 0; b < i; b += 4) d = c[a.charCodeAt(b)], e = c[a.charCodeAt(b + 1)], f = c[a.charCodeAt(b + 2)], g = c[a.charCodeAt(b + 3)], l[j++] = d << 2 | e >> 4, l[j++] = (15 & e) << 4 | f >> 2, l[j++] = (3 & f) << 6 | 63 & g;
                        return k
                    }
                }()
            }, function(a, b) {
                (function(b) {
                    function c(a) {
                        for (var b = 0; b < a.length; b++) {
                            var c = a[b];
                            if (c.buffer instanceof ArrayBuffer) {
                                var d = c.buffer;
                                if (c.byteLength !== d.byteLength) {
                                    var e = new Uint8Array(c.byteLength);
                                    e.set(new Uint8Array(d, c.byteOffset, c.byteLength)), d = e.buffer
                                }
                                a[b] = d
                            }
                        }
                    }

                    function d(a, b) {
                        b = b || {};
                        var d = new f;
                        c(a);
                        for (var e = 0; e < a.length; e++) d.append(a[e]);
                        return b.type ? d.getBlob(b.type) : d.getBlob()
                    }

                    function e(a, b) {
                        return c(a), new Blob(a, b || {})
                    }
                    var f = b.BlobBuilder || b.WebKitBlobBuilder || b.MSBlobBuilder || b.MozBlobBuilder,
                        g = function() {
                            try {
                                var a = new Blob(["hi"]);
                                return 2 === a.size
                            } catch (a) {
                                return !1
                            }
                        }(),
                        h = g && function() {
                            try {
                                var a = new Blob([new Uint8Array([1, 2])]);
                                return 2 === a.size
                            } catch (a) {
                                return !1
                            }
                        }(),
                        i = f && f.prototype.append && f.prototype.getBlob;
                    a.exports = function() {
                        return g ? h ? b.Blob : e : i ? d : void 0
                    }()
                }).call(b, function() {
                    return this
                }())
            }, function(a, b) {
                b.encode = function(a) {
                    var b = "";
                    for (var c in a) a.hasOwnProperty(c) && (b.length && (b += "&"), b += encodeURIComponent(c) + "=" + encodeURIComponent(a[c]));
                    return b
                }, b.decode = function(a) {
                    for (var b = {}, c = a.split("&"), d = 0, e = c.length; d < e; d++) {
                        var f = c[d].split("=");
                        b[decodeURIComponent(f[0])] = decodeURIComponent(f[1])
                    }
                    return b
                }
            }, function(a, b) {
                a.exports = function(a, b) {
                    var c = function() {};
                    c.prototype = b.prototype, a.prototype = new c, a.prototype.constructor = a
                }
            }, function(a, b) {
                "use strict";

                function c(a) {
                    var b = "";
                    do b = g[a % h] + b, a = Math.floor(a / h); while (a > 0);
                    return b
                }

                function d(a) {
                    var b = 0;
                    for (k = 0; k < a.length; k++) b = b * h + i[a.charAt(k)];
                    return b
                }

                function e() {
                    var a = c(+new Date);
                    return a !== f ? (j = 0, f = a) : a + "." + c(j++)
                }
                for (var f, g = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), h = 64, i = {}, j = 0, k = 0; k < h; k++) i[g[k]] = k;
                e.encode = c, e.decode = d, a.exports = e
            }, function(a, b, c) {
                (function(b) {
                    function d() {}

                    function e(a) {
                        f.call(this, a), this.query = this.query || {}, h || (b.___eio || (b.___eio = []), h = b.___eio), this.index = h.length;
                        var c = this;
                        h.push(function(a) {
                            c.onData(a)
                        }), this.query.j = this.index, b.document && b.addEventListener && b.addEventListener("beforeunload", function() {
                            c.script && (c.script.onerror = d)
                        }, !1)
                    }
                    var f = c(18),
                        g = c(29);
                    a.exports = e;
                    var h, i = /\n/g,
                        j = /\\n/g;
                    g(e, f), e.prototype.supportsBinary = !1, e.prototype.doClose = function() {
                        this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), f.prototype.doClose.call(this)
                    }, e.prototype.doPoll = function() {
                        var a = this,
                            b = document.createElement("script");
                        this.script && (this.script.parentNode.removeChild(this.script), this.script = null), b.async = !0, b.src = this.uri(), b.onerror = function(b) {
                            a.onError("jsonp poll error", b)
                        };
                        var c = document.getElementsByTagName("script")[0];
                        c ? c.parentNode.insertBefore(b, c) : (document.head || document.body).appendChild(b), this.script = b;
                        var d = "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent);
                        d && setTimeout(function() {
                            var a = document.createElement("iframe");
                            document.body.appendChild(a), document.body.removeChild(a)
                        }, 100)
                    }, e.prototype.doWrite = function(a, b) {
                        function c() {
                            d(), b()
                        }

                        function d() {
                            if (e.iframe) try {
                                e.form.removeChild(e.iframe)
                            } catch (a) {
                                e.onError("jsonp polling iframe removal error", a)
                            }
                            try {
                                var a = '<iframe src="javascript:0" name="' + e.iframeId + '">';
                                f = document.createElement(a)
                            } catch (a) {
                                f = document.createElement("iframe"), f.name = e.iframeId, f.src = "javascript:0"
                            }
                            f.id = e.iframeId, e.form.appendChild(f), e.iframe = f
                        }
                        var e = this;
                        if (!this.form) {
                            var f, g = document.createElement("form"),
                                h = document.createElement("textarea"),
                                k = this.iframeId = "eio_iframe_" + this.index;
                            g.className = "socketio", g.style.position = "absolute", g.style.top = "-1000px", g.style.left = "-1000px", g.target = k, g.method = "POST", g.setAttribute("accept-charset", "utf-8"), h.name = "d", g.appendChild(h), document.body.appendChild(g), this.form = g, this.area = h
                        }
                        this.form.action = this.uri(), d(), a = a.replace(j, "\\\n"), this.area.value = a.replace(i, "\\n");
                        try {
                            this.form.submit()
                        } catch (a) {}
                        this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
                            "complete" === e.iframe.readyState && c()
                        } : this.iframe.onload = c
                    }
                }).call(b, function() {
                    return this
                }())
            }, function(a, b, c) {
                (function(b) {
                    function d(a) {
                        var b = a && a.forceBase64;
                        b && (this.supportsBinary = !1), this.perMessageDeflate = a.perMessageDeflate, this.usingBrowserWebSocket = k && !a.forceNode, this.protocols = a.protocols, this.usingBrowserWebSocket || (l = e), f.call(this, a)
                    }
                    var e, f = c(19),
                        g = c(20),
                        h = c(28),
                        i = c(29),
                        j = c(30),
                        k = (c(3)("engine.io-client:websocket"), b.WebSocket || b.MozWebSocket);
                    if ("undefined" == typeof window) try {
                        e = c(33)
                    } catch (a) {}
                    var l = k;
                    l || "undefined" != typeof window || (l = e), a.exports = d, i(d, f), d.prototype.name = "websocket", d.prototype.supportsBinary = !0, d.prototype.doOpen = function() {
                        if (this.check()) {
                            var a = this.uri(),
                                b = this.protocols,
                                c = {
                                    agent: this.agent,
                                    perMessageDeflate: this.perMessageDeflate
                                };
                            c.pfx = this.pfx, c.key = this.key, c.passphrase = this.passphrase, c.cert = this.cert, c.ca = this.ca, c.ciphers = this.ciphers, c.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (c.headers = this.extraHeaders), this.localAddress && (c.localAddress = this.localAddress);
                            try {
                                this.ws = this.usingBrowserWebSocket ? b ? new l(a, b) : new l(a) : new l(a, b, c)
                            } catch (a) {
                                return this.emit("error", a)
                            }
                            void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners()
                        }
                    }, d.prototype.addEventListeners = function() {
                        var a = this;
                        this.ws.onopen = function() {
                            a.onOpen()
                        }, this.ws.onclose = function() {
                            a.onClose()
                        }, this.ws.onmessage = function(b) {
                            a.onData(b.data)
                        }, this.ws.onerror = function(b) {
                            a.onError("websocket error", b)
                        }
                    }, d.prototype.write = function(a) {
                        function c() {
                            d.emit("flush"), setTimeout(function() {
                                d.writable = !0, d.emit("drain")
                            }, 0)
                        }
                        var d = this;
                        this.writable = !1;
                        for (var e = a.length, f = 0, h = e; f < h; f++) ! function(a) {
                            g.encodePacket(a, d.supportsBinary, function(f) {
                                if (!d.usingBrowserWebSocket) {
                                    var g = {};
                                    if (a.options && (g.compress = a.options.compress), d.perMessageDeflate) {
                                        var h = "string" == typeof f ? b.Buffer.byteLength(f) : f.length;
                                        h < d.perMessageDeflate.threshold && (g.compress = !1)
                                    }
                                }
                                try {
                                    d.usingBrowserWebSocket ? d.ws.send(f) : d.ws.send(f, g)
                                } catch (a) {}--e || c()
                            })
                        }(a[f])
                    }, d.prototype.onClose = function() {
                        f.prototype.onClose.call(this)
                    }, d.prototype.doClose = function() {
                        "undefined" != typeof this.ws && this.ws.close()
                    }, d.prototype.uri = function() {
                        var a = this.query || {},
                            b = this.secure ? "wss" : "ws",
                            c = "";
                        this.port && ("wss" === b && 443 !== Number(this.port) || "ws" === b && 80 !== Number(this.port)) && (c = ":" + this.port),
                            this.timestampRequests && (a[this.timestampParam] = j()), this.supportsBinary || (a.b64 = 1), a = h.encode(a), a.length && (a = "?" + a);
                        var d = this.hostname.indexOf(":") !== -1;
                        return b + "://" + (d ? "[" + this.hostname + "]" : this.hostname) + c + this.path + a
                    }, d.prototype.check = function() {
                        return !(!l || "__initialize" in l && this.name === d.prototype.name)
                    }
                }).call(b, function() {
                    return this
                }())
            }, function(a, b) {}, function(a, b) {
                var c = [].indexOf;
                a.exports = function(a, b) {
                    if (c) return a.indexOf(b);
                    for (var d = 0; d < a.length; ++d)
                        if (a[d] === b) return d;
                    return -1
                }
            }, function(a, b) {
                (function(b) {
                    var c = /^[\],:{}\s]*$/,
                        d = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
                        e = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                        f = /(?:^|:|,)(?:\s*\[)+/g,
                        g = /^\s+/,
                        h = /\s+$/;
                    a.exports = function(a) {
                        return "string" == typeof a && a ? (a = a.replace(g, "").replace(h, ""), b.JSON && JSON.parse ? JSON.parse(a) : c.test(a.replace(d, "@").replace(e, "]").replace(f, "")) ? new Function("return " + a)() : void 0) : null
                    }
                }).call(b, function() {
                    return this
                }())
            }, function(a, b, c) {
                "use strict";

                function d(a, b, c) {
                    this.io = a, this.nsp = b, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, c && c.query && (this.query = c.query), this.io.autoConnect && this.open()
                }
                var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
                        return typeof a
                    } : function(a) {
                        return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
                    },
                    f = c(4),
                    g = c(5),
                    h = c(37),
                    i = c(38),
                    j = c(39),
                    k = (c(3)("socket.io-client:socket"), c(28));
                a.exports = b = d;
                var l = {
                        connect: 1,
                        connect_error: 1,
                        connect_timeout: 1,
                        connecting: 1,
                        disconnect: 1,
                        error: 1,
                        reconnect: 1,
                        reconnect_attempt: 1,
                        reconnect_failed: 1,
                        reconnect_error: 1,
                        reconnecting: 1,
                        ping: 1,
                        pong: 1
                    },
                    m = g.prototype.emit;
                g(d.prototype), d.prototype.subEvents = function() {
                    if (!this.subs) {
                        var a = this.io;
                        this.subs = [i(a, "open", j(this, "onopen")), i(a, "packet", j(this, "onpacket")), i(a, "close", j(this, "onclose"))]
                    }
                }, d.prototype.open = d.prototype.connect = function() {
                    return this.connected ? this : (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting"), this)
                }, d.prototype.send = function() {
                    var a = h(arguments);
                    return a.unshift("message"), this.emit.apply(this, a), this
                }, d.prototype.emit = function(a) {
                    if (l.hasOwnProperty(a)) return m.apply(this, arguments), this;
                    var b = h(arguments),
                        c = {
                            type: f.EVENT,
                            data: b
                        };
                    return c.options = {}, c.options.compress = !this.flags || !1 !== this.flags.compress, "function" == typeof b[b.length - 1] && (this.acks[this.ids] = b.pop(), c.id = this.ids++), this.connected ? this.packet(c) : this.sendBuffer.push(c), delete this.flags, this
                }, d.prototype.packet = function(a) {
                    a.nsp = this.nsp, this.io.packet(a)
                }, d.prototype.onopen = function() {
                    if ("/" !== this.nsp)
                        if (this.query) {
                            var a = "object" === e(this.query) ? k.encode(this.query) : this.query;
                            this.packet({
                                type: f.CONNECT,
                                query: a
                            })
                        } else this.packet({
                            type: f.CONNECT
                        })
                }, d.prototype.onclose = function(a) {
                    this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", a)
                }, d.prototype.onpacket = function(a) {
                    if (a.nsp === this.nsp) switch (a.type) {
                        case f.CONNECT:
                            this.onconnect();
                            break;
                        case f.EVENT:
                            this.onevent(a);
                            break;
                        case f.BINARY_EVENT:
                            this.onevent(a);
                            break;
                        case f.ACK:
                            this.onack(a);
                            break;
                        case f.BINARY_ACK:
                            this.onack(a);
                            break;
                        case f.DISCONNECT:
                            this.ondisconnect();
                            break;
                        case f.ERROR:
                            this.emit("error", a.data)
                    }
                }, d.prototype.onevent = function(a) {
                    var b = a.data || [];
                    null != a.id && b.push(this.ack(a.id)), this.connected ? m.apply(this, b) : this.receiveBuffer.push(b)
                }, d.prototype.ack = function(a) {
                    var b = this,
                        c = !1;
                    return function() {
                        if (!c) {
                            c = !0;
                            var d = h(arguments);
                            b.packet({
                                type: f.ACK,
                                id: a,
                                data: d
                            })
                        }
                    }
                }, d.prototype.onack = function(a) {
                    var b = this.acks[a.id];
                    "function" == typeof b && (b.apply(this, a.data), delete this.acks[a.id])
                }, d.prototype.onconnect = function() {
                    this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered()
                }, d.prototype.emitBuffered = function() {
                    var a;
                    for (a = 0; a < this.receiveBuffer.length; a++) m.apply(this, this.receiveBuffer[a]);
                    for (this.receiveBuffer = [], a = 0; a < this.sendBuffer.length; a++) this.packet(this.sendBuffer[a]);
                    this.sendBuffer = []
                }, d.prototype.ondisconnect = function() {
                    this.destroy(), this.onclose("io server disconnect")
                }, d.prototype.destroy = function() {
                    if (this.subs) {
                        for (var a = 0; a < this.subs.length; a++) this.subs[a].destroy();
                        this.subs = null
                    }
                    this.io.destroy(this)
                }, d.prototype.close = d.prototype.disconnect = function() {
                    return this.connected && this.packet({
                        type: f.DISCONNECT
                    }), this.destroy(), this.connected && this.onclose("io client disconnect"), this
                }, d.prototype.compress = function(a) {
                    return this.flags = this.flags || {}, this.flags.compress = a, this
                }
            }, function(a, b) {
                function c(a, b) {
                    var c = [];
                    b = b || 0;
                    for (var d = b || 0; d < a.length; d++) c[d - b] = a[d];
                    return c
                }
                a.exports = c
            }, function(a, b) {
                "use strict";

                function c(a, b, c) {
                    return a.on(b, c), {
                        destroy: function() {
                            a.removeListener(b, c)
                        }
                    }
                }
                a.exports = c
            }, function(a, b) {
                var c = [].slice;
                a.exports = function(a, b) {
                    if ("string" == typeof b && (b = a[b]), "function" != typeof b) throw new Error("bind() requires a function");
                    var d = c.call(arguments, 2);
                    return function() {
                        return b.apply(a, d.concat(c.call(arguments)))
                    }
                }
            }, function(a, b) {
                function c(a) {
                    a = a || {}, this.ms = a.min || 100, this.max = a.max || 1e4, this.factor = a.factor || 2, this.jitter = a.jitter > 0 && a.jitter <= 1 ? a.jitter : 0, this.attempts = 0
                }
                a.exports = c, c.prototype.duration = function() {
                    var a = this.ms * Math.pow(this.factor, this.attempts++);
                    if (this.jitter) {
                        var b = Math.random(),
                            c = Math.floor(b * this.jitter * a);
                        a = 0 == (1 & Math.floor(10 * b)) ? a - c : a + c
                    }
                    return 0 | Math.min(a, this.max)
                }, c.prototype.reset = function() {
                    this.attempts = 0
                }, c.prototype.setMin = function(a) {
                    this.ms = a
                }, c.prototype.setMax = function(a) {
                    this.max = a
                }, c.prototype.setJitter = function(a) {
                    this.jitter = a
                }
            }])
        }),
        function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = {}.hasOwnProperty,
                u = [].indexOf || function(a) {
                    for (var b = 0, c = this.length; b < c; b++)
                        if (b in this && this[b] === a) return b;
                    return -1
                };
            f = {
                is_unordered: !1,
                is_counting: !1,
                is_exclusive: !1,
                is_solitary: !1,
                prevent_default: !1,
                prevent_repeat: !1
            }, r = "meta alt option ctrl shift cmd".split(" "), p = "ctrl", a = {
                debug: !1
            };
            var v = function(a) {
                var b, c;
                for (b in a) t.call(a, b) && (c = a[b], !1 !== c && (this[b] = c));
                this.keys = this.keys || [], this.count = this.count || 0
            };
            v.prototype.allows_key_repeat = function() {
                return !this.prevent_repeat && "function" == typeof this.on_keydown
            }, v.prototype.reset = function() {
                return this.count = 0, this.keyup_fired = null
            };
            var w = function(a, b) {
                var c, d;
                "undefined" != typeof jQuery && null !== jQuery && a instanceof jQuery && (1 !== a.length && o("Warning: your jQuery selector should have exactly one object."), a = a[0]), this.should_force_event_defaults = this.should_suppress_event_defaults = !1, this.sequence_delay = 800, this._registered_combos = [], this._keys_down = [], this._active_combos = [], this._sequence = [], this._sequence_timer = null, this._prevent_capture = !1, this._defaults = b || {};
                for (c in f) t.call(f, c) && (d = f[c], this._defaults[c] = this._defaults[c] || d);
                this.element = a || document.body, c = function(a, b, c) {
                    return a.addEventListener ? a.addEventListener(b, c) : a.attachEvent && a.attachEvent("on" + b, c), c
                };
                var e = this;
                this.keydown_event = c(this.element, "keydown", function(a) {
                    return a = a || window.event, e._receive_input(a, !0), e._bug_catcher(a)
                });
                var g = this;
                this.keyup_event = c(this.element, "keyup", function(a) {
                    return a = a || window.event, g._receive_input(a, !1)
                });
                var h = this;
                this.blur_event = c(window, "blur", function() {
                    var a, b, c, d;
                    for (d = h._keys_down, b = 0, c = d.length; b < c; b++) a = d[b], h._key_up(a, {});
                    return h._keys_down = []
                })
            };
            w.prototype.destroy = function() {
                var a;
                return a = function(a, b, c) {
                    return null != a.removeEventListener ? a.removeEventListener(b, c) : null != a.removeEvent ? a.removeEvent("on" + b, c) : void 0
                }, a(this.element, "keydown", this.keydown_event), a(this.element, "keyup", this.keyup_event), a(window, "blur", this.blur_event)
            }, w.prototype._bug_catcher = function(a) {
                var b, c;
                if ("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && "cmd" !== (b = d(null != (c = a.keyCode) ? c : a.key)) && "shift" !== b && "alt" !== b && "caps" !== b && "tab" !== b) return this._receive_input(a, !1)
            }, w.prototype._cmd_bug_check = function(a) {
                return !("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && 0 > u.call(a, "cmd"))
            }, w.prototype._prevent_default = function(a, b) {
                if ((b || this.should_suppress_event_defaults) && !this.should_force_event_defaults && (a.preventDefault ? a.preventDefault() : a.returnValue = !1, a.stopPropagation)) return a.stopPropagation()
            }, w.prototype._get_active_combos = function(a) {
                var b, c;
                return b = [], c = g(this._keys_down, function(b) {
                    return b !== a
                }), c.push(a), this._match_combo_arrays(c, function(a) {
                    return function(c) {
                        if (a._cmd_bug_check(c.keys)) return b.push(c)
                    }
                }(this)), this._fuzzy_match_combo_arrays(c, function(a) {
                    return function(c) {
                        if (!(0 <= u.call(b, c)) && !c.is_solitary && a._cmd_bug_check(c.keys)) return b.push(c)
                    }
                }(this)), b
            }, w.prototype._get_potential_combos = function(a) {
                var b, c, d, e, f;
                for (c = [], f = this._registered_combos, d = 0, e = f.length; d < e; d++) b = f[d], b.is_sequence || 0 <= u.call(b.keys, a) && this._cmd_bug_check(b.keys) && c.push(b);
                return c
            }, w.prototype._add_to_active_combos = function(a) {
                var b, c, d, e, f, g, h, i, j, k, l;
                if (g = !1, f = !0, d = !1, 0 <= u.call(this._active_combos, a)) return !0;
                if (this._active_combos.length)
                    for (e = h = 0, k = this._active_combos.length; 0 <= k ? h < k : h > k; e = 0 <= k ? ++h : --h)
                        if ((b = this._active_combos[e]) && b.is_exclusive && a.is_exclusive) {
                            if (b = b.keys, !g)
                                for (i = 0, j = b.length; i < j; i++)
                                    if (c = b[i], g = !0, 0 > u.call(a.keys, c)) {
                                        g = !1;
                                        break
                                    }
                            if (f && !g)
                                for (l = a.keys, i = 0, j = l.length; i < j; i++)
                                    if (c = l[i], f = !1, 0 > u.call(b, c)) {
                                        f = !0;
                                        break
                                    }
                            g && (d ? (b = this._active_combos.splice(e, 1)[0], null != b && b.reset()) : (b = this._active_combos.splice(e, 1, a)[0], null != b && b.reset(), d = !0), f = !1)
                        }
                return f && this._active_combos.unshift(a), g || f
            }, w.prototype._remove_from_active_combos = function(a) {
                var b, c, d, e;
                for (c = d = 0, e = this._active_combos.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d)
                    if (b = this._active_combos[c], b === a) {
                        a = this._active_combos.splice(c, 1)[0], a.reset();
                        break
                    }
            }, w.prototype._get_possible_sequences = function() {
                var a, b, c, d, e, f, h, i, j, k, l, m;
                for (d = [], k = this._registered_combos, f = 0, j = k.length; f < j; f++)
                    for (a = k[f], b = h = 1, l = this._sequence.length; 1 <= l ? h <= l : h >= l; b = 1 <= l ? ++h : --h)
                        if (e = this._sequence.slice(-b), a.is_sequence) {
                            if (0 > u.call(a.keys, "shift") && (e = g(e, function(a) {
                                    return "shift" !== a
                                }), !e.length)) continue;
                            for (b = i = 0, m = e.length; 0 <= m ? i < m : i > m; b = 0 <= m ? ++i : --i) {
                                if (a.keys[b] !== e[b]) {
                                    c = !1;
                                    break
                                }
                                c = !0
                            }
                            c && d.push(a)
                        }
                return d
            }, w.prototype._add_key_to_sequence = function(a, b) {
                var c, d, e, f;
                if (this._sequence.push(a), d = this._get_possible_sequences(), d.length) {
                    for (e = 0, f = d.length; e < f; e++) c = d[e], this._prevent_default(b, c.prevent_default);
                    this._sequence_timer && clearTimeout(this._sequence_timer), -1 < this.sequence_delay && (this._sequence_timer = setTimeout(function() {
                        return this._sequence = []
                    }, this.sequence_delay))
                } else this._sequence = []
            }, w.prototype._get_sequence = function(a) {
                var b, c, d, e, f, h, i, j, k, l, m, n;
                for (l = this._registered_combos, h = 0, k = l.length; h < k; h++)
                    if (b = l[h], b.is_sequence) {
                        for (c = i = 1, m = this._sequence.length; 1 <= m ? i <= m : i >= m; c = 1 <= m ? ++i : --i)
                            if (f = g(this._sequence, function(a) {
                                    return 0 <= u.call(b.keys, "shift") || "shift" !== a
                                }).slice(-c), b.keys.length === f.length)
                                for (c = j = 0, n = f.length; 0 <= n ? j < n : j > n; c = 0 <= n ? ++j : --j)
                                    if (e = f[c], !(0 > u.call(b.keys, "shift") && "shift" === e || "shift" === a && 0 > u.call(b.keys, "shift"))) {
                                        if (b.keys[c] !== e) {
                                            d = !1;
                                            break
                                        }
                                        d = !0
                                    }
                        if (d) return b.is_exclusive && (this._sequence = []), b
                    }
                return !1
            }, w.prototype._receive_input = function(a, b) {
                var c, e;
                if (this._prevent_capture) this._keys_down.length && (this._keys_down = []);
                else if (c = d(null != (e = a.keyCode) ? e : a.key), (b || this._keys_down.length || !("alt" === c || c === p)) && c) return b ? this._key_down(c, a) : this._key_up(c, a)
            }, w.prototype._fire = function(a, b, c, d) {
                if ("function" == typeof b["on_" + a] && this._prevent_default(c, !0 !== b["on_" + a].call(b.this, c, b.count, d)), "release" === a && (b.count = 0), "keyup" === a) return b.keyup_fired = !0
            }, w.prototype._match_combo_arrays = function(a, d) {
                var e, f, g, h;
                for (h = this._registered_combos, f = 0, g = h.length; f < g; f++) e = h[f], (!e.is_unordered && c(a, e.keys) || e.is_unordered && b(a, e.keys)) && d(e)
            }, w.prototype._fuzzy_match_combo_arrays = function(a, b) {
                var c, d, e, f;
                for (f = this._registered_combos, d = 0, e = f.length; d < e; d++) c = f[d], (!c.is_unordered && j(c.keys, a) || c.is_unordered && i(c.keys, a)) && b(c)
            }, w.prototype._keys_remain = function(a) {
                var b, c, d, e;
                for (e = a.keys, c = 0, d = e.length; c < d; c++)
                    if (a = e[c], 0 <= u.call(this._keys_down, a)) {
                        b = !0;
                        break
                    }
                return b
            }, w.prototype._key_down = function(a, b) {
                var c, d, f, g, h;
                (c = e(a, b)) && (a = c), this._add_key_to_sequence(a, b), (c = this._get_sequence(a)) && this._fire("keydown", c, b);
                for (f in q) c = q[f], b[c] && (f === a || 0 <= u.call(this._keys_down, f) || this._keys_down.push(f));
                for (f in q)
                    if (c = q[f], f !== a && 0 <= u.call(this._keys_down, f) && !b[c] && !("cmd" === f && "cmd" !== p))
                        for (c = d = 0, g = this._keys_down.length; 0 <= g ? d < g : d > g; c = 0 <= g ? ++d : --d) this._keys_down[c] === f && this._keys_down.splice(c, 1);
                for (d = this._get_active_combos(a), f = this._get_potential_combos(a), g = 0, h = d.length; g < h; g++) c = d[g], this._handle_combo_down(c, f, a, b);
                if (f.length)
                    for (d = 0, g = f.length; d < g; d++) c = f[d], this._prevent_default(b, c.prevent_default);
                0 > u.call(this._keys_down, a) && this._keys_down.push(a)
            }, w.prototype._handle_combo_down = function(a, b, c, d) {
                var e, f, g, h, i;
                if (0 > u.call(a.keys, c)) return !1;
                if (this._prevent_default(d, a && a.prevent_default), e = !1, 0 <= u.call(this._keys_down, c) && (e = !0, !a.allows_key_repeat())) return !1;
                if (g = this._add_to_active_combos(a, c), c = a.keyup_fired = !1, a.is_exclusive)
                    for (h = 0, i = b.length; h < i; h++)
                        if (f = b[h], f.is_exclusive && f.keys.length > a.keys.length) {
                            c = !0;
                            break
                        }
                return !c && (a.is_counting && "function" == typeof a.on_keydown && (a.count += 1), g) ? this._fire("keydown", a, d, e) : void 0
            }, w.prototype._key_up = function(a, b) {
                var c, d, f, g, h, i;
                if (c = a, (f = e(a, b)) && (a = f), f = n[c], b.shiftKey ? f && 0 <= u.call(this._keys_down, f) || (a = c) : c && 0 <= u.call(this._keys_down, c) || (a = f), (g = this._get_sequence(a)) && this._fire("keyup", g, b), 0 > u.call(this._keys_down, a)) return !1;
                for (g = h = 0, i = this._keys_down.length; 0 <= i ? h < i : h > i; g = 0 <= i ? ++h : --h)
                    if ((d = this._keys_down[g]) === a || d === f || d === c) {
                        this._keys_down.splice(g, 1);
                        break
                    }
                for (d = this._active_combos.length, f = [], i = this._active_combos, g = 0, h = i.length; g < h; g++) c = i[g], 0 <= u.call(c.keys, a) && f.push(c);
                for (g = 0, h = f.length; g < h; g++) c = f[g], this._handle_combo_up(c, b, a);
                if (1 < d)
                    for (h = this._active_combos, d = 0, g = h.length; d < g; d++) c = h[d], void 0 === c || 0 <= u.call(f, c) || this._keys_remain(c) || this._remove_from_active_combos(c)
            }, w.prototype._handle_combo_up = function(a, c, d) {
                var e, f;
                this._prevent_default(c, a && a.prevent_default), f = this._keys_remain(a), a.keyup_fired || (e = this._keys_down.slice(), e.push(d), a.is_solitary && !b(e, a.keys)) || (this._fire("keyup", a, c), a.is_counting && "function" == typeof a.on_keyup && "function" != typeof a.on_keydown && (a.count += 1)), f || (this._fire("release", a, c), this._remove_from_active_combos(a))
            }, w.prototype.simple_combo = function(a, b) {
                return this.register_combo({
                    keys: a,
                    on_keydown: b
                })
            }, w.prototype.counting_combo = function(a, b) {
                return this.register_combo({
                    keys: a,
                    is_counting: !0,
                    is_unordered: !1,
                    on_keydown: b
                })
            }, w.prototype.sequence_combo = function(a, b) {
                return this.register_combo({
                    keys: a,
                    on_keydown: b,
                    is_sequence: !0,
                    is_exclusive: !0
                })
            }, w.prototype.register_combo = function(a) {
                var b, c, d;
                "string" == typeof a.keys && (a.keys = a.keys.split(" ")), d = this._defaults;
                for (b in d) t.call(d, b) && (c = d[b], void 0 === a[b] && (a[b] = c));
                if (a = new v(a), s(a)) return this._registered_combos.push(a), a
            }, w.prototype.register_many = function(a) {
                var b, c, d, e;
                for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.register_combo(b));
                return e
            }, w.prototype.unregister_combo = function(a) {
                var d, e, f, g, h, i;
                if (!a) return !1;
                var j = this;
                if (e = function(a) {
                        var b, c, d, e;
                        for (e = [], b = c = 0, d = j._registered_combos.length; 0 <= d ? c < d : c > d; b = 0 <= d ? ++c : --c) {
                            if (a === j._registered_combos[b]) {
                                j._registered_combos.splice(b, 1);
                                break
                            }
                            e.push(void 0)
                        }
                        return e
                    }, a instanceof v) return e(a);
                for ("string" == typeof a && (a = a.split(" ")), h = this._registered_combos, i = [], f = 0, g = h.length; f < g; f++) d = h[f], null != d && (d.is_unordered && b(a, d.keys) || !d.is_unordered && c(a, d.keys) ? i.push(e(d)) : i.push(void 0));
                return i
            }, w.prototype.unregister_many = function(a) {
                var b, c, d, e;
                for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.unregister_combo(b));
                return e
            }, w.prototype.get_registered_combos = function() {
                return this._registered_combos
            }, w.prototype.reset = function() {
                return this._registered_combos = []
            }, w.prototype.listen = function() {
                return this._prevent_capture = !1
            }, w.prototype.stop_listening = function() {
                return this._prevent_capture = !0
            }, w.prototype.get_meta_key = function() {
                return p
            }, a.Listener = w, d = function(a) {
                return m[a]
            }, g = function(a, b) {
                var c;
                if (a.filter) return a.filter(b);
                var d, e, f;
                for (f = [], d = 0, e = a.length; d < e; d++) c = a[d], b(c) && f.push(c);
                return f
            }, b = function(a, b) {
                var c, d, e;
                if (a.length !== b.length) return !1;
                for (d = 0, e = a.length; d < e; d++)
                    if (c = a[d], !(0 <= u.call(b, c))) return !1;
                return !0
            }, c = function(a, b) {
                var c, d, e;
                if (a.length !== b.length) return !1;
                for (c = d = 0, e = a.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d)
                    if (a[c] !== b[c]) return !1;
                return !0
            }, i = function(a, b) {
                var c, d, e;
                for (d = 0, e = a.length; d < e; d++)
                    if (c = a[d], 0 > u.call(b, c)) return !1;
                return !0
            }, h = Array.prototype.indexOf || function(a, b) {
                var c, d, e;
                for (c = d = 0, e = a.length; 0 <= e ? d <= e : d >= e; c = 0 <= e ? ++d : --d)
                    if (a[c] === b) return c;
                return -1
            }, j = function(a, b) {
                var c, d, e, f;
                for (e = d = 0, f = a.length; e < f; e++) {
                    if (c = a[e], c = h.call(b, c), !(c >= d)) return !1;
                    d = c
                }
                return !0
            }, o = function() {
                if (a.debug) return console.log.apply(console, arguments)
            }, k = function(a) {
                var b, c, d;
                b = !1;
                for (d in m)
                    if (c = m[d], a === c) {
                        b = !0;
                        break
                    }
                if (!b)
                    for (d in n)
                        if (c = n[d], a === c) {
                            b = !0;
                            break
                        }
                return b
            }, s = function(a) {
                var b, c, d, e, g, i, j;
                for (g = !0, a.keys.length || o("You're trying to bind a combo with no keys:", a), c = i = 0, j = a.keys.length; 0 <= j ? i < j : i > j; c = 0 <= j ? ++i : --i) d = a.keys[c], (b = l[d]) && (d = a.keys[c] = b), "meta" === d && a.keys.splice(c, 1, p), "cmd" === d && o('Warning: use the "meta" key rather than "cmd" for Windows compatibility');
                for (j = a.keys, b = 0, i = j.length; b < i; b++) d = j[b], k(d) || (o('Do not recognize the key "' + d + '"'), g = !1);
                if (0 <= u.call(a.keys, "meta") || 0 <= u.call(a.keys, "cmd")) {
                    for (b = a.keys.slice(), i = 0, j = r.length; i < j; i++) d = r[i], -1 < (c = h.call(b, d)) && b.splice(c, 1);
                    1 < b.length && (o("META and CMD key combos cannot have more than 1 non-modifier keys", a, b), g = !1)
                }
                for (e in a) "undefined" === f[e] && o("The property " + e + " is not a valid combo property. Your combo has still been registered.");
                return g
            }, e = function(a, b) {
                var c;
                return !!b.shiftKey && (c = n[a], null != c && c)
            }, q = {
                cmd: "metaKey",
                ctrl: "ctrlKey",
                shift: "shiftKey",
                alt: "altKey"
            }, l = {
                escape: "esc",
                control: "ctrl",
                command: "cmd",
                break: "pause",
                windows: "cmd",
                option: "alt",
                caps_lock: "caps",
                apostrophe: "'",
                semicolon: ";",
                tilde: "~",
                accent: "`",
                scroll_lock: "scroll",
                num_lock: "num"
            }, n = {
                "/": "?",
                ".": ">",
                ",": "<",
                "'": '"',
                ";": ":",
                "[": "{",
                "]": "}",
                "\\": "|",
                "`": "~",
                "=": "+",
                "-": "_",
                1: "!",
                2: "@",
                3: "#",
                4: "$",
                5: "%",
                6: "^",
                7: "&",
                8: "*",
                9: "(",
                0: ")"
            }, m = {
                0: "\\",
                8: "backspace",
                9: "tab",
                12: "num",
                13: "enter",
                16: "shift",
                17: "ctrl",
                18: "alt",
                19: "pause",
                20: "caps",
                27: "esc",
                32: "space",
                33: "pageup",
                34: "pagedown",
                35: "end",
                36: "home",
                37: "left",
                38: "up",
                39: "right",
                40: "down",
                44: "print",
                45: "insert",
                46: "delete",
                48: "0",
                49: "1",
                50: "2",
                51: "3",
                52: "4",
                53: "5",
                54: "6",
                55: "7",
                56: "8",
                57: "9",
                65: "a",
                66: "b",
                67: "c",
                68: "d",
                69: "e",
                70: "f",
                71: "g",
                72: "h",
                73: "i",
                74: "j",
                75: "k",
                76: "l",
                77: "m",
                78: "n",
                79: "o",
                80: "p",
                81: "q",
                82: "r",
                83: "s",
                84: "t",
                85: "u",
                86: "v",
                87: "w",
                88: "x",
                89: "y",
                90: "z",
                91: "cmd",
                92: "cmd",
                93: "cmd",
                96: "num_0",
                97: "num_1",
                98: "num_2",
                99: "num_3",
                100: "num_4",
                101: "num_5",
                102: "num_6",
                103: "num_7",
                104: "num_8",
                105: "num_9",
                106: "num_multiply",
                107: "num_add",
                108: "num_enter",
                109: "num_subtract",
                110: "num_decimal",
                111: "num_divide",
                112: "f1",
                113: "f2",
                114: "f3",
                115: "f4",
                116: "f5",
                117: "f6",
                118: "f7",
                119: "f8",
                120: "f9",
                121: "f10",
                122: "f11",
                123: "f12",
                124: "print",
                144: "num",
                145: "scroll",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                223: "`",
                224: "cmd",
                225: "alt",
                57392: "ctrl",
                63289: "num",
                59: ";",
                61: "=",
                173: "-"
            }, a._keycode_dictionary = m, a._is_array_in_array_sorted = j, -1 !== navigator.userAgent.indexOf("Mac OS X") && (p = "cmd"), -1 !== navigator.userAgent.indexOf("Opera") && (m[17] = "cmd"), "function" == typeof define && define.amd ? define([], function() {
                return a
            }) : "undefined" != typeof exports && null !== exports ? exports.keypress = a : window.keypress = a
        }.call(this), THREE.OBJLoader = function(a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.materials = null, this.regexp = {
                vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
                normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
                uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
                face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
                face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
                face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
                face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
                object_pattern: /^[og]\s*(.+)?/,
                smoothing_pattern: /^s\s+(\d+|on|off)/,
                material_library_pattern: /^mtllib /,
                material_use_pattern: /^usemtl /
            }
        }, THREE.OBJLoader.prototype = {
            constructor: THREE.OBJLoader,
            load: function(a, b, c, d) {
                var e = this,
                    f = new THREE.FileLoader(e.manager);
                f.setPath(this.path), f.load(a, function(a) {
                    b(e.parse(a))
                }, c, d)
            },
            setPath: function(a) {
                this.path = a
            },
            setMaterials: function(a) {
                this.materials = a
            },
            _createParserState: function() {
                var a = {
                    objects: [],
                    object: {},
                    vertices: [],
                    normals: [],
                    uvs: [],
                    materialLibraries: [],
                    startObject: function(a, b) {
                        if (this.object && this.object.fromDeclaration === !1) return this.object.name = a, void(this.object.fromDeclaration = b !== !1);
                        this.object && "function" == typeof this.object._finalize && this.object._finalize();
                        var c = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                        if (this.object = {
                                name: a || "",
                                fromDeclaration: b !== !1,
                                geometry: {
                                    vertices: [],
                                    normals: [],
                                    uvs: []
                                },
                                materials: [],
                                smooth: !0,
                                startMaterial: function(a, b) {
                                    var c = this._finalize(!1);
                                    c && (c.inherited || c.groupCount <= 0) && this.materials.splice(c.index, 1);
                                    var d = {
                                        index: this.materials.length,
                                        name: a || "",
                                        mtllib: Array.isArray(b) && b.length > 0 ? b[b.length - 1] : "",
                                        smooth: void 0 !== c ? c.smooth : this.smooth,
                                        groupStart: void 0 !== c ? c.groupEnd : 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: !1,
                                        clone: function(a) {
                                            return {
                                                index: "number" == typeof a ? a : this.index,
                                                name: this.name,
                                                mtllib: this.mtllib,
                                                smooth: this.smooth,
                                                groupStart: this.groupEnd,
                                                groupEnd: -1,
                                                groupCount: -1,
                                                inherited: !1
                                            }
                                        }
                                    };
                                    return this.materials.push(d), d
                                },
                                currentMaterial: function() {
                                    if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                                },
                                _finalize: function(a) {
                                    var b = this.currentMaterial();
                                    return b && b.groupEnd === -1 && (b.groupEnd = this.geometry.vertices.length / 3, b.groupCount = b.groupEnd - b.groupStart, b.inherited = !1), a !== !1 && 0 === this.materials.length && this.materials.push({
                                        name: "",
                                        smooth: this.smooth
                                    }), b
                                }
                            }, c && c.name && "function" == typeof c.clone) {
                            var d = c.clone(0);
                            d.inherited = !0, this.object.materials.push(d)
                        }
                        this.objects.push(this.object)
                    },
                    finalize: function() {
                        this.object && "function" == typeof this.object._finalize && this.object._finalize()
                    },
                    parseVertexIndex: function(a, b) {
                        var c = parseInt(a, 10);
                        return 3 * (c >= 0 ? c - 1 : c + b / 3)
                    },
                    parseNormalIndex: function(a, b) {
                        var c = parseInt(a, 10);
                        return 3 * (c >= 0 ? c - 1 : c + b / 3)
                    },
                    parseUVIndex: function(a, b) {
                        var c = parseInt(a, 10);
                        return 2 * (c >= 0 ? c - 1 : c + b / 2)
                    },
                    addVertex: function(a, b, c) {
                        var d = this.vertices,
                            e = this.object.geometry.vertices;
                        e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[a + 2]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[b + 2]), e.push(d[c + 0]), e.push(d[c + 1]), e.push(d[c + 2])
                    },
                    addVertexLine: function(a) {
                        var b = this.vertices,
                            c = this.object.geometry.vertices;
                        c.push(b[a + 0]), c.push(b[a + 1]), c.push(b[a + 2])
                    },
                    addNormal: function(a, b, c) {
                        var d = this.normals,
                            e = this.object.geometry.normals;
                        e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[a + 2]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[b + 2]), e.push(d[c + 0]), e.push(d[c + 1]), e.push(d[c + 2])
                    },
                    addUV: function(a, b, c) {
                        var d = this.uvs,
                            e = this.object.geometry.uvs;
                        e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[c + 0]), e.push(d[c + 1])
                    },
                    addUVLine: function(a) {
                        var b = this.uvs,
                            c = this.object.geometry.uvs;
                        c.push(b[a + 0]), c.push(b[a + 1])
                    },
                    addFace: function(a, b, c, d, e, f, g, h, i, j, k, l) {
                        var m, n = this.vertices.length,
                            o = this.parseVertexIndex(a, n),
                            p = this.parseVertexIndex(b, n),
                            q = this.parseVertexIndex(c, n);
                        if (void 0 === d ? this.addVertex(o, p, q) : (m = this.parseVertexIndex(d, n), this.addVertex(o, p, m), this.addVertex(p, q, m)), void 0 !== e) {
                            var r = this.uvs.length;
                            o = this.parseUVIndex(e, r), p = this.parseUVIndex(f, r), q = this.parseUVIndex(g, r), void 0 === d ? this.addUV(o, p, q) : (m = this.parseUVIndex(h, r), this.addUV(o, p, m), this.addUV(p, q, m))
                        }
                        if (void 0 !== i) {
                            var s = this.normals.length;
                            o = this.parseNormalIndex(i, s), p = i === j ? o : this.parseNormalIndex(j, s), q = i === k ? o : this.parseNormalIndex(k, s), void 0 === d ? this.addNormal(o, p, q) : (m = this.parseNormalIndex(l, s), this.addNormal(o, p, m), this.addNormal(p, q, m))
                        }
                    },
                    addLineGeometry: function(a, b) {
                        this.object.geometry.type = "Line";
                        for (var c = this.vertices.length, d = this.uvs.length, e = 0, f = a.length; e < f; e++) this.addVertexLine(this.parseVertexIndex(a[e], c));
                        for (var g = 0, f = b.length; g < f; g++) this.addUVLine(this.parseUVIndex(b[g], d))
                    }
                };
                return a.startObject("", !1), a
            },
            parse: function(a) {
                console.time("OBJLoader");
                var b = this._createParserState();
                a.indexOf("\r\n") !== -1 && (a = a.replace("\r\n", "\n"));
                for (var c = a.split("\n"), d = "", e = "", f = "", g = 0, h = [], i = "function" == typeof "".trimLeft, j = 0, k = c.length; j < k; j++)
                    if (d = c[j], d = i ? d.trimLeft() : d.trim(), g = d.length, 0 !== g && (e = d.charAt(0), "#" !== e))
                        if ("v" === e)
                            if (f = d.charAt(1), " " === f && null !== (h = this.regexp.vertex_pattern.exec(d))) b.vertices.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
                            else if ("n" === f && null !== (h = this.regexp.normal_pattern.exec(d))) b.normals.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
                else {
                    if ("t" !== f || null === (h = this.regexp.uv_pattern.exec(d))) throw new Error("Unexpected vertex/normal/uv line: '" + d + "'");
                    b.uvs.push(parseFloat(h[1]), parseFloat(h[2]))
                } else if ("f" === e)
                    if (null !== (h = this.regexp.face_vertex_uv_normal.exec(d))) b.addFace(h[1], h[4], h[7], h[10], h[2], h[5], h[8], h[11], h[3], h[6], h[9], h[12]);
                    else if (null !== (h = this.regexp.face_vertex_uv.exec(d))) b.addFace(h[1], h[3], h[5], h[7], h[2], h[4], h[6], h[8]);
                else if (null !== (h = this.regexp.face_vertex_normal.exec(d))) b.addFace(h[1], h[3], h[5], h[7], void 0, void 0, void 0, void 0, h[2], h[4], h[6], h[8]);
                else {
                    if (null === (h = this.regexp.face_vertex.exec(d))) throw new Error("Unexpected face line: '" + d + "'");
                    b.addFace(h[1], h[2], h[3], h[4])
                } else if ("l" === e) {
                    var l = d.substring(1).trim().split(" "),
                        m = [],
                        n = [];
                    if (d.indexOf("/") === -1) m = l;
                    else
                        for (var o = 0, p = l.length; o < p; o++) {
                            var q = l[o].split("/");
                            "" !== q[0] && m.push(q[0]), "" !== q[1] && n.push(q[1])
                        }
                    b.addLineGeometry(m, n)
                } else if (null !== (h = this.regexp.object_pattern.exec(d))) {
                    var r = h[0].substr(1).trim();
                    b.startObject(r)
                } else if (this.regexp.material_use_pattern.test(d)) b.object.startMaterial(d.substring(7).trim(), b.materialLibraries);
                else if (this.regexp.material_library_pattern.test(d)) b.materialLibraries.push(d.substring(7).trim());
                else {
                    if (null === (h = this.regexp.smoothing_pattern.exec(d))) {
                        if ("\0" === d) continue;
                        throw new Error("Unexpected line: '" + d + "'")
                    }
                    var s = h[1].trim().toLowerCase();
                    b.object.smooth = "1" === s || "on" === s;
                    var t = b.object.currentMaterial();
                    t && (t.smooth = b.object.smooth)
                }
                b.finalize();
                var u = new THREE.Group;
                u.materialLibraries = [].concat(b.materialLibraries);
                for (var j = 0, k = b.objects.length; j < k; j++) {
                    var v = b.objects[j],
                        w = v.geometry,
                        x = v.materials,
                        y = "Line" === w.type;
                    if (0 !== w.vertices.length) {
                        var z = new THREE.BufferGeometry;
                        z.addAttribute("position", new THREE.BufferAttribute(new Float32Array(w.vertices), 3)), w.normals.length > 0 ? z.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(w.normals), 3)) : z.computeVertexNormals(), w.uvs.length > 0 && z.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(w.uvs), 2));
                        for (var A = [], B = 0, C = x.length; B < C; B++) {
                            var D = x[B],
                                t = void 0;
                            if (null !== this.materials && (t = this.materials.create(D.name), y && t && !(t instanceof THREE.LineBasicMaterial))) {
                                var E = new THREE.LineBasicMaterial;
                                E.copy(t), t = E
                            }
                            t || (t = y ? new THREE.LineBasicMaterial : new THREE.MeshPhongMaterial, t.name = D.name), t.shading = D.smooth ? THREE.SmoothShading : THREE.FlatShading, A.push(t)
                        }
                        var F;
                        if (A.length > 1) {
                            for (var B = 0, C = x.length; B < C; B++) {
                                var D = x[B];
                                z.addGroup(D.groupStart, D.groupCount, B)
                            }
                            var G = new THREE.MultiMaterial(A);
                            F = y ? new THREE.LineSegments(z, G) : new THREE.Mesh(z, G)
                        } else F = y ? new THREE.LineSegments(z, A[0]) : new THREE.Mesh(z, A[0]);
                        F.name = v.name, u.add(F)
                    }
                }
                return console.timeEnd("OBJLoader"), u
            }
        };
    var ka = function() {
        var a = window.innerWidth,
            b = window.innerHeight;
        Cc && (Cc.setSize(a, b), hd()), za && (za.width = a, za.height = b), Fc && (Fc.fov = 75, Fc.aspect = a / b, Fc.updateProjectionMatrix()), Gc && (Gc.left = -a / 2, Gc.right = a / 2, Gc.top = b / 2, Gc.bottom = -b / 2, Gc.updateProjectionMatrix())
    };
    window.addEventListener("resize", ka, !1);
    var la = new THREE.TextureLoader,
        ma = new THREE.FileLoader,
        na = new THREE.OBJLoader,
        oa = {},
        pa = {},
        qa = {},
        ra = {},
        sa = {};
    sa.promises = [], sa.compute = function(a) {
        return sa.promises.push(new Promise(function(b, c) {
            a(), b()
        })), sa.promises[sa.promises.length - 1]
    }, sa.loadTexture = function(a) {
        return sa.promises.push(new Promise(function(b, c) {
            la.load(a, function(c) {
                oa[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
            }, function(a) {}, function(a) {})
        })), sa.promises[sa.promises.length - 1]
    }, sa.loadModel = function(a) {
        return sa.promises.push(new Promise(function(b, c) {
            na.load(a, function(c) {
                qa[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
            })
        })), sa.promises[sa.promises.length - 1]
    }, sa.loadShader = function(a) {
        return sa.promises.push(new Promise(function(b, c) {
            ma.load(a, function(c) {
                pa[a.substring(a.lastIndexOf("/") + 1, a.length)] = c, b()
            })
        })), sa.promises[sa.promises.length - 1]
    }, sa.loadJSON = function(a) {
        return sa.promises.push(new Promise(function(b, c) {
            $.getJSON(a, function(c) {
                ra[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
            })
        })), sa.promises[sa.promises.length - 1]
    }, sa.onFinish = function(a) {
        Promise.all(sa.promises).then(function(b) {
            a && a()
        })
    };
    var ta = [{
            value: 1e18,
            symbol: "E"
        }, {
            value: 1e15,
            symbol: "P"
        }, {
            value: 1e12,
            symbol: "T"
        }, {
            value: 1e9,
            symbol: "G"
        }, {
            value: 1e6,
            symbol: "M"
        }, {
            value: 1e3,
            symbol: "k"
        }],
        ua = /\.0+$|(\.[0-9]*[1-9])0+$/,
        va = function(a) {
            return 1 == a || "true" == a
        };
    sa.loadTexture("../data/terrain/color.jpg"), sa.loadTexture("../data/terrain/heightmap.jpg"), sa.loadTexture("../data/terrain/grassmap.png"), sa.loadTexture("../data/terrain/grass.png"), sa.loadTexture("../data/terrain/detail.jpg"), sa.loadTexture("../data/terrain/detail2.jpg"), sa.loadTexture("../data/terrain/detail_h.jpg"), sa.loadShader("script/shader/grass.vert"), sa.loadShader("script/shader/grass.frag"), sa.loadShader("script/shader/terrain.vert"), sa.loadShader("script/shader/terrain.frag");
    var wa = function() {
            sa.loadTexture("../data/efx/gradient.jpg"), sa.loadTexture("../data/efx/heal_alpha.jpg"), sa.loadTexture("../data/efx/heal_color.jpg"), sa.loadTexture("../data/efx/ice_color.jpg"), sa.loadTexture("../data/efx/leech_color.jpg"), sa.loadTexture("../data/efx/decay_alpha.jpg"), sa.loadTexture("../data/efx/decay_color.jpg"), sa.loadTexture("../data/efx/swingtest.jpg"), sa.loadTexture("../data/efx/alpha.jpg"), sa.loadTexture("../data/factionA.png"), sa.loadTexture("../data/factionB.png"), sa.loadTexture("../data/items/items.png"), sa.loadModel("../data/model/crown.obj"), sa.loadModel("../data/model/helmet.obj"), sa.loadJSON("../data/items/items.json")
        },
        xa = ["armor", "weapon", "offhand", "glove", "armlet", "boot", "gem", "ring", "bag"],
        ya = {
            g: {
                type: "gold",
                name: "Gold",
                drop: 0
            },
            sw: {
                description: "Sword",
                slot: "weapon",
                type: "sword",
                rotatedSprite: !0,
                name: ["Wooden Sword", "Rusty Ironsword", "Troll Blade", "Broadsword ", "Longsword", "Carved Bonesword", "Greatsword", "Ghastly Scimitar", "Nullfire Sword", "Knight's Greatsword", "King's Glaive", "Void Blade", "Zerstrer", "Hearteater", "Demonedge", "Excalibur", "Harbinger"],
                drop: 1,
                class: ["warrior"],
                lvl: [1, 3, 9, 15, 21, 28, 34, 40, 46, 52, 58, 64, 70, 76, 82, 88, 94],
                stats: {
                    mindmg: {
                        base: 3,
                        multi: .7,
                        low: .6,
                        high: .9
                    },
                    maxdmg: {
                        base: 5,
                        multi: .8,
                        low: 1.1,
                        high: 1.2
                    },
                    crit: {
                        base: 2,
                        multi: .12,
                        low: .8,
                        high: 1,
                        float: !0
                    }
                }
            },
            st: {
                description: "Staff",
                slot: "weapon",
                type: "staff",
                rotatedSprite: !0,
                name: ["Broken Twig", "Cracked Stick", "Gnarled Broomstick", "Oak Stave", "Mystic Wand", "Bone Stave", "Encrusted Rod", "Imbued Staff", "Emerald Staff", "Sapphire Staff", "Frozen Greatstaff", "Infernal Staff", "Hellfire Greatsaff", "Staff of Angelness ", "Crystal Core", "Witch's Heart", "Deathweaver"],
                drop: 1,
                class: ["mage"],
                lvl: [1, 4, 10, 16, 22, 29, 35, 41, 47, 53, 59, 65, 71, 77, 83, 89, 95],
                stats: {
                    mindmg: {
                        base: 2,
                        multi: .9,
                        low: .6,
                        high: .9
                    },
                    maxdmg: {
                        base: 3,
                        multi: 1.1,
                        low: 1.1,
                        high: 1.2
                    },
                    crit: {
                        base: 2,
                        multi: .1,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    mp: {
                        base: 5,
                        multi: .8,
                        low: .8,
                        high: 1
                    },
                    mpreg: {
                        base: .5,
                        multi: .05,
                        low: .8,
                        high: 1,
                        float: !0
                    }
                }
            },
            hm: {
                description: "Hammer",
                slot: "weapon",
                type: "hammer",
                rotatedSprite: !0,
                name: ["Splintered Club", "Wooden Mallet", "Rusty Flail", "Orcish Bludgeon", "Heavy Mace", "Iron Basher", "Darkmetal Maul", "Divine Gavel", "Hallowed Hammer", "Dwarfen Maul", "Coldforged Gavel", "Amboss", "Skullshatterer", "Benevolence ", "Hammer of Gaia", "Worldender", "Nightmare"],
                drop: 1,
                class: ["shaman"],
                lvl: [1, 5, 11, 17, 23, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96],
                stats: {
                    mindmg: {
                        base: 1,
                        multi: .6,
                        low: .6,
                        high: 1
                    },
                    maxdmg: {
                        base: 4,
                        multi: .8,
                        low: .7,
                        high: 1
                    },
                    mpreg: {
                        base: 1,
                        multi: .05,
                        low: .8,
                        high: 1,
                        float: !0
                    }
                }
            },
            bw: {
                description: "Bow",
                slot: "weapon",
                type: "bow",
                rotatedSprite: !0,
                name: ["Driftwood Shortbow", "Novice Shortbow", "Curved Shortbow", "Adventurer's Shortbow", "Long Bow", "Bone Bow", "Elven Bow", "Ancient Bow", "Iron Piercer", "Silver Recurve", "Assassin's Bow", "Skyfire Warbow", "Hellfire Warbow", "Widowmaker", "Stormsong", "Scarebow", "Fury"],
                drop: 1,
                class: ["archer"],
                lvl: [1, 6, 12, 18, 24, 31, 37, 43, 49, 55, 61, 67, 73, 79, 85, 91, 97],
                stats: {
                    mindmg: {
                        base: 1,
                        multi: .7,
                        low: .7,
                        high: 1
                    },
                    maxdmg: {
                        base: 3,
                        multi: .9,
                        low: 1,
                        high: 1.1
                    },
                    crit: {
                        base: 3,
                        multi: .15,
                        low: .6,
                        high: 1,
                        float: !0
                    }
                }
            },
            ar: {
                description: "Chest armor",
                slot: "armor",
                type: "armor",
                rotatedSprite: !1,
                name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather", "Scaled Chestguard", "Sky Cloak", "Shadow Cloak", "Obsidian Cloak", "Hellfire Cloak", "Soulkeeper", "Deathless"],
                drop: 1,
                lvl: [1, 9, 18, 27, 36, 45, 56, 65, 74, 83],
                stats: {
                    def: {
                        base: 5,
                        multi: .9,
                        low: .6,
                        high: 1
                    },
                    hp: {
                        base: 10,
                        multi: 1.2,
                        low: .6,
                        high: 1
                    },
                    hpreg: {
                        base: .5,
                        multi: .05,
                        low: .3,
                        high: 1,
                        float: !0
                    }
                }
            },
            gl: {
                description: "Gloves",
                slot: "glove",
                type: "glove",
                rotatedSprite: !1,
                name: ["Hand Wraps", "Cloth Mitts", "Leather Gloves", "Bone Grips", "Iron Gauntlets", "Imbued Gloves", "Wartorn Mitts", "Fiery Handguards", "Gloves of Empowerment ", "Coldforged Fists", "Eternal Gauntlets", "Gloves of Midas", "Titan's Mitts"],
                drop: 2,
                lvl: [1, 8, 17, 26, 35, 44, 55, 64, 73, 82],
                stats: {
                    crit: {
                        base: .2,
                        multi: .05,
                        low: .2,
                        high: 1,
                        float: !0
                    },
                    def: {
                        base: 2,
                        multi: .3,
                        low: .5,
                        high: 1
                    },
                    hp: {
                        base: 3,
                        multi: .4,
                        low: .5,
                        high: 1
                    }
                }
            },
            al: {
                description: "Armlet",
                slot: "armlet",
                type: "armlet",
                rotatedSprite: !1,
                name: ["Simple Bracelet", "Makeshift Brace", "Leather Armlet", "Ivory Bracelet", "Iron Vambrace", "Imbued Bracers", "Ember Cuffs", "Mirrored Armlet", "Golem Fragment", "Coldforged Bracer", "Blackstar Gem", "Eternal Vambraces", "Lost Guardian"],
                drop: 2,
                lvl: [1, 7, 16, 25, 34, 43, 54, 63, 72, 81],
                stats: {
                    def: {
                        base: 2,
                        multi: .4,
                        low: .5,
                        high: 1
                    },
                    hp: {
                        base: 3,
                        multi: .3,
                        low: .5,
                        high: 1
                    },
                    mp: {
                        base: 5,
                        multi: 1,
                        low: .5,
                        high: 1
                    },
                    mpreg: {
                        base: .2,
                        multi: .05,
                        low: .5,
                        high: 1,
                        float: !0
                    }
                }
            },
            bt: {
                description: "Boots",
                slot: "boot",
                type: "boot",
                rotatedSprite: !1,
                name: ["Sandals", "Cloth Footpads", "Leather Boots", "Bone Greaves", "Scaled Treads", "Patterned Greaves", "Wartorn Boots", "Imbued Treads", "Skyswift Boots", "Coldforged Greaves", "Cloudrunner Treads", "Boots of Hermes", "Starshard Greaves"],
                drop: 2,
                lvl: [1, 6, 15, 24, 33, 42, 53, 62, 71, 80],
                stats: {
                    def: {
                        base: 2,
                        multi: .3,
                        low: .5,
                        high: 1
                    },
                    hp: {
                        base: 3,
                        multi: .3,
                        low: .5,
                        high: 1
                    },
                    move: {
                        base: .1,
                        multi: .02,
                        low: .5,
                        high: 1,
                        float: !0
                    }
                }
            },
            gm: {
                description: "Gem",
                slot: "gem",
                type: "gem",
                rotatedSprite: !1,
                name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather"],
                drop: 0,
                lvl: [1, 9, 18, 27, 36, 45, 56, 65, 74, 83],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    maxdmg: {
                        multi: 1,
                        low: 1.5,
                        high: 1.9
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    def: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    hp: {
                        multi: .5,
                        low: .8,
                        high: 1
                    },
                    hpreg: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    mp: {
                        multi: .5,
                        low: .8,
                        high: 1
                    },
                    mpreg: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    move: {
                        multi: 1,
                        low: .8,
                        high: 1,
                        float: !0
                    }
                }
            },
            ri: {
                description: "Ring",
                slot: "ring",
                type: "ring",
                rotatedSprite: !1,
                name: ["Woven Band", "Ironbark Circlet", "Brass Ringlet", "Hollowed Bone", "Elven Band", "Imbued Circlet", "Arcane Ring", "Emerald Band", "Infernal Ring", "Ancient Talisman", "Hallowed Relic", "Cantor's Trinket", "Peacekeeper"],
                drop: 1,
                lvl: [1, 5, 14, 23, 32, 41, 52, 61, 70, 79],
                stats: {
                    hpreg: {
                        base: .1,
                        multi: .05,
                        low: .2,
                        high: 1,
                        float: !0
                    },
                    mpreg: {
                        base: .1,
                        multi: .05,
                        low: .2,
                        high: 1,
                        float: !0
                    }
                }
            },
            bg: {
                description: "Bag",
                slot: "bag",
                type: "bag",
                rotatedSprite: !1,
                name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather"],
                drop: 0,
                lvl: [1, 9, 18, 27, 36, 45, 56, 65, 74, 83],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    maxdmg: {
                        multi: 1,
                        low: 1.5,
                        high: 1.9
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    def: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    hp: {
                        multi: .5,
                        low: .8,
                        high: 1
                    },
                    hpreg: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    mp: {
                        multi: .5,
                        low: .8,
                        high: 1
                    },
                    mpreg: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    move: {
                        multi: 1,
                        low: .8,
                        high: 1,
                        float: !0
                    }
                }
            },
            qv: {
                description: "Quiver",
                slot: "offhand",
                type: "quiver",
                rotatedSprite: !0,
                name: ["Linen Quiver", "Reinforced Quiver", "Last Reserves", "Lotharien", "Snake Quiver"],
                drop: 1,
                class: ["archer"],
                lvl: [5, 25, 45, 65, 85],
                stats: {
                    crit: {
                        base: .5,
                        multi: .08,
                        low: .5,
                        high: 1,
                        float: !0
                    },
                    move: {
                        base: .1,
                        multi: .03,
                        low: .5,
                        high: 1,
                        float: !0
                    }
                }
            },
            sh: {
                description: "Shield",
                slot: "offhand",
                type: "shield",
                rotatedSprite: !1,
                name: ["Wooden Shield", "Buckler", "Old Bulwark", "Metal Guard", "Protecteron"],
                drop: 2,
                class: ["shaman", "warrior"],
                lvl: [2, 13, 33, 63, 88],
                stats: {
                    def: {
                        base: 15,
                        multi: 1.2,
                        low: .5,
                        high: 1
                    },
                    hp: {
                        base: 8,
                        multi: .4,
                        low: .5,
                        high: 1
                    },
                    hpreg: {
                        base: .1,
                        multi: .05,
                        low: .5,
                        high: 1,
                        float: !0
                    }
                }
            },
            ta: {
                description: "Talisman",
                slot: "offhand",
                type: "talisman",
                rotatedSprite: !1,
                name: ["Smelly Talisman", "Guided Talisman", "Ocean Talisman", "Qui'ton", "Dimension Talisman"],
                drop: 1,
                class: ["mage"],
                lvl: [7, 27, 47, 67, 87],
                stats: {
                    mp: {
                        base: 3,
                        multi: 1.2,
                        low: .5,
                        high: 1
                    },
                    mpreg: {
                        base: .1,
                        multi: .1,
                        low: .5,
                        high: 1,
                        float: !0
                    }
                }
            },
            to: {
                description: "Totem",
                slot: "offhand",
                type: "totem",
                rotatedSprite: !0,
                name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather"],
                drop: 0,
                lvl: [10, 30, 50, 70, 90],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    maxdmg: {
                        multi: 1,
                        low: 1.5,
                        high: 1.9
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    def: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    hp: {
                        multi: .5,
                        low: .8,
                        high: 1
                    },
                    hpreg: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    mp: {
                        multi: .5,
                        low: .8,
                        high: 1
                    },
                    mpreg: {
                        multi: .5,
                        low: .8,
                        high: 1,
                        float: !0
                    },
                    move: {
                        multi: 1,
                        low: .8,
                        high: 1,
                        float: !0
                    }
                }
            }
        },
        za = {};
    Jc = new Object, za.entities = Jc;
    var Aa, Ba = function(a, b) {
            if (Jc.hasOwnProperty(a)) {
                if (void 0 === Jc[a]) return;
                Jc[a].timeSinceLastUpdate = 0, Jc[a].parseDeltaMsg(b)
            }
        },
        Ca = function(a) {
            Ic && Ic.id == a && (Ic = void 0), Jc.hasOwnProperty(a) && void 0 !== Jc[a] && (Ic && Ic.target == Jc[a] && (Ic.target = void 0), jb(Jc[a]), Jc[a].destroyBody(), Jc[a] = void 0)
        },
        Da = function() {
            for (e in Jc) Jc.hasOwnProperty(e) && Jc[e] && Jc[e].id && Ca(Jc[e].id);
            for (var a in nb) nb.hasOwnProperty(a) && nb[a].destroy();
            Hb(), Ic = void 0
        },
        Ea = !1,
        Fa = !1,
        Ga = !1,
        Ha = !1,
        Ia = !1,
        Ja = !1,
        Ka = function(a) {
            var b = {
                is_unordered: !0,
                prevent_repeat: !0,
                prevent_default: !0
            };
            Aa = new window.keypress.Listener(document.getElementById("body"), b), $("input").bind("focus", function() {
                Aa.stop_listening()
            }).bind("blur", function() {
                Aa.listen()
            }), document.onkeyup = function(a) {
                a = a || window.event;
                var b = !1;
                b = "key" in a ? "Escape" == a.key : 27 == a.keyCode, b && Ic && (Ic.target = void 0)
            }, La()
        },
        La = function() {
					Aa.reset(), Aa.simple_combo(Pa.get("toggleHelp"), function() {
						$(".modal-help").replaceWith('<div class="modal fade in" id="modal-help" tabindex="-1" role="dialog" style="display: block;"><div class="modal-dialog modal-body-base modal-help" role="document"><div class="modal-content"><div class="modal-body"><button class="close" type="button" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button><h4><div class="sys-icon icon-help iconpanelmod"></div> Help</h4><div><h5>Controls <small>Can be changed with /rebind</small></h5><table class="table controltable"><tbody><tr><td><kbd>W A S D</kbd></td><td class="td-help"> Move around</td></tr><tr><td><kbd>1 2 3 4</kbd></td><td class="td-help"> Use skills on current target</td></tr><tr><td><kbd>B</kbd></td><td class="td-help"> Inventory</td></tr><tr><td><kbd>C</kbd></td><td class="td-help"> Character Panel</td></tr><tr><td><kbd>Left mouse</kbd></td><td class="td-help"> Select a target / Rotate camera</td></tr><tr><td><kbd>Right mouse</kbd></td><td class="td-help"> Look around</td></tr><tr><td><kbd>Tab</kbd></td><td class="td-help"> Next target</td></tr><tr><td><kbd>Shift</kbd></td><td class="td-help"> Next ally</td></tr><tr><td><kbd>F1</kbd></td><td class="td-help"> Toggle help</td></tr><tr><td style = "background-color: #FFCE44"><kbd>X</kbd></td><td class="td-help" style = "background-color: #FFCE44"> Show the XHORDES keys</td></tr></tbody></table><h5>Chat Commands <small>Type into chat to activate</small></h5><table class="table controltable"><tbody><tr><td><kbd>/bindings</kbd></td><td class="td-help"> Show list of current bindings</td></tr><tr><td><kbd>/rebind</kbd></td><td class="td-help"> Change the binding of a key</td></tr><tr><td><kbd>/resetbindings</kbd></td><td class="td-help"> Reset all bindings to default</td></tr><tr><td><kbd>/respawn</kbd></td><td class="td-help"> Suicide and go back to spawn</td></tr></tbody></table></div></div></div></div>')
						$("#modal-help").modal("toggle");
					}), Aa.simple_combo(Pa.get("toggleLegusHelp"), function() {
						$(".modal-help").replaceWith('<div class="modal fade in" id="modal-help" tabindex="-1" role="dialog" style="display: block;"><div class="modal-dialog modal-body-base modal-help" role="document"><div class="modal-content"><div class="modal-body"><button class="close" type="button" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button><h4><div class="sys-icon icon-help iconpanelmod"></div> XHORDES Help</h4><div><h5>Controls <small>Can be changed with /rebind</small></h5><table class="table controltable"><tbody><tr><td style = "background-color: #757575"><kbd>F1</kbd></td><td class="td-help" style = "background-color: #757575"> Toggle Regular Help</td></tr><tr><td><kbd>G</kbd></td><td class="td-help"> Select Global Chat</td></tr><tr><td><kbd>H</kbd></td><td class="td-help"> Select Clan Chat</td></tr><tr><td><kbd>F2</kbd></td><td class="td-help"> Hide/Show the Chat</td></tr><tr><td><kbd>F3</kbd></td><td class="td-help"> Hide/Show the Leaderboard</td></tr></tbody></table><h5>Chat Commands <small>Type into chat to activate</small></h5><table class="table controltable"><tbody><tr><td><kbd>/mute [player]</kbd></td><td class="td-help"> Mutes a player (case-sensitive!)</td></tr><tr><td><kbd>/unmute [player]</kbd></td><td class="td-help"> Unmutes a player (case-sensitive!)</td></tr><tr><td><kbd>/mutelist</kbd></td><td class="td-help"> Lists all the people you have muted</td></tr></tbody></table></div></div></div></div>')
						$("#modal-help").modal("toggle");
					}),	Aa.simple_combo(Pa.get("toggleChat"), function() {
						$("#chatbox").toggle()
					}),	Aa.simple_combo(Pa.get("toggleLb"), function() {
						$("#ladder-body").toggle();
						$("#statistics").toggle();
					}), Aa.simple_combo(Pa.get("globalChat"), function() {
						$("#chatChannelName").text("Global"), hc = "g";
						$("#chatInputForm").show(), $("#chatInput").focus(), a && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
					}), Aa.simple_combo(Pa.get("clanChat"), function() {
						$("#chatChannelName").text("Clan"), hc = "c";
						$("#chatInputForm").show(), $("#chatInput").focus(), a && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
					}), Aa.register_combo({
						keys: Pa.get("nextAlly"),
						on_keydown: function() {
							Ic && td && (Ic.target = td)
						}
					}), Aa.register_combo({
						keys: Pa.get("nextTarget"),
						on_keydown: function() {
							Ic && sd && (Ic.target = sd)
						}
					}), Aa.register_combo({
						keys: Pa.get("walkForward"),
						on_keydown: function() {
							Ga = !0
						},
						on_release: function() {
							Ga = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("walkBackward"),
						on_keydown: function() {
							Ha = !0
						},
						on_release: function() {
							Ha = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("walkRight"),
						on_keydown: function() {
							Fa = !0
						},
						on_release: function() {
							Fa = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("walkLeft"),
						on_keydown: function() {
							Ea = !0
						},
						on_release: function() {
							Ea = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("turnLeft"),
						on_keydown: function() {
							Ja = !0
						},
						on_release: function() {
							Ja = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("turnRight"),
						on_keydown: function() {
							Ia = !0
						},
						on_release: function() {
							Ia = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("walkForward2"),
						on_keydown: function() {
							Ga = !0
						},
						on_release: function() {
							Ga = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("walkBackward2"),
						on_keydown: function() {
							Ha = !0
						},
						on_release: function() {
							Ha = !1
						}
					}), Aa.register_combo({
						keys: Pa.get("inventory"),
						prevent_default: !1,
						on_release: function() {
							Ic && $("#inventory").toggle()
						}
					}), Aa.register_combo({
						keys: Pa.get("character"),
						prevent_default: !1,
						on_release: function() {
							Ic && $("#characterpanel").toggle()
						}
					}), Aa.simple_combo(Pa.get("skill1"), function() {
						Ic && Ic.useSkill(1)
					}), Aa.simple_combo(Pa.get("skill2"), function() {
						Ic && Ic.useSkill(2)
					}), Aa.simple_combo(Pa.get("skill3"), function() {
						Ic && Ic.useSkill(3)
					}), Aa.simple_combo(Pa.get("skill4"), function() {
						Ic && Ic.useSkill(4)
					}), Aa.simple_combo("enter", function() {
						if (cc.chatboxWrapper) {
							Tb.unLock();
							var a = Math.round(cc.chatboxWrapper[0].scrollHeight - cc.chatboxWrapper[0].scrollTop) === Math.round(cc.chatboxWrapper[0].clientHeight);
							$("#chatInputForm").show(), $("#chatInput").focus(), a && cc.chatboxWrapper.scrollTop(cc.chatboxWrapper[0].scrollHeight)
						}
					}), $("#skillButtonKbd1").html(Pa.get("skill1")), $("#skillButtonKbd2").html(Pa.get("skill2")), $("#skillButtonKbd3").html(Pa.get("skill3")), $("#skillButtonKbd4").html(Pa.get("skill4"))
				},
				Ma = !1;
			if ("undefined" != typeof Storage) try {
				x = "__storage_test__", localStorage.setItem(x, x), localStorage.removeItem(x), Ma = !0, console.log("Webstorage found. loading settings..")
			} catch (a) {
				console.log("Error: Webstorage not working.")
			} else console.log("Error: Webstorage not working.");
			var Na = {
					skill1: "1",
					skill2: "2",
					skill3: "3",
					skill4: "4",
					nextTarget: "tab",
					nextAlly: "shift",
					walkForward: "w",
					walkLeft: "a",
					walkRight: "d",
					walkBackward: "s",
					turnLeft: "left",
					turnRight: "right",
					walkForward2: "up",
					walkBackward2: "down",
					toggleHelp: "f1",
					toggleChat: "f2",
					globalChat: "g",
					clanChat: "h",
					toggleLb: "f3",
					toggleLegusHelp: "x",
					inventory: "b",
					character: "c"
				},
        Oa = function() {
            this.get = function(a) {
                return this.hasOwnProperty(a) ? this[a] : void 0
            }, this.parse = function(a, b) {
                var c = b;
                return Ma && (c = localStorage.getItem(a), c || (c = b)), this[a] = c, c
            }, this.set = function(a, b) {
                return Ma && localStorage.setItem(a, b), this[a] = b, b
            }, this.parse("name", void 0), this.parse("faction", void 0), this.parse("class", void 0), this.parse("server", void 0), this.parse("camlock", "true"), this.parse("resolution", "10"), this.parse("skillefx", "true"), this.parse("lastAd", "0"), this.parse("dmgnumbers", "true"), this.parse("nameplates", "true"), this.parse("shadows", "0"), this.parse("grass", "3"), this.parse("chat-loot", "true"), this.parse("chat-chat", "true"), this.parse("chat-exp", "true"), this.parse("chat-pvp", "true");
            for (k in Na) this.parse(k, Na[k])
        },
        Pa = new Oa,
        Qa = function(a) {
            if ("string" != typeof a || a.length <= 0) return !1;
            if ("/" == a[0]) {
                var b = a.split(" ");
                if (b.length <= 0) return !1;
                var c = b.shift().substring(1),
                    d = a.substring(1);
				if(typeof localStorage.muted==="string")window.muted=localStorage.muted.split("&");
                Ra.hasOwnProperty(c) ? Ra[c](b, d) : Y({
                    msg: "Unknown command: " + c,
                    src: "system"
                })
            } else f(a, hc)
        },
        Ra = {
            respawn: function(a) {
                Y({
                    msg: "Respawning...",
                    src: "system"
                }), wd.emit("respawn")
            },
            rebind: function(a) {
                return a.length < 2 ? void Y({
                    msg: "Wrong usage. Example: '/rebind skill1 e'. For a list of keybindings, try /bindings",
                    src: "system"
                }) : Na.hasOwnProperty(a[0]) ? (Y({
                    msg: "Changed binding '" + a[0] + "' to: " + a[1],
                    src: "system"
                }), Pa.set(a[0], a[1]), void La()) : void Y({
                    msg: "No such keybinding: '" + a[0] + "'. For a list of keybindings, try /bindings",
                    src: "system"
                })
            },
            resetbindings: function() {
                Y({
                    msg: "Keybindings have been reset to default.",
                    src: "system"
                });
                for (k in Na) Pa.set(k, Na[k]);
                La()
            },
            bindings: function() {
                Y({
                    msg: "List of keybindings: ",
                    src: "system"
                });
                for (k in Na) Y({
                    msg: k + ": " + Pa.get(k),
                    src: "system"
				});
                },
			mute: function(a) {
				Y({msg: "Muted "+a.join(' ')+" successfully!", src:"system"});
				typeof window.muted==="undefined"?window.muted=[a.join(' ')]:window.muted.push(a.join(' '));
				localStorage.muted = window.muted.join("&");
			},
			unmute: function(a) {
				var m='';
				window.muted.indexOf(a.join(' '))===-1?m='Could not find '+a.join(' '):m='Successfully unmuted '+a.join(' ');
				Y({msg: m, src: 'system'});
				window.muted=window.muted.filter(function(i){return i!==a.join(' ')});
				localStorage.muted = window.muted.join("&");
			},
			mutelist: function(a) {
				Y({msg: window.muted||"Nobody is muted!", src: 'system'})
			},
            hideui: function() {
                pc("hide")
            },
            hideplayer: function() {
                Ic.geometry.visible = !1, Ic.namesprite.visible = !1, Ic.clansprite.visible = !1
            },
            msg: function(a) {
                if (!(a.length < 1)) {
                    if (a.length > 1)
                        for (var b = 2; b < a.length; ++b) a[1] = a[1] + " " + a[b];
                    var c = {};
                    c[a[0]] = a[1] || "", xd.emit("msg", c)
                }
            },
            global: function(a, b) {
                f(b.substring(6), "g")
            }
        },
        Sa = void 0,
        Ta = void 0,
        Ua = 2 * Math.PI,
        Va = !1,
        Wa = !1,
        Xa = "144.217.80.63",
        Ya = 150;
    j.prototype.tick = function(a) {
        if (!this.stats.isDead()) {
            var b = new THREE.Vector3(0, 0, 0);
            if (b.z = -this.walkForward, b.x = this.walkSideward, b.lengthSq() > 0 && b.normalize(), this.walkForward == -1 && (b.z *= .5, b.x *= .5), b.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation), this.velocity = b, !this.ignSteep && !this.isAi && (Va || this == Ic) && (0 != this.velocity.x || 0 != this.velocity.y)) {
                var c = b.clone();
                c.normalize();
                var d = .5,
                    e = Qc(this.position.x, this.position.z),
                    f = Qc(this.position.x + c.x, this.position.z),
                    g = Qc(this.position.x, this.position.z + c.z),
                    h = f - e > d ? 0 : 1,
                    i = g - e > d ? 0 : 1;
                this.velocity.x *= h, this.velocity.z *= i
            }
            this.position.x += this.velocity.x * a * this.stats.movespeed, this.position.y += this.velocity.y * a * this.stats.movespeed, this.position.z += this.velocity.z * a * this.stats.movespeed, this.class && this.class.tick && this.class.tick(a), this.stats.tick(a)
        }
        for (; this.rotation < 0;) this.rotation += Ua;
        for (; this.rotation > Ua;) this.rotation -= Ua;
        this.state.tick(a, this)
    }, j.prototype.getDeltaMsg = function() {
        var a = {};
        if (Va || !Va && !this.stats.incapacitated) {
            var b = this.walkForward != this.last.walkForward || this.walkSideward != this.last.walkSideward ? 0 : Va ? this.isAi ? 8 : .5 : .3;
            Za(this.position, this.last.position, "x", b, a, "x", 1), Za(this.position, this.last.position, "z", b, a, "z", 1);
            this.isAi || ($a(this, this.last, "walkForward", a, "wf"), $a(this, this.last, "walkSideward", a, "ws"), Za(this, this.last, "rotation", .08, a, "r", 2))
        }
        Va && ($a(this.state, this.last.state, "id", a, "s"), $a(this, this.last, "faction", a, "f"), _a(this, this.last, "name", a, "n"), _a(this, this.last, "id", a, "id"), _a(this, this.last, "clan", a, "c"), _a(this, this.last, "isAi", a, "ai") && (a.ai = 1 == a.ai ? 1 : 0), this.stats.parseStatChanges(a), $a(this.class, this.last.class, "level", a, "lvl"), _a(this.class, this.last.class, "type", a, "class"), _a(this.stats, this.last.stats, "invincible", a, "ivc"), _a(this.stats, this.last.stats, "incapacitated", a, "inc"), _a(this.stats, this.last.stats, "stunned", a, "stn"), _a(this, this.last, "combat", a, "cbt"), this.isAi ? ($a(this.class.ai, this.last.class.ai, "isresetting", a, "rs"), Za(this.class.ai, this.last.class.ai, "goalx", .1, a, "gx", 1), Za(this.class.ai, this.last.class.ai, "goalz", .1, a, "gz", 1)) : this.stats.incapacitated && this.lastPositionUpdate.copy(this.position), _a(this.visuals, this.last.visuals, "h", a, "vh")), (Va || this == Ic) && (this.target && this.target.id != this.last.target.id ? _a(this.target, this.last.target, "id", a, "tr") : void 0 == this.target && void 0 != this.last.target.id && (a.tr = "", this.last.target.id = void 0));
        for (var c in this.serverMsgQueue) this.serverMsgQueue.hasOwnProperty(c) && (a[c] = this.serverMsgQueue[c]);
        this.serverMsgQueue = {};
        var d = l(a);
        if (Va) {
            var e = Date.now();
            if (d) {
                if (!(e - this.lastserverheartbeat > 2e3)) return !1;
                this.lastserverheartbeat = e
            } else this.lastserverheartbeat = e
        } else {
            var e = Date.now();
            if (d) {
                if (!(e - this.last.updateTime > 2e3)) return !1;
                this.last.updateTime = e
            } else this.last.updateTime = e
        }
        return a
    }, j.prototype.parseDeltaMsg = function(a) {
        if (Va || !this.isPlayer) {
            var b = new THREE.Vector3;
            if (Va) {
                if (!this.stats.incapacitated && this.ignoreMovement <= 0) {
                    b.copy(this.position);
                    var c = ab(a, "x", "x", b),
                        d = ab(a, "z", "z", b);
                    (c || d) && this.verifyPosition(b)
                }
                a.hasOwnProperty("lus") && "number" == typeof a.lus && this.class.skills.hasOwnProperty(a.lus) && this.class.skills[a.lus].tryLevelUp()
            } else if (ab(a, "x", "x", b) && (this.last.position.x = this.position.x, this.position.x = this.next.position.x, this.next.position.x = b.x), ab(a, "z", "z", b) && (this.last.position.z = this.position.z, this.position.z = this.next.position.z, this.next.position.z = b.z), this.isAi) {
                bb(a, "isresetting", "rs", this.class.ai);
                var e = ab(a, "x", "gx", this.class.ai.goal),
                    f = ab(a, "z", "gz", this.class.ai.goal);
                (e || f) && (this.class.ai.hasReachedGoal = !1)
            }(!Va || Va && !this.stats.incapacitated) && (bb(a, "walkForward", "wf", this), bb(a, "walkSideward", "ws", this), ab(a, "rotation", "r", this), cb(a, "queuedAction", "a", this))
        }
        if ((Va || this != Ic) && a.hasOwnProperty("tr") && ("" == a.tr ? (this.target = void 0, Va || (this.desiredTarget = "")) : za.entities.hasOwnProperty(a.tr) ? (this.target = za.entities[a.tr], Va || (this.desiredTarget = "")) : Va || (this.desiredTarget = a.tr)), a.hasOwnProperty("ab"))
            for (var g = 0; g < a.ab.length; ++g) !Va && this == Ic && this.class.skills[a.ab[g]].simulate || this.useSkill(a.ab[g], !0);
        if (a.hasOwnProperty("abi"))
            for (var g = 0; g < a.abi.length; ++g) this.class.skills[a.abi[g]] && !this.class.skills[a.abi[g]].ignoreEc && (this.class.skills[a.abi[g]].interruptCast(), this.class.skills[a.abi[g]].interruptChannel());
        if (!Va) {
            if (cb(a, "invincible", "ivc", this.stats), cb(a, "incapacitated", "inc", this.stats), cb(a, "stunned", "stn", this.stats), a.hasOwnProperty("ec"))
                for (var g = 0; g < a.ec.length; ++g) this.class.skills.hasOwnProperty(a.ec[g]) && this.class.skills[a.ec[g]].endCast(!0);
            if (cb(a, "isAi", "ai", this), cb(a, "id", "id", this), a.hasOwnProperty("s") && a.s != this.state.id && (this.state = this.parseState(parseInt(a.s))), a.hasOwnProperty("f") && this.updateFaction(a.f), a.hasOwnProperty("c") && void 0 !== a.c && (this.clan = a.c, this.clansprite && this.clansprite._text != this.clan && (this.clansprite._fillStyle = 0 == this.faction ? "#8CD8FF" : "#FF8481", this.clansprite._text = this.clan.substring(0, 4), this.clansprite.updateText(), this == Ic && (this.namesprite.position.set(Math.round(.5 * this.clansprite.canvas.textWidth), 30, 0), this.clansprite.position.set(-Math.round(.5 * this.namesprite.canvas.textWidth + 5), 30, 0)))), a.hasOwnProperty("n") && (a.n && (this.name = a.n, this.namesprite && this.namesprite._text != this.name && (this.namesprite._text = this.name, this.namesprite.updateText())), this == Ic && Fb.charName.text(this.name)), bb(a, "clanrole", "clr", this), a.hasOwnProperty("d") && "true" == Pa.get("dmgnumbers"))
                for (var g = 0; g < a.d.length; ++g) this.createCombatText(a.d[g], g);
            if (Ic && this.faction == Ic.faction && "true" == Pa.get("dmgnumbers") && a.hasOwnProperty("hl"))
                for (var g = 0; g < a.hl.length; ++g) this.createCombatText(a.hl[g], g, !0);
            bb(a, "currentmp", "mp", this.stats), bb(a, "maxmp", "mmp", this.stats) && this.isPlayer && Fb.mp.text(this.stats.maxmp), bb(a, "currenthp", "h", this.stats), bb(a, "maxhp", "mh", this.stats) && this.isPlayer && Fb.hp.text(this.stats.maxhp), ab(a, "servermovespeed", "ms", this.stats) && this.isPlayer && Fb.ms.text(this.stats.servermovespeed);
            var h = this.class.level;
            if (bb(a, "level", "lvl", this.class) && (this == Ic && h < this.class.level && (Y({
                    msg: "You have reached level " + this.class.level + "!",
                    src: "system"
                }), Fb.lvl.text(this.class.level)), this.levelsprite._text = this.class.level, this.levelsprite.updateText(), Ic && (this != Ic ? this.canFightPlayer = ib(this, Ic).canFight() : od())), this.isPlayer) {
                bb(a, "gold", "g", this), a.g && cc.gold.text(a.g), a.gd && Y({
                    msg: (a.gd > 0 ? "Gained " : "Lost ") + Math.abs(a.gd) + " $g",
                    src: "loot"
                }), this.class && a.sl && this.class.skills.hasOwnProperty(a.sl.i) && (this.class.skills[a.sl.i].setLevel(a.sl.l), jc($("#skillLevelButton" + a.sl.i), a.sl.i), Y({
                    msg: this.class.skills[a.sl.i].name + " raised to ability level " + a.sl.l + "!",
                    src: "system"
                })), a.dexp && Y({
                    msg: (a.dexp > 0 ? "Gained " : "Lost ") + Math.abs(a.dexp) + " experience.",
                    src: "exp"
                });
                var i = bb(a, "exp", "exp", this.class),
                    j = bb(a, "nextLevelExp", "nxp", this.class);
                (i || j) && W();
                var k = bb(a, "fame", "fm", this);
                k && Fb.fame.text(this.fame), a.dfm && Y({
                    msg: (parseInt(a.dfm) > 0 ? "Earned " : "Lost ") + Math.abs(a.dfm) + " fame. ( You have " + this.fame + " fame)",
                    src: "exp"
                }), ab(a, "x", "x", this.serverpos), ab(a, "z", "z", this.serverpos), this.stats.incapacitated && (this.position.copy(this.serverpos), this.visualPosition.copy(this.position), bb(a, "walkForward", "wf", this), bb(a, "walkSideward", "ws", this)), a.hasOwnProperty("r") && Math.abs(E(this.geometry.rotation.y, a.r)) > .9 * Math.PI && (this.rotation = a.r, this.geometry.rotation.y = this.rotation);
                var l = ab(a, "x", "hrx", this.position),
                    m = ab(a, "z", "hrz", this.position);
                (l || m) && (this.serverpos.copy(this.position), this.visualPosition.copy(this.position)), void 0 !== a.hpr && Fb.hpr.text(a.hpr + "/s"), void 0 !== a.mpr && Fb.mpr.text(a.mpr + "/s"), void 0 === a.mid && void 0 === a.mad || (void 0 !== a.mid && (Fb.mid = a.mid), void 0 !== a.mad && (Fb.mad = a.mad), Fb.power.text(Fb.mid + " - " + Fb.mad)), void 0 !== a.cr && Fb.crit.text(a.cr + "%"), void 0 !== a.def && Fb.def.text(a.def)
            }
            if (a.hasOwnProperty("class") && a.class != this.class.type) {
                var n = this.class ? this.class.nextLevelExp : void 0;
                switch (a.class) {
                    case "warrior":
                        this.class = new R(this.class.level);
                        break;
                    case "shaman":
                        this.class = new U(this.class.level);
                        break;
                    case "mage":
                        this.class = new S(this.class.level);
                        break;
                    case "archer":
                        this.class = new T(this.class.level);
                        break;
                    case "mob_sword":
                        this.class = new O(this.class.level), this.isAi = !0;
                        break;
                    case "mob_bow":
                        this.class = new P(this.class.level), this.isAi = !0;
                        break;
                    case "mob_slime":
                        this.class = new Q(this.class.level), this.isAi = !0;
                        break;
                    case "king":
                        this.class = L(), this.isAi = !0;
                        break;
                    case "warden":
                        this.class = M(), this.isAi = !0;
                        break;
                    case "vendor":
                        this.class = N();
                        break;
                    default:
                        console.log("warning: unknown class: " + a.class)
                }
                this.isAi && (this.class.ai.class = this.class, this.class.ai.parent = this), this.class.stats = this.stats, this.class.parent = this, this.class.initBaseBody.call(this), this.class.initBodyGeometry.call(this), this.class.update(), this.stats.spawn(), this.hasParsedClass = !0, this.body.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), n && (this.class.nextLevelExp = n), Va || this != Ic || (this.class.skills[1].configureUiElements($("#skillIcon1"), $("#skillOverlay1"), $("#skillCooldown1")), this.class.skills[2].configureUiElements($("#skillIcon2"), $("#skillOverlay2"), $("#skillCooldown2")), this.class.skills[3].configureUiElements($("#skillIcon3"), $("#skillOverlay3"), $("#skillCooldown3")), this.class.skills[4].configureUiElements($("#skillIcon4"), $("#skillOverlay4"), $("#skillCooldown4")), this.class.skills[1].setInfoPanel("skill1"), this.class.skills[2].setInfoPanel("skill2"), this.class.skills[3].setInfoPanel("skill3"), this.class.skills[4].setInfoPanel("skill4"), Fb.charImg.attr("src", "data/class/class_" + this.class.type + ".png"))
            }
            bb(a, "h", "vh", this.visuals) && this.updateVisual("h")
        }
    }, j.prototype.parseState = function(a) {
        switch (a) {
            case 0:
                return this.chest.material = this.class.color, new A;
            case 2:
                return this.animationQueue[0] = new V({
                    id: "dead",
                    type: "static",
                    duration: 5
                }), Va || this == Ic && (Y({
                    msg: "You have died and lost exp.",
                    src: "death"
                }), $("#deathScreen").fadeIn(400)), new C;
            default:
                return this.state
        }
    }, j.prototype.canSellToTrader = function() {
        if (void 0 !== this.target && void 0 !== this.target.class && "vendor" == this.target.class.type) {
            var a = ib(this, this.target);
            if (void 0 !== a) {
                var b = a.distance();
                if (void 0 !== b && b < 3) return !0
            }
        }
        return !1
    };
    var Za = function(a, b, c, d, e, f, g) {
            return (Math.abs(a[c] - b[c]) > d || void 0 === b[c]) && (e[f] = parseFloat(a[c]).toFixed(g), b[c] = a[c], !0)
        },
        $a = function(a, b, c, d, e) {
            return a[c] !== b[c] && (d[e] = parseInt(a[c]), b[c] = a[c], !0)
        },
        _a = function(a, b, c, d, e) {
            return a[c] !== b[c] && (d[e] = a[c], b[c] = a[c], !0)
        },
        ab = function(a, b, c, d) {
            return !!a.hasOwnProperty(c) && (d[b] = parseFloat(a[c]), !0)
        },
        bb = function(a, b, c, d) {
            return !!a.hasOwnProperty(c) && (d[b] = parseInt(a[c]), !0)
        },
        cb = function(a, b, c, d) {
            return !!a.hasOwnProperty(c) && (d[b] = a[c], !0)
        },
        db = {
            linear: function(a) {
                return a
            },
            easeInQuad: function(a) {
                return a * a
            },
            easeOutQuad: function(a) {
                return a * (2 - a)
            },
            easeInOutQuad: function(a) {
                return a < .5 ? 2 * a * a : -1 + (4 - 2 * a) * a
            },
            easeInCubic: function(a) {
                return a * a * a
            },
            easeOutCubic: function(a) {
                return --a * a * a + 1
            },
            easeInOutCubic: function(a) {
                return a < .5 ? 4 * a * a * a : (a - 1) * (2 * a - 2) * (2 * a - 2) + 1
            },
            easeInQuart: function(a) {
                return a * a * a * a
            },
            easeOutQuart: function(a) {
                return 1 - --a * a * a * a
            },
            easeInOutQuart: function(a) {
                return a < .5 ? 8 * a * a * a * a : 1 - 8 * --a * a * a * a
            },
            easeInQuint: function(a) {
                return a * a * a * a * a
            },
            easeOutQuint: function(a) {
                return 1 + --a * a * a * a * a
            },
            easeInOutQuint: function(a) {
                return a < .5 ? 16 * a * a * a * a * a : 1 + 16 * --a * a * a * a * a
            }
        },
        eb = function(a) {
            return a[Math.floor(Math.random() * a.length)]
        },
        fb = new Object,
        gb = function() {
            for (var a in fb) {
                var b = fb[a];
                void 0 !== b && (kb(b.a) && kb(b.b) && (!Va || lb(b.a, b.b)) ? b.clearIntervalData() : delete fb[a])
            }
        };
    o.prototype.distance = function() {
        return void 0 === this._distance ? (this._distance = Math.max(0, J(this.a, this.b) - (this.a.stats.scale + this.b.stats.scale)), this._distance) : this._distance
    }, o.prototype.aggro = function(a) {
        return this.a == a ? this.aggroA : this.aggroB
    }, o.prototype.modifyAggro = function(a, b) {
        a == this.a ? this.aggroA += b : this.aggroB += b
    }, o.prototype.resetAggro = function(a) {
        a == this.a ? this.aggroA = 0 : this.aggroB = 0
    }, o.prototype.canFight = function() {
        if (void 0 !== this._canFight) return this._canFight;
        if (this._canFight = !0, Va && (this.a.isAi && 1 == this.a.class.ai.isresetting && (this._canFight = !1), this.b.isAi && 1 == this.b.class.ai.isresetting && (this._canFight = !1)), !this.a.isAi && !this.b.isAi) {
            var a = Math.min(this.a.class.level, this.b.class.level),
                b = Math.max(this.a.class.level, this.b.class.level);
            b > 1.8 * Math.max(3, a) + 2 && (this._canFight = !1)
        }
        return this._canFight
    }, o.prototype.expShare = function(a) {
        return a == this.a ? this.expShareA : a == this.b ? this.expShareB : void 0
    }, o.prototype.modifyExpShare = function(a, b) {
        a == this.a && (this.expShareA += b), a == this.b && (this.expShareB += b)
    }, o.prototype.clearIntervalData = function() {
        this._distance = void 0, this._canFight = void 0
    };
    var hb = function(a, b) {
            return a.id < b.id ? a.id + "," + b.id : b.id + "," + a.id
        },
        ib = function(a, b) {
            if (void 0 === a || void 0 === b || a == b) return null;
            var c = hb(a, b);
            return void 0 === fb[c] && (fb[c] = new o(a, b)), fb[c]
        },
        jb = function(a) {},
        kb = function(a) {
            if (void 0 == a) return !1;
            if (Va) {
                if (a.isAi || a.class.idleAi ? void 0 == za.npcs[a.id] : void 0 == za.players[a.id]) return !1
            } else if (void 0 == za.entities[a.id]) return !1;
            return !0
        },
        lb = function(a, b) {
            if (void 0 != a && void 0 != b) {
                var c = getChunkCoord(a.position),
                    d = getChunkCoord(b.position);
                return Math.abs(c.x - d.x) < 2 && Math.abs(c.z - d.z) < 2
            }
        },
        mb = {};
    mb.damage = function(a) {
        var b = a.scaledmg || 1,
            c = a.spread || .1,
            d = a.basedmg || 1,
            e = a.attacker || void 0,
            f = a.target || void 0,
            g = a.mode || "single",
            h = a.aoeCenter || void 0,
            i = a.aoeRange || 1,
            j = a.aoeArc || void 0,
            k = a.heal || !1,
            l = a.buff || !1,
            m = a.debuff || !1,
            n = "aoe" == g ? Va ? getChunk(e ? e.position : h).entities : Kc : void 0,
            o = a.mod || void 0,
            p = a.aggro || 1,
            q = a.targetFun || void 0,
            r = a.aoeFun || void 0;
        if (e || "aoe" != g || h) {
            var s = [];
            if (!f || e && f.faction != e.faction && !ib(e, f).canFight() || s.push(f), "aoe" == g && n)
                for (var t = 0; t < n.length; ++t) {
                    var u = n[t];
                    if (!(void 0 === u || u.stats.isDead() || e && (k || l ? u.faction != e.faction : u.faction == e.faction || !ib(e, u).canFight()))) {
                        if (j && e) {
                            var v = E(e.rotation, G(e.position, u.position));
                            if (Math.abs(v) > j) continue
                        }
                        var w = void 0;
                        w = h ? I(u, h) : u == e ? 0 : ib(u, e).distance(), void 0 != w && w < i && s.push(u)
                    }
                }
            for (var x = 0; x < s.length; ++x) {
                if (!l && !m) {
                    var z = Math.max(0, (d + (e.stats.currentmindmg + (e.stats.currentmaxdmg - e.stats.currentmindmg) * Math.random()) * b) * (1 + (Math.random() - .5) * c));
                    Math.random() < e.stats.crit / 100 && (z *= 2.5), k ? s[x].takeHealing(z, e) : s[x].takeDamage(z, e, p)
                }
                void 0 != o && s[x].stats.addMod(new y(s[x], e, o)), q && q(s[x], e)
            }
            r && r(s, e)
        }
    }, mb.interrupt = function(a, b) {
        if (ib(b, a).canFight())
            for (skill in a.class.skills) a.class.skills.hasOwnProperty(skill) && a.class.skills[skill].interruptCast()
    };
    var nb = {};
    p.prototype.clientInit = function(a) {
        void 0 !== a.x && void 0 !== a.z && void 0 !== a.t && void 0 !== a.i && (this.drop = !0, this.position = {
            x: parseFloat(a.x),
            z: parseFloat(a.z)
        }, this.id = a.i, this.type = a.t, this.identifier = ya[this.type].type, this.name = ya[this.type].name[a.o], this.spritename = this.identifier + ("g" == this.type ? "" : a.o), this.timeout = Date.now() + 1e3 * parseInt(a.m), this.ownerid = a.k)
    }, p.prototype.destroy = function() {
        this.quad && Ac.remove(this.quad), this.shadow && Ac.remove(this.shadow), void 0 !== nb[this.id] && (nb[this.id] = void 0, delete nb[this.id])
    }, p.prototype.tick = function(a, b) {
        this.createModel(b), void 0 !== this.quad && Wc.push(this.quad), this.timeout < b && this.destroy()
    }, p.prototype.getInfoPanelString = function() {
        return "<div class='targetinfo targettext ally'><span class='targetname'>" + this.name + "</span></div> Item"
    }, p.prototype.createModel = function(a) {
        if (void 0 === this.quad && !(void 0 === Ic || void 0 !== this.ownerid && "" != this.ownerid && this.ownerid != Ic.id && this.timeout - a > 105e3)) {
            this.quad = new THREE.Mesh(kd.items[("g" == this.type ? "" : this.identifier + "/") + this.spritename], Vc.item), this.quad.position.set(this.position.x, Qc(this.position.x, this.position.z) + ("g" == this.type ? .15 : .2 + .1 * Math.random()), this.position.z);
            var b = Rc(this.position.x, this.position.z);
            b.y < 0 && (b.y *= -1, b.x *= -1, b.z *= -1), b.x += this.quad.position.x, b.y += this.quad.position.y, b.z += this.quad.position.z, this.quad.lookAt(b), this.quad.rotation.z = Math.random() * Ua, Ac.add(this.quad), this.quad.entity = this
        }
    };
    var ob = 0;
    p.prototype.requestPickUp = function() {
        var a = Date.now();
        !Ic || a - ob < 500 || n(this.position, Ic.position) < 4 && (ob = a, wd.emit("d", {
            i: this.id
        }))
    };
    var pb, qb = function(a) {
            var b = Date.now(),
                c = 1.2 + .13 * Math.sin(b / 90);
            Vc.item.color.r = c, Vc.item.color.g = c, Vc.item.color.b = c;
            for (var d in nb) nb.hasOwnProperty(d) && nb[d].tick(a, b)
        },
        rb = void 0,
        sb = function(a) {
            if (rb = a, void 0 === a || a.none) $("#claninfo").hide(), $("#clancreation").show();
            else if (void 0 !== Ic) {
                a.n && a.f && (a.fn = a.n + " <small> " + (0 == a.f ? "Vanguard Clan" : "Bloodlust Clan") + "</small>"), tb(a, "fn", "c-name"), tb(a, "m", "c-mcount"), tb(a, "t", "c-tag");
                var b = $("#clanmembers");
                b.html(""), a.b.forEach(function(a) {
                    $("<tr><td><img class='classicon' src='data/" + vb[a.c] + ".png'> " + a.n + " </td><td class='detailText'>" + ub[a.r] + (a.r < 2 && Ic.clanrole >= 2 ? " <input data-kick='" + a.n + "' class='clanchange' type='checkbox'" + (a.r > 0 ? "checked" : "") + ">" : "") + "</td><td class='detailText'>" + a.f + " fame</td><td class='detailText'>Lv. " + a.l + "</td><td class='detailText'>" + (1 == a.o ? "Online" : "Offline") + "</td> <td class='detailText'>" + (a.r < Ic.clanrole ? "<button type='button' data-kick='" + a.n + "' class='close clankick' style='font-size:1.0em'><span>&times;</span>" : "") + "</button></td></tr>").appendTo(b)
                }), $(".clankick").on("click", function() {
                    wd.emit("ca", {
                        a: "kick",
                        m: this.dataset.kick
                    })
                }), $(".clanchange").on("click", function() {
                    return wd.emit("ca", {
                        a: "change",
                        m: this.dataset.kick
                    }), !1
                }), 3 == Ic.clanrole ? $("#disbandClanButton").show() : $("#disbandClanButton").hide(), $("#claninfo").show(), $("#clancreation").hide()
            }
        },
        tb = function(a, b, c) {
            void 0 !== a[b] && (document.getElementById(c).innerHTML = a[b])
        },
        ub = ["Member", "Officer", "Leader", "Owner"],
        vb = ["warrior", "mage", "archer", "shaman"],
        wb = {},
        xb = {},
        yb = function(a) {
            for (i in a) {
                var b = a[i];
                if (b.del) wb[i] && (void 0 !== b.g && (bb(b, "gold", "g", Ic), void 0 !== b.g && cc.gold.text(b.g), void 0 !== b.gd && Y({
                    msg: "Sold " + wb[i].name + " for " + b.gd + " $g",
                    src: "loot"
                })), delete xb[wb[i].l], delete wb[i]);
                else if (b.mod) {
                    if (void 0 !== wb[i]) {
                        var c = wb[i].l,
                            d = b.l;
                        void 0 !== b.l && (xb[c] === wb[i] && (xb[c] = void 0), wb[i].l = d, xb[d] = wb[i])
                    }
                } else {
                    if (wb[i] = b, wb[i].worth = b.w, wb[i].name = ya[b.u].name[b.t], wb[i].img = ya[b.u].type + "" + b.t + ".png", wb[i].classReqString = "", ya[b.u].class)
                        for (var e = 0; e < ya[b.u].class.length; ++e) wb[i].classReqString += t(ya[b.u].class[e] + (e < ya[b.u].class.length - 1 ? ", " : ""));
                    if (b.s) {
//THE GREAT WALL OF LEGUSX
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//b is the item variable
                    var swords = ["Wooden Sword","Rusty Ironsword", "Troll Blade", "Broadsword ", "Longsword", "Carved Bonesword", "Greatsword", "Ghastly Scimitar", "Nullfire Sword", "Knight's Greatsword", "King's Glaive", "Void Blade", "Zerstrer","Hearteater", "Demonedge", "Excalibur", "Harbinger"]
                    var swordmaxdmg = ["4-6","5-8","9-14","12-19","16-25","21-32","24-38","28-43","32-49","36-55","40-61","43-66","47-72","51-78","55-84","58-89","62-95"]
                    var swordcrit = ["2.1","2.4","3.1","3.8","4.5","5.4","6.1","6.8","7.5","8.2","9","9.7","10.4","11.1","11.8","12.6","13.3"]
                    var talismans = ["Smelly Talisman", "Guided Talisman", "Ocean Talisman", "Qui'ton", "Dimension Talisman"]
                    var talimp = ["11", "35", "59", "83", "107"]
                    var talimpregen = ["0.8", "2.8", "4.8", "6.8", "8.8"]
                    var shields = ["Wooden Shield", "Buckler", "Old Bulwark", "Metal Guard", "Protecteron"]
                    var shielddef = ["17", "31", "55", "91", "121"]
                    var shieldhp = ["9", "13", "21", "33", "43"]
                    var shieldhpregen = ["0.2", "0.8", "1.8", "3.3", "4.5"]
                    var quivers = ["Linen Quiver", "Reinforced Quiver", "Last Reserves", "Lotharien", "Snake Quiver"]
                    var quivercrit = ["0.9", "2.5", "4.1", "5.7", "7.3"]
                    var quivermv = ["0.3", "0.9", "1.5", "2.1", "2.7"]
                    var rings = ["Woven Band", "Ironbark Circlet", "Brass Ringlet", "Hollowed Bone", "Elven Band", "Imbued Circlet", "Arcane Ring", "Emerald Band", "Infernal Ring", "Ancient Talisman", "Hallowed Relic", "Cantor's Trinket", "Peacekeeper"]
                    var ringhpregen = ["0.2", "0.4", "0.8", "1.3", "1.7", "2.2", "2.7", "3.2", "3.6", "4.1"]
                    var ringmpregen = ["0.2", "0.4", "0.8", "1.3", "1.7", "2.2", "2.7", "3.2", "3.6", "4.1"]
                    var boots = ["Sandals", "Cloth Footpads", "Leather Boots", "Bone Greaves", "Scaled Treads", "Patterned Greaves", "Wartorn Boots", "Imbued Treads", "Skyswift Boots", "Coldforged Greaves", "Cloudrunner Treads", "Boots of Hermes", "Starshard Greaves"]
                    var bootdef = ["2", "4", "7", "9", "12", "15", "18", "21", "23", "26"]
                    var boothp = ["3", "5", "8", "10", "13", "16", "19", "22", "24", "27"]
                    var bootmv = ["0.1", "0.2", "0.4", "0.6", "0.8", "0.9", "1.2", "1.3", "1.5", "1.7"]
                    var braclets = ["Simple Bracelet", "Makeshift Brace", "Leather Armlet", "Ivory Bracelet", "Iron Vambrace", "Imbued Bracers", "Ember Cuffs", "Mirrored Armlet", "Golem Fragment", "Coldforged Bracer", "Blackstar Gem", "Eternal Vambraces", "Lost Guardian"]
                    var bracletdef = ["2", "5", "8", "12", "16", "19", "24", "27", "31", "34"]
                    var braclethp = ["3", "5", "8", "11", "13", "16", "19", "22", "25", "27"]
                    var bracletmp = ["6", "12", "21", "30", "39", "48", "59", "68", "77", "86"]
                    var bracletmpregen = ["0.3", "0.6", "1", "1.5", "1.9", "2.4", "2.9", "3.4", "3.8", "4.3"]
                    var gloves = ["Hand Wraps", "Cloth Mitts", "Leather Gloves", "Bone Grips", "Iron Gauntlets", "Imbued Gloves", "Wartorn Mitts", "Fiery Handguards", "Gloves of Empowerment ", "Coldforged Fists", "Eternal Gauntlets", "Gloves of Midas", "Titan's Mitts"]
                    var glovedef = ["2", "4", "7", "10", "13", "15", "19", "21", "24", "27"]
                    var glovecrit = ["0.3", "0.6", "1.1", "1.5", "2", "2.4", "3", "3.4", "3.9", "4.3"]
                    var glovehp = ["3", "6", "10", "13", "17", "21", "25", "29", "32", "36"]
                    var armor = ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather", "Scaled Chestguard", "Sky Cloak", "Shadow Cloak", "Obsidian Cloak", "Hellfire Cloak", "Soulkeeper", "Deathless"]
                    var armordef = ["6", "13", "21", "29", "37", "46", "55", "64", "72", "80", "88"]
                    var armorhp = ["11", "21", "32", "42", "53", "64", "77", "88", "99", "110", "120"]
                    var armorhpregen = ["0.6", "1.4", "1.9", "2.3", "2.8", "3.3", "3.8", "4.2", "4.7", "5.1"]
                    var bows = ["Driftwood Shortbow", "Novice Shortbow", "Curved Shortbow", "Adventurer's Shortbow", "Long Bow", "Bone Bow", "Elven Bow", "Ancient Bow", "Iron Piercer", "Silver Recurve", "Assassin's Bow", "Skyfire Warbow", "Hellfire Warbow", "Widowmaker", "Stormsong", "Scarebow", "Fury"]
                    var bowmaxdmg = ["2-4","5-9","9-15","14-21","18-27","23-34","27-40","31-46","35-52","40-57","44-63","48-69","52-75","56-81","61-87","65-93","69-99"]
                    var bowcrit = ["3.2", "3.9", "4.8", "5.7", "6.6", "7.7", "8.6", "9.5", "10.4", "11.3", "12.2", "13.1", "14", "14.9", "15.8", "16.7", "17.6"]
                    var hammers = ["Splintered Club", "Wooden Mallet", "Rusty Flail", "Orcish Bludgeon", "Heavy Mace", "Iron Basher", "Darkmetal Maul", "Divine Gavel", "Hallowed Hammer", "Dwarfen Maul", "Coldforged Gavel", "Amboss", "Skullshatterer", "Benevolence ", "Hammer of Gaia", "Worldender", "Nightmare"]
                    var hammermaxdmg = ["2-5","4-8","8-13","11-18","15-22","19-28","23-33","26-38","30-42","33-47","37-52","41-57","44-62","48-66","51-71","55-76","59-81"]
                    var hammermpregen = ["1.1", "1.3", "1.6", "1.9", "2.2", "2.5", "2.8", "3.1", "3.4", "3.7", "4", "4.3", "4.6", "4.9", "5.2", "5.5", "5.8"]
                    var staffs = ["Broken Twig", "Cracked Stick", "Gnarled Broomstick", "Oak Stave", "Mystic Wand", "Bone Stave", "Encrusted Rod", "Imbued Staff", "Emerald Staff", "Sapphire Staff", "Frozen Greatstaff", "Infernal Staff", "Hellfire Greatsaff", "Staff of Angelness ", "Crystal Core", "Witch's Heart", "Deathweaver"]
                    var staffmaxdmg = ["3-4","5-8","10-16","15-24","20-32","25-41","30-49","35-57","40-65","45-73","50-81","55-89","60-97","64-105","69-113","74-120","79-128"]
                    var staffcrit = ["2.1", "2.4", "3", "3.6", "4.2", "4.9", "5.5", "6.1", "6.7", "7.3", "7.9", "8.5", "9.1", "9.7", "10.3", "10.9", "11.5"]
                    var staffmp = ["6", "8", "13", "18", "23", "28", "33", "38", "43", "47", "52", "57", "62", "67", "71", "76", "81"]
                    var staffmpregen = ["0.6", "0.7", "1", "1.3", "1.6", "2", "2.3", "2.6", "2.9", "3.2", "3.5", "3.8", "4.1", "4.4", "4.7", "5", "5.3"]
                    	var xItem = {}
                        if (swords.includes(b.name)) {
                          xItem.dmg = swordmaxdmg[swords.indexOf(b.name)]
                          xItem.crit = swordcrit[swords.indexOf(b.name)]
                        } else if (talismans.includes(b.name)) {
                          xItem.mp = talimp[talismans.indexOf(b.name)]
                          xItem.mpregen = talimpregen[talismans.indexOf(b.name)]
                        } else if (shields.includes(b.name)) {  
                          xItem.def = shielddef[shields.indexOf(b.name)]
                          xItem.hp = shieldhp[shields.indexOf(b.name)]
                          xItem.hpregen = shieldhpregen[shields.indexOf(b.name)]
                        } else if (quivers.includes(b.name)) {  
                          xItem.crit = quivercrit[quivers.indexOf(b.name)]
                          xItem.mv = quivermv[quivers.indexOf(b.name)]
                        } else if (rings.includes(b.name)) { 
                          xItem.hpregen = ringhpregen[rings.indexOf(b.name)]
                          xItem.mpregen = ringmpregen[rings.indexOf(b.name)]
                        } else if (boots.includes(b.name)) { 
                          xItem.def = bootdef[boots.indexOf(b.name)]
                          xItem.hp = boothp[boots.indexOf(b.name)]
                          xItem.mv = bootmv[boots.indexOf(b.name)]
                        } else if (braclets.includes(b.name)) {
                          xItem.def = bracletdef[braclets.indexOf(b.name)]
                          xItem.hp = braclethp[braclets.indexOf(b.name)]
                          xItem.mp = bracletmp[braclets.indexOf(b.name)]
                          xItem.mpregen = bracletmpregen[braclets.indexOf(b.name)]
                        } else if (gloves.includes(b.name)) {
                          xItem.def = glovedef[gloves.indexOf(b.name)]
                          xItem.crit = glovecrit[gloves.indexOf(b.name)]
                          xItem.hp = glovehp[gloves.indexOf(b.name)]
                        } else if (armor.includes(b.name)) {
                          xItem.hp = armorhp[armor.indexOf(b.name)]
                          xItem.def = armordef[armor.indexOf(b.name)]
                          xItem.hpregen = armorhpregen[armor.indexOf(b.name)]
                        } else if (bows.includes(b.name)) {
                          xItem.dmg = bowmaxdmg[bows.indexOf(b.name)]
                          xItem.crit = bowcrit[bows.indexOf(b.name)]
                        } else if (hammers.includes(b.name)) {
                          xItem.dmg = hammermaxdmg[hammers.indexOf(b.name)]
                          xItem.mpregen = hammermpregen[hammers.indexOf(b.name)]
                        } else if (staffs.includes(b.name)) {
                          xItem.dmg = staffmaxdmg[staffs.indexOf(b.name)]
                          xItem.crit = staffcrit[staffs.indexOf(b.name)]
                          xItem.mp = staffmp[staffs.indexOf(b.name)]
                          xItem.mpregen = staffmpregen[staffs.indexOf(b.name)]
                        } else {
                          xItem.dmg = "???"
                          xItem.def = "???"
                          xItem.hp = "???"
                          xItem.hpregen = "???"
                          xItem.mp = "???"
                          xItem.mpregen = "???"
                          xItem.crit = "???"
                        }
                        var f = "";
						window.b = b;
						window.xItem = xItem;
						b.s.dmgtext = b.s.mindmg + "-" +b.s.maxdmg;
                        b.s.mindmg && b.s.maxdmg && (f += "<span "+((b.s.dmgtext == xItem.dmg) ? 'style="color: #ffbd24;">' : ">") +b.s.mindmg + " - " + b.s.maxdmg + " Damage</span> <span><em>Max: "+xItem.dmg+"</em></span><br>"), b.s.def && (f += "<span "+((b.s.def == xItem.def) ? 'style="color: #ffbd24;">' : ">")+b.s.def + " Defense</span> <span><em>Max: "+xItem.def+"</em></span><br>"), b.s.hp && (f += "<span "+((b.s.hp == xItem.hp) ? "style='color: #ffbd24;'>" : ">")+b.s.hp + " HP</span> <span><em>Max: "+xItem.hp+"</em></span><br>"), b.s.hpreg && (f += "<span "+((b.s.hpreg == xItem.hpregen) ? 'style="color: #ffbd24;">' : ">")+b.s.hpreg + "/s HP Reg.</span> <span><em>Max: "+xItem.hpregen+"</em></span><br>"), b.s.mp && (f += "<span "+((b.s.mp == xItem.mp) ? 'style="color: #ffbd24;">' : ">")+b.s.mp + " MP</span> <span><em>Max: "+xItem.mp+"</em></span><br>"), b.s.mpreg && (f += "<span "+((b.s.mpreg == xItem.mpregen) ? 'style="color: #ffbd24;">' : ">")+b.s.mpreg + "/s MP Reg.</span> <span><em>Max: "+xItem.mpregen+"</em></span><br>"), b.s.crit && (f += "<span "+((b.s.crit == xItem.crit) ? 'style="color: #ffbd24;">' : ">")+b.s.crit + "% Critical</span> <span><em>Max: "+xItem.crit+"%</em></span><br>"), b.s.move && (f += "<span "+((b.s.move == xItem.mv) ? 'style="color: #ffbd24;">' : ">")+b.s.move + " Move speed</span> <span><em>Max: "+xItem.mv+"</em></span>"), wb[i].statText = f
                    }
                    wb[i].minlvl = ya[b.u].lvl[b.t], wb[i].l && (xb[wb[i].l] = wb[i])
                }
            }
            Ib()
        },
        zb = function(a, b) {
            void 0 !== xb[a] && void 0 === Db && (Db = xb[a], Eb.css("display", "block"), Eb.html($(b.firstChild).clone()))
        },
        Ab = function() {
            Eb.css("display", "none"), Db = void 0
        },
        Bb = 21,
        Cb = {},
        Db = void 0,
        Eb = void 0,
        Fb = {},
        Gb = function() {
            Eb = $("#mouseItemDiv"), $(".uiclosebutton").click(function(a) {
                $(this).parent().hide()
            }), Cb = {}, window.addEventListener("mouseup", q, !1), Pb(document.getElementById("characterpanel")), Pb(document.getElementById("inventory"));
            var a = $("#character-items");
            a.html(""), xa.forEach(function(b) {
                var c = $("<div/>");
                Cb[b] = c, c.appendTo(a)
            });
            var b = $("#inventory-items");
            b.html("");
            for (var c = 0; c < Bb; ++c) {
                var d = $("<div/>");
                Cb[c] = d, d.appendTo(b)
            }
            for (c in Cb) Cb[c].mouseover({
                slot: c
            }, function(a) {
                var b = xb[a.data.slot];
                if (b) {
                    var c = this.getBoundingClientRect();
                    c.left < 200 ? (pb.css("left", c.left - 2), pb.css("right", "")) : (pb.css("right", za.width - c.left - 2), pb.css("left", "")), pb.css("bottom", za.height - c.top - 2), Jb.itemname.text(b.name), Jb.description.text(ya[b.u].description), b.statText ? (Jb.stats.html(b.statText), Jb.stats.css("display", "block")) : Jb.stats.css("display", "none"), Jb.requirements.html(""), Jb.requirements.append("<span class='" + (Ic.class.level >= b.minlvl ? "statReq" : "statReqMiss") + "'> Requires level " + b.minlvl + " </span>" + ("" != b.classReqString ? "<br><span class='" + (ya[b.u].class.indexOf(Ic.class.type) > -1 ? "statReq" : "statReqMiss") + "'> Class: " + b.classReqString + " </span>" : "") + "<h5 class='detailText'> Sells for " + b.worth + " <img src='data/coin.png' class='goldCoin'></h5>"), pb.css("display", "block")
                } else pb.css("display", "none");
                return !1
            }), Cb[c].mouseout({
                slot: c
            }, function(a) {
                return pb.css("display", "none"), 1 == a.buttons && zb(a.data.slot, this), !1
            }), Cb[c].mousedown({
                slot: c
            }, function(a) {
                return 0 == a.button, !1
            }), Cb[c].mouseup({
                slot: c
            }, function(a) {
                0 === a.which || 0 === a.button ? void 0 === Db ? zb(a.data.slot, this) : (wd.emit("i", {
                    i: Db.l,
                    a: "m",
                    t: a.data.slot
                }), Ab()) : 3 !== a.which && 2 !== a.button || wd.emit("i", {
                    i: a.data.slot,
                    a: Lb ? "s" : "u"
                })
            });
            var e = $("<div/>", {
                id: "character-icon"
            });
            e.appendTo(a), Fb.charName = $("<h4/>"), Fb.charName.appendTo(e),
                Fb.charImg = $("<img/>", {
                    class: "charPanelIcon"
                }), Fb.charImg.appendTo(e), Fb.power = $("#stat_power"), Fb.crit = $("#stat_crit"), Fb.def = $("#stat_def"), Fb.hp = $("#stat_hp"), Fb.hpr = $("#stat_hpr"), Fb.mp = $("#stat_mp"), Fb.mpr = $("#stat_mpr"), Fb.ms = $("#stat_ms"), Fb.lvl = $("#stat_lvl"), Fb.fame = $("#stat_fame"), Kb(), Ib(), $("#invtrashcan, #trader").mouseup({
                    slot: c
                }, function(a) {
                    void 0 !== Db && (wd.emit("i", {
                        i: Db.l,
                        a: Lb ? "s" : "t"
                    }), Ab())
                })
        },
        Hb = function() {
            for (i in wb) delete xb[wb[i].l], delete wb[i]
        },
        Ib = function() {
            for (s in Cb)
                if (void 0 !== xb[s]) {
                    Cb[s].get(0).className = "item" + (isNaN(s) ? " equipslot slot_" + s + " clearslot" : "");
                    var a = $("<img/>", {
                        class: ya[xb[s].u].rotatedSprite ? "itemPic itemPicRotated" : "itemPic"
                    });
                    a.attr("src", "data/items/" + xb[s].img), Cb[s].html(a), Cb[s].item = xb[s]
                } else Cb[s].get(0).className = "itemEmpty" + (isNaN(s) ? " equipslot slot_" + s : ""), Cb[s].html(""), Cb[s].item = void 0
        },
        Jb = {},
        Kb = function() {
            pb = $("#itemview"), Jb.itemname = $("<p/>", {
                class: "itemName"
            }), pb.append(Jb.itemname), Jb.description = $("<p/>", {
                class: "itemDescription"
            }), pb.append(Jb.description), Jb.stats = $("<p/>", {
                class: "itemStat"
            }), pb.append(Jb.stats), Jb.requirements = $("<p/>", {
                class: "itemRequirements"
            }), pb.append(Jb.requirements)
        },
        Lb = !1,
        Mb = void 0,
        Nb = 0,
        Ob = 0,
        Pb = function(a) {
            a.addEventListener("mousedown", function(b) {
                Mb = a, Nb = b.pageX - $(this).offset().left, Ob = b.pageY - $(this).offset().top, window.addEventListener("mousemove", r, !0)
            }, !1)
        },
        Qb = [],
        Rb = function(a) {
            for (var b = Qb.length; b--;) {
                var c = Qb[b];
                c.tick(a), c.deleteMe && (c.remove(), Qb.splice(b, 1))
            }
        };
    Va || (u.prototype.visualtick = function(a) {
        this.geometry.position.copy(this.position), this.target && this.target.geometry && this.geometry.lookAt(this.target.chest ? this.target.chest.getWorldPosition() : this.target.position)
    }), u.prototype.tick = function(a) {
        switch (this.mode) {
            case "attach":
                void 0 === this.target || this.target.stats.isDead() ? this.deleteMe = !0 : Va || !this.target.chest ? this.position.copy(this.target.position) : this.position.copy(this.target.chest.getWorldPosition());
            case "static":
                this.effectCallback && this.effectInterval > 0 && (this.effectTimer -= a, this.effectTimer < 0 && (this.effectTimer = this.effectInterval, this.effectCallback({
                    spell: this,
                    target: this.target,
                    source: this.source
                }))), "static" == this.mode && this.movedir && (this.position.x += this.movedir.x * this.movespeed * a, this.position.y += this.movedir.y * this.movespeed * a, this.position.z += this.movedir.z * this.movespeed * a);
                break;
            case "follow":
                if (void 0 != this.target) {
                    var b = new THREE.Vector3;
                    Va || !this.target.chest ? b.subVectors(this.target.position, this.position) : b.subVectors(this.target.chest.getWorldPosition(), this.position);
                    var c = b.lengthSq();
                    c > Math.pow(this.movespeed * a, 2) ? (b.normalize(), b.multiplyScalar(this.movespeed * a), this.position.x += b.x, this.position.z += b.z, this.position.y += b.y) : (this.effectCallback && this.effectCallback({
                        spell: this,
                        target: this.target
                    }), this.deleteMe = !0)
                } else this.deleteMe = !0
        }!Va && this.visualtick && this.visualtick(a), this.timeout > 0 && (this.timeout -= a, this.timeout <= 0 && (this.deleteMe = !0))
    }, u.prototype.remove = function() {
        Va || (ca(this.geometry), Ac.remove(this.geometry), this.geometry = void 0, this.ribbonObject && this.ribbon.deleteWithSpell && (this.ribbonObject.deleteMe = !0, this.ribbonObject = void 0))
    }, j.prototype.useSkill = function(a, b) {
        var c = !1;
        if (0 == this.state.id || !Va && b) switch (a) {
            case "test":
            case "sit":
            case "logOut":
                break;
            default:
                if (this.class && this.class.skills.hasOwnProperty(a)) {
                    var d = !0;
                    if (!Va && b && 1 == this.state.id)
                        if (d = !1, this.state.skill.slot != a) this.class.skills[a].interruptCast(), this.state = new A, d = !0;
                        else {
                            var e = this.state.duration / this.state.maxduration;
                            this.state.maxduration += this.state.skill.casttime - this.state.duration, this.state.duration = this.state.maxduration * e
                        }
                    d && this.class.skills[a].cast(Va ? void 0 : b) && (c = !0)
                }
        } else 1 != this.state.id || !Va && b && !(this.state.duration < .5 * this.state.maxduration) || (this.queuedSkill = a);
        (c && Va && (1 == b || this.class.ai) || !Va && this == Ic && !b) && (this.serverMsgQueue.ab || (this.serverMsgQueue.ab = []), this.serverMsgQueue.ab.push(a))
    }, v.prototype.tick = function(a) {
        this.class.parent && (this.parent = this.class.parent), this.isOnCooldown() && (this.cooldowntimer -= a), this.isCasting() ? (this.casttimer -= a, this.casttimer <= 0 ? Va ? this.endCast(!1) : this.casttimer = .01 : Va || this.addCastAnimation(), this.targetIsValid() || Va && this.interruptCast()) : Va || this.removeCastAnimation(), this.isChanneling() && (this.channelTimer -= a, this.channelInterval > 0 && (this.channelIntervalTimer -= a, this.channelIntervalTimer <= 0 && (this.hasChanneledSpell && this.channelspell ? this.channelspell.effectCallback({
            spell: this.channelspell,
            target: this.channelspell.target
        }) : this.confirmEffect(), this.channelIntervalTimer = this.channelInterval)), this.channelTimer <= 0 && (Va || this.removeChannelAnimation()), this.targetIsValid() || (Va || this.ignoreEc) && this.interruptChannel()), !Va && this.uielement && this.updateUiElement()
    }, v.prototype.addCastAnimation = function() {
        this.castAnimationActive || (this.castAnimation.deleteMe = !1, this.castAnimation.timer = 0, this.parent.animationQueue.push(this.castAnimation), this.castAnimationActive = !0)
    }, v.prototype.removeCastAnimation = function() {
        if (this.castAnimationActive) {
            var a = this.parent.animationQueue.indexOf(this.castAnimation);
            a > -1 && this.parent.animationQueue.splice(a, 1), this.castAnimationActive = !1
        }
    }, v.prototype.addChannelAnimation = function() {
        this.channelAnimationActive || (this.channelAnimation.deleteMe = !1, this.channelAnimation.timer = 0, this.parent.animationQueue.push(this.channelAnimation), this.channelAnimationActive = !0)
    }, v.prototype.removeChannelAnimation = function() {
        if (this.channelAnimationActive) {
            var a = this.parent.animationQueue.indexOf(this.channelAnimation);
            a > -1 && this.parent.animationQueue.splice(a, 1), this.channelAnimationActive = !1
        }
    }, v.prototype.cast = function(a) {
        if (this.parent && (a || this.level > 0 && !this.isOnCooldown() && !this.isCasting() && !this.isChanneling())) {
            var b = !1;
            switch (this.casttarget = this.parent.target, this.targettype) {
                case "enemy":
                    b = void 0 !== this.casttarget && this.casttarget.faction != this.parent.faction && !this.casttarget.stats.isDead(), Va || b || this.parent != Ic || !sd || (Ic.target = sd);
                    break;
                case "friendly":
                    void 0 != this.casttarget && this.casttarget.faction == this.parent.faction || (this.casttarget = this.parent, this.parent.target = this.parent), b = this.casttarget.faction == this.parent.faction;
                    break;
                case "none":
                    b = !0;
                    break;
                default:
                    console.log("error (" + this.name + "): unknwon target type:" + this.targettype)
            }
            if (b && (!!Va || this.predict) || a) switch (this.casttype) {
                case "timed":
                    return !(!a && !this.targetIsValid()) && (this.startCast(), this.causeGlobalCooldown && this.class.globalCooldown(), !0);
                case "instant":
                    if ("channel" == this.effecttype) {
                        var c = !this.spell || this.confirmEffect(!1);
                        return this.startChannel(), c
                    }
                    return this.confirmEffect(!1)
            }
        }
        return !1
    }, v.prototype.targetIsValid = function(a) {
        if (void 0 === a && (a = this.casttarget), "none" != this.targettype && void 0 != a) {
            if (!this.allowDeadTarget && a.stats.isDead()) return !1;
            if ("enemy" == this.targettype && this.parent != a && !ib(this.parent, a).canFight()) return !1;
            var b = this.parent != a ? ib(this.parent, a).distance() : 0;
            return b <= (this.isCasting() ? 1.1 * this.maxrange : this.maxrange) + (Va ? 1.5 : 1.3)
        }
        return !0
    }, v.prototype.confirmEffect = function(a) {
        if (Va || this.removeCastAnimation(), this.effect && this.targetIsValid()) {
            if (this.cooldowntimer <= 0 && !this.consumeMana()) return !1;
            if (this.cooldowntimer = Math.max(this.cooldown, this.cooldowntimer), this.causeGlobalCooldown && this.class.globalCooldown(), this.spell) {
                var b = this.spell(this.casttarget, this.parent, this.effectWrapper);
                b && Qb.push(b), this.hasChanneledSpell && (this.channelspell = b), this.unique && (void 0 != this.oldspell && (this.oldspell.deleteMe = !0), this.oldspell = b)
            } else this.effectWrapper({
                isParse: a
            });
            return this.simulate == !a && !Va && "channel" != this.effecttype && this.parent && this.parent.animationQueue.push(this.getCharacterAnim()), !0
        }
        return !1
    }, v.prototype.consumeMana = function() {
        return this.parent && this.parent.stats && this.parent.stats.useMana(this.manacost * this.parent.stats.basemana)
    }, v.prototype.hasEnoughMana = function() {
        return this.parent && this.parent.stats && this.parent.stats.currentmp > this.manacost * this.parent.stats.basemana
    }, v.prototype.endCast = function(a) {
        Va ? (this.parent.serverMsgQueue.ec || (this.parent.serverMsgQueue.ec = []), this.parent.serverMsgQueue.ec.push(this.slot), this.parent.addPersonalMessage("ec", this.slot)) : this.casttimer <= .1 * this.casttime && (this.casttimer = -1);
        var b = !1;
        void 0 != this.casttarget && (this.parent.target != this.casttarget || Va && !this.targetIsValid()) ? this.interruptCast() : (b = !0, this.confirmEffect(a)), "channel" == this.effecttype && b && this.startChannel()
    }, v.prototype.interruptCast = function() {
        Va || this.removeCastAnimation(), Va && this.parent && this.parent.addServerMessage("abi", this.slot), this.casttimer = -1
    }, v.prototype.interruptChannel = function() {
        Va || this.removeChannelAnimation(), Va && this.parent && this.parent.addServerMessage("abi", this.slot), this.channelspell && (this.channelspell.deleteMe = !0, this.channelspell = void 0), this.channelTimer = -1
    }, v.prototype.isCasting = function() {
        return this.casttimer > 0
    }, v.prototype.isOnCooldown = function() {
        return this.cooldowntimer > 0
    }, v.prototype.isChanneling = function() {
        return this.channelTimer > 0
    }, v.prototype.configureUiElements = function(a, b, c) {
        this.uielement = a, this.uielement.attr("src", this.icon), this.uielementOverlay = b, this.uielementCooldown = c, this.uielementOverlay.addClass("skillOverlayDisable"), this.uielementCooldown.css("display", "none")
    }, v.prototype.updateUiElement = function() {
        if (this.uielement) {
            if (this.level > 0) {
                var a = !this.targetIsValid(Ic.target),
                    b = !this.hasEnoughMana(),
                    c = this.isOnCooldown();
                if (this.oldIsOnCooldown == c && this.oldIsOom == b && this.oldIsInvalid == a || (this.oldIsOnCooldown = c, this.oldIsOom = b, this.oldIsInvalid = a, this.uielementOverlay.css("display", a || c || b ? "block" : "none"), this.uielementCooldown.css("display", a || c || b ? "block" : "none")), c || b || a) {
                    var d = "";
                    b && (d = "MP"), c && (d = this.cooldowntimer < 10 ? ("" + this.cooldowntimer).substring(0, 3) : parseInt(this.cooldowntimer)), this.uielementCooldown.html(d)
                }
            }
            if (this.oldCanLevelUp != this.canLevelUp() && (this.oldCanLevelUp = this.canLevelUp(), 1 == this.oldCanLevelUp)) {
                var e = $("#skillLevelButton" + this.slot);
                jc(e, this.slot), e.fadeIn(1500), e.fadeOut(1500), e.fadeIn(1500), e.fadeOut(1500)
            }
        }
    }, v.prototype.globalCooldown = function(a) {
        this.cooldowntimer = Math.max(this.cooldowntimer, a)
    }, v.prototype.startCast = function() {
        this.casttimer = this.casttime, this.parent.state = new B({
            skill: this,
            casttime: this.casttime,
            activeCheck: this.isCasting,
            interrupt: this.interruptCast
        }), Va || (this.removeCastAnimation(), this.addCastAnimation())
    }, v.prototype.startChannel = function() {
        this.parent && (this.channelTimer = this.channelDuration, this.channelIntervalTimer = this.channelInterval, this.parent.state = new B({
            skill: this,
            casttime: this.channelTimer,
            activeCheck: this.isChanneling,
            interrupt: this.interruptChannel
        }), this.channelInstantFirstTick && (this.hasChanneledSpell ? this.channelspell && this.channelspell.effectCallback({
            spell: this.channelspell,
            target: this.channelspell.target
        }) : this.confirmEffect()), Va || (this.removeChannelAnimation(), this.addChannelAnimation(), this.onCastFun && this.onCastFun()))
    }, v.prototype.setInfoPanel = function(a) {
        var b = this;
        ec[a] = function() {
            var a = "<h5 class='skillName'>" + b.name + "<small> " + b.casttype + " cast </small></h5><p class='skillDescription'>" + b.description + "</p>" + (0 == b.level ? "Press the green button to level up this skill! <br>" : "<p class='skillLvlInfo'>" + parseInt(100 * b.abilitypower) + "% ability effect <br> Level: " + b.level + " <br>Mana cost: " + parseInt(b.manacost * b.parent.stats.basemana) + " <br>Cooldown: " + b.cooldown + " Seconds <br>") + "<span class=" + (b.parent.gold >= b.nextLevelCost ? "skillReq" : "skillReqMiss") + "> Upgrade cost: " + b.nextLevelCost + " " + dc.goldCoin + "</span><br><span class=" + (b.parent.class.level >= b.levelUpMinLevel ? "skillReq" : "skillReqMiss") + "> Minimum character level: " + b.levelUpMinLevel + "</span></p>";
            return a
        }
    }, v.prototype.setLevel = function(a) {
        var b = this.level;
        this.level = a, this.nextLevelCost = parseInt(Math.pow((a + 1) * (a + 3), 1.9)), this.levelUpMinLevel = Math.max(0, Math.round(4 * (this.level - 4))), this.abilitypower = this.getAbilityPowerAtLevel(a), Va && this.parent && this.parent.addPersonalMessage("sl", {
            i: this.slot,
            l: this.level
        }), !Va && 0 == b && this.level > 0 && Ic && this.parent == Ic && this.uielementOverlay.removeClass("skillOverlayDisable")
    }, v.prototype.canLevelUp = function() {
        return this.parent.gold >= this.nextLevelCost && this.parent.class.level >= this.levelUpMinLevel
    }, v.prototype.tryLevelUp = function() {
        return !!this.parent && void(Va ? this.canLevelUp() && this.parent.tryModifyGold(-this.nextLevelCost) && this.setLevel(this.level + 1) : this.parent.serverMsgQueue.lus = this.slot)
    }, v.prototype.getAbilityPowerAtLevel = function(a) {
        return .5 + .1 * a
    }, w.prototype.tick = function(a) {
        Va && (this._invincible = !1, this._incapacitated = !1, this._stunned = !1, this._healmod = 1, this.currenthp < this.maxhp && (this.periodicTickTimerHP -= a), this.periodicTickTimerHP <= 0 && (this.hpregen < 1 ? (this.periodicTickTimerHP = 1 / this.hpregen, this.parent.takeHealing(1)) : (this.periodicTickTimerHP = 1, this.parent.takeHealing(this.hpregen))), this.currentmp < this.maxmp && (this.periodicTickTimerMP -= a), this.periodicTickTimerMP <= 0 && (this.mpregen < 1 ? (this.periodicTickTimerMP = 1 / this.mpregen, this.gainMana(1)) : (this.periodicTickTimerMP = 1, this.gainMana(this.mpregen))));
        for (var b = this.mods.length; b--;) this.mods[b].tick(a, this), this.mods[b].deleteMe && this.mods.splice(b, 1);
        Va && (this.invincible = this._invincible, this.incapacitated = this._incapacitated, this.stunned = this._stunned, this.healmod = this._healmod), Va || this.servermovespeed && (this.movespeed = this.servermovespeed)
    }, w.prototype.canBeAttacked = function(a) {
        return !(this.isDead() || a && a.faction == parent.faction)
    }, w.prototype.isDead = function() {
        return 2 == this.parent.state.id || this.currenthp <= 0
    }, w.prototype.spawn = function() {
        this.currenthp = this.maxhp, this.currentmp = this.maxmp
    }, w.prototype.clearBuffs = function() {
        for (var a = this.mods.length; a--;) this.mods[a].deleteMe = !0
    }, w.prototype.reset = function() {
        this.currenthp = this.maxhp, this.currentmp = this.maxmp, this.clearBuffs()
    }, w.prototype.addMod = function(a) {
        if ((1 == a.overwrite || 1 == a.unique) && void 0 !== a.id)
            for (m in this.mods) this.mods.hasOwnProperty(m) && this.mods[m].id == a.id && (a.unique ? this.mods[m].deleteMe = !0 : a.overwrite && this.mods[m].source == a.source && (this.mods[m].deleteMe = !0));
        this.mods.push(a)
    }, w.prototype.queryMod = function(a) {
        for (var b = [], c = this.mods.length; c--;) {
            var d = this.mods[c];
            a.source && d.source != a.source || a.id && d.id != a.id || b.push(d)
        }
        return b
    }, y.prototype.tick = function(a, b) {
        this.timer -= a, this.timer <= 0 && (this.deleteMe = !0), this.effectinterval > 0 && void 0 != this.effectfunction && (this.effecttimer -= a, this.effecttimer <= 0 && (this.effectfunction(), this.effecttimer = this.effectinterval)), this.deleteMe || Va && (this.invincible && (b._invincible = !0), this.incapacitate && (b._incapacitated = !0), this.stun && (b._stunned = !0), this.healmod && (b._healmod = this.healmod(b._healmod)), this.movespeed && (b.movespeed = this.movespeed(b.movespeed)))
    }, w.prototype.gainMana = function(a) {
        this.isDead() || (this.currentmp += parseInt(a), this.currentmp > this.maxmp && (this.currentmp = this.maxmp))
    }, w.prototype.useMana = function(a) {
        return !this.isDead() && (a = parseInt(a), !(this.currentmp < a) && (this.currentmp -= a, !0))
    }, A.prototype = new z, A.prototype.constructor = A, B.prototype = new z, B.prototype.constructor = B, C.prototype = new z, C.prototype.constructor = C, K.prototype.skills = {}, K.prototype.getMaxHp = function() {
        return parseInt(70 + 3 * this.level)
    }, K.prototype.getMaxMp = function() {
        return parseInt(30 + 2 * this.level)
    }, K.prototype.getMinDmg = function() {
        return parseInt(2 + .2 * this.level)
    }, K.prototype.getMaxDmg = function() {
        return parseInt(3 + .3 * this.level)
    }, K.prototype.getMovespeed = function() {
        return 8
    }, K.prototype.getCrit = function() {
        return 2 + .005 * this.level
    }, K.prototype.getHpRegen = function() {
        return .3 + .1 * this.level
    }, K.prototype.getMpRegen = function() {
        return .5 + .2 * this.level
    }, K.prototype.getDefense = function() {
        return parseInt(80 + 2 * this.level)
    }, K.prototype.getScale = function() {
        return 1 + .005 * this.level
    }, K.prototype.globalCooldown = function() {
        for (skill in this.skills) this.skills.hasOwnProperty(skill) && this.skills[skill].globalCooldown(1.2)
    }, K.prototype.tick = function(a) {
        this.ai && this.ai.tick(a);
        for (skill in this.skills) this.skills.hasOwnProperty(skill) && this.skills[skill].tick(a);
        this.update()
    }, K.prototype.update = function() {
        Va && this.checkLevelUp(), this.scale = this.getScale(), this.stats.basemana = this.getMaxMp(), (Va || Wa) && (this.movespeed = this.getMovespeed(), this.ai && this.statCalcDone || (this.ai && (this.statCalcDone = !0), this.mindmg = this.getMinDmg(), this.maxdmg = this.getMaxDmg(), this.maxhp = this.getMaxHp(), this.maxmp = this.stats.basemana, this.hpregen = this.getHpRegen(), this.mpregen = this.getMpRegen(), this.defense = this.getDefense(), this.crit = this.getCrit(), this.parent.inventory && (void 0 !== this.parent.inventory.sum.hp && (this.maxhp += this.parent.inventory.sum.hp), void 0 !== this.parent.inventory.sum.mp && (this.maxmp += this.parent.inventory.sum.mp), void 0 !== this.parent.inventory.sum.mindmg && (this.mindmg += this.parent.inventory.sum.mindmg), void 0 !== this.parent.inventory.sum.maxdmg && (this.maxdmg += this.parent.inventory.sum.maxdmg), void 0 !== this.parent.inventory.sum.def && (this.defense += this.parent.inventory.sum.def), void 0 !== this.parent.inventory.sum.hpreg && (this.hpregen += this.parent.inventory.sum.hpreg), void 0 !== this.parent.inventory.sum.mpreg && (this.mpregen += this.parent.inventory.sum.mpreg), void 0 !== this.parent.inventory.sum.crit && (this.crit += this.parent.inventory.sum.crit), void 0 !== this.parent.inventory.sum.move && (this.movespeed += this.parent.inventory.sum.move))), this.stats.movespeed = this.movespeed, this.stats.maxhp = this.maxhp, this.stats.maxmp = this.maxmp, this.stats.currentmindmg = this.mindmg, this.stats.currentmaxdmg = this.maxdmg, this.stats.hpregen = this.hpregen, this.stats.mpregen = this.mpregen, this.stats.defense = this.defense, this.stats.crit = this.crit), this.stats.scale = this.scale
    }, K.prototype.isCasting = function() {
        for (skill in this.skills)
            if (this.skills.hasOwnProperty(skill) && (this.skills[skill].isCasting() || this.skills[skill].isChanneling())) return !0;
        return !1
    }, Va || Wa || (K.prototype.headGearOffset = new THREE.Vector3(0, .5, 0), K.prototype.headGearOffsetScale = new THREE.Vector3(.5, .5, .5), K.prototype.initBaseBody = function() {
        this.chest = new THREE.Mesh(kd.chest.geo, this.class.color), this.chest.scale.set(kd.chest.scale[0], kd.chest.scale[1], kd.chest.scale[2]), this.chest.castShadow = !0, this.chest.rotation.order = "YXZ", this.chest.cycle = 0, this.chest.material = this.class.color, this.body.add(this.chest);
        var a = new THREE.Mesh(kd.leg.geo, Vc.leg);
        a.scale.set(kd.leg.scale[0], kd.leg.scale[1], kd.leg.scale[2]), Ac.add(a);
        var b = new THREE.Mesh(kd.leg.geo, Vc.leg);
        b.scale.set(kd.leg.scale[0], kd.leg.scale[1], kd.leg.scale[2]), Ac.add(b), this.legs = new THREE.Group, Ac.add(b), this.body.add(this.legs), this.legs.add(b), this.legs.add(a), this.legs.l = a, this.legs.r = b, this.legs.cycle = 0, this.legs.lastVisualPos = new THREE.Vector3;
        var c = new THREE.Mesh(kd.hand.geo, Vc.leg);
        c.scale.set(kd.hand.scale[0], kd.hand.scale[1], kd.hand.scale[2]), Ac.add(c);
        var d = new THREE.Mesh(kd.hand.geo, Vc.leg);
        d.scale.set(kd.hand.scale[0], kd.hand.scale[1], kd.hand.scale[2]), Ac.add(d), this.hands = new THREE.Group, this.hands.cycle = 0, Ac.add(d), this.chest.add(this.hands), this.hands.add(d), this.hands.add(c), this.hands.l = c, this.hands.r = d
    }, K.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(kd.generic_sword.geo, Vc.generic_sword), this.weapon.scale.set(kd.generic_sword.scale[0], kd.generic_sword.scale[1], kd.generic_sword.scale[2]), this.weapon.rotation.y = .5, Ac.add(this.weapon), this.weapon.position.set(0, 0, .7), this.chest.add(this.weapon)
    }, K.prototype.tickBaseAnimation = function(a, b, c) {
        var d = new THREE.Vector3;
        d.subVectors(this.visualPosition, this.legs.lastVisualPos);
        var e = this.stats.movespeed * c;
        switch (this.walkForward == -1 && (e *= 1.3), a) {
            case "cast":
                this.hands.cycle = b.timer / b.duration * Ua;
                var f = Math.sin(this.hands.cycle),
                    g = Math.cos(this.hands.cycle);
                this.chest.rotation.y = -1 + .05 * f, this.chest.rotation.x = -.2 + .03 * f, this.chest.rotation.z = .2 + .02 * g, this.chest.position.y = .2 * f + .3, this.chest.position.z = -.2, this.hands.r.rotation.set(.3 + .2 * f, .2 * f, 0), this.hands.l.rotation.set(.3 + .2 * g, .2 * -g, 0), this.hands.r.position.set(.3 + .1 * f, -.3 + .1 * f, -.75), this.hands.l.position.set(-.2 - .1 * f, -.1 + .1 * g, -.75);
                break;
            case "channel":
                this.hands.cycle = b.timer / b.duration * Ua;
                var f = Math.sin(this.hands.cycle),
                    g = Math.cos(this.hands.cycle);
                this.chest.rotation.y = -.2 + .01 * f, this.chest.rotation.x = .3 + .01 * f, this.chest.rotation.z = -.5 + .01 * g, this.chest.position.y = .1 * f + .3, this.chest.position.z = -.2, this.hands.r.rotation.set(.3 + .05 * f, .2 * f, 0), this.hands.l.rotation.set(.3 + .05 * g, .2 * -g, 0), this.hands.r.position.set(.5 + .05 * f, .3 + .1 * g, -.6), this.hands.l.position.set(-.5 + .05 * f, 1 + .05 * f, -.6);
                break;
            case "release_spell":
                var h = db.easeOutQuint(1 - b.timer / b.duration);
                this.chest.rotation.y = -1 + h, this.chest.rotation.x = -.2 + .2 * h, this.chest.rotation.z = .2 - .2 * h, this.chest.position.y = .3 - .3 * h, this.chest.position.z = -.2 + .2 * h, this.hands.r.rotation.set(.3 - .3 * h, 0, 0), this.hands.l.rotation.set(.3 - .3 * h, 0, 0), this.hands.r.position.set(.35 + .2 * h, 0, -1), this.hands.l.position.set(-.35 - .2 * h, 0, -1);
                break;
            case "release_buff":
                var h = db.easeOutQuint(1 - b.timer / b.duration);
                this.chest.rotation.y = 0, this.chest.rotation.x = 0, this.chest.rotation.z = 0, this.hands.r.rotation.set(1.5 * h, 0, 0), this.hands.l.rotation.set(1.5 * h, 0, 0);
                var i = Math.sin(3 * h);
                this.hands.r.position.set(-.12 - .35 * i, -.1 + .8 * h, -.3 - i), this.hands.l.position.set(.12 + .35 * i, 0 + .8 * h, -.3 - i);
                break;
            case "boost":
                var h = db.easeInOutQuart(.5 + .5 * Math.sin(b.timer / b.duration * Math.PI * 2));
                this.chest.rotation.x = .4 * h, this.hands.r.rotation.set(0, 0, 0), this.hands.l.rotation.set(0, 0, 0), this.hands.r.position.set(.6 + .2 * h, .8 * h, -.3), this.hands.l.position.set(-.6 - .2 * h, .8 * h, -.3);
                break;
            case "swing_melee":
                this.hands.r.position.copy(this.weapon.position), this.hands.r.position.multiplyScalar(.5), this.chest.rotation.set(0, b.timer / b.duration * .5, 0);
                break;
            case "spin":
                this.body.rotation.y = b.timer / b.duration * Math.PI * 4, this.chest.position.z = .3, this.hands.l.position.set(-.2, 0, -1), this.hands.r.position.set(.2, 0, -1);
                break;
            case "dead":
                this.chest.material = Vc.dead, this.body.rotation.x = -(Math.min(this.state.timer, .8) / .8) * Math.PI * .5, this.state.timer > 2 && this.state.timer < 5 && (this.body.position.y -= .2 * c);
                break;
            default:
            case "idle":
                if (this.body.position.set(0, 0, 0), this.body.rotation.set(0, 0, 0), this.chest.position.set(0, 0, 0), this.chest.rotation.set(0, 0, 0), this.walkForward || this.walkSideward) {
                    var j = .6;
                    this.walkForward == -1 && (j = .3);
                    var k = Math.sin(this.legs.cycle);
                    this.hands.l.position.set(-.7 + .2 * Math.sin(2 * this.legs.cycle + 5), -.2 + .3 * Math.sin(this.legs.cycle), -.2 + k * j * 1.5), this.hands.r.position.set(.7 - .2 * Math.sin(2 * this.legs.cycle + 5), -.2 + .3 * -Math.sin(this.legs.cycle), -.2 - k * j * 1.5), this.hands.r.rotation.set(0, .5 + .8 * this.hands.l.position.z, 0), this.hands.l.rotation.set(0, -(.5 + .8 * this.hands.r.position.z), 0)
                } else {
                    this.hands.rotation.y = 0;
                    var f = Math.sin(this.chest.cycle + .5 * Math.PI);
                    this.hands.r.rotation.set(0, .43 - .15 * f, -.3), this.hands.l.rotation.set(0, -.43 + .15 * f, .3), this.hands.l.position.set(-.7, -.3 + .08 * f, -.15 + .1 * f), this.hands.r.position.set(.7, -.3 + .08 * f, -.15 + .1 * f)
                }
        }
        switch (this.legs.cycle > Ua ? this.legs.cycle -= Ua : this.legs.cycle < 0 && (this.legs.cycle += Ua), a) {
            case "dead":
                break;
            case "spin":
                this.legs.cycle += 10 * c;
            default:
            case "idle":
                if (this.walkForward || this.walkSideward) {
                    var l = .8;
                    this.walkForward == -1 && (l = .3), this.legs.rotation.y = -this.rotation + D(new THREE.Vector2(d.x, d.z)), this.legs.cycle += 1.8 * e / this.stats.scale, this.legs.l.position.set(-.3, Math.max(0, .6 * Math.cos(this.legs.cycle)) + .1, Math.sin(-this.legs.cycle) * l), this.legs.r.position.set(.3, Math.max(0, .6 * Math.cos(this.legs.cycle + Math.PI)) + .1, Math.sin(-this.legs.cycle + Math.PI) * l), this.legs.r.rotation.x = .3 * this.legs.l.position.z, this.legs.l.rotation.x = .3 * this.legs.r.position.z, this.chest.position.y = .1 * Math.cos(2 * this.legs.cycle) + 1.1
                } else switch (this.legs.rotation.y = 0, this.legs.r.rotation.x = 0, this.legs.l.rotation.x = 0, this.chest.cycle += 3 * c, this.chest.cycle > Ua && (this.chest.cycle -= Ua), this.chest.position.y = .1 * Math.cos(this.chest.cycle) + 1.1, a) {
                    case "cast":
                        this.legs.l.position.set(-.4, .1, -.25), this.legs.r.position.set(.35, .1, .1), this.legs.l.rotation.y = 1, this.legs.r.rotation.y = .5;
                    case "channel":
                        this.legs.l.position.set(-.4, .1, -.6);
                        break;
                    case "release_buff":
                        var h = db.easeOutQuint(1 - b.timer / b.duration);
                        this.chest.position.y = 1.2 + .2 * Math.sin(3 + 5 * h);
                        break;
                    default:
                        this.legs.l.position.set(-.45, .1, 0), this.legs.r.position.set(.45, .1, 0), this.legs.r.rotation.y = 0, this.legs.l.rotation.y = 0
                }
                this.legs.lastVisualPos.copy(this.visualPosition)
        }
    }, K.prototype.tickClassAnimation = function(a, b) {
        switch (a) {
            case "swing_melee":
                var c = db.easeInOutQuad(b.timer / b.duration),
                    d = .5 * -Math.PI + Math.PI * c;
                this.weapon.rotation.set(.5 * Math.PI, 0, d), this.weapon.position.set(1.5 * Math.sin(d), 0, 1.5 * -Math.cos(d));
                break;
            case "spin":
                this.weapon.rotation.set(.5 * Math.PI, 0, 0), this.weapon.position.set(0, 0, -2);
                break;
            default:
            case "idle":
                this.weapon.rotation.set(0, 0, .5), this.weapon.position.set(0, 0, .7)
        }
    }), O.prototype = new K, O.prototype.constructor = O, O.prototype.getMaxHp = function() {
        return parseInt(.8 * Math.pow(12 + 1.5 * this.level, 1.6))
    }, O.prototype.getMovespeed = function() {
        return 1 == this.ai.isresetting ? 12 : 9
    }, O.prototype.getScale = function() {
        return .8 + .04 * this.level
    }, O.prototype.getMinDmg = function() {
        return 1 + .6 * this.level
    }, O.prototype.getMaxDmg = function() {
        return 2 + .9 * this.level
    }, O.prototype.getDefense = function() {
        return 0
    }, P.prototype = new K, P.prototype.constructor = P, P.prototype.getMaxHp = function() {
        return parseInt(.6 * Math.pow(12 + 1.5 * this.level, 1.6))
    }, P.prototype.getMovespeed = function() {
        return 1 == this.ai.isresetting ? 12 : 9
    }, P.prototype.getScale = function() {
        return .7 + .02 * this.level
    }, P.prototype.getMinDmg = function() {
        return 1 + .6 * this.level
    }, P.prototype.getMaxDmg = function() {
        return 2 + .9 * this.level
    }, P.prototype.getDefense = function() {
        return 0
    }, Q.prototype = new K, Q.prototype.constructor = Q, Va || (Q.prototype.headGearOffset = new THREE.Vector3(0, .6, 0), Q.prototype.headGearOffsetScale = new THREE.Vector3(.6, .6, .6), Q.prototype.initBaseBody = function() {
        this.chest = new THREE.Mesh(kd.slime.geo, this.class.color), this.chest.scale.set(kd.slime.scale[0], kd.slime.scale[1], kd.slime.scale[2]), this.chest.rotation.order = "YXZ", this.chest.cycle = 0, this.chest.castShadow = !0, this.chest.position.y = .5, this.body.add(this.chest)
    }, Q.prototype.tickBaseAnimation = function(a, b, c) {
        switch (this.chest.cycle += c * (0 != this.walkForward ? 6 : 2), this.chest.cycle > Ua && (this.chest.cycle -= Ua), this.chest.position.y = .3 - .1 * Math.cos(this.chest.cycle), this.chest.position.z = 0, this.chest.scale.set(.1 * Math.cos(this.chest.cycle) + 1, 1 - .1 * Math.cos(this.chest.cycle), .1 * Math.cos(this.chest.cycle) + 1), a) {
            case "swing_melee":
                var d = Math.sin(3.1 * db.easeInOutQuad(b.timer / b.duration)) / this.stats.scale;
                this.chest.position.z -= 2 * d;
                break;
            case "dead":
                this.chest.position.y = 0, this.state.timer > 1 && this.state.timer < 5 && (this.body.position.y -= .15 * c), this.chest.scale.set(1 + .3 * this.state.timer, 1 / (1 + this.state.timer), 1 + .3 * this.state.timer)
        }
    }, Q.prototype.initBodyGeometry = function() {}, Q.prototype.tickClassAnimation = function(a, b) {}), Q.prototype.getMaxHp = function() {
        return parseInt(Math.pow(12 + 1.5 * this.level, 1.6))
    }, Q.prototype.getMovespeed = function() {
        return 1 == this.ai.isresetting ? 10 : 5
    }, Q.prototype.getScale = function() {
        return 1.05 + .07 * this.level
    }, Q.prototype.getMinDmg = function() {
        return 1 + .6 * this.level
    }, Q.prototype.getMaxDmg = function() {
        return 2 + .9 * this.level
    }, Q.prototype.getDefense = function() {
        return 0
    }, R.prototype = new K, R.prototype.constructor = R, R.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(kd.warrior_sword.geo, Vc.generic_metal), this.weapon.scale.set(kd.warrior_sword.scale[0], kd.warrior_sword.scale[1], kd.warrior_sword.scale[2]), this.weapon.position.y = .5, this.hands.r.add(this.weapon), this.shield = new THREE.Mesh(kd.warrior_shield.geo, Vc.generic_metal), this.shield.scale.set(kd.warrior_shield.scale[0], kd.warrior_shield.scale[1], kd.warrior_shield.scale[2]), this.shield.position.x = -.5, this.hands.l.add(this.shield)
    }, R.prototype.tickClassAnimation = function(a, b) {
        if (b) var c = db.easeInOutQuint(b.timer / b.duration);
        switch (a) {
            case "swing_melee":
                this.hands.r.position.set(-.5 + c, 2 * c - 1, -1), this.hands.r.lookAt(new THREE.Vector3(0, 0, 0)), this.hands.r.rotation.x -= 1.5, this.hands.r.rotation.z -= 3 * c - 1, this.chest.rotation.set(0, 1 - 3 * c, 0);
                break;
            case "spin":
                this.hands.r.rotation.set(-1.5, 0, 0), this.hands.r.position.z -= .3, this.hands.l.position.z += .2;
                break;
            default:
            case "idle":
                this.hands.l.rotation.z -= .1, this.hands.l.position.y += .1, this.hands.r.rotation.x -= .5, this.hands.r.position.y -= .2, this.hands.r.position.x += .1, this.weapon && this.oldanimId != a && (this.weapon.rotation.set(0, 0, 0), this.weapon.position.set(0, 1, 0))
        }
        this.oldanimId = a
    }, S.prototype = new K, S.prototype.constructor = S, S.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(kd.mage_staff.geo, Vc.generic_wood), this.weapon.scale.set(kd.mage_staff.scale[0], kd.mage_staff.scale[1], kd.mage_staff.scale[2]), this.weapon.rotation.z = .5, this.weapon.position.set(0, 0, .7), this.chest.add(this.weapon), this.shield = new THREE.Mesh(kd.mage_shield.geo, Vc.generic_white), this.shield.scale.set(kd.mage_shield.scale[0], kd.mage_shield.scale[1], kd.mage_shield.scale[2]), this.shield.position.x = -.4, this.shield.rotation.x = .25 * Math.PI, this.hands.l.add(this.shield)
    }, S.prototype.tickClassAnimation = function(a, b) {
        switch (a) {
            default:
                case "idle":
        }
    }, T.prototype = new K, T.prototype.constructor = T, T.prototype.initBodyGeometry = function() {
        this.bowcontainer = new THREE.Object3D, this.weapon = new THREE.Mesh(kd.archer_bow.geo, Vc.generic_wood), this.weapon.scale.set(2.5, 2.5, 1.9), this.weapon.rotation.z = .32, this.weapon.position.y = -2, this.bowcontainer.add(this.weapon), this.bowendU = new THREE.Mesh(kd.archer_bow_end.geo, Vc.generic_wood), this.bowendL = new THREE.Mesh(kd.archer_bow_end.geo, Vc.generic_wood), this.bowendU.position.x = 3.2, this.bowendL.position.x = -3.2, this.bowendU.position.y = -.7, this.bowendL.position.y = -.7, this.bowendL.scale.set(kd.archer_bow_end.scale[0], kd.archer_bow_end.scale[1], kd.archer_bow_end.scale[2]), this.bowendU.scale.set(kd.archer_bow_end.scale[0], kd.archer_bow_end.scale[1], kd.archer_bow_end.scale[2]), this.bowendL.rotation.z = 2.4, this.bowendU.rotation.z = .7, this.bowcontainer.add(this.bowendU), this.bowcontainer.add(this.bowendL), this.bowcontainer.rotation.z = 1.5, this.bowcontainer.rotation.x = 1.6, this.bowcontainer.position.x = 1.1, this.bowcontainer.position.z = -.1, this.hands.l.add(this.bowcontainer), this.ammo = new THREE.Mesh(kd.archer_ammo.geo, Vc.archer_ammo), this.ammo.position.z = .7, this.ammo.rotation.z = -.4, this.ammo.rotation.x = .16, this.ammo.position.y = -.15, this.ammo.scale.set(kd.archer_ammo.scale[0], kd.archer_ammo.scale[1], kd.archer_ammo.scale[2]), this.chest.add(this.ammo), this.ammo2 = new THREE.Mesh(kd.archer_ammo2.geo, Vc.archer_ammo2), this.ammo2.position.y = .8, this.ammo2.scale.set(kd.archer_ammo2.scale[0], kd.archer_ammo2.scale[1], kd.archer_ammo2.scale[2]), this.ammo.add(this.ammo2)
    }, T.prototype.tickClassAnimation = function(a, b) {
        if (b) {
            var c = db.easeInOutQuint(b.timer / b.duration);
            Math.sin(3.14 * c)
        }
        switch (a) {
            case "release_spell":
                var d = 1 - db.easeInQuint(b.timer / b.duration);
                this.hands.l.rotation.set(1.5, 2 + .4 * d, 1.5), this.hands.l.position.set(-.2, -.4 + .3 * d, -.8 - .8 * d), this.chest.rotation.y = 0, this.chest.rotation.x = -.2 + .2 * d, this.chest.rotation.z = 0, this.chest.position.z = 0, this.hands.r.position.set(.5 + .2 * d, -.2 + .4 * d, -.9 + (1 - b.timer / b.duration));
                break;
            default:
            case "idle":
                var e = Math.sin(this.chest.cycle + .5 * Math.PI),
                    f = Math.sin(this.legs.cycle);
                this.hands.l.rotation.set(-.2 + .1 * e + .1 * f, -1.4 + .15 * e + .1 * f, .3), this.hands.l.position.set(-.15 - .2 * e - .2 * f, -.3 + .1 * e + .1 * f, -.9 + .1 * f), this.chest.rotation.y = .1, this.chest.rotation.x = -.1 + .1 * e, this.chest.position.z = -.1, this.legs.l.position.z -= .3, this.legs.r.position.z += .1
        }
    }, U.prototype = new K, U.prototype.constructor = U, U.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(kd.shaman_mace1.geo, Vc.generic_wood), this.weapontop = new THREE.Mesh(kd.shaman_mace2.geo, Vc.shaman_macetop), this.weapon.scale.set(kd.shaman_mace1.scale[0], kd.shaman_mace1.scale[1], kd.shaman_mace1.scale[2]), this.weapontop.scale.set(kd.shaman_mace2.scale[0], kd.shaman_mace2.scale[1], kd.shaman_mace2.scale[2]), this.weapon.position.y = -.5, this.weapontop.position.y = .8, this.hands.r.add(this.weapon), this.weapon.add(this.weapontop), this.shield = new THREE.Mesh(kd.shaman_shield.geo, Vc.generic_white), this.shield.scale.set(kd.shaman_shield.scale[0], kd.shaman_shield.scale[1], kd.shaman_shield.scale[2]), this.shield.position.z = .6, this.shield.position.y = .1,
            this.shield.rotation.z = .25 * Math.PI, this.chest.add(this.shield), this.robe = new THREE.Mesh(kd.shaman_robe.geo, Vc.generic_white), this.robe.scale.set(kd.shaman_robe.scale[0], kd.shaman_robe.scale[1], kd.shaman_robe.scale[2]), this.robe.position.z = -.5, this.robe.position.y = -.5, this.chest.add(this.robe)
    }, U.prototype.tickClassAnimation = function(a, b) {
        if (b) {
            db.easeInOutQuint(b.timer / b.duration)
        }
        switch (a) {
            default:
                case "idle":
                this.hands.l.rotation.z -= .1,
            this.hands.l.position.y += .1,
            this.hands.r.rotation.x -= 1.3,
            this.hands.r.position.y -= .1,
            this.hands.r.position.x += .1,
            this.weapon.rotation.set(0, 0, 0),
            this.weapon.position.set(0, .2, 0)
        }
    }, j.prototype.updateVisual = function(a) {
        switch (a) {
            case "h":
                switch (this.head && (ca(this.head), this.chest.remove(this.head), this.head = void 0), this.visuals.h) {
                    default:
                        case 0:
                        break;
                    case 1:
                            this.head = new THREE.Mesh(qa.helmet.children[0].geometry, Vc.metal);
                        break;
                    case 2:
                            this.head = new THREE.Mesh(qa.helmet.children[0].geometry, Vc.silver);
                        break;
                    case 3:
                            this.head = new THREE.Mesh(qa.helmet.children[0].geometry, Vc.gold);
                        break;
                    case 4:
                            this.head = new THREE.Mesh(qa.crown.children[0].geometry, Vc.metal);
                        break;
                    case 5:
                            this.head = new THREE.Mesh(qa.crown.children[0].geometry, Vc.silver);
                        break;
                    case 6:
                            this.head = new THREE.Mesh(qa.crown.children[0].geometry, Vc.gold)
                }
                this.head && (this.head.position.copy(this.class.headGearOffset), this.head.scale.copy(this.class.headGearOffsetScale), this.chest.add(this.head))
        }
    };
    var Sb = 0;
    j.prototype.tickDamageWobble = function(a) {
        if (this.dmgShake > 0 && this.chest)
            if (this.dmgShake -= a, this.dmgShake > .4 && (this.dmgShake = .4), this.dmgShake > 0) {
                var b = this.stats.scale + this.dmgShake * Math.sin(50 * this.dmgShake) * .5;
                this.body.scale.set(b, b, b), this.chest.material = Vc.damage
            } else this.body.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), this.chest.material = this.class.color
    }, j.prototype.tickAnimations = function(a) {
        if (this.animationQueue.length > 0) {
            var b = this.animationQueue[0];
            b.tick(a), (b.timer <= 0 || 1 == b.deleteMe) && this.animationQueue.shift()
        }
        this.worlddist < 60 ? (this.tickDamageWobble(a), this.tickBodyPartAnimations(a)) : this.isInHud && Sb % Math.round(.08 * (this.worlddist - 60) + 1 + this.globalAnimStepFuss) == 0 && (this.tickDamageWobble(($c - (this.lastBodyAnimTick || 0)) / 1e3), this.tickBodyPartAnimations(($c - (this.lastBodyAnimTick || 0)) / 1e3), this.lastBodyAnimTick = $c)
    }, V.prototype.tick = function(a) {
        "timed" != this.type && "loop" != this.type || (this.timer -= a, this.timer <= 0 && "loop" == this.type && (this.timer = this.duration))
    }, j.prototype.tickBodyPartAnimations = function(a) {
        if (this.hasParsedClass) {
            var b, c = void 0;
            this.animationQueue.length > 0 ? (b = this.animationQueue[0].id, c = this.animationQueue[0]) : b = "idle", this.class && this.class.type && (this.class.tickBaseAnimation.call(this, b, c, a), this.class.tickClassAnimation.call(this, b, c))
        }
    };
    var Tb, Ub = !1,
        Vb = function() {
            var a = this,
                b = Math.PI / 2;
            this.locked = !1, this.lmb = !1, this.rmb = !1, this.cameraX = 0, this.cameraY = 0, this.cameraZoom = 8, this.mouse = new THREE.Vector2, this.mouseOld = new THREE.Vector2, this.mouseElement = void 0, this.lmbLastDownTime = 0, this.lastX = 0, this.lastY = 0, this.mouseMove_unlocked = function(b) {
                a.mouseElement = b.target.getAttribute ? b.target.getAttribute("data-infopanel") : null, a.mouse.x = b.clientX / window.innerWidth * 2 - 1, a.mouse.y = 2 * -(b.clientY / window.innerHeight) + 1, Wb || (a.lastX = b.x, a.lastY = b.y), void 0 != Db && Eb.css({
                    left: b.pageX,
                    top: b.pageY
                })
            }, this.mouseMove_locked = function(c) {
                c.preventDefault();
                var d = c.movementX || c.mozMovementX || c.webkitMovementX || 0,
                    e = c.movementY || c.mozMovementY || c.webkitMovementY || 0;
                Wb ? (d = c.movementX || c.mozMovementX || c.webkitMovementX || 0, e = c.movementY || c.mozMovementY || c.webkitMovementY || 0) : (d = c.x - a.lastX, e = c.y - a.lastY, a.lastX = c.x, a.lastY = c.y), a.cameraY -= .0035 * d, a.cameraX -= .0021 * e, a.cameraX = Math.max(-b, Math.min(b, a.cameraX))
            }, this.onMouseDown = function(b) {
                if (b.target.dataset.mouselock || a.lmb || a.rmb) {
                    switch (b.button) {
                        case 0:
                            a.lmb = !0, this.lmbLastDownTime = performance.now();
                            break;
                        case 3:
                        case 2:
                            a.rmb = !0
                    }
                    return Ic && (a.lmb || a.rmb) && a.tryLock(), !1
                }
            }, this.onMouseUp = function(b) {
                switch (b.button) {
                    case 0:
                        a.lmb = !1, performance.now() - this.lmbLastDownTime < 300 && void 0 != Xc && void 0 != Ic && (Xc.drop ? Xc.requestPickUp() : (Ic.target = Xc, "vendor" == Ic.target.class.type && Ic && Ic.canSellToTrader() && ($("#trader").centerMe(0, -100), $("#trader").show(), $("#inventory").show(), Lb = !0, Ub || (Ub = !0, (adsbygoogle = window.adsbygoogle || []).push({})))));
                        break;
                    case 3:
                    case 2:
                        a.rmb = !1
                }
                return a.lmb || a.rmb || a.unLock(), !1
            }, this.mouseWheelEvent = function(b) {
                if (b.target == Cc.domElement || b.target == document.body) {
                    b.preventDefault();
                    var c = b.wheelDelta ? b.wheelDelta : -b.detail;
                    a.cameraZoom -= c > 0 ? 1 : -1, a.cameraZoom = Math.min(30, Math.max(a.cameraZoom, 3))
                }
            }, document.addEventListener("mousemove", this.mouseMove_unlocked, !1), document.addEventListener("mousedown", this.onMouseDown), document.addEventListener("mouseup", this.onMouseUp), document.addEventListener("mousewheel", this.mouseWheelEvent), document.addEventListener("DOMMouseScroll", this.mouseWheelEvent), this.tryLock = function() {
                if (Wb) {
                    var a = document.body;
                    a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock, a.requestPointerLock()
                } else this.locked = !0, document.addEventListener("mousemove", Tb.mouseMove_locked, !1), document.removeEventListener("mousemove", Tb.mouseMove_unlocked, !1)
            }, this.unLock = function() {
                Wb ? (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock, document.exitPointerLock()) : (this.locked = !1, document.addEventListener("mousemove", Tb.mouseMove_unlocked, !1), document.removeEventListener("mousemove", Tb.mouseMove_locked, !1))
            }
        };
    window.oncontextmenu = function() {
        return !1
    };
    var Wb = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
    if (Wb) {
        var Xb = document.body,
            Yb = function(a) {
                document.pointerLockElement === Xb || document.mozPointerLockElement === Xb || document.webkitPointerLockElement === Xb ? (Tb.locked = !0, document.addEventListener("mousemove", Tb.mouseMove_locked, !1), document.removeEventListener("mousemove", Tb.mouseMove_unlocked, !1)) : (Tb.locked = !1, document.addEventListener("mousemove", Tb.mouseMove_unlocked, !1), document.removeEventListener("mousemove", Tb.mouseMove_locked, !1))
            };
        document.addEventListener("pointerlockchange", Yb, !1), document.addEventListener("mozpointerlockchange", Yb, !1), document.addEventListener("webkitpointerlockchange", Yb, !1)
    } else console.log("ERROR: Your browser does seems to not support the pointer lock API.");
    var Zb = void 0,
        $b = !0,
        _b = void 0,
        ac = function() {
            _b = $("#fpsdisplay"), Zb = setInterval(function() {
                $b || _b.text((1e3 / Zc).toFixed(1) + " fps")
            }, 200), $("#modal-settings").on("hidden.bs.modal", function(a) {
                pc("show"), $b = !0
            }), $("#modal-settings").on("show.bs.modal", function(a) {
                pc("hide"), $b = !1
            }), $("#sys-settings").on("click", function() {
                $("#setting-camlock").prop("checked", "true" == Pa.get("camlock")), $("#setting-resolution").val(parseInt(Pa.get("resolution"))), $("#setting-skillefx").prop("checked", "true" == Pa.get("skillefx")), $("#setting-shadows").val(parseInt(Pa.get("shadows"))), $("#setting-grass").val(parseInt(Pa.get("grass"))), $("#modal-settings").modal("show")
            }), $("#setting-camlock").on("change", function() {
                Pa.set("camlock", this.checked + "")
            }), $("#setting-resolution").on("input change", function() {
                Pa.set("resolution", this.value + ""), hd()
            }), $("#setting-skillefx").on("change", function() {
                Pa.set("skillefx", this.checked + "")
            }), $("#setting-shadows").on("input change", function() {
                Pa.set("shadows", this.value + ""), id()
            }), $("#setting-grass").on("change", function() {
                Pa.set("grass", this.value + ""), g(Z(oa.grassmap.image), uc.geometry)
            });
            var a = $(".chatsettingbutton");
            a.each(function() {
                var a = $(this).data("chat"),
                    b = va(Pa.get(a));
                b || $(this).addClass("chatsettingdisable")
            })
        },
        bc = {},
        cc = {},
        dc = {
            goldCoin: "<img src='data/coin.png' class='goldCoin'></img>",
            faction1: "<img src='data/factionA.png' class='goldCoin'></img>",
            faction2: "<img src='data/factionB.png' class='goldCoin'></img>"
        },
        ec = {},
        fc = void 0,
        gc = {},
        hc = "g";
    createUi = function(a) {
        var b = document.body;
        bc.player = new TargetPanel($("#upperLeftContainer"), "You"), bc.target = new TargetPanel($("#upperLeftContainer"), "Target"), gc.claninvite = $("<button style='position:absolute; top: 0px; right: -32px;' class='btn btn-default btn-xs'><img style='width: 15px;margin: 3px;' src='data/icons/horde.png'></img></button>").appendTo(bc.target.panel), gc.claninvite.on("click", function(a) {
            Ic && void 0 !== Ic.target && Ic.target.faction == Ic.faction && wd.emit("ca", {
                a: "invite"
            })
        });
        var c = $("<p/>", {
            class: "resourcesText",
            style: "float:left",
            id: "invtrashcan"
        }).appendTo($("#inventory"));
        c.html("<img src='/trash.png'>");
        var d = $("<p/>", {
            class: "resourcesText"
        }).appendTo($("#inventory"));
        d.html(dc.goldCoin + " <span>0</span>"), cc.gold = $(d).find("span"), Gb();
        var e = document.createElement("div");
        e.id = "expBarContainer", e.innerHTML = "<div class='progress' id='expbarprogress'><div class=\"progress-bar\" id='expbar' role=\"progressbar\"></div></div>", b.appendChild(e), cc.expbar = $("#expbar"), cc.expbarcontainer = $(e), cc.expbartext = $("<p/>", {
            class: "progressbartext",
            id: "expbartext"
        }), cc.expbartext.insertAfter(expbar);
        var f = document.createElement("div");
        f.innerHTML = "<div id='skillbar'></div>", b.appendChild(f), cc.skillbar = $("#skillbar"), ic(1, cc.skillbar), ic(2, cc.skillbar), ic(3, cc.skillbar), ic(4, cc.skillbar), castbarcontainer = document.createElement("div"), castbarcontainer.innerHTML = '<div class=\'progress\'><div class="progress-bar" id=\'castbar\' role="progressbar" style="width:0% padding:0px"> </div> </div>', castbarcontainer.id = "castBarContainer", b.appendChild(castbarcontainer), cc.castbar = $("#castbar"), cc.castbarcontainer = $("#castBarContainer"), cc.infoPanel = $("<div/>", {
            class: "panel panel-default",
            id: "infoPanel"
        }).appendTo($("#infoPanelContainer")), cc.infoPanel.hide(), cc.statistics = $("#statistics"), cc.chatboxBody = $("#chatboxBody"), cc.chatboxWrapper = $("#chatboxWrapper"), cc.chatInput = $("#chatInputForm"), cc.chatbox = $("#chatbox"), cc.ladder = $("#ladder"), cc.ladderBody = $("#ladder-body"), $("#chatInputForm").submit(function(a) {
            a.preventDefault(), cc.chatInput.hide();
            Qa($("#chatInput").val());
            $("#chatInput").val(""), $("#chatInput").blur()
        }), $("#cbt-g").on("click", function() {
            $("#chatChannelName").text("Global"), hc = "g"
        }), $("#cbt-c").on("click", function() {
            $("#chatChannelName").text("Clan"), hc = "c"
        }), $("#loginform").submit(function(a) {
            a.preventDefault(), sc()
        }), $("#loginformbutton").on("click", function(a) {
            load_c && load_g && sc(), a.preventDefault()
        }), $("#logintabs a").click(function(a) {
            a.preventDefault(), $(this).tab("show")
        }), $("#loginTabButton").on("click", function() {
            var a = $("#loginTabId").val();
            "" != a && (Ed = a, sc())
        });
        var g = $("#classSelection .classChoice");
        g.on("click", function() {
            g.removeClass("active"), $(this).addClass("active"), Pa.set("class", $(this).data("class"))
        }), cc.classSelection = g;
        var h = $("#factionSelectionPanel .factionSelect");
        h.on("click", function() {
            h.removeClass("active"), $(this).addClass("active"), Pa.set("faction", $(this).data("faction"))
        }), cc.factionSelection = h, cc.sysbar = $("#systembar"), $("#sys-user").on("click", function() {
            $("#serverLoginMessage").hide(), $("#modal-user").modal("show"), wd.emit("reqid")
        }), $("#modal-user").on("hidden.bs.modal", function(a) {
            pc("show")
        }), $("#modal-user").on("show.bs.modal", function(a) {
            pc("hide")
        }), $("#switchIdButton").on("click", function() {
            var a = $("#switchIdField").val();
            a != Ad && "" != a && ($("#serverLoginMessage").hide(), Md($("#switchIdField").val()))
        }), $("#setNickModalButton").on("click", function() {
            $("#modal-setnick").modal("show")
        }), $("#visitProfile").on("click", function() {
            Ic && window.open("http://www.hordes.io/player/" + Ic.name, "_blank")
        }), $("#setNickButton").on("click", function() {
            var a = $("#setNickField").val();
            "" != a && ($("#setNickMsg").hide(), wd.emit("cn", a))
        }), $("#sys-help").on("click", function() {
            $("#modal-help").modal("show")
        }), $("#sys-inventory").on("click", function() {
            $("#inventory").toggle()
        }), $("#sys-charpanel").on("click", function() {
            $("#characterpanel").toggle()
        }), $("#sys-clan").on("click", function() {
            sb(rb), $("#modal-clan").modal("show")
        }), $("#respawnButton").on("click", function() {
            $("#deathScreen").hide(), fc = function() {
                wd && wd.emit("confrespawn")
            }, tc()
        }), $("#sys-clan").on("click", function() {
            $("#modal-clan").modal("show")
        }), $("#createClanButton").on("click", function() {
            var a = $("#createClanName").val(),
                b = $("#createClanTag").val();
            "" != a && "" != b && ($("#createClanMsg").hide(), Nd({
                n: $("#createClanName").val(),
                t: $("#createClanTag").val()
            }))
        }), $("#leaveClanButton").on("click", function() {
            wd.emit("ca", {
                a: "leave"
            })
        }), $("#disbandClanButton").on("click", function() {
            wd.emit("ca", {
                a: "disband"
            })
        }), $("#interact-accept").on("click", function() {
            $("#userinteract").hide(), wd.emit("ca", {
                a: "accept"
            })
        }), $("#interact-decline").on("click", function() {
            $("#userinteract").hide()
        });
        var i = $(".chatsettingbutton");
        i.on("click", function() {
            var a = $(this).data("chat"),
                b = !va(Pa.get(a));
            Pa.set(a, b), b ? $(this).removeClass("chatsettingdisable") : $(this).addClass("chatsettingdisable")
        }), ac();
        var j = Pa.get("faction");
        switch (parseInt(j)) {
            case 0:
            case 1:
                cc.factionSelection.eq(j).click()
        }
        var k = Pa.get("class");
        switch (k) {
            case "warrior":
                cc.classSelection.eq(0).click();
                break;
            case "mage":
                cc.classSelection.eq(1).click();
                break;
            case "shaman":
                cc.classSelection.eq(2).click();
                break;
            case "archer":
                cc.classSelection.eq(3).click()
        }
        var l = Pa.get("name");
        $("#usernameInputField").val(l)
    };
    var ic = function(a, b) {
            var c = "<div data-infopanel='skill" + a + "' class='skill' id='skillButton" + a + "'><img data-infopanel='skill" + a + "' id='skillIcon" + a + "' src='' class='skillIcon'></img><div data-infopanel='skill" + a + "' id='skillOverlay" + a + "' class='skillOverlay'></div><kbd id='skillButtonKbd" + a + "'data-infopanel='skill" + a + "' class='skillHotkey'>" + Pa.get("skill" + a) + "</kbd><p data-infopanel='skill" + a + "' id='skillCooldown" + a + "' class='skillCooldown'></p></div>";
            b.append(c);
            var d = $("#skillButton" + a),
                e = $("<button id='skillLevelButton" + a + "' class='btn skillLvlUpButton'>+</button>");
            d.mouseover(function(b) {
                jc(e, a), e.stop(!0, !0), e.show()
            }), d.mouseout(function(a) {
                e.stop(!0, !0), e.fadeOut(400)
            }), e.hide(), e.click(function(b) {
                Ic && Ic.class && Ic.class.skills[a].tryLevelUp()
            }).appendTo(d)
        },
        jc = function(a, b) {
            Ic.class.skills[b].canLevelUp() ? a.removeClass("skillButtonDisabled") : a.addClass("skillButtonDisabled")
        },
        kc = void 0,
        lc = void 0,
        mc = !0,
        nc = !0,
        oc = void 0;
    updateUi = function(a) {
        nc || (Ic ? (bc.player.update({
            name: Ic.name,
            level: Ic.class.level,
            relationship: "ally",
            hp: Ic.stats.currenthp,
            maxhp: Ic.stats.maxhp,
            mp: Ic.stats.currentmp,
            maxmp: Ic.stats.maxmp,
            icon: 0 == Ic.faction ? "factionA" : "factionB",
            class: Ic.class.type
        }), Ic.target ? (bc.target.update({
            name: Ic.target.name,
            level: Ic.target.class.level,
            relationship: Ic.target.faction == Ic.faction ? "ally" : "enemy",
            hp: Ic.target.stats.currenthp,
            maxhp: Ic.target.stats.maxhp,
            mp: Ic.target.stats.currentmp,
            maxmp: Ic.target.stats.maxmp,
            icon: 0 == Ic.target.faction ? "factionA" : "factionB",
            class: Ic.target.isAi ? "monster" : Ic.target.class.type
        }), Ic.target != oc && (Ic.clanrole > 0 && Ic.target.faction == Ic.faction && void 0 == Ic.target.class.ai ? gc.claninvite.show() : gc.claninvite.hide())) : bc.target.update({
            hide: !0
        })) : (bc.player.update({
            hide: !0
        }), bc.target.update({
            hide: !0
        })), Tb.mouseElement == kc && Xc == lc || (kc = Tb.mouseElement, lc = Xc, null == Tb.mouseElement ? void 0 != Xc ? (cc.infoPanel.html(Xc.getInfoPanelString()), mc && (cc.infoPanel.stop(!0, !0), cc.infoPanel.show(), mc = !1)) : mc || (cc.infoPanel.stop(!0, !0), cc.infoPanel.fadeOut(400), mc = !0) : ec.hasOwnProperty(Tb.mouseElement) ? (cc.infoPanel.html(ec[Tb.mouseElement]), mc && (cc.infoPanel.stop(!0, !0), cc.infoPanel.show(), mc = !1)) : mc || (cc.infoPanel.stop(!0, !0), cc.infoPanel.fadeOut(400), mc = !0)), Lb && Ic && !Ic.canSellToTrader() && ($("#trader").hide(), Lb = !1))
    };
    var pc = function(a, b) {
            cc.ladder[a](b), cc.chatbox[a](b), cc.expbarcontainer[a](b), cc.infoPanel[a](b), cc.skillbar[a](b), cc.statistics[a](b), cc.castbarcontainer[a](b), bc.player.panel[a](b), bc.target.panel[a](b), cc.sysbar[a](b)
        },
        qc = [{}, {}, {}, {}, {}, {}, {}, {}],
        rc = function(a, b) {
            var c = $("#laddertable").find("tr").eq(a).find("td");
            void 0 !== b.name && (c[0].innerHTML = "<img class='classicon' src='data/" + b.class + ".png'> " + b.name), void 0 !== b.lvl && (c[1].innerHTML = parseInt(b.lvl)), void 0 !== b.fame && (c[2].innerHTML = "<b>" + parseInt(b.fame) + "</b>"), void 0 !== b.horde && c.attr("class", 1 == parseInt(b.horde) ? "factionB" : "factionA")
        },
        sc = function() {
            $("nav").fadeOut(300), $("#loginfade").fadeOut(300, function() {
                $("#renderer").fadeOut(300, function() {
                    tc()
                })
            })
        };
    fc = function() {
        Jd(Cd)
    };
    var tc = function() {
        fc()
    };
    $.fn.centerMe = function(a, b) {
        this.css("left", $(window).width() / 2 - $(this).width() / 2 + a), this.css("top", $(window).height() / 2 - $(this).height() / 2 + b)
    }, TargetPanel = function(a, b) {
        var c = $("<div/>", {
            class: "panel panel-default targetPanel"
        });
        c.appendTo(a);
        var d = $("<div/>", {
                class: "targetinfo"
            }).appendTo(c),
            e = $("<p/>", {
                class: "targettext targetname",
                text: ""
            }).appendTo(d),
            f = $("<img/>", {
                class: "factionicon",
                src: "data/factionA.png"
            }).prependTo(e),
            g = $("<span/>").appendTo(e),
            h = $("<p/>", {
                class: "targettext targetlevel",
                text: ""
            }).appendTo(d),
            i = $("<span/>").appendTo(h),
            j = $("<img/>", {
                class: "classicon",
                src: "data/warrior.png"
            }).prependTo(h),
            k = $("<div/>", {
                class: "progress hpbarbg"
            }).appendTo(c),
            l = $("<div/>", {
                class: "progress-bar hpbar",
                role: "progressbar"
            }).appendTo(k),
            m = $("<p/>", {
                class: "targettext targethealthtext",
                text: "1321 / 2384"
            }).appendTo(k),
            n = $("<div/>", {
                class: "progress mpbarbg"
            }).appendTo(c),
            o = $("<div/>", {
                class: "progress-bar mpbar",
                role: "progressbar"
            }).appendTo(n),
            p = $("<p/>", {
                class: "targettext targethealthtext manafont",
                text: "1321 / 2384"
            }).appendTo(n);
        this.panel = c, this.name = g, this.icon = f, this.class = j, this.level = i, this.hpbar = l, this.hpbarBg = k, this.mpbar = o, this.mpbarBg = n, this.hptext = m, this.mptext = p, this.targetmode = b, this.tlvl = h, this.hp = 0, this.maxhp = 1, this.mp = 0, this.maxmp = 1, this.relationship = "ally", this.lasticon = "", this.lastclass = "", this.hidden = !0, this.panel.hide()
    }, TargetPanel.prototype.update = function(a) {
        if (a.hide) return void(this.hidden || (this.panel.hide(), this.hidden = !0));
        this.hidden && (this.panel.show(), this.hidden = !1);
        var b = !1,
            c = !1;
        for (param in a)
            if (a.hasOwnProperty(param)) {
                var d = a[param];
                switch (param) {
                    case "name":
                        d != this.oldname && (this.oldname = d, this.name.text(d), this[param].append(" <span class='targetMode'>" + this.targetmode + "</span>"));
                        break;
                    case "level":
                        this.level.text() != d && this.level.text(d);
                        break;
                    case "relationship":
                        a[param] != this.relationship && (this.relationship = d, this.name.attr("class", "targettext targetname " + this.relationship));
                        break;
                    case "hp":
                    case "maxhp":
                        ("hp" == param && d != this.hp || "maxhp" == param && d != this.maxhp) && (b = !0, this[param] = d);
                        break;
                    case "mp":
                    case "maxmp":
                        ("mp" == param && d != this.mp || "maxmp" == param && d != this.maxmp) && (c = !0, this[param] = d);
                        break;
                    case "icon":
                        d != this.lasticon && (this.icon.attr("src", "data/" + d + ".png"), this.lasticon = d);
                        break;
                    case "class":
                        d != this.lastclass && (this.class.attr("src", "data/" + d + ".png"), this.lastclass = d)
                }
            }
        b && (this.hptext.text(this.hp + "/" + this.maxhp), this.hpbar.css("width", Math.round(this.hp / this.maxhp * 100) + "%")), c && (this.mptext.text(this.mp + "/" + this.maxmp), this.mpbar.css("width", Math.round(this.mp / this.maxmp * 100) + "%"))
    };
    var uc, vc, wc, xc, yc, zc, Ac, Bc, Cc, Dc, Ec, Fc, Gc, Hc, Ic, Jc, Kc, Lc = 4,
        Mc = function() {
            Va || (zc = Z(oa.heightmap.image));
            var a = Va ? heightmap.shape[0] : oa.heightmap.image.width,
                b = Va ? heightmap.shape[1] : oa.heightmap.image.height;
            wc = a * Lc, xc = 3 * a, Va || (oa.detail.wrapS = THREE.RepeatWrapping, oa.detail.wrapT = THREE.RepeatWrapping, oa.detail2.wrapS = THREE.RepeatWrapping, oa.detail2.wrapT = THREE.RepeatWrapping, oa.detail_h.wrapS = THREE.RepeatWrapping, oa.detail_h.wrapT = THREE.RepeatWrapping, Vc.terrain = new THREE.RawShaderMaterial({
                uniforms: {
                    map: {
                        value: oa.color
                    },
                    detail: {
                        value: oa.detail
                    },
                    detailHeight: {
                        value: oa.detail_h
                    },
                    detail2: {
                        value: oa.detail2
                    },
                    shadow: {
                        value: Ec.shadow.map
                    },
                    ambient: {
                        value: Dc.color
                    },
                    directional: {
                        value: Ec.color
                    },
                    directionalDir: {
                        value: Ec.position
                    },
                    directionalMVP: {
                        value: new THREE.Matrix4
                    },
                    fogColor: {
                        value: Ac.fog.color
                    },
                    fogDensity: {
                        value: Ac.fog.density
                    },
                    targetCircle: {
                        value: new THREE.Vector4(0, 0, 0, 2)
                    },
                    targetCirclePos: {
                        value: new THREE.Vector2(0, 0)
                    },
                    shadowSize: {
                        value: 0
                    }
                },
                vertexShader: pa["terrain.vert"],
                fragmentShader: pa["terrain.frag"],
                depthTest: !0,
                depthWrite: !0
            })), vc = new THREE.PlaneBufferGeometry(wc, wc, a - 1, b - 1);
            for (var c = 0; c < a; ++c)
                for (var d = 0; d < b; ++d) {
                    var e = xc * d + 3 * c;
                    vc.attributes.position.array[e + 0] = c * Lc, vc.attributes.position.array[e + 2] = d * Lc, vc.attributes.position.array[e + 1] = .6 * aa(c + 1, d + 1).r
                }
            vc.computeFaceNormals(), vc.computeVertexNormals(), vc.normalsNeedUpdate = !0, vc.verticesNeedUpdate = !0, yc = vc.attributes.position.array.length, uc = new THREE.Mesh(vc, Va ? void 0 : Vc.terrain), Va || (uc.receiveShadow = !0, uc.castShadow = !1, Ac.add(uc))
        },
        Nc = void 0,
        Oc = 0,
        Pc = function(a) {
            5e-4 * performance.now();
            uc.material.uniforms.directionalMVP.value = Ec.shadow.matrix, Ec.shadow.map && (uc.material.uniforms.shadow.value = Ec.shadow.map.texture), Oc > 0 && (Oc -= Oc * a * 15);
            var b = Xc && Xc.drop ? Xc : Ic ? Ic.target : void 0;
            Ic && b ? (Nc != b && (Oc = 1), Nc = b, Xc && Xc.drop ? (uc.material.uniforms.targetCirclePos.value = new THREE.Vector2(b.position.x, b.position.z), uc.material.uniforms.targetCircle.value.w = .5 * Math.max(Xc.quad.geometry.sh_h, Xc.quad.geometry.sh_w) + .1 + .5 * Oc, uc.material.uniforms.targetCircle.value.x = .7, uc.material.uniforms.targetCircle.value.y = .7, uc.material.uniforms.targetCircle.value.z = .7) : (uc.material.uniforms.targetCirclePos.value = new THREE.Vector2(b.visualPosition.x, b.visualPosition.z), uc.material.uniforms.targetCircle.value.w = b.stats.scale + .2 + Oc, uc.material.uniforms.targetCircle.value.x = b.faction == Ic.faction ? 0 : 1, uc.material.uniforms.targetCircle.value.y = b.faction == Ic.faction ? 1 : 0, uc.material.uniforms.targetCircle.value.z = 0)) : uc.material.uniforms.targetCirclePos.value = new THREE.Vector2(0, 0)
        },
        Qc = function(a, b) {
            var c = a / Lc,
                d = b / Lc,
                e = c % 1,
                f = d % 1;
            0 == e && (c += 1e-10), 0 == f && (d += 1e-10);
            var g, h, i;
            if (g = xc * Math.ceil(d) + 3 * Math.floor(c), h = xc * Math.floor(d) + 3 * Math.ceil(c), i = e + f > 1 ? xc * Math.ceil(d) + 3 * Math.ceil(c) : xc * Math.floor(d) + 3 * Math.floor(c), g < 0 || h < 0 || i < 0 || g >= yc || h >= yc || i >= yc) return 0;
            var j = Uc(Sc(g), Sc(h), Sc(i), a, b);
            return j || 0
        },
        Rc = function(a, b) {
            var c = a / Lc,
                d = b / Lc,
                e = c % 1,
                f = d % 1;
            0 == e && (c += 1e-10), 0 == f && (d += 1e-10);
            var g, h, i;
            if (g = xc * Math.ceil(d) + 3 * Math.floor(c), h = xc * Math.floor(d) + 3 * Math.ceil(c), e + f > 1) i = xc * Math.ceil(d) + 3 * Math.ceil(c);
            else {
                i = xc * Math.floor(d) + 3 * Math.floor(c);
                var j = i;
                i = h, h = j
            }
            if (g < 0 || h < 0 || i < 0 || g >= yc || h >= yc || i >= yc) return 0;
            var k = new THREE.Triangle(Tc(g), Tc(h), Tc(i));
            return k.normal()
        },
        Sc = function(a) {
            return {
                x: vc.attributes.position.array[a],
                y: vc.attributes.position.array[a + 1],
                z: vc.attributes.position.array[a + 2]
            }
        },
        Tc = function(a) {
            return new THREE.Vector3(vc.attributes.position.array[a], vc.attributes.position.array[a + 1], vc.attributes.position.array[a + 2])
        },
        Uc = function(a, b, c, d, e) {
            var f = (b.z - c.z) * (a.x - c.x) + (c.x - b.x) * (a.z - c.z),
                g = ((b.z - c.z) * (d - c.x) + (c.x - b.x) * (e - c.z)) / f,
                h = ((c.z - a.z) * (d - c.x) + (a.x - c.x) * (e - c.z)) / f,
                i = 1 - g - h;
            return g * a.y + h * b.y + i * c.y
        },
        Vc = {},
        Wc = [],
        Xc = void 0,
        Yc = 0,
        Zc = 0,
        $c = 0,
        _c = 10,
        ad = function() {
            Ka(Cc.domElement), Tb = new Vb, Ac = new THREE.Scene, Bc = new THREE.Scene, Hc = new THREE.Raycaster, Ac.fog = new THREE.FogExp2(6664656, .0065), Cc.setClearColor(9561076), Fc = new THREE.PerspectiveCamera(75, 0, .1, 1e3), Ac.add(Fc), Gc = new THREE.OrthographicCamera(1, 1, 1, 1, 1, 10), Gc.position.z = 10, Dc = new THREE.AmbientLight(6793417), Ac.add(Dc), Ec = new THREE.DirectionalLight(11711133, .65), Ac.add(Ec), Ac.add(Ec.target), Mc(), g(Z(oa.grassmap.image), uc.geometry), id(), ka(), $("#upperLeftContainer").fadeIn(), Yc = performance.now();
            var a = function() {
                requestAnimationFrame(a), $c = performance.now(), Zc += ($c - Yc - Zc) / _c;
                var b = Math.min(($c - Yc) / 1e3, .1);
                Yc = $c, Sb++, gb(), qd = [], rd = [], Kc = [];
                for (var c in Jc) Kc.push(Jc[c]);
                void 0 !== Ic && (Ic.playertick(b), Ic.clienttick(b));
                for (var c in Jc) Jc.hasOwnProperty(c) && void 0 != Jc[c] && Jc[c] != Ic && Jc[c].clienttick(b);
                md(b), updateUi(b), void 0 == Ic ? gd(b) : (zd(), ed(), Rb(b), qb(b)), h(b), Pc(b), Cc.clear(), Cc.render(Ac, Fc), Cc.clearDepth(), Cc.render(Bc, Gc)
            };
            a()
        },
        bd = function() {
            var a = {
                w: oa.items.image.width,
                h: oa.items.image.height
            };
            kd.items = {};
            for (var b in ra.items.frames) {
                var c = ra.items.frames[b].frame,
                    d = ra.items.frames[b].rotated,
                    e = (d ? c.h : c.w) / a.w,
                    f = (d ? c.w : c.h) / a.h,
                    g = e / 2,
                    h = c.x / a.w,
                    i = 1 - c.y / a.h - f;
                kd.items[b] = new THREE.PlaneBufferGeometry(1, 1, 2, 1), kd.items[b].attributes.uv.array[0] = h, kd.items[b].attributes.uv.array[1] = i + f, kd.items[b].attributes.uv.array[2] = h + g, kd.items[b].attributes.uv.array[3] = i + f, kd.items[b].attributes.uv.array[4] = h + e, kd.items[b].attributes.uv.array[5] = i + f, kd.items[b].attributes.uv.array[6] = h, kd.items[b].attributes.uv.array[7] = i, kd.items[b].attributes.uv.array[8] = h + g, kd.items[b].attributes.uv.array[9] = i, kd.items[b].attributes.uv.array[10] = h + e, kd.items[b].attributes.uv.array[11] = i;
                var j = (d ? c.h : c.w) / 38,
                    k = (d ? c.w : c.h) / 38,
                    l = 0;
                switch (b.replace(/[0-9]/g, "")) {
                    default:
                        case "gold":
                        case "bow":
                        l = 0;
                    break;
                    case "sword":
                            case "shield":
                            case "totem":
                            case "hammer":
                            case "glove":
                            case "boot":
                            case "bag":
                            l = .2;
                        break;
                    case "armor":
                            case "staff":
                            case "quiver":
                            l = .3
                }
                l *= j, kd.items[b].sh_w = j + .5, kd.items[b].sh_h = k + .5, kd.items[b].attributes.position.array[0] = -j, kd.items[b].attributes.position.array[1] = k, kd.items[b].attributes.position.array[3] = 0, kd.items[b].attributes.position.array[4] = k, kd.items[b].attributes.position.array[5] = l, kd.items[b].attributes.position.array[6] = j, kd.items[b].attributes.position.array[7] = k, kd.items[b].attributes.position.array[9] = -j, kd.items[b].attributes.position.array[10] = -k, kd.items[b].attributes.position.array[12] = 0, kd.items[b].attributes.position.array[13] = -k, kd.items[b].attributes.position.array[14] = l, kd.items[b].attributes.position.array[15] = j, kd.items[b].attributes.position.array[16] = -k, kd.items[b].computeFaceNormals(), kd.items[b].computeVertexNormals(), kd.items[b].normalsNeedUpdate = !0, kd.items[b].verticesNeedUpdate = !0
            }
        },
        cd = function() {
            Vc.item = new THREE.MeshBasicMaterial({
                map: oa.items,
                transparent: !0,
                alphaTest: .5,
                color: 6710886,
                side: THREE.DoubleSide
            }), Vc.hpbarbg = new THREE.SpriteMaterial({
                color: 0
            }), Vc.hpbarclan = new THREE.SpriteMaterial({
                color: 4486399
            }), Vc.hpbarfriendly = new THREE.SpriteMaterial({
                color: 65280
            }), Vc.hpbarenemy = new THREE.SpriteMaterial({
                color: 16711680
            }), Vc.hpbarmob = new THREE.SpriteMaterial({
                color: 16147241
            }), Vc.factionA = new THREE.SpriteMaterial({
                map: oa.factionA,
                color: 16777215
            }), Vc.factionB = new THREE.SpriteMaterial({
                map: oa.factionB,
                color: 16777215
            }), Vc.hpbarcantfight = new THREE.SpriteMaterial({
                color: 6710886
            }), Vc.hpbarbgTransparent = new THREE.SpriteMaterial({
                color: 0
            }), Vc.hpbarfriendlyTransparent = new THREE.SpriteMaterial({
                color: 65280
            }), Vc.hpbarenemyTransparent = new THREE.SpriteMaterial({
                color: 16711680
            }), Vc.hpbarmobTransparent = new THREE.SpriteMaterial({
                color: 16147241
            }), Vc.hpbarcantfightTransparent = new THREE.SpriteMaterial({
                color: 6710886
            }), Vc.hpbarcantfightTransparent.transparent = !0, Vc.hpbarbgTransparent.transparent = !0, Vc.hpbarfriendlyTransparent.transparent = !0, Vc.hpbarenemyTransparent.transparent = !0, Vc.hpbarmobTransparent.transparent = !0, Vc.hpbarcantfightTransparent.opacity = .5, Vc.hpbarbgTransparent.opacity = .2, Vc.hpbarfriendlyTransparent.opacity = .5, Vc.hpbarenemyTransparent.opacity = .8, Vc.hpbarmobTransparent.opacity = .7, Vc.hitbox = new THREE.MeshBasicMaterial({
                visible: !1
            }), Vc.ribbon_arrow = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                alphaMap: oa.gradient,
                transparent: !0,
                alphaTest: .15
            }), Vc.ribbon_heal = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: oa.heal_color,
                alphaMap: oa.heal_alpha,
                transparent: !0,
                alphaTest: .05
            }), Vc.ribbon_ice = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: oa.ice_color,
                alphaMap: oa.heal_alpha,
                transparent: !0,
                alphaTest: .05
            }), Vc.ribbon_decay = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: oa.decay_color,
                alphaMap: oa.decay_alpha,
                transparent: !0,
                alphaTest: .05
            }), Vc.ribbon_leech = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: oa.leech_color,
                alphaMap: oa.heal_alpha,
                transparent: !0,
                alphaTest: .2
            }), Vc.ribbon_whirlwind = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: oa.swingtest,
                alphaMap: oa.alpha,
                transparent: !0,
                alphaTest: .2
            }), Vc.slime_green = new THREE.MeshPhongMaterial({
                color: 11531468,
                transparent: !0,
                opacity: .7,
                shininess: 50,
                specular: 8684676,
                map: oa.heal_color
            }), Vc.slime_blue = new THREE.MeshPhongMaterial({
                color: 687583,
                transparent: !0,
                opacity: .7,
                shininess: 50,
                specular: 8684676
            }), Vc.slime_red = new THREE.MeshPhongMaterial({
                color: 16711680,
                transparent: !0,
                opacity: .7,
                shininess: 50,
                specular: 8684676
            })
        };
    $(document).ready(function() {
        Cc = new THREE.WebGLRenderer({
            antialias: !0
        }), Cc.autoClear = !1, Cc.domElement.dataset.mouselock = !0, Cc.domElement.id = "renderer", $(Cc.domElement).insertBefore("#loginfade"), sa.onFinish(function() {
            ad(), load_g = !0, wa(), sa.onFinish(function() {
                createUi(Cc.domElement), pc("hide"), cd(), bd()
            })
        })
    });
    var dd = 0,
        ed = function() {
            if (dd++, null == Tb.mouseElement && (dd > 20 || Tb.mouseOld.x != Tb.mouse.x || Tb.mouseOld.y != Tb.mouse.y)) {
                dd = 0, Tb.mouseOld.copy(Tb.mouse), Hc.setFromCamera(Tb.mouse, Fc);
                var a = Hc.intersectObjects(Wc);
                a.length > 0 ? (Xc = a[0].object.entity, document.body.style.cursor = "pointer") : (Xc = void 0, document.body.style.cursor = "default"), Wc = []
            }
        },
        fd = 0,
        gd = function(a) {
            fd += a;
            var b = new THREE.Vector3(.5 * wc + Math.sin(.003 * fd) * wc * .25, 0, .5 * wc + Math.cos(.003 * fd) * wc * .25);
            b.y = Qc(b.x, b.z) + 2, Fc.position.copy(b), Ec.position.copy(b)
        },
        hd = function() {
            var a = parseInt(Pa.get("resolution"));
            "number" == typeof a && (a = Math.max(.1, Math.min(1, .1 * a)), Cc.setPixelRatio(a))
        },
        id = function() {
            if ("0" != Pa.get("shadows")) {
                Cc.shadowMap.enabled = !0, Cc.shadowMap.type = THREE.PCFSoftShadowMap, Ec.castShadow = !0, Ec.shadow && delete Ec.shadow, Ec.shadow = new THREE.DirectionalLightShadow, Ec.shadow.camera.left = -100, Ec.shadow.camera.right = 100, Ec.shadow.camera.top = 100, Ec.shadow.camera.bottom = -100, Ec.shadow.camera.near = .5, Ec.shadow.camera.far = 3e3, Ec.shadow.bias = -.001, Cc.shadowMap.renderReverseSided = !1;
                var a = 64;
                switch (parseInt(Pa.get("shadows"))) {
                    default:
                        case 1:
                        a = 128;
                    break;
                    case 2:
                            a = 256;
                        break;
                    case 3:
                            a = 512;
                        break;
                    case 3:
                            a = 1024;
                        break;
                    case 4:
                            a = 2048
                }
                Ec.shadow.mapSize.width = a, Ec.shadow.mapSize.height = a, uc && (uc.material.uniforms.shadowSize.value = a, uc.material.uniforms.shadow.value = Ec.shadow.map), Vc.foliage && (Vc.foliage.uniforms.shadowSize.value = a, Vc.foliage.uniforms.shadow.value = Ec.shadow.map)
            } else Cc.shadowMap.enabled = !1, Ec.castShadow = !1, uc && (uc.material.uniforms.shadowSize.value = 0, uc.material.uniforms.shadow.value = void 0), Vc.foliage && (Vc.foliage.uniforms.shadowSize.value = 0, Vc.foliage.uniforms.shadow.value = void 0)
        },
        jd = {
            box: new THREE.BoxBufferGeometry(1, 1, 1),
            icebolt: new THREE.SphereBufferGeometry(.3, 4, 3),
            frostcall: new THREE.CylinderBufferGeometry(12, 12, .15, 20, 1),
            frostblizz: new THREE.SphereBufferGeometry(.3, 3, 2),
            iceblock: new THREE.SphereBufferGeometry(3, 4, 5),
            bow: new THREE.TorusBufferGeometry(1.3, .15, 3, 4, 2.5),
            slime: new THREE.SphereBufferGeometry(.9, 6, 3, 0, 2 * Math.PI, 0, 1.9)
        },
        kd = {};
    kd.chest = {
        geo: jd.box,
        scale: [1, 1, 1]
    }, kd.leg = {
        geo: jd.box,
        scale: [.4, .4, .4]
    }, kd.hand = {
        geo: jd.box,
        scale: [.45, .4, .4]
    }, kd.hitbox = {
        geo: jd.box,
        scale: [1.4, 2.2, 1.4]
    }, kd.mage_staff = {
        geo: jd.box,
        scale: [.2, 1.8, .2]
    }, kd.mage_shield = {
        geo: jd.box,
        scale: [.4, 2.4, 2.4]
    }, kd.icebolt = {
        geo: jd.icebolt
    }, kd.frostcall = {
        geo: jd.frostcall
    }, kd.frostcallblizz = {
        geo: jd.frostblizz
    }, kd.iceblock = {
        geo: jd.iceblock
    }, kd.shaman_mace1 = {
        geo: jd.box,
        scale: [.6, 2, .6]
    }, kd.shaman_mace2 = {
        geo: jd.box,
        scale: [1.8, .8, 2.7]
    }, kd.shaman_robe = {
        geo: jd.box,
        scale: [.5, .8, .1]
    }, kd.shaman_shield = {
        geo: jd.box,
        scale: [1, 1, .2]
    }, kd.equilibrate = {
        geo: jd.box,
        scale: [.5, .5, .5]
    }, kd.warrior_sword = {
        geo: jd.box,
        scale: [.9, 4.2, .5]
    }, kd.warrior_shield = {
        geo: jd.box,
        scale: [.5, 3.5, 3.5]
    }, kd.archer_bow = {
        geo: jd.bow
    }, kd.archer_bow_end = {
        geo: jd.box,
        scale: [1, .6, .5]
    }, kd.archer_ammo = {
        geo: jd.box,
        scale: [.27, .5, .27]
    }, kd.archer_ammo2 = {
        geo: jd.box,
        scale: [1.2, .8, 1.2]
    }, kd.archer_arrow = {
        geo: jd.box,
        scale: [.1, .1, .8]
    }, kd.generic_sword = {
        geo: jd.box,
        scale: [.3, 1.3, .15]
    }, kd.generic_backpack = {
        geo: jd.box,
        scale: [1.1, .8, .6]
    }, kd.generic_vendorlist = {
        geo: jd.box,
        scale: [.4, 2, 2]
    }, kd.slime = {
        geo: jd.slime,
        scale: [1, 1, 1]
    }, Vc.monster = new THREE.MeshLambertMaterial({
        color: 8286051,
        shading: THREE.FlatShading
    }), Vc.bone = new THREE.MeshLambertMaterial({
        color: 14800547,
        shading: THREE.FlatShading
    }), Vc.shaman = new THREE.MeshLambertMaterial({
        color: 3687924,
        shading: THREE.FlatShading
    }), Vc.warrior = new THREE.MeshLambertMaterial({
        color: 15172191,
        shading: THREE.FlatShading
    }), Vc.archer = new THREE.MeshLambertMaterial({
        color: 10471258,
        shading: THREE.FlatShading
    }), Vc.mage = new THREE.MeshLambertMaterial({
        color: 6607340,
        shading: THREE.FlatShading
    }), Vc.warden = new THREE.MeshLambertMaterial({
        color: 14755623,
        shading: THREE.FlatShading
    }), Vc.damage = new THREE.MeshLambertMaterial({
        color: 13382451,
        emissive: 4393996
    }), Vc.dead = new THREE.MeshBasicMaterial({
        color: 2236962,
        shading: THREE.FlatShading
    }), Vc.vendor = new THREE.MeshLambertMaterial({
        color: 12467195,
        shading: THREE.FlatShading
    }), Vc.leg = new THREE.MeshLambertMaterial({
        color: 3451301,
        shading: THREE.FlatShading
    }), Vc.generic_sword = new THREE.MeshLambertMaterial({
        color: 16711680,
        shading: THREE.FlatShading
    }), Vc.generic_wood = new THREE.MeshLambertMaterial({
        color: 8937028,
        shading: THREE.FlatShading
    }), Vc.generic_metal = new THREE.MeshStandardMaterial({
        color: 14736861,
        shading: THREE.FlatShading
    }), Vc.generic_white = new THREE.MeshLambertMaterial({
        color: 16777215,
        shading: THREE.FlatShading
    }), Vc.generic_ice = new THREE.MeshBasicMaterial({
        color: 16777215
    }), Vc.mage_frost = new THREE.MeshBasicMaterial({
        color: 13434879,
        transparent: !0,
        opacity: .6
    }), Vc.shaman_macetop = new THREE.MeshLambertMaterial({
        color: 11643819,
        shading: THREE.FlatShading
    }), Vc.archer_ammo = new THREE.MeshLambertMaterial({
        color: 14795173,
        shading: THREE.FlatShading
    }), Vc.archer_ammo2 = new THREE.MeshLambertMaterial({
        color: 16312288,
        shading: THREE.FlatShading
    }), Vc.gold = new THREE.MeshStandardMaterial({
        color: 16440582,
        emissive: 16740864,
        metalness: .5,
        roughness: .4
    }), Vc.metal = new THREE.MeshStandardMaterial({
        color: 11582396,
        emissive: 3158071,
        metalness: .55,
        roughness: .4
    }), Vc.silver = new THREE.MeshStandardMaterial({
        color: 13891577,
        emissive: 5994641,
        metalness: .58,
        roughness: .4
    });
    var ld = [],
        md = function(a) {
            for (var b = ld.length; b--;) {
                var c = ld[b];
                c.tick(a), c.deleteMe && (c.remove(), ld.splice(b, 1))
            }
        },
        nd = function(a) {
            if (!Va && "false" != Pa.get("skillefx")) {
                var b = new ba(a);
                return ld.push(b), b
            }
        };
    ba.prototype.tick = function(a) {
        this.stepIntervalTimer -= a, this.stepIntervalTimer <= 0 ? (this.stepIntervalTimer = this.stepInterval, this.step()) : "glue" == this.headType && (this.at[this.steps - 1].copy(this.a.getWorldPosition()), this.bt[this.steps - 1].copy(this.b.getWorldPosition()), this.updateVertice(this.steps - 1)), "compress" == this.tailType && (this.uvStepSize = 1 / Math.min(this.steps, this.stepsDone - this.stepIntervalTimer / this.stepInterval)), this.uvShift = this.uvStepSize * (this.stepIntervalTimer / this.stepInterval);
        for (var b = 0; b < this.steps; b++) this.updateUV(b);
        this.timeout && (this.timer -= a, this.timer < 0 && (this.deleteMe = !0))
    }, ba.prototype.step = function(a, b) {
        ++this.stepsDone;
        var c = a || this.a.getWorldPosition(),
            d = b || this.b.getWorldPosition();
        this.at.shift(), this.bt.shift(), this.at.push(c), this.bt.push(d);
        for (var e = 0; e < this.steps; e++) this.updateVertice(e)
    }, ba.prototype.updateVertice = function(a) {
        this.geom.vertices[2 * a].copy(this.at[a]), this.geom.vertices[2 * a + 1].copy(this.bt[a]), this.geom.verticesNeedUpdate = !0, this.geom.normalsNeedUpdate = !0
    }, ba.prototype.updateUV = function(a) {
        if (a < this.steps - 1) {
            var b = (this.steps - a - 1) * this.uvStepSize - this.uvShift,
                c = (this.steps - a - 2) * this.uvStepSize - this.uvShift;
            this.geom.faceVertexUvs[0][2 * a][0].y = b, this.geom.faceVertexUvs[0][2 * a][1].y = c, this.geom.faceVertexUvs[0][2 * a][2].y = b, this.geom.faceVertexUvs[0][2 * a + 1][0].y = c, this.geom.faceVertexUvs[0][2 * a + 1][1].y = c, this.geom.faceVertexUvs[0][2 * a + 1][2].y = b, this.geom.uvsNeedUpdate = !0
        }
    }, ba.prototype.remove = function() {
        Ac.remove(this.mesh), Ac.remove(this.a), Ac.remove(this.b), this.geom.dispose()
    }, j.prototype.timeSinceLastUpdate = 0, j.prototype.initPlayer = function(a, b) {
        this.id = a, this.geometry = new THREE.Object3D, Ac.add(this.geometry), this.body = new THREE.Group, Ac.add(this.body), this.geometry.add(this.body), this.hitbox = new THREE.Mesh(kd.hitbox.geo, Vc.hitbox), this.hitbox.scale.set(kd.hitbox.scale[0], kd.hitbox.scale[1], kd.hitbox.scale[2]), this.body.add(this.hitbox), this.hitbox.position.y = 1, this.hitbox.entity = this, this.visualPosition = new THREE.Vector3, b && (this.isPlayer = !0, Ic = this, this.outofpositioncounter = 0, Ac.remove(Fc), Fc.position.x = 0, Fc.position.z = 8, Fc.position.y = 1.5, this.camPivot = new THREE.Object3D, this.camPivot.rotation.order = "YXZ", Ac.add(this.camPivot), this.camPivot.add(Fc), this.serverpos = new THREE.Vector3, this.ignoreInput = 0), this.visualRotationSpeed = 0, this.visualRotationLast = 0, this.visualRotation = 0, this.dmgSprites = new Array, "true" == Pa.get("nameplates") && (this.namesprite = new ha("", {
            align: Od.center,
            font: "500 18px 'Roboto'",
            fillStyle: "#FFFFFF",
            outlineSize: 4,
            outlineStyle: "black",
            antialias: !1
        }), Bc.add(this.namesprite), this.namesprite.position.set(0, 30, 0), this.namesprite.scale.set(1, 1, 1), this.clansprite = new ha("", {
            align: Od.center,
            font: "800 18px 'Roboto'",
            fillStyle: "#FFFFFF",
            outlineSize: 4,
            outlineStyle: "black",
            antialias: !1
        }), Bc.add(this.clansprite), this.clansprite.position.set(-50, 30, 0), this.clansprite.scale.set(1, 1, 1)), this.levelsprite = new ha("5", {
            align: Od.center,
            font: "500 18px 'Roboto'",
            fillStyle: "#FFFFFF",
            outlineSize: 4,
            outlineStyle: "black",
            antialias: !1
        }), Bc.add(this.levelsprite), this.levelsprite.position.set(0, 0, 0), this.levelsprite.scale.set(1, 1, 1), this.hpbar = new Object, this.hpbar.bg = new THREE.Sprite(Vc.hpbarbg), Bc.add(this.hpbar.bg), this.hpbar.fg = new THREE.Sprite(Vc.hpbarfriendly), Bc.add(this.hpbar.fg), this.factionIcon = new THREE.Sprite(Vc.factionA), this.factionIcon.position.set(0, 0, 0), this.factionIcon.scale.set(1, 1, 1), Bc.add(this.factionIcon)
    }, j.prototype.playertick = function(a) {
        if (this != Ic) return void(this.isPlayer = !1);
        if (this.ignoreInput -= a, this.ignoreInput < 0 && (this.ignoreInput = 0), this.stats && !this.stats.isDead() && !this.stats.incapacitated && this.ignoreInput <= 0 && (this.walkForward = 0, this.walkSideward = 0, Ia && (Tb.cameraY -= 2.3 * a), Ja && (Tb.cameraY += 2.3 * a), this.camPivot.rotation.x = Tb.cameraX, this.camPivot.rotation.y = Tb.cameraY, (Tb.rmb || Ia || Ja || "true" == Pa.get("camlock")) && (this.geometry.rotation.y = Tb.cameraY), (Ga || Tb.lmb && Tb.rmb) && (this.walkForward = 1), Ha && (this.walkForward = -1), Fa && (this.walkSideward = 1), Ea && (this.walkSideward = -1), this.rotation = this.geometry.rotation.y, 0 != Ga && !Tb.lmb && !Tb.rmb && "true" != Pa.get("camlock"))) {
            var b = E(Tb.cameraY, this.geometry.rotation.y) * a * 2;
            Math.abs(b) > .03 * a ? (b = b > 0 ? Math.max(b, .6 * a) : Math.min(b, -.6 * a), Tb.cameraY += b) : Tb.cameraY = this.geometry.rotation.y
        }
        this.camPivot.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), Fc.position.z = Tb.cameraZoom
    }, j.prototype.clienttick = function(a) {
        if (this.tick(a), !this.stats.isDead())
            if (this.isPlayer) {
                if (!this.stats.incapacitated) {
                    var b = Math.abs(this.serverpos.x - this.position.x),
                        c = Math.abs(this.serverpos.z - this.position.z);
                    b > 10 || c > 10 ? (this.outofpositioncounter += a, (this.outofpositioncounter > 3 || b > 50 || c > 50) && (this.position.x = this.serverpos.x, this.position.z = this.serverpos.z, this.outofpositioncounter = 0)) : this.outofpositioncounter = 0
                }
                this.geometry.position.x = this.position.x, this.geometry.position.z = this.position.z, this.geometry.position.y = Qc(this.geometry.position.x, this.geometry.position.z), this.visualPosition.copy(this.position), this.geometry.rotation.y = this.rotation
            } else {
                this.next.position.x += this.velocity.x * a * this.stats.movespeed, this.next.position.z += this.velocity.z * a * this.stats.movespeed;
                var d = new THREE.Vector3;
                d.subVectors(this.position, this.visualPosition);
                var e = 0 != d.x || 0 != d.z ? d.length() : 0;
                if (e > .8 * this.stats.movespeed ? (this.visualPosition.copy(this.position), d.x = 0, d.z = 0) : e > .1 * this.stats.movespeed ? d.setLength(a * this.stats.movespeed) : (this.position != this.next.position && (this.position.x = this.next.position.x, this.position.z = this.next.position.z), d.multiplyScalar(10 * a)), this.visualPosition.add(d), this.geometry.position.x = this.visualPosition.x, this.geometry.position.z = this.visualPosition.z, this.geometry.position.y = Qc(this.geometry.position.x, this.geometry.position.z), this.visualRotationLast != this.rotation && (this.visualRotationLast - this.rotation > Math.PI ? this.visualRotationSpeed = 10 * (this.rotation + Ua - this.visualRotation) * a : this.visualRotationLast - this.rotation < -Math.PI ? this.visualRotationSpeed = 10 * (this.rotation - Ua - this.visualRotation) * a : this.visualRotationSpeed = 10 * (this.rotation - this.visualRotation) * a, this.visualRotationLast = this.rotation), Math.abs(this.rotation - this.visualRotation) > Math.abs(this.visualRotationSpeed)) {
                    for (this.visualRotation += this.visualRotationSpeed; this.visualRotation < 0;) this.visualRotation += Ua, this.visualRotationLast = this.visualRotation;
                    for (; this.visualRotation > Ua;) this.visualRotation -= Ua, this.visualRotationLast = this.visualRotation
                }
                this.geometry.rotation.y = this.visualRotation, Wc.push(this.hitbox), void 0 !== this.desiredTarget && "" != this.desiredTarget && za.entities.hasOwnProperty(this.desiredTarget) && (this.target = za.entities[this.desiredTarget], this.desiredTarget = "")
            }
        if (this.tickAnimations(a), this != Ic) this.timeSinceLastUpdate += a, this.timeSinceLastUpdate > 3 && Ca(this.id);
        else {
            this.camPivot.position.copy(this.geometry.position), this.camPivot.updateMatrixWorld(), Fc.updateMatrixWorld();
            var f = new THREE.Vector3(30 * Math.round(this.geometry.position.x / 30), 30 * Math.round(this.geometry.position.y / 30), 30 * Math.round(this.geometry.position.z / 30));
            f.x == Ec.target.position.x && f.y == Ec.target.position.y && f.z == Ec.target.position.z || (Ec.position.set(f.x + 1500, f.y + 2500, f.z), Ec.target.position.copy(f))
        }
        if (this.stats.scale != this.last.stats.scale) {
            this.last.stats.scale = this.stats.scale;
            var g = Math.max(1, 2 / this.stats.scale);
            this.hitbox.scale.set(g, g, g)
        }
        this.hpbar && this.tickHud(a)
    }, j.prototype.destroyBody = function() {
        this.namesprite && this.namesprite.finalCleanUp(), this.clansprite && this.clansprite.finalCleanUp(), this.levelsprite && this.levelsprite.finalCleanUp(), Bc.remove(this.clansprite), Bc.remove(this.namesprite), Bc.remove(this.hpbar.fg), Bc.remove(this.hpbar.bg), Bc.remove(this.levelsprite), Bc.remove(this.factionIcon), delete this.namesprite, delete this.clansprite, delete this.levelsprite, delete this.hpbar.fg, delete this.hpbar.bg, delete this.factionIcon, this.isPlayer && Ac.remove(this.camPivot);
        for (var a = this.dmgSprites.length; a--;) Bc.remove(this.dmgSprites[a]), this.dmgSprites[a].finalCleanUp(), this.dmgSprites.splice(a, 1);
        ca(this.geometry), Ac.remove(this.geometry), delete this.geometry
    }, j.prototype.takeDamage = function(a) {
        this.stats.invincible || (this.dmgShake = .2)
    }, j.prototype.takeHealing = function(a) {}, j.prototype.updateFaction = function(a, b) {
        if (this.faction = a, !b) {
            var c;
            switch (a) {
                case 0:
                    c = Vc.factionA;
                    break;
                case 1:
                    c = Vc.factionB;
                    break;
                case 2:
                    return
            }
            this.factionIcon.material = c
        }
        if (Ic && (2 == this.faction ? this.hpbar.fg.material = Vc.hpbarmob : this.hpbar.fg.material = this.faction == Ic.faction ? Vc.hpbarfriendly : Vc.hpbarenemy, this.hpbar.fg.materialNeedsUpdate = !0, this == Ic))
            for (var d in Jc) Jc.hasOwnProperty(d) && void 0 !== Jc[d] && Jc[d] != this && Jc[d].updateFaction(Jc[d].faction, !0)
    }, j.prototype.getInfoPanelString = function() {
        if (!Ic) return "";
        var a = this.faction == Ic.faction ? "Friendly" : "Hostile",
            b = this.faction == Ic.faction ? "ally" : "enemy",
            c = this.isAi ? "monster" : "player";
        return "<div class='targetinfo targettext " + b + "'><span class='targetname'>" + this.name + "</span> <span class='targetlevel'>" + this.class.level + "</span></div> " + a + " " + c
    };
    var od = function() {
            for (e in za.entities) za.entities[e] && za.entities[e] != Ic && (za.entities[e].canFightPlayer = ib(za.entities[e], Ic).canFight())
        },
        pd = new THREE.Vector2(100, 10),
        qd = [],
        rd = [],
        sd = void 0,
        td = void 0,
        ud = .996,
        vd = .8;
    j.prototype.tickHud = function(a) {
        if (Ic && this.geometry) {
            var b = new THREE.Vector3;
            b.copy(this.geometry.position), b.y += Math.max(.5, this.stats.scale + 1), b = da(b, Fc);
            var c = (ud - b.z) * (1 / (ud - vd));
            this.worlddist = Ic && this != Ic ? ib(Ic, this).distance() : 1;
            var d = !1,
                e = 1;
            if (this.isInHud = b.z < 1 && Math.abs(b.x) < .5 * za.width && Math.abs(b.y) < .5 * za.height, this != Ic && !this.stats.isDead() && this.worlddist < 50 && b.z > vd && this.isInHud) {
                var f = Ic && this == Ic.target || this == Ic,
                    g = f ? 1 : Math.min(1.5, .4 + 12 * c);
                (f || "" != this.clan && this.clan == Ic.clan) && (b.z = 4), b.y += 8;
                var h = Math.round(b.y + 15 * g);
                this.levelsprite.position.set(b.x + (.5 * pd.x + .5 * this.levelsprite.canvas.textWidth + 2) * g, b.y, b.z + 3e-5);
                var i = pd.x * Math.max(0, Math.min(1, this.stats.currenthp / this.stats.maxhp));
                this.hpbar.bg.position.set(b.x, b.y, b.z + 1e-5), this.hpbar.fg.position.set(b.x + (.5 * i - .5 * pd.x) * g, b.y, b.z + 2e-5), this.factionIcon.position.set(b.x - 55 * g, b.y, b.z + 3e-5), this.hpbar.bg.scale.set((pd.x + 4) * g, (pd.y + 4) * g, 1), this.hpbar.fg.scale.set(i * g, pd.y * g, 1), this.levelsprite.scale.set(g, g, 1), this.factionIcon.scale.set(20 * g, 20 * g, 1), this.hpbar.fg.material = Ic && "" != this.clan && this.clan == Ic.clan ? Vc.hpbarclan : void 0 === Ic || this.faction == Ic.faction ? f ? Vc.hpbarfriendly : Vc.hpbarfriendlyTransparent : f ? 2 == this.faction ? Vc.hpbarmob : this.canFightPlayer ? Vc.hpbarenemy : Vc.hpbarcantfight : 2 == this.faction ? Vc.hpbarmobTransparent : this.canFightPlayer ? Vc.hpbarenemyTransparent : Vc.hpbarcantfightTransparent, this.hpbar.bg.material = f || "" != this.clan && this.clan == Ic.clan ? Vc.hpbarbg : Vc.hpbarbgTransparent, e = f ? 1 : "" != this.clan && this.clan == Ic.clan ? 1 : .4, this.levelsprite.material.opacity = e, this.stats.isDead() || (this.faction != Ic.faction ? qd.push({
                    entity: this,
                    z: this.worlddist
                }) : rd.push({
                    entity: this,
                    z: this.worlddist
                })), this.hpbar.fg.visible = !0, this.hpbar.bg.visible = !0, this.levelsprite.visible = !0, this.factionIcon.visible = 2 != this.faction, this.namesprite && (this.namesprite.visible = !0, this.namesprite.position.set(Math.round(b.x + (this.clan ? .5 * this.clansprite.canvas.textWidth * g : 0)), h, b.z + 3e-5), this.namesprite.material.opacity = e, this.namesprite.scale.set(g, g, 1)), this.clansprite && ("" != this.clan ? (this.clansprite.visible = !0, this.clansprite.position.set(Math.round(b.x - (.5 * this.namesprite.canvas.textWidth + 5) * g), h, b.z + 3e-5), this.clansprite.material.opacity = e, this.clansprite.scale.set(g, g, 1)) : this.clansprite.visible = !1), d = !0
            } else this.hpbar.fg.visible = !1, this.hpbar.bg.visible = !1, this != Ic && (this.namesprite && (this.namesprite.visible = !1), this.clansprite && (this.clansprite.visible = !1)), this.levelsprite.visible = !1, this.factionIcon.visible = !1;
            this == Ic && X();
            for (var j = this.dmgSprites.length; j--;) {
                var k = this.dmgSprites[j];
                if (k.timer += a, k.timer > 1.5) Bc.remove(k), k.finalCleanUp(), this.dmgSprites.splice(j, 1);
                else if (this.isInHud) {
                    var l = Math.max(1, 2 - 3 * k.timer);
                    k.scale.set(l, l, 1), k.origin.y += k.yvel * a, k.timer > .8 && (k.material.opacity -= 2 * a);
                    var b = da(k.origin, Fc);
                    k.position.set(b.x + k.xoffset, b.y + 30, 6), k.isVisible = !0
                } else k.isVisible = !1
            }
        }
    }, j.prototype.createCombatText = function(a, b, c) {
        if (!Ic || this.faction == Ic.faction || !c) {
            var d = new THREE.Vector3(this.geometry.position.x, this.geometry.position.y + this.stats.scale + 1.2, this.geometry.position.z),
                e = da(d, Fc);
            if (e.z > vd && e.z < 1 && Math.abs(e.x) < .5 * za.width && Math.abs(e.y) < .5 * za.height) {
                var f = this.faction == (Ic ? Ic.faction : 0) ? c ? "#59DD36" : "#FF0000" : "#FFFF00",
                    g = new ha(a, {
                        align: Od.center,
                        font: "500 24px 'Roboto'",
                        fillStyle: f
                    });
                Bc.add(g), g.origin = d, g.xoffset = (10 * Math.random() - 5) * this.dmgSprites.length, g.yvel = 3 + 10 * Math.min(b / this.stats.maxhp, .3), g.timer = 0, this.dmgSprites.push(g)
            }
        }
    };
    var wd, xd, yd, zd = function() {
            if (sd = void 0, td = void 0, qd.sort(function(a, b) {
                    return a.z - b.z
                }), rd.sort(function(a, b) {
                    return a.z - b.z
                }), Ic && Ic.target) {
                for (var a = 0, b = qd.length; a < b; ++a) Ic.target == qd[a].entity && (sd = qd[a + 1] ? qd[a + 1].entity : qd[0].entity);
                for (var a = 0, b = rd.length; a < b; ++a) Ic.target == rd[a].entity && (td = rd[a + 1] ? rd[a + 1].entity : rd[0].entity)
            }
            void 0 == sd && qd.length > 0 && (sd = qd[0].entity), void 0 == td && rd.length > 0 && (td = rd[0].entity)
        },
        Ad = void 0,
        Bd = 0,
        Cd = void 0,
        Dd = void 0,
        Ed = void 0,
        Fd = ["Alpheos", "Balius", "Charon", "Deimos", "Ether", "Fates", "Garrosh", "Helios", "Iris"],
        Gd = void 0,
        Hd = void 0;
    $(document).ready(function() {
        Id()
    });
    var Id = function() {
            xd = "localhost" == document.location.hostname ? io("localhost:8123") : io(Xa + ":80"), xd.on("d", function(a) {
                load_c = !0, void 0 !== a.address && (Cd = a.address), void 0 !== a.id && (Dd = a.id), Cd = Cd.replace("127.0.0.1", "localhost"), a.sc === !0 && Jd(Cd)
            }), xd.on("m", function(a) {
                if (a) {
                    if (a.m)
                        for (var b in a.m) a.m.hasOwnProperty(b) && (a.m[b].hasOwnProperty("dps") && $("#" + b + "dps").html(d(parseInt(a.m[b].dps), 1) + " dps"), a.m[b].hasOwnProperty("pc") && $("#" + b + "players").html(parseInt(a.m[b].pc) + " players"), a.m[b].hasOwnProperty("kh") && $("#" + b + "king").html("King: " + parseInt(a.m[b].kh) + "%"), a.m[b].hasOwnProperty("g") && $("#" + b + "gold").html(d(parseInt(a.m[b].g), 1)));
                    if (a.l)
                        for (m in a.l) void 0 !== a.l[m].c && (qc[m].class = a.l[m].c), void 0 !== a.l[m].n && (qc[m].name = a.l[m].n), void 0 !== a.l[m].l && (qc[m].level = a.l[m].l), void 0 !== a.l[m].f && (qc[m].fame = a.l[m].f), void 0 !== a.l[m].h && (qc[m].horde = a.l[m].h), rc(parseInt(m) + 1, {
                            class: qc[m].class,
                            name: qc[m].name,
                            fame: qc[m].fame,
                            lvl: qc[m].level,
                            horde: qc[m].horde
                        });
                    if (void 0 !== a.s && "object" == typeof a.s) {
                        $("#channelname").html((Fd.length - 1 > Dd ? Fd[Dd] + (Fd.length - 1 > Dd ? " (" + a.s[Dd] + ")" : "") : "Channel") + " <span class='caret'>");
                        var c = $("#serverselectionlist");
                        c.empty();
                        for (var e = 0; e < parseInt(a.s.length); ++e) {
                            var f = $("<li/>").appendTo(c),
                                g = $("<a/>").text(Fd[e] + ("" != a.s[e] ? " (" + a.s[e] + ")" : "")).appendTo(f).data("sr", e);
                            e == Dd && g.css("font-weight", 800), g.on("click", function(a) {
                                xd.emit("sr", parseInt($(this).data("sr")))
                            })
                        }
                    }
                }
            }), xd.on("c", function(a) {
                a.m && a.i && Y({
                    msg: a.m,
                    src: a.i,
                    name: a.n,
                    r: a.r,
                    c: a.c,
                    f: a.f
                })
            }), xd.on("gm", function(a) {
                switch (a.t) {
                    case "pk":
                        Y({
                            msg: "$" + a.f + a.a + " killed $" + (0 == a.f ? 1 : 0) + a.b + " and stole " + a.fa + " fame and " + a.g + " $g",
                            src: "playerkill"
                        })
                }
            })
        },
        Jd = function(b) {
            if (void 0 !== b) {
                void 0 != wd && (wd.disconnect(), delete wd), void 0 !== Hd && (clearInterval(Hd), Hd = void 0), void 0 !== Gd && (clearInterval(Gd), Gd = void 0), wd = io(b), wd.on("handshake", function(a) {
                    yd = a.playerid, void 0 !== Ed ? (Md(Ed), Ed = void 0) : void 0 !== Ad ? Md(Ad) : Kd(), $("#loginfade").remove()
                });
                var c = [],
                    d = 5,
                    e = function(a) {
                        var b = a.e;
                        for (var e in b)
                            if (b.hasOwnProperty(e) && (Jc.hasOwnProperty(e) && void 0 != Jc[e] || (Jc[e] = new j(0), Jc[e].initPlayer(e, e == yd), e == yd && b[e].r && (Tb.cameraY = parseFloat(b[e].r), Tb.cameraX = -.5))), Ba(e, b[e]), void 0 === Jc[e].class.type) c.indexOf(e) < 0 && c.push(e + "");
                            else {
                                var f = c.indexOf(e);
                                f > -1 && c.splice(f, 1)
                            }
                        if (d++, d >= 10 && c.length > 0 && (d = 0, wd.emit("ref", c), c = []), a.pr)
                            for (var e in a.pr) a.pr.hasOwnProperty(e) && Jc.hasOwnProperty(e) && Ba(e, a.pr[e]);
                        if (a.i)
                            for (var g in a.i) a.i.hasOwnProperty(g) && (void 0 !== a.i[g].r ? void 0 !== nb[g] && nb[g].destroy() : void 0 === nb[g] && (a.i[g].i = g, nb[g] = new p(a.i[g])))
                    };
                wd.on("e", e), wd.on("c", function(a) {
                    a.m && a.i && Y({
                        msg: a.m,
                        src: a.i,
                        name: a.n,
                        r: a.r,
                        c: a.c,
                        f: a.f
                    })
                }), wd.on("spawn", function(b) {
                    if (e(b.m), b.dbid && ($("#charIdDisplay").text(b.dbid), Ad = b.dbid, xd.emit("a", b.dbid)), Ic && b.abl)
                        for (a in b.abl) Ic.class.skills[parseInt(a)].setLevel(b.abl[a]);
                    var c = Pa.get("name");
                    c && wd.emit("namechange", c), bc.player.panel.hide(), $("#renderer").fadeIn(300, function() {
                        pc("fadeIn", 300), bc.target.panel.hide(), nc = !1, $("#inventory").show(), $("#characterpanel").show()
                    }), Hb()
                }), wd.on("del", function(a) {
                    Ca(a)
                }), wd.on("disconnect", function() {
                    Da(), pc("fadeOut", 500), Ac.add(Fc)
                }), wd.on("lm", function(a) {
                    var b;
                    switch (a.r) {
                        case "l":
                            $("#modal-user").modal("show"), b = "#serverLoginMessage";
                            break;
                        case "c":
                            b = "#createClanMsg";
                            break;
                        case "n":
                            b = "#setNickMsg";
                            break;
                        case "ca":
                            b = "#clanActionMsg"
                    }
                    $(b).text(a.m), $(b).fadeIn()
                }), wd.on("inv", function(a) {
                    yb(a)
                }), wd.on("cl", function(a) {
                    sb(a)
                }), wd.on("ci", function(a) {
                    $("#userinteract").show().centerMe(0, -150), $("#userinteractmsg").html("<b>" + a.i + "</b> has invited you to join the clan <b>" + a.t + "</b>")
                }), Gd = setInterval(function() {
                    if (!document.hidden && performance.now() - Yc < 1e3 && Ic) {
                        var a = Ic.getDeltaMsg();
                        a !== !1 && wd.emit("u", a)
                    }
                }, Ya);
                var f;
                Hd = setInterval(function() {
                    document.hidden || (f = performance.now(), wd.emit("pi"))
                }, 2e3), wd.on("po", function(a) {
                    Bd = Math.max(0, (2 * Bd + (performance.now() - f)) / 3)
                })
            }
        },
        Kd = function() {
            Ld($("#usernameInputField").val()), wd.emit("requestSpawn", {
                name: Pa.get("name"),
                class: Pa.get("class"),
                faction: Pa.get("faction")
            })
        },
        Ld = function(a) {
            void 0 != a && "string" == typeof a || (a = ""), Pa.set("name", a)
        },
        Md = function(a) {
            wd.emit("requestSpawn", {
                id: a
            })
        },
        Nd = function(a) {
            wd.emit("cc", a)
        };
    if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); + function(a) {
        "use strict";
        var b = a.fn.jquery.split(" ")[0].split(".");
        if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1 || b[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.button"),
                    f = "object" == typeof b && b;
                e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b)
            })
        }
        var c = function(b, d) {
            this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1
        };
        c.VERSION = "3.3.7", c.DEFAULTS = {
            loadingText: "loading..."
        }, c.prototype.setState = function(b) {
            var c = "disabled",
                d = this.$element,
                e = d.is("input") ? "val" : "html",
                f = d.data();
            b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function() {
                d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c).prop(c, !0)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c).prop(c, !1))
            }, this), 0)
        }, c.prototype.toggle = function() {
            var a = !0,
                b = this.$element.closest('[data-toggle="buttons"]');
            if (b.length) {
                var c = this.$element.find("input");
                "radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change")
            } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
        };
        var d = a.fn.button;
        a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function() {
            return a.fn.button = d, this
        }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(c) {
            var d = a(c.target).closest(".btn");
            b.call(d, "toggle"), a(c.target).is('input[type="radio"], input[type="checkbox"]') || (c.preventDefault(), d.is("input,button") ? d.trigger("focus") : d.find("input:visible,button:visible").first().trigger("focus"))
        }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(b) {
            a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type))
        })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            var c = b.attr("data-target");
            c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));
            var d = c && a(c);
            return d && d.length ? d : b.parent()
        }

        function c(c) {
            c && 3 === c.which || (a(e).remove(), a(f).each(function() {
                var d = a(this),
                    e = b(d),
                    f = {
                        relatedTarget: this
                    };
                e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger(a.Event("hidden.bs.dropdown", f)))))
            }))
        }

        function d(b) {
            return this.each(function() {
                var c = a(this),
                    d = c.data("bs.dropdown");
                d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c)
            })
        }
        var e = ".dropdown-backdrop",
            f = '[data-toggle="dropdown"]',
            g = function(b) {
                a(b).on("click.bs.dropdown", this.toggle)
            };
        g.VERSION = "3.3.7", g.prototype.toggle = function(d) {
            var e = a(this);
            if (!e.is(".disabled, :disabled")) {
                var f = b(e),
                    g = f.hasClass("open");
                if (c(), !g) {
                    "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);
                    var h = {
                        relatedTarget: this
                    };
                    if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;
                    e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h))
                }
                return !1
            }
        }, g.prototype.keydown = function(c) {
            if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
                var d = a(this);
                if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
                    var e = b(d),
                        g = e.hasClass("open");
                    if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");
                    var h = " li:not(.disabled):visible a",
                        i = e.find(".dropdown-menu" + h);
                    if (i.length) {
                        var j = i.index(c.target);
                        38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus")
                    }
                }
            }
        };
        var h = a.fn.dropdown;
        a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function() {
            return a.fn.dropdown = h, this
        }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function(a) {
            a.stopPropagation()
        }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown)
    }(jQuery), + function(a) {
        "use strict";

        function b(b, d) {
            return this.each(function() {
                var e = a(this),
                    f = e.data("bs.modal"),
                    g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b);
                f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d)
            })
        }
        var c = function(b, c) {
            this.options = c, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function() {
                this.$element.trigger("loaded.bs.modal")
            }, this))
        };
        c.VERSION = "3.3.7", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = {
            backdrop: !0,
            keyboard: !0,
            show: !0
        }, c.prototype.toggle = function(a) {
            return this.isShown ? this.hide() : this.show(a)
        }, c.prototype.show = function(b) {
            var d = this,
                e = a.Event("show.bs.modal", {
                    relatedTarget: b
                });
            this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function() {
                d.$element.one("mouseup.dismiss.bs.modal", function(b) {
                    a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0)
                })
            }), this.backdrop(function() {
                var e = a.support.transition && d.$element.hasClass("fade");
                d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();
                var f = a.Event("shown.bs.modal", {
                    relatedTarget: b
                });
                e ? d.$dialog.one("bsTransitionEnd", function() {
                    d.$element.trigger("focus").trigger(f)
                }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f)
            }))
        }, c.prototype.hide = function(b) {
            b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal())
        }, c.prototype.enforceFocus = function() {
            a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function(a) {
                document === a.target || this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus")
            }, this))
        }, c.prototype.escape = function() {
            this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function(a) {
                27 == a.which && this.hide()
            }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
        }, c.prototype.resize = function() {
            this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal")
        }, c.prototype.hideModal = function() {
            var a = this;
            this.$element.hide(), this.backdrop(function() {
                a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal")
            })
        }, c.prototype.removeBackdrop = function() {
            this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
        }, c.prototype.backdrop = function(b) {
            var d = this,
                e = this.$element.hasClass("fade") ? "fade" : "";
            if (this.isShown && this.options.backdrop) {
                var f = a.support.transition && e;
                if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function(a) {
                        return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
                    }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;
                f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b()
            } else if (!this.isShown && this.$backdrop) {
                this.$backdrop.removeClass("in");
                var g = function() {
                    d.removeBackdrop(), b && b()
                };
                a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g()
            } else b && b()
        }, c.prototype.handleUpdate = function() {
            this.adjustDialog()
        }, c.prototype.adjustDialog = function() {
            var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;
            this.$element.css({
                paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "",
                paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : ""
            })
        }, c.prototype.resetAdjustments = function() {
            this.$element.css({
                paddingLeft: "",
                paddingRight: ""
            })
        }, c.prototype.checkScrollbar = function() {
            var a = window.innerWidth;
            if (!a) {
                var b = document.documentElement.getBoundingClientRect();
                a = b.right - Math.abs(b.left)
            }
            this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar()
        }, c.prototype.setScrollbar = function() {
            var a = parseInt(this.$body.css("padding-right") || 0, 10);
            this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth)
        }, c.prototype.resetScrollbar = function() {
            this.$body.css("padding-right", this.originalBodyPad)
        }, c.prototype.measureScrollbar = function() {
            var a = document.createElement("div");
            a.className = "modal-scrollbar-measure", this.$body.append(a);
            var b = a.offsetWidth - a.clientWidth;
            return this.$body[0].removeChild(a), b
        };
        var d = a.fn.modal;
        a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function() {
            return a.fn.modal = d, this
        }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(c) {
            var d = a(this),
                e = d.attr("href"),
                f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
                g = f.data("bs.modal") ? "toggle" : a.extend({
                    remote: !/#/.test(e) && e
                }, f.data(), d.data());
            d.is("a") && c.preventDefault(), f.one("show.bs.modal", function(a) {
                a.isDefaultPrevented() || f.one("hidden.bs.modal", function() {
                    d.is(":visible") && d.trigger("focus")
                })
            }), b.call(f, g, this)
        })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.tab");
                e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]()
            })
        }
        var c = function(b) {
            this.element = a(b)
        };
        c.VERSION = "3.3.7", c.TRANSITION_DURATION = 150, c.prototype.show = function() {
            var b = this.element,
                c = b.closest("ul:not(.dropdown-menu)"),
                d = b.data("target");
            if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
                var e = c.find(".active:last a"),
                    f = a.Event("hide.bs.tab", {
                        relatedTarget: b[0]
                    }),
                    g = a.Event("show.bs.tab", {
                        relatedTarget: e[0]
                    });
                if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
                    var h = a(d);
                    this.activate(b.closest("li"), c), this.activate(h, h.parent(), function() {
                        e.trigger({
                            type: "hidden.bs.tab",
                            relatedTarget: b[0]
                        }), b.trigger({
                            type: "shown.bs.tab",
                            relatedTarget: e[0]
                        })
                    })
                }
            }
        }, c.prototype.activate = function(b, d, e) {
            function f() {
                g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e()
            }
            var g = d.find("> .active"),
                h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);
            g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in")
        };
        var d = a.fn.tab;
        a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function() {
            return a.fn.tab = d, this
        };
        var e = function(c) {
            c.preventDefault(), b.call(a(this), "show")
        };
        a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e)
    }(jQuery), + function(a) {
        "use strict";

        function b() {
            var a = document.createElement("bootstrap"),
                b = {
                    WebkitTransition: "webkitTransitionEnd",
                    MozTransition: "transitionend",
                    OTransition: "oTransitionEnd otransitionend",
                    transition: "transitionend"
                };
            for (var c in b)
                if (void 0 !== a.style[c]) return {
                    end: b[c]
                };
            return !1
        }
        a.fn.emulateTransitionEnd = function(b) {
            var c = !1,
                d = this;
            a(this).one("bsTransitionEnd", function() {
                c = !0
            });
            var e = function() {
                c || a(d).trigger(a.support.transition.end)
            };
            return setTimeout(e, b), this
        }, a(function() {
            a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = {
                bindType: a.support.transition.end,
                delegateType: a.support.transition.end,
                handle: function(b) {
                    return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0
                }
            })
        })
    }(jQuery);
    var Od = {
            center: new THREE.Vector2(0, 0),
            left: new THREE.Vector2(1, 0),
            topLeft: new THREE.Vector2(1, -1),
            topRight: new THREE.Vector2(-1, -1),
            right: new THREE.Vector2(-1, 0),
            bottomLeft: new THREE.Vector2(1, 1),
            bottomRight: new THREE.Vector2(-1, 1)
        },
        Pd = {};
    ga.prototype.width = function() {
        return this.canvas.width
    }, ga.prototype.height = function() {
        return this.canvas.height
    }, ga.prototype.drawText = function(a, b) {
        return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx.font = b.font, this.textWidth = Math.max(1, Math.ceil(this.ctx.measureText(a).width)), this.textHeight = fa(this.ctx.font), this.canvas.width = THREE.Math.nextPowerOfTwo(this.textWidth), this.canvas.height = THREE.Math.nextPowerOfTwo(this.textHeight), this.ctx.font = b.font, this.ctx.fillStyle = b.fillStyle, this.ctx.textAlign = "center", this.ctx.textBaseline = "middle", b.shadow > 0 ? (this.ctx.shadowBlur = 1, this.ctx.shadowColor = "black", this.ctx.shadowOffsetX = 1.5, this.ctx.shadowOffsetY = 1.5) : (this.ctx.shadowOffsetX = 0, this.ctx.shadowOffsetY = 0), this.ctx.fillText(a, .5 * this.canvas.width, .5 * this.canvas.height), this.canvas
    }, ha.prototype = new THREE.Object3D, ha.prototype.constructor = ha, ha.prototype.width = function() {
        return this.canvas.textWidth
    }, ha.prototype.height = function() {
        return this.canvas.textHeight
    }, ha.prototype.getText = function() {
        return this._text
    }, ha.prototype.setText = function(a) {
        this._text !== a && (this._text = a, this.updateText())
    }, ha.prototype.getFont = function() {
        return this._font
    }, ha.prototype.setFont = function(a) {
        this._font !== a && (this._font = a, this.updateText())
    }, ha.prototype.getFillStyle = function() {
        return this._fillStyle
    }, ha.prototype.setFillStyle = function(a) {
        this._fillStyle !== a && (this._fillStyle = a, this.updateText())
    }, ha.prototype.updateText = function() {
        this.canvas.drawText(this._text, {
            font: this._font,
            fillStyle: this._fillStyle,
            shadow: this._shadow
        }), this.cleanUp(), this.texture = new THREE.Texture(this.canvas.canvas), this.texture.needsUpdate = !0, this.applyAntiAlias(), this.material ? this.material.map = this.texture : this.material = new THREE.SpriteMaterial({
            map: this.texture
        }), this.sprite || (this.sprite = new THREE.Sprite(this.material), this.add(this.sprite)), this.sprite.scale.set(this.canvas.width(), this.canvas.height(), 1)
    }, ha.prototype.cleanUp = function() {
        this.texture && this.texture.dispose()
    }, ha.prototype.finalCleanUp = function() {
        this.cleanUp(), this.material && this.material.dispose(), this.sprite && (this.remove(this.sprite), this.sprite = void 0)
    }, ha.prototype.applyAntiAlias = function() {
        this.antialias === !1 && (this.texture.magFilter = THREE.NearestFilter, this.texture.minFilter = THREE.LinearMipMapLinearFilter)
    }
}(window, document);